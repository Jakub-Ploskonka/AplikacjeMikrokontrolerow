
mniam_player_stm32f4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000fd54  080001b0  080001b0  000011b0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000004a8  0800ff04  0800ff04  00010f04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080103ac  080103ac  00012080  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  080103ac  080103ac  000113ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080103b4  080103b4  00012080  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080103b4  080103b4  000113b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  080103b8  080103b8  000113b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000080  20000000  080103bc  00012000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmram       00000000  10000000  10000000  00012080  2**0
                  CONTENTS
 10 .bss          00014624  20000080  20000080  00012080  2**2
                  ALLOC
 11 ._user_heap_stack 00000604  200146a4  200146a4  00012080  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00012080  2**0
                  CONTENTS, READONLY
 13 .debug_info   0006cc68  00000000  00000000  000120b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000dc18  00000000  00000000  0007ed18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 000203f8  00000000  00000000  0008c930  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000027f8  00000000  00000000  000acd28  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000025eb  00000000  00000000  000af520  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00014b43  00000000  00000000  000b1b0b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0004b962  00000000  00000000  000c664e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    00103909  00000000  00000000  00111fb0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  002158b9  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00007f04  00000000  00000000  002158fc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 0000004d  00000000  00000000  0021d800  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001b0 <__do_global_dtors_aux>:
 80001b0:	b510      	push	{r4, lr}
 80001b2:	4c05      	ldr	r4, [pc, #20]	@ (80001c8 <__do_global_dtors_aux+0x18>)
 80001b4:	7823      	ldrb	r3, [r4, #0]
 80001b6:	b933      	cbnz	r3, 80001c6 <__do_global_dtors_aux+0x16>
 80001b8:	4b04      	ldr	r3, [pc, #16]	@ (80001cc <__do_global_dtors_aux+0x1c>)
 80001ba:	b113      	cbz	r3, 80001c2 <__do_global_dtors_aux+0x12>
 80001bc:	4804      	ldr	r0, [pc, #16]	@ (80001d0 <__do_global_dtors_aux+0x20>)
 80001be:	f3af 8000 	nop.w
 80001c2:	2301      	movs	r3, #1
 80001c4:	7023      	strb	r3, [r4, #0]
 80001c6:	bd10      	pop	{r4, pc}
 80001c8:	20000080 	.word	0x20000080
 80001cc:	00000000 	.word	0x00000000
 80001d0:	0800feec 	.word	0x0800feec

080001d4 <frame_dummy>:
 80001d4:	b508      	push	{r3, lr}
 80001d6:	4b03      	ldr	r3, [pc, #12]	@ (80001e4 <frame_dummy+0x10>)
 80001d8:	b11b      	cbz	r3, 80001e2 <frame_dummy+0xe>
 80001da:	4903      	ldr	r1, [pc, #12]	@ (80001e8 <frame_dummy+0x14>)
 80001dc:	4803      	ldr	r0, [pc, #12]	@ (80001ec <frame_dummy+0x18>)
 80001de:	f3af 8000 	nop.w
 80001e2:	bd08      	pop	{r3, pc}
 80001e4:	00000000 	.word	0x00000000
 80001e8:	20000084 	.word	0x20000084
 80001ec:	0800feec 	.word	0x0800feec

080001f0 <memchr>:
 80001f0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80001f4:	2a10      	cmp	r2, #16
 80001f6:	db2b      	blt.n	8000250 <memchr+0x60>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	d008      	beq.n	8000210 <memchr+0x20>
 80001fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000202:	3a01      	subs	r2, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d02d      	beq.n	8000264 <memchr+0x74>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	b342      	cbz	r2, 8000260 <memchr+0x70>
 800020e:	d1f6      	bne.n	80001fe <memchr+0xe>
 8000210:	b4f0      	push	{r4, r5, r6, r7}
 8000212:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000216:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800021a:	f022 0407 	bic.w	r4, r2, #7
 800021e:	f07f 0700 	mvns.w	r7, #0
 8000222:	2300      	movs	r3, #0
 8000224:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000228:	3c08      	subs	r4, #8
 800022a:	ea85 0501 	eor.w	r5, r5, r1
 800022e:	ea86 0601 	eor.w	r6, r6, r1
 8000232:	fa85 f547 	uadd8	r5, r5, r7
 8000236:	faa3 f587 	sel	r5, r3, r7
 800023a:	fa86 f647 	uadd8	r6, r6, r7
 800023e:	faa5 f687 	sel	r6, r5, r7
 8000242:	b98e      	cbnz	r6, 8000268 <memchr+0x78>
 8000244:	d1ee      	bne.n	8000224 <memchr+0x34>
 8000246:	bcf0      	pop	{r4, r5, r6, r7}
 8000248:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800024c:	f002 0207 	and.w	r2, r2, #7
 8000250:	b132      	cbz	r2, 8000260 <memchr+0x70>
 8000252:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000256:	3a01      	subs	r2, #1
 8000258:	ea83 0301 	eor.w	r3, r3, r1
 800025c:	b113      	cbz	r3, 8000264 <memchr+0x74>
 800025e:	d1f8      	bne.n	8000252 <memchr+0x62>
 8000260:	2000      	movs	r0, #0
 8000262:	4770      	bx	lr
 8000264:	3801      	subs	r0, #1
 8000266:	4770      	bx	lr
 8000268:	2d00      	cmp	r5, #0
 800026a:	bf06      	itte	eq
 800026c:	4635      	moveq	r5, r6
 800026e:	3803      	subeq	r0, #3
 8000270:	3807      	subne	r0, #7
 8000272:	f015 0f01 	tst.w	r5, #1
 8000276:	d107      	bne.n	8000288 <memchr+0x98>
 8000278:	3001      	adds	r0, #1
 800027a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800027e:	bf02      	ittt	eq
 8000280:	3001      	addeq	r0, #1
 8000282:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000286:	3001      	addeq	r0, #1
 8000288:	bcf0      	pop	{r4, r5, r6, r7}
 800028a:	3801      	subs	r0, #1
 800028c:	4770      	bx	lr
 800028e:	bf00      	nop

08000290 <__aeabi_drsub>:
 8000290:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000294:	e002      	b.n	800029c <__adddf3>
 8000296:	bf00      	nop

08000298 <__aeabi_dsub>:
 8000298:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0800029c <__adddf3>:
 800029c:	b530      	push	{r4, r5, lr}
 800029e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002a2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002a6:	ea94 0f05 	teq	r4, r5
 80002aa:	bf08      	it	eq
 80002ac:	ea90 0f02 	teqeq	r0, r2
 80002b0:	bf1f      	itttt	ne
 80002b2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002b6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002be:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002c2:	f000 80e2 	beq.w	800048a <__adddf3+0x1ee>
 80002c6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ce:	bfb8      	it	lt
 80002d0:	426d      	neglt	r5, r5
 80002d2:	dd0c      	ble.n	80002ee <__adddf3+0x52>
 80002d4:	442c      	add	r4, r5
 80002d6:	ea80 0202 	eor.w	r2, r0, r2
 80002da:	ea81 0303 	eor.w	r3, r1, r3
 80002de:	ea82 0000 	eor.w	r0, r2, r0
 80002e2:	ea83 0101 	eor.w	r1, r3, r1
 80002e6:	ea80 0202 	eor.w	r2, r0, r2
 80002ea:	ea81 0303 	eor.w	r3, r1, r3
 80002ee:	2d36      	cmp	r5, #54	@ 0x36
 80002f0:	bf88      	it	hi
 80002f2:	bd30      	pophi	{r4, r5, pc}
 80002f4:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80002f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002fc:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000300:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000304:	d002      	beq.n	800030c <__adddf3+0x70>
 8000306:	4240      	negs	r0, r0
 8000308:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800030c:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000310:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000314:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000318:	d002      	beq.n	8000320 <__adddf3+0x84>
 800031a:	4252      	negs	r2, r2
 800031c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000320:	ea94 0f05 	teq	r4, r5
 8000324:	f000 80a7 	beq.w	8000476 <__adddf3+0x1da>
 8000328:	f1a4 0401 	sub.w	r4, r4, #1
 800032c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000330:	db0d      	blt.n	800034e <__adddf3+0xb2>
 8000332:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000336:	fa22 f205 	lsr.w	r2, r2, r5
 800033a:	1880      	adds	r0, r0, r2
 800033c:	f141 0100 	adc.w	r1, r1, #0
 8000340:	fa03 f20e 	lsl.w	r2, r3, lr
 8000344:	1880      	adds	r0, r0, r2
 8000346:	fa43 f305 	asr.w	r3, r3, r5
 800034a:	4159      	adcs	r1, r3
 800034c:	e00e      	b.n	800036c <__adddf3+0xd0>
 800034e:	f1a5 0520 	sub.w	r5, r5, #32
 8000352:	f10e 0e20 	add.w	lr, lr, #32
 8000356:	2a01      	cmp	r2, #1
 8000358:	fa03 fc0e 	lsl.w	ip, r3, lr
 800035c:	bf28      	it	cs
 800035e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000362:	fa43 f305 	asr.w	r3, r3, r5
 8000366:	18c0      	adds	r0, r0, r3
 8000368:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800036c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000370:	d507      	bpl.n	8000382 <__adddf3+0xe6>
 8000372:	f04f 0e00 	mov.w	lr, #0
 8000376:	f1dc 0c00 	rsbs	ip, ip, #0
 800037a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800037e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000382:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000386:	d31b      	bcc.n	80003c0 <__adddf3+0x124>
 8000388:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 800038c:	d30c      	bcc.n	80003a8 <__adddf3+0x10c>
 800038e:	0849      	lsrs	r1, r1, #1
 8000390:	ea5f 0030 	movs.w	r0, r0, rrx
 8000394:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000398:	f104 0401 	add.w	r4, r4, #1
 800039c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003a0:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80003a4:	f080 809a 	bcs.w	80004dc <__adddf3+0x240>
 80003a8:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80003ac:	bf08      	it	eq
 80003ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003b2:	f150 0000 	adcs.w	r0, r0, #0
 80003b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ba:	ea41 0105 	orr.w	r1, r1, r5
 80003be:	bd30      	pop	{r4, r5, pc}
 80003c0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003c4:	4140      	adcs	r0, r0
 80003c6:	eb41 0101 	adc.w	r1, r1, r1
 80003ca:	3c01      	subs	r4, #1
 80003cc:	bf28      	it	cs
 80003ce:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80003d2:	d2e9      	bcs.n	80003a8 <__adddf3+0x10c>
 80003d4:	f091 0f00 	teq	r1, #0
 80003d8:	bf04      	itt	eq
 80003da:	4601      	moveq	r1, r0
 80003dc:	2000      	moveq	r0, #0
 80003de:	fab1 f381 	clz	r3, r1
 80003e2:	bf08      	it	eq
 80003e4:	3320      	addeq	r3, #32
 80003e6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ea:	f1b3 0220 	subs.w	r2, r3, #32
 80003ee:	da0c      	bge.n	800040a <__adddf3+0x16e>
 80003f0:	320c      	adds	r2, #12
 80003f2:	dd08      	ble.n	8000406 <__adddf3+0x16a>
 80003f4:	f102 0c14 	add.w	ip, r2, #20
 80003f8:	f1c2 020c 	rsb	r2, r2, #12
 80003fc:	fa01 f00c 	lsl.w	r0, r1, ip
 8000400:	fa21 f102 	lsr.w	r1, r1, r2
 8000404:	e00c      	b.n	8000420 <__adddf3+0x184>
 8000406:	f102 0214 	add.w	r2, r2, #20
 800040a:	bfd8      	it	le
 800040c:	f1c2 0c20 	rsble	ip, r2, #32
 8000410:	fa01 f102 	lsl.w	r1, r1, r2
 8000414:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000418:	bfdc      	itt	le
 800041a:	ea41 010c 	orrle.w	r1, r1, ip
 800041e:	4090      	lslle	r0, r2
 8000420:	1ae4      	subs	r4, r4, r3
 8000422:	bfa2      	ittt	ge
 8000424:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000428:	4329      	orrge	r1, r5
 800042a:	bd30      	popge	{r4, r5, pc}
 800042c:	ea6f 0404 	mvn.w	r4, r4
 8000430:	3c1f      	subs	r4, #31
 8000432:	da1c      	bge.n	800046e <__adddf3+0x1d2>
 8000434:	340c      	adds	r4, #12
 8000436:	dc0e      	bgt.n	8000456 <__adddf3+0x1ba>
 8000438:	f104 0414 	add.w	r4, r4, #20
 800043c:	f1c4 0220 	rsb	r2, r4, #32
 8000440:	fa20 f004 	lsr.w	r0, r0, r4
 8000444:	fa01 f302 	lsl.w	r3, r1, r2
 8000448:	ea40 0003 	orr.w	r0, r0, r3
 800044c:	fa21 f304 	lsr.w	r3, r1, r4
 8000450:	ea45 0103 	orr.w	r1, r5, r3
 8000454:	bd30      	pop	{r4, r5, pc}
 8000456:	f1c4 040c 	rsb	r4, r4, #12
 800045a:	f1c4 0220 	rsb	r2, r4, #32
 800045e:	fa20 f002 	lsr.w	r0, r0, r2
 8000462:	fa01 f304 	lsl.w	r3, r1, r4
 8000466:	ea40 0003 	orr.w	r0, r0, r3
 800046a:	4629      	mov	r1, r5
 800046c:	bd30      	pop	{r4, r5, pc}
 800046e:	fa21 f004 	lsr.w	r0, r1, r4
 8000472:	4629      	mov	r1, r5
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f094 0f00 	teq	r4, #0
 800047a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800047e:	bf06      	itte	eq
 8000480:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000484:	3401      	addeq	r4, #1
 8000486:	3d01      	subne	r5, #1
 8000488:	e74e      	b.n	8000328 <__adddf3+0x8c>
 800048a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800048e:	bf18      	it	ne
 8000490:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000494:	d029      	beq.n	80004ea <__adddf3+0x24e>
 8000496:	ea94 0f05 	teq	r4, r5
 800049a:	bf08      	it	eq
 800049c:	ea90 0f02 	teqeq	r0, r2
 80004a0:	d005      	beq.n	80004ae <__adddf3+0x212>
 80004a2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004a6:	bf04      	itt	eq
 80004a8:	4619      	moveq	r1, r3
 80004aa:	4610      	moveq	r0, r2
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	ea91 0f03 	teq	r1, r3
 80004b2:	bf1e      	ittt	ne
 80004b4:	2100      	movne	r1, #0
 80004b6:	2000      	movne	r0, #0
 80004b8:	bd30      	popne	{r4, r5, pc}
 80004ba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004be:	d105      	bne.n	80004cc <__adddf3+0x230>
 80004c0:	0040      	lsls	r0, r0, #1
 80004c2:	4149      	adcs	r1, r1
 80004c4:	bf28      	it	cs
 80004c6:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80004ca:	bd30      	pop	{r4, r5, pc}
 80004cc:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80004d0:	bf3c      	itt	cc
 80004d2:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80004d6:	bd30      	popcc	{r4, r5, pc}
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004dc:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80004e0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80004e4:	f04f 0000 	mov.w	r0, #0
 80004e8:	bd30      	pop	{r4, r5, pc}
 80004ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ee:	bf1a      	itte	ne
 80004f0:	4619      	movne	r1, r3
 80004f2:	4610      	movne	r0, r2
 80004f4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004f8:	bf1c      	itt	ne
 80004fa:	460b      	movne	r3, r1
 80004fc:	4602      	movne	r2, r0
 80004fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000502:	bf06      	itte	eq
 8000504:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000508:	ea91 0f03 	teqeq	r1, r3
 800050c:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000510:	bd30      	pop	{r4, r5, pc}
 8000512:	bf00      	nop

08000514 <__aeabi_ui2d>:
 8000514:	f090 0f00 	teq	r0, #0
 8000518:	bf04      	itt	eq
 800051a:	2100      	moveq	r1, #0
 800051c:	4770      	bxeq	lr
 800051e:	b530      	push	{r4, r5, lr}
 8000520:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000524:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000528:	f04f 0500 	mov.w	r5, #0
 800052c:	f04f 0100 	mov.w	r1, #0
 8000530:	e750      	b.n	80003d4 <__adddf3+0x138>
 8000532:	bf00      	nop

08000534 <__aeabi_i2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000548:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 800054c:	bf48      	it	mi
 800054e:	4240      	negmi	r0, r0
 8000550:	f04f 0100 	mov.w	r1, #0
 8000554:	e73e      	b.n	80003d4 <__adddf3+0x138>
 8000556:	bf00      	nop

08000558 <__aeabi_f2d>:
 8000558:	0042      	lsls	r2, r0, #1
 800055a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800055e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000562:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000566:	bf1f      	itttt	ne
 8000568:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 800056c:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000570:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000574:	4770      	bxne	lr
 8000576:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 800057a:	bf08      	it	eq
 800057c:	4770      	bxeq	lr
 800057e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8000582:	bf04      	itt	eq
 8000584:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000588:	4770      	bxeq	lr
 800058a:	b530      	push	{r4, r5, lr}
 800058c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000590:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000594:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000598:	e71c      	b.n	80003d4 <__adddf3+0x138>
 800059a:	bf00      	nop

0800059c <__aeabi_ul2d>:
 800059c:	ea50 0201 	orrs.w	r2, r0, r1
 80005a0:	bf08      	it	eq
 80005a2:	4770      	bxeq	lr
 80005a4:	b530      	push	{r4, r5, lr}
 80005a6:	f04f 0500 	mov.w	r5, #0
 80005aa:	e00a      	b.n	80005c2 <__aeabi_l2d+0x16>

080005ac <__aeabi_l2d>:
 80005ac:	ea50 0201 	orrs.w	r2, r0, r1
 80005b0:	bf08      	it	eq
 80005b2:	4770      	bxeq	lr
 80005b4:	b530      	push	{r4, r5, lr}
 80005b6:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 80005ba:	d502      	bpl.n	80005c2 <__aeabi_l2d+0x16>
 80005bc:	4240      	negs	r0, r0
 80005be:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005c2:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80005c6:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80005ca:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005ce:	f43f aed8 	beq.w	8000382 <__adddf3+0xe6>
 80005d2:	f04f 0203 	mov.w	r2, #3
 80005d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005da:	bf18      	it	ne
 80005dc:	3203      	addne	r2, #3
 80005de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005e2:	bf18      	it	ne
 80005e4:	3203      	addne	r2, #3
 80005e6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005ea:	f1c2 0320 	rsb	r3, r2, #32
 80005ee:	fa00 fc03 	lsl.w	ip, r0, r3
 80005f2:	fa20 f002 	lsr.w	r0, r0, r2
 80005f6:	fa01 fe03 	lsl.w	lr, r1, r3
 80005fa:	ea40 000e 	orr.w	r0, r0, lr
 80005fe:	fa21 f102 	lsr.w	r1, r1, r2
 8000602:	4414      	add	r4, r2
 8000604:	e6bd      	b.n	8000382 <__adddf3+0xe6>
 8000606:	bf00      	nop

08000608 <__gedf2>:
 8000608:	f04f 3cff 	mov.w	ip, #4294967295
 800060c:	e006      	b.n	800061c <__cmpdf2+0x4>
 800060e:	bf00      	nop

08000610 <__ledf2>:
 8000610:	f04f 0c01 	mov.w	ip, #1
 8000614:	e002      	b.n	800061c <__cmpdf2+0x4>
 8000616:	bf00      	nop

08000618 <__cmpdf2>:
 8000618:	f04f 0c01 	mov.w	ip, #1
 800061c:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000620:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000624:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000628:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800062c:	bf18      	it	ne
 800062e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000632:	d01b      	beq.n	800066c <__cmpdf2+0x54>
 8000634:	b001      	add	sp, #4
 8000636:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800063a:	bf0c      	ite	eq
 800063c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000640:	ea91 0f03 	teqne	r1, r3
 8000644:	bf02      	ittt	eq
 8000646:	ea90 0f02 	teqeq	r0, r2
 800064a:	2000      	moveq	r0, #0
 800064c:	4770      	bxeq	lr
 800064e:	f110 0f00 	cmn.w	r0, #0
 8000652:	ea91 0f03 	teq	r1, r3
 8000656:	bf58      	it	pl
 8000658:	4299      	cmppl	r1, r3
 800065a:	bf08      	it	eq
 800065c:	4290      	cmpeq	r0, r2
 800065e:	bf2c      	ite	cs
 8000660:	17d8      	asrcs	r0, r3, #31
 8000662:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000666:	f040 0001 	orr.w	r0, r0, #1
 800066a:	4770      	bx	lr
 800066c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000670:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000674:	d102      	bne.n	800067c <__cmpdf2+0x64>
 8000676:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800067a:	d107      	bne.n	800068c <__cmpdf2+0x74>
 800067c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000680:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000684:	d1d6      	bne.n	8000634 <__cmpdf2+0x1c>
 8000686:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800068a:	d0d3      	beq.n	8000634 <__cmpdf2+0x1c>
 800068c:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000690:	4770      	bx	lr
 8000692:	bf00      	nop

08000694 <__aeabi_cdrcmple>:
 8000694:	4684      	mov	ip, r0
 8000696:	4610      	mov	r0, r2
 8000698:	4662      	mov	r2, ip
 800069a:	468c      	mov	ip, r1
 800069c:	4619      	mov	r1, r3
 800069e:	4663      	mov	r3, ip
 80006a0:	e000      	b.n	80006a4 <__aeabi_cdcmpeq>
 80006a2:	bf00      	nop

080006a4 <__aeabi_cdcmpeq>:
 80006a4:	b501      	push	{r0, lr}
 80006a6:	f7ff ffb7 	bl	8000618 <__cmpdf2>
 80006aa:	2800      	cmp	r0, #0
 80006ac:	bf48      	it	mi
 80006ae:	f110 0f00 	cmnmi.w	r0, #0
 80006b2:	bd01      	pop	{r0, pc}

080006b4 <__aeabi_dcmpeq>:
 80006b4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80006b8:	f7ff fff4 	bl	80006a4 <__aeabi_cdcmpeq>
 80006bc:	bf0c      	ite	eq
 80006be:	2001      	moveq	r0, #1
 80006c0:	2000      	movne	r0, #0
 80006c2:	f85d fb08 	ldr.w	pc, [sp], #8
 80006c6:	bf00      	nop

080006c8 <__aeabi_dcmplt>:
 80006c8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80006cc:	f7ff ffea 	bl	80006a4 <__aeabi_cdcmpeq>
 80006d0:	bf34      	ite	cc
 80006d2:	2001      	movcc	r0, #1
 80006d4:	2000      	movcs	r0, #0
 80006d6:	f85d fb08 	ldr.w	pc, [sp], #8
 80006da:	bf00      	nop

080006dc <__aeabi_dcmple>:
 80006dc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80006e0:	f7ff ffe0 	bl	80006a4 <__aeabi_cdcmpeq>
 80006e4:	bf94      	ite	ls
 80006e6:	2001      	movls	r0, #1
 80006e8:	2000      	movhi	r0, #0
 80006ea:	f85d fb08 	ldr.w	pc, [sp], #8
 80006ee:	bf00      	nop

080006f0 <__aeabi_dcmpge>:
 80006f0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80006f4:	f7ff ffce 	bl	8000694 <__aeabi_cdrcmple>
 80006f8:	bf94      	ite	ls
 80006fa:	2001      	movls	r0, #1
 80006fc:	2000      	movhi	r0, #0
 80006fe:	f85d fb08 	ldr.w	pc, [sp], #8
 8000702:	bf00      	nop

08000704 <__aeabi_dcmpgt>:
 8000704:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000708:	f7ff ffc4 	bl	8000694 <__aeabi_cdrcmple>
 800070c:	bf34      	ite	cc
 800070e:	2001      	movcc	r0, #1
 8000710:	2000      	movcs	r0, #0
 8000712:	f85d fb08 	ldr.w	pc, [sp], #8
 8000716:	bf00      	nop

08000718 <__aeabi_uldivmod>:
 8000718:	b953      	cbnz	r3, 8000730 <__aeabi_uldivmod+0x18>
 800071a:	b94a      	cbnz	r2, 8000730 <__aeabi_uldivmod+0x18>
 800071c:	2900      	cmp	r1, #0
 800071e:	bf08      	it	eq
 8000720:	2800      	cmpeq	r0, #0
 8000722:	bf1c      	itt	ne
 8000724:	f04f 31ff 	movne.w	r1, #4294967295
 8000728:	f04f 30ff 	movne.w	r0, #4294967295
 800072c:	f000 b988 	b.w	8000a40 <__aeabi_idiv0>
 8000730:	f1ad 0c08 	sub.w	ip, sp, #8
 8000734:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000738:	f000 f806 	bl	8000748 <__udivmoddi4>
 800073c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000740:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000744:	b004      	add	sp, #16
 8000746:	4770      	bx	lr

08000748 <__udivmoddi4>:
 8000748:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800074c:	9d08      	ldr	r5, [sp, #32]
 800074e:	468e      	mov	lr, r1
 8000750:	4604      	mov	r4, r0
 8000752:	4688      	mov	r8, r1
 8000754:	2b00      	cmp	r3, #0
 8000756:	d14a      	bne.n	80007ee <__udivmoddi4+0xa6>
 8000758:	428a      	cmp	r2, r1
 800075a:	4617      	mov	r7, r2
 800075c:	d962      	bls.n	8000824 <__udivmoddi4+0xdc>
 800075e:	fab2 f682 	clz	r6, r2
 8000762:	b14e      	cbz	r6, 8000778 <__udivmoddi4+0x30>
 8000764:	f1c6 0320 	rsb	r3, r6, #32
 8000768:	fa01 f806 	lsl.w	r8, r1, r6
 800076c:	fa20 f303 	lsr.w	r3, r0, r3
 8000770:	40b7      	lsls	r7, r6
 8000772:	ea43 0808 	orr.w	r8, r3, r8
 8000776:	40b4      	lsls	r4, r6
 8000778:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 800077c:	fa1f fc87 	uxth.w	ip, r7
 8000780:	fbb8 f1fe 	udiv	r1, r8, lr
 8000784:	0c23      	lsrs	r3, r4, #16
 8000786:	fb0e 8811 	mls	r8, lr, r1, r8
 800078a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800078e:	fb01 f20c 	mul.w	r2, r1, ip
 8000792:	429a      	cmp	r2, r3
 8000794:	d909      	bls.n	80007aa <__udivmoddi4+0x62>
 8000796:	18fb      	adds	r3, r7, r3
 8000798:	f101 30ff 	add.w	r0, r1, #4294967295
 800079c:	f080 80ea 	bcs.w	8000974 <__udivmoddi4+0x22c>
 80007a0:	429a      	cmp	r2, r3
 80007a2:	f240 80e7 	bls.w	8000974 <__udivmoddi4+0x22c>
 80007a6:	3902      	subs	r1, #2
 80007a8:	443b      	add	r3, r7
 80007aa:	1a9a      	subs	r2, r3, r2
 80007ac:	b2a3      	uxth	r3, r4
 80007ae:	fbb2 f0fe 	udiv	r0, r2, lr
 80007b2:	fb0e 2210 	mls	r2, lr, r0, r2
 80007b6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80007ba:	fb00 fc0c 	mul.w	ip, r0, ip
 80007be:	459c      	cmp	ip, r3
 80007c0:	d909      	bls.n	80007d6 <__udivmoddi4+0x8e>
 80007c2:	18fb      	adds	r3, r7, r3
 80007c4:	f100 32ff 	add.w	r2, r0, #4294967295
 80007c8:	f080 80d6 	bcs.w	8000978 <__udivmoddi4+0x230>
 80007cc:	459c      	cmp	ip, r3
 80007ce:	f240 80d3 	bls.w	8000978 <__udivmoddi4+0x230>
 80007d2:	443b      	add	r3, r7
 80007d4:	3802      	subs	r0, #2
 80007d6:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 80007da:	eba3 030c 	sub.w	r3, r3, ip
 80007de:	2100      	movs	r1, #0
 80007e0:	b11d      	cbz	r5, 80007ea <__udivmoddi4+0xa2>
 80007e2:	40f3      	lsrs	r3, r6
 80007e4:	2200      	movs	r2, #0
 80007e6:	e9c5 3200 	strd	r3, r2, [r5]
 80007ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80007ee:	428b      	cmp	r3, r1
 80007f0:	d905      	bls.n	80007fe <__udivmoddi4+0xb6>
 80007f2:	b10d      	cbz	r5, 80007f8 <__udivmoddi4+0xb0>
 80007f4:	e9c5 0100 	strd	r0, r1, [r5]
 80007f8:	2100      	movs	r1, #0
 80007fa:	4608      	mov	r0, r1
 80007fc:	e7f5      	b.n	80007ea <__udivmoddi4+0xa2>
 80007fe:	fab3 f183 	clz	r1, r3
 8000802:	2900      	cmp	r1, #0
 8000804:	d146      	bne.n	8000894 <__udivmoddi4+0x14c>
 8000806:	4573      	cmp	r3, lr
 8000808:	d302      	bcc.n	8000810 <__udivmoddi4+0xc8>
 800080a:	4282      	cmp	r2, r0
 800080c:	f200 8105 	bhi.w	8000a1a <__udivmoddi4+0x2d2>
 8000810:	1a84      	subs	r4, r0, r2
 8000812:	eb6e 0203 	sbc.w	r2, lr, r3
 8000816:	2001      	movs	r0, #1
 8000818:	4690      	mov	r8, r2
 800081a:	2d00      	cmp	r5, #0
 800081c:	d0e5      	beq.n	80007ea <__udivmoddi4+0xa2>
 800081e:	e9c5 4800 	strd	r4, r8, [r5]
 8000822:	e7e2      	b.n	80007ea <__udivmoddi4+0xa2>
 8000824:	2a00      	cmp	r2, #0
 8000826:	f000 8090 	beq.w	800094a <__udivmoddi4+0x202>
 800082a:	fab2 f682 	clz	r6, r2
 800082e:	2e00      	cmp	r6, #0
 8000830:	f040 80a4 	bne.w	800097c <__udivmoddi4+0x234>
 8000834:	1a8a      	subs	r2, r1, r2
 8000836:	0c03      	lsrs	r3, r0, #16
 8000838:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 800083c:	b280      	uxth	r0, r0
 800083e:	b2bc      	uxth	r4, r7
 8000840:	2101      	movs	r1, #1
 8000842:	fbb2 fcfe 	udiv	ip, r2, lr
 8000846:	fb0e 221c 	mls	r2, lr, ip, r2
 800084a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800084e:	fb04 f20c 	mul.w	r2, r4, ip
 8000852:	429a      	cmp	r2, r3
 8000854:	d907      	bls.n	8000866 <__udivmoddi4+0x11e>
 8000856:	18fb      	adds	r3, r7, r3
 8000858:	f10c 38ff 	add.w	r8, ip, #4294967295
 800085c:	d202      	bcs.n	8000864 <__udivmoddi4+0x11c>
 800085e:	429a      	cmp	r2, r3
 8000860:	f200 80e0 	bhi.w	8000a24 <__udivmoddi4+0x2dc>
 8000864:	46c4      	mov	ip, r8
 8000866:	1a9b      	subs	r3, r3, r2
 8000868:	fbb3 f2fe 	udiv	r2, r3, lr
 800086c:	fb0e 3312 	mls	r3, lr, r2, r3
 8000870:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8000874:	fb02 f404 	mul.w	r4, r2, r4
 8000878:	429c      	cmp	r4, r3
 800087a:	d907      	bls.n	800088c <__udivmoddi4+0x144>
 800087c:	18fb      	adds	r3, r7, r3
 800087e:	f102 30ff 	add.w	r0, r2, #4294967295
 8000882:	d202      	bcs.n	800088a <__udivmoddi4+0x142>
 8000884:	429c      	cmp	r4, r3
 8000886:	f200 80ca 	bhi.w	8000a1e <__udivmoddi4+0x2d6>
 800088a:	4602      	mov	r2, r0
 800088c:	1b1b      	subs	r3, r3, r4
 800088e:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 8000892:	e7a5      	b.n	80007e0 <__udivmoddi4+0x98>
 8000894:	f1c1 0620 	rsb	r6, r1, #32
 8000898:	408b      	lsls	r3, r1
 800089a:	fa22 f706 	lsr.w	r7, r2, r6
 800089e:	431f      	orrs	r7, r3
 80008a0:	fa0e f401 	lsl.w	r4, lr, r1
 80008a4:	fa20 f306 	lsr.w	r3, r0, r6
 80008a8:	fa2e fe06 	lsr.w	lr, lr, r6
 80008ac:	ea4f 4917 	mov.w	r9, r7, lsr #16
 80008b0:	4323      	orrs	r3, r4
 80008b2:	fa00 f801 	lsl.w	r8, r0, r1
 80008b6:	fa1f fc87 	uxth.w	ip, r7
 80008ba:	fbbe f0f9 	udiv	r0, lr, r9
 80008be:	0c1c      	lsrs	r4, r3, #16
 80008c0:	fb09 ee10 	mls	lr, r9, r0, lr
 80008c4:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 80008c8:	fb00 fe0c 	mul.w	lr, r0, ip
 80008cc:	45a6      	cmp	lr, r4
 80008ce:	fa02 f201 	lsl.w	r2, r2, r1
 80008d2:	d909      	bls.n	80008e8 <__udivmoddi4+0x1a0>
 80008d4:	193c      	adds	r4, r7, r4
 80008d6:	f100 3aff 	add.w	sl, r0, #4294967295
 80008da:	f080 809c 	bcs.w	8000a16 <__udivmoddi4+0x2ce>
 80008de:	45a6      	cmp	lr, r4
 80008e0:	f240 8099 	bls.w	8000a16 <__udivmoddi4+0x2ce>
 80008e4:	3802      	subs	r0, #2
 80008e6:	443c      	add	r4, r7
 80008e8:	eba4 040e 	sub.w	r4, r4, lr
 80008ec:	fa1f fe83 	uxth.w	lr, r3
 80008f0:	fbb4 f3f9 	udiv	r3, r4, r9
 80008f4:	fb09 4413 	mls	r4, r9, r3, r4
 80008f8:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 80008fc:	fb03 fc0c 	mul.w	ip, r3, ip
 8000900:	45a4      	cmp	ip, r4
 8000902:	d908      	bls.n	8000916 <__udivmoddi4+0x1ce>
 8000904:	193c      	adds	r4, r7, r4
 8000906:	f103 3eff 	add.w	lr, r3, #4294967295
 800090a:	f080 8082 	bcs.w	8000a12 <__udivmoddi4+0x2ca>
 800090e:	45a4      	cmp	ip, r4
 8000910:	d97f      	bls.n	8000a12 <__udivmoddi4+0x2ca>
 8000912:	3b02      	subs	r3, #2
 8000914:	443c      	add	r4, r7
 8000916:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800091a:	eba4 040c 	sub.w	r4, r4, ip
 800091e:	fba0 ec02 	umull	lr, ip, r0, r2
 8000922:	4564      	cmp	r4, ip
 8000924:	4673      	mov	r3, lr
 8000926:	46e1      	mov	r9, ip
 8000928:	d362      	bcc.n	80009f0 <__udivmoddi4+0x2a8>
 800092a:	d05f      	beq.n	80009ec <__udivmoddi4+0x2a4>
 800092c:	b15d      	cbz	r5, 8000946 <__udivmoddi4+0x1fe>
 800092e:	ebb8 0203 	subs.w	r2, r8, r3
 8000932:	eb64 0409 	sbc.w	r4, r4, r9
 8000936:	fa04 f606 	lsl.w	r6, r4, r6
 800093a:	fa22 f301 	lsr.w	r3, r2, r1
 800093e:	431e      	orrs	r6, r3
 8000940:	40cc      	lsrs	r4, r1
 8000942:	e9c5 6400 	strd	r6, r4, [r5]
 8000946:	2100      	movs	r1, #0
 8000948:	e74f      	b.n	80007ea <__udivmoddi4+0xa2>
 800094a:	fbb1 fcf2 	udiv	ip, r1, r2
 800094e:	0c01      	lsrs	r1, r0, #16
 8000950:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 8000954:	b280      	uxth	r0, r0
 8000956:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 800095a:	463b      	mov	r3, r7
 800095c:	4638      	mov	r0, r7
 800095e:	463c      	mov	r4, r7
 8000960:	46b8      	mov	r8, r7
 8000962:	46be      	mov	lr, r7
 8000964:	2620      	movs	r6, #32
 8000966:	fbb1 f1f7 	udiv	r1, r1, r7
 800096a:	eba2 0208 	sub.w	r2, r2, r8
 800096e:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 8000972:	e766      	b.n	8000842 <__udivmoddi4+0xfa>
 8000974:	4601      	mov	r1, r0
 8000976:	e718      	b.n	80007aa <__udivmoddi4+0x62>
 8000978:	4610      	mov	r0, r2
 800097a:	e72c      	b.n	80007d6 <__udivmoddi4+0x8e>
 800097c:	f1c6 0220 	rsb	r2, r6, #32
 8000980:	fa2e f302 	lsr.w	r3, lr, r2
 8000984:	40b7      	lsls	r7, r6
 8000986:	40b1      	lsls	r1, r6
 8000988:	fa20 f202 	lsr.w	r2, r0, r2
 800098c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000990:	430a      	orrs	r2, r1
 8000992:	fbb3 f8fe 	udiv	r8, r3, lr
 8000996:	b2bc      	uxth	r4, r7
 8000998:	fb0e 3318 	mls	r3, lr, r8, r3
 800099c:	0c11      	lsrs	r1, r2, #16
 800099e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80009a2:	fb08 f904 	mul.w	r9, r8, r4
 80009a6:	40b0      	lsls	r0, r6
 80009a8:	4589      	cmp	r9, r1
 80009aa:	ea4f 4310 	mov.w	r3, r0, lsr #16
 80009ae:	b280      	uxth	r0, r0
 80009b0:	d93e      	bls.n	8000a30 <__udivmoddi4+0x2e8>
 80009b2:	1879      	adds	r1, r7, r1
 80009b4:	f108 3cff 	add.w	ip, r8, #4294967295
 80009b8:	d201      	bcs.n	80009be <__udivmoddi4+0x276>
 80009ba:	4589      	cmp	r9, r1
 80009bc:	d81f      	bhi.n	80009fe <__udivmoddi4+0x2b6>
 80009be:	eba1 0109 	sub.w	r1, r1, r9
 80009c2:	fbb1 f9fe 	udiv	r9, r1, lr
 80009c6:	fb09 f804 	mul.w	r8, r9, r4
 80009ca:	fb0e 1119 	mls	r1, lr, r9, r1
 80009ce:	b292      	uxth	r2, r2
 80009d0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80009d4:	4542      	cmp	r2, r8
 80009d6:	d229      	bcs.n	8000a2c <__udivmoddi4+0x2e4>
 80009d8:	18ba      	adds	r2, r7, r2
 80009da:	f109 31ff 	add.w	r1, r9, #4294967295
 80009de:	d2c4      	bcs.n	800096a <__udivmoddi4+0x222>
 80009e0:	4542      	cmp	r2, r8
 80009e2:	d2c2      	bcs.n	800096a <__udivmoddi4+0x222>
 80009e4:	f1a9 0102 	sub.w	r1, r9, #2
 80009e8:	443a      	add	r2, r7
 80009ea:	e7be      	b.n	800096a <__udivmoddi4+0x222>
 80009ec:	45f0      	cmp	r8, lr
 80009ee:	d29d      	bcs.n	800092c <__udivmoddi4+0x1e4>
 80009f0:	ebbe 0302 	subs.w	r3, lr, r2
 80009f4:	eb6c 0c07 	sbc.w	ip, ip, r7
 80009f8:	3801      	subs	r0, #1
 80009fa:	46e1      	mov	r9, ip
 80009fc:	e796      	b.n	800092c <__udivmoddi4+0x1e4>
 80009fe:	eba7 0909 	sub.w	r9, r7, r9
 8000a02:	4449      	add	r1, r9
 8000a04:	f1a8 0c02 	sub.w	ip, r8, #2
 8000a08:	fbb1 f9fe 	udiv	r9, r1, lr
 8000a0c:	fb09 f804 	mul.w	r8, r9, r4
 8000a10:	e7db      	b.n	80009ca <__udivmoddi4+0x282>
 8000a12:	4673      	mov	r3, lr
 8000a14:	e77f      	b.n	8000916 <__udivmoddi4+0x1ce>
 8000a16:	4650      	mov	r0, sl
 8000a18:	e766      	b.n	80008e8 <__udivmoddi4+0x1a0>
 8000a1a:	4608      	mov	r0, r1
 8000a1c:	e6fd      	b.n	800081a <__udivmoddi4+0xd2>
 8000a1e:	443b      	add	r3, r7
 8000a20:	3a02      	subs	r2, #2
 8000a22:	e733      	b.n	800088c <__udivmoddi4+0x144>
 8000a24:	f1ac 0c02 	sub.w	ip, ip, #2
 8000a28:	443b      	add	r3, r7
 8000a2a:	e71c      	b.n	8000866 <__udivmoddi4+0x11e>
 8000a2c:	4649      	mov	r1, r9
 8000a2e:	e79c      	b.n	800096a <__udivmoddi4+0x222>
 8000a30:	eba1 0109 	sub.w	r1, r1, r9
 8000a34:	46c4      	mov	ip, r8
 8000a36:	fbb1 f9fe 	udiv	r9, r1, lr
 8000a3a:	fb09 f804 	mul.w	r8, r9, r4
 8000a3e:	e7c4      	b.n	80009ca <__udivmoddi4+0x282>

08000a40 <__aeabi_idiv0>:
 8000a40:	4770      	bx	lr
 8000a42:	bf00      	nop

08000a44 <AMCOM_UpdateCRC>:
const uint8_t  AMCOM_SOP         = 0xA1;
const uint16_t AMCOM_INITIAL_CRC = 0xFFFF;

static uint16_t AMCOM_UpdateCRC(uint8_t byte, uint16_t crc)
{
	byte ^= (uint8_t)(crc & 0x00ff);
 8000a44:	b2cb      	uxtb	r3, r1
 8000a46:	4058      	eors	r0, r3
	byte ^= (uint8_t)(byte << 4);
 8000a48:	0103      	lsls	r3, r0, #4
 8000a4a:	b2db      	uxtb	r3, r3
 8000a4c:	ea83 0200 	eor.w	r2, r3, r0
	return ((((uint16_t)byte << 8) | (uint8_t)(crc >> 8)) ^ (uint8_t)(byte >> 4) ^ ((uint16_t)byte << 3));
 8000a50:	0210      	lsls	r0, r2, #8
 8000a52:	ea40 2011 	orr.w	r0, r0, r1, lsr #8
 8000a56:	b200      	sxth	r0, r0
 8000a58:	ea80 1012 	eor.w	r0, r0, r2, lsr #4
 8000a5c:	ea80 00c2 	eor.w	r0, r0, r2, lsl #3
}
 8000a60:	b280      	uxth	r0, r0
 8000a62:	4770      	bx	lr

08000a64 <AMCOM_InitReceiver>:


void AMCOM_InitReceiver(AMCOM_Receiver* receiver, AMCOM_PacketHandler packetHandlerCallback, void* userContext) {
 8000a64:	b570      	push	{r4, r5, r6, lr}
 8000a66:	4604      	mov	r4, r0
 8000a68:	460e      	mov	r6, r1
 8000a6a:	4615      	mov	r5, r2
	memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
 8000a6c:	22cd      	movs	r2, #205	@ 0xcd
 8000a6e:	2100      	movs	r1, #0
 8000a70:	f00e f920 	bl	800ecb4 <memset>
	receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
 8000a74:	2300      	movs	r3, #0
 8000a76:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
    receiver->packetHandler = packetHandlerCallback;
 8000a7a:	f8c4 60d8 	str.w	r6, [r4, #216]	@ 0xd8
    receiver->userContext = userContext;
 8000a7e:	f8c4 50dc 	str.w	r5, [r4, #220]	@ 0xdc
    receiver->payloadCounter = 0;
 8000a82:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
}
 8000a86:	bd70      	pop	{r4, r5, r6, pc}

08000a88 <AMCOM_Serialize>:

size_t AMCOM_Serialize(uint8_t packetType, const void* payload, size_t payloadSize, uint8_t* destinationBuffer) {
	
	if(!(destinationBuffer) || payloadSize>AMCOM_MAX_PAYLOAD_SIZE || (payloadSize > 0 && payload == NULL)){
 8000a88:	b3a3      	cbz	r3, 8000af4 <AMCOM_Serialize+0x6c>
size_t AMCOM_Serialize(uint8_t packetType, const void* payload, size_t payloadSize, uint8_t* destinationBuffer) {
 8000a8a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000a8e:	4606      	mov	r6, r0
 8000a90:	460d      	mov	r5, r1
 8000a92:	4614      	mov	r4, r2
 8000a94:	461f      	mov	r7, r3
	if(!(destinationBuffer) || payloadSize>AMCOM_MAX_PAYLOAD_SIZE || (payloadSize > 0 && payload == NULL)){
 8000a96:	2ac8      	cmp	r2, #200	@ 0xc8
 8000a98:	d82e      	bhi.n	8000af8 <AMCOM_Serialize+0x70>
 8000a9a:	b102      	cbz	r2, 8000a9e <AMCOM_Serialize+0x16>
 8000a9c:	b371      	cbz	r1, 8000afc <AMCOM_Serialize+0x74>
	    return 0;
	}
	
	//initial CRC
	uint16_t crc = AMCOM_INITIAL_CRC;
    crc = AMCOM_UpdateCRC(packetType, crc);
 8000a9e:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8000aa2:	4630      	mov	r0, r6
 8000aa4:	f7ff ffce 	bl	8000a44 <AMCOM_UpdateCRC>
 8000aa8:	4601      	mov	r1, r0
    crc = AMCOM_UpdateCRC((uint8_t)payloadSize, crc);
 8000aaa:	fa5f f884 	uxtb.w	r8, r4
 8000aae:	4640      	mov	r0, r8
 8000ab0:	f7ff ffc8 	bl	8000a44 <AMCOM_UpdateCRC>
 8000ab4:	4601      	mov	r1, r0
	
	//CRC calculation
	const uint8_t* payloadData = (const uint8_t*)payload;
	for (size_t i = 0; i < payloadSize; i++) {
 8000ab6:	f04f 0900 	mov.w	r9, #0
 8000aba:	e006      	b.n	8000aca <AMCOM_Serialize+0x42>
        crc = AMCOM_UpdateCRC(*(payloadData+i), crc);
 8000abc:	f815 0009 	ldrb.w	r0, [r5, r9]
 8000ac0:	f7ff ffc0 	bl	8000a44 <AMCOM_UpdateCRC>
 8000ac4:	4601      	mov	r1, r0
	for (size_t i = 0; i < payloadSize; i++) {
 8000ac6:	f109 0901 	add.w	r9, r9, #1
 8000aca:	45a1      	cmp	r9, r4
 8000acc:	d3f6      	bcc.n	8000abc <AMCOM_Serialize+0x34>
    }
	
	//HEADER
	*(destinationBuffer) = AMCOM_SOP;
 8000ace:	23a1      	movs	r3, #161	@ 0xa1
 8000ad0:	703b      	strb	r3, [r7, #0]
	*(destinationBuffer+1) = packetType;
 8000ad2:	707e      	strb	r6, [r7, #1]
	*(destinationBuffer+2) = (uint8_t)payloadSize;
 8000ad4:	f887 8002 	strb.w	r8, [r7, #2]
    *(destinationBuffer+3) = (uint8_t)(crc);
 8000ad8:	70f9      	strb	r1, [r7, #3]
	*(destinationBuffer+4) = (uint8_t)(crc >> 8);
 8000ada:	f3c1 2007 	ubfx	r0, r1, #8, #8
 8000ade:	7138      	strb	r0, [r7, #4]
    
	if (payloadSize > 0) {
 8000ae0:	b914      	cbnz	r4, 8000ae8 <AMCOM_Serialize+0x60>
        memcpy(destinationBuffer+5, payload, payloadSize);
    }
	
	//return payloadSize + headerSize
	return payloadSize + 5;
 8000ae2:	1d60      	adds	r0, r4, #5
}
 8000ae4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        memcpy(destinationBuffer+5, payload, payloadSize);
 8000ae8:	4622      	mov	r2, r4
 8000aea:	4629      	mov	r1, r5
 8000aec:	1d78      	adds	r0, r7, #5
 8000aee:	f00e f9ba 	bl	800ee66 <memcpy>
 8000af2:	e7f6      	b.n	8000ae2 <AMCOM_Serialize+0x5a>
	    return 0;
 8000af4:	2000      	movs	r0, #0
}
 8000af6:	4770      	bx	lr
	    return 0;
 8000af8:	2000      	movs	r0, #0
 8000afa:	e7f3      	b.n	8000ae4 <AMCOM_Serialize+0x5c>
 8000afc:	2000      	movs	r0, #0
 8000afe:	e7f1      	b.n	8000ae4 <AMCOM_Serialize+0x5c>

08000b00 <AMCOM_Deserialize>:

void AMCOM_Deserialize(AMCOM_Receiver* receiver, const void* data, size_t dataSize) {
 8000b00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000b04:	4604      	mov	r4, r0
 8000b06:	460f      	mov	r7, r1
 8000b08:	4616      	mov	r6, r2
    const uint8_t* receivedData = (const uint8_t*)data;
    
    uint8_t curr;
    //uint16_t crc;
    
    for (size_t i = 0; i < dataSize; i++) {
 8000b0a:	2500      	movs	r5, #0
 8000b0c:	e010      	b.n	8000b30 <AMCOM_Deserialize+0x30>
        curr = *(receivedData+i);
        switch (receiver->receivedPacketState) {
            
            case AMCOM_PACKET_STATE_EMPTY:
                if (curr == AMCOM_SOP) {
 8000b0e:	28a1      	cmp	r0, #161	@ 0xa1
 8000b10:	d108      	bne.n	8000b24 <AMCOM_Deserialize+0x24>
                    //memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
                    //crc = AMCOM_INITIAL_CRC;
                    //receiver->payloadCounter = 0;
                    receiver->receivedPacket.header.sop = curr;
 8000b12:	7020      	strb	r0, [r4, #0]
                    receiver->receivedPacketState = AMCOM_PACKET_STATE_GOT_SOP;
 8000b14:	2301      	movs	r3, #1
 8000b16:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
 8000b1a:	e003      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                }
                break;
                
            case AMCOM_PACKET_STATE_GOT_SOP:
                receiver->receivedPacket.header.type = curr;
 8000b1c:	7060      	strb	r0, [r4, #1]
                //crc = AMCOM_UpdateCRC(curr, crc);
                receiver->receivedPacketState = AMCOM_PACKET_STATE_GOT_TYPE;
 8000b1e:	2302      	movs	r3, #2
 8000b20:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
                    receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
                    memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
                }
                break;
        }
        if(receiver->receivedPacketState == AMCOM_PACKET_STATE_GOT_WHOLE_PACKET){
 8000b24:	f894 30d4 	ldrb.w	r3, [r4, #212]	@ 0xd4
 8000b28:	2b07      	cmp	r3, #7
 8000b2a:	f000 8095 	beq.w	8000c58 <AMCOM_Deserialize+0x158>
    for (size_t i = 0; i < dataSize; i++) {
 8000b2e:	3501      	adds	r5, #1
 8000b30:	42b5      	cmp	r5, r6
 8000b32:	f080 80a0 	bcs.w	8000c76 <AMCOM_Deserialize+0x176>
        curr = *(receivedData+i);
 8000b36:	5d78      	ldrb	r0, [r7, r5]
        switch (receiver->receivedPacketState) {
 8000b38:	f894 30d4 	ldrb.w	r3, [r4, #212]	@ 0xd4
 8000b3c:	2b06      	cmp	r3, #6
 8000b3e:	d8f1      	bhi.n	8000b24 <AMCOM_Deserialize+0x24>
 8000b40:	a201      	add	r2, pc, #4	@ (adr r2, 8000b48 <AMCOM_Deserialize+0x48>)
 8000b42:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000b46:	bf00      	nop
 8000b48:	08000b0f 	.word	0x08000b0f
 8000b4c:	08000b1d 	.word	0x08000b1d
 8000b50:	08000b65 	.word	0x08000b65
 8000b54:	08000b83 	.word	0x08000b83
 8000b58:	08000b8f 	.word	0x08000b8f
 8000b5c:	08000b25 	.word	0x08000b25
 8000b60:	08000be1 	.word	0x08000be1
                if (curr > AMCOM_MAX_PAYLOAD_SIZE) {
 8000b64:	28c8      	cmp	r0, #200	@ 0xc8
 8000b66:	d804      	bhi.n	8000b72 <AMCOM_Deserialize+0x72>
                    receiver->receivedPacket.header.length = curr;
 8000b68:	70a0      	strb	r0, [r4, #2]
                    receiver->receivedPacketState = AMCOM_PACKET_STATE_GOT_LENGTH;
 8000b6a:	2303      	movs	r3, #3
 8000b6c:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
 8000b70:	e7d8      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                    receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
 8000b72:	2100      	movs	r1, #0
 8000b74:	f884 10d4 	strb.w	r1, [r4, #212]	@ 0xd4
                    memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
 8000b78:	22cd      	movs	r2, #205	@ 0xcd
 8000b7a:	4620      	mov	r0, r4
 8000b7c:	f00e f89a 	bl	800ecb4 <memset>
 8000b80:	e7d0      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                receiver->receivedPacket.header.crc = curr;
 8000b82:	f8a4 0003 	strh.w	r0, [r4, #3]
                receiver->receivedPacketState = AMCOM_PACKET_STATE_GOT_CRC_LO;
 8000b86:	2304      	movs	r3, #4
 8000b88:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
                break;
 8000b8c:	e7ca      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                receiver->receivedPacket.header.crc |= ((uint16_t)curr << 8);
 8000b8e:	f8b4 8003 	ldrh.w	r8, [r4, #3]
 8000b92:	ea48 2800 	orr.w	r8, r8, r0, lsl #8
 8000b96:	f8a4 8003 	strh.w	r8, [r4, #3]
                if (receiver->receivedPacket.header.length == 0) {
 8000b9a:	f894 9002 	ldrb.w	r9, [r4, #2]
 8000b9e:	f1b9 0f00 	cmp.w	r9, #0
 8000ba2:	d116      	bne.n	8000bd2 <AMCOM_Deserialize+0xd2>
                    crc = AMCOM_UpdateCRC(receiver->receivedPacket.header.type, crc);
 8000ba4:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8000ba8:	7860      	ldrb	r0, [r4, #1]
 8000baa:	f7ff ff4b 	bl	8000a44 <AMCOM_UpdateCRC>
 8000bae:	4601      	mov	r1, r0
                    crc = AMCOM_UpdateCRC(receiver->receivedPacket.header.length, crc);
 8000bb0:	4648      	mov	r0, r9
 8000bb2:	f7ff ff47 	bl	8000a44 <AMCOM_UpdateCRC>
                    if (crc == receiver->receivedPacket.header.crc) {
 8000bb6:	4580      	cmp	r8, r0
 8000bb8:	d103      	bne.n	8000bc2 <AMCOM_Deserialize+0xc2>
                        receiver->receivedPacketState = AMCOM_PACKET_STATE_GOT_WHOLE_PACKET;
 8000bba:	2307      	movs	r3, #7
 8000bbc:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
 8000bc0:	e7b0      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                        receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
 8000bc2:	2100      	movs	r1, #0
 8000bc4:	f884 10d4 	strb.w	r1, [r4, #212]	@ 0xd4
                        memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
 8000bc8:	22cd      	movs	r2, #205	@ 0xcd
 8000bca:	4620      	mov	r0, r4
 8000bcc:	f00e f872 	bl	800ecb4 <memset>
 8000bd0:	e7a8      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                    receiver->payloadCounter = 0;
 8000bd2:	2300      	movs	r3, #0
 8000bd4:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
                    receiver->receivedPacketState = AMCOM_PACKET_STATE_GETTING_PAYLOAD;
 8000bd8:	2306      	movs	r3, #6
 8000bda:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
 8000bde:	e7a1      	b.n	8000b24 <AMCOM_Deserialize+0x24>
				if (receiver->payloadCounter < AMCOM_MAX_PAYLOAD_SIZE) {
 8000be0:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
 8000be4:	2bc7      	cmp	r3, #199	@ 0xc7
 8000be6:	d82f      	bhi.n	8000c48 <AMCOM_Deserialize+0x148>
					receiver->receivedPacket.payload[receiver->payloadCounter] = curr;
 8000be8:	18e2      	adds	r2, r4, r3
 8000bea:	7150      	strb	r0, [r2, #5]
					receiver->payloadCounter += 1;
 8000bec:	3301      	adds	r3, #1
 8000bee:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
					if (receiver->payloadCounter == receiver->receivedPacket.header.length) {
 8000bf2:	f894 8002 	ldrb.w	r8, [r4, #2]
 8000bf6:	4543      	cmp	r3, r8
 8000bf8:	d194      	bne.n	8000b24 <AMCOM_Deserialize+0x24>
                        crc = AMCOM_UpdateCRC(receiver->receivedPacket.header.type, crc);
 8000bfa:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8000bfe:	7860      	ldrb	r0, [r4, #1]
 8000c00:	f7ff ff20 	bl	8000a44 <AMCOM_UpdateCRC>
 8000c04:	4601      	mov	r1, r0
                        crc = AMCOM_UpdateCRC(receiver->receivedPacket.header.length, crc);
 8000c06:	4640      	mov	r0, r8
 8000c08:	f7ff ff1c 	bl	8000a44 <AMCOM_UpdateCRC>
 8000c0c:	4601      	mov	r1, r0
						for (size_t j = 0; j < (size_t)receiver->receivedPacket.header.length; j++) {
 8000c0e:	f04f 0900 	mov.w	r9, #0
 8000c12:	e007      	b.n	8000c24 <AMCOM_Deserialize+0x124>
							crc = AMCOM_UpdateCRC(receiver->receivedPacket.payload[j], crc);
 8000c14:	eb04 0309 	add.w	r3, r4, r9
 8000c18:	7958      	ldrb	r0, [r3, #5]
 8000c1a:	f7ff ff13 	bl	8000a44 <AMCOM_UpdateCRC>
 8000c1e:	4601      	mov	r1, r0
						for (size_t j = 0; j < (size_t)receiver->receivedPacket.header.length; j++) {
 8000c20:	f109 0901 	add.w	r9, r9, #1
 8000c24:	45c8      	cmp	r8, r9
 8000c26:	d8f5      	bhi.n	8000c14 <AMCOM_Deserialize+0x114>
						if (crc == receiver->receivedPacket.header.crc) {
 8000c28:	f8b4 3003 	ldrh.w	r3, [r4, #3]
 8000c2c:	428b      	cmp	r3, r1
 8000c2e:	d103      	bne.n	8000c38 <AMCOM_Deserialize+0x138>
                        receiver->receivedPacketState = AMCOM_PACKET_STATE_GOT_WHOLE_PACKET;
 8000c30:	2307      	movs	r3, #7
 8000c32:	f884 30d4 	strb.w	r3, [r4, #212]	@ 0xd4
 8000c36:	e775      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                            receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
 8000c38:	2100      	movs	r1, #0
 8000c3a:	f884 10d4 	strb.w	r1, [r4, #212]	@ 0xd4
                            memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
 8000c3e:	22cd      	movs	r2, #205	@ 0xcd
 8000c40:	4620      	mov	r0, r4
 8000c42:	f00e f837 	bl	800ecb4 <memset>
 8000c46:	e76d      	b.n	8000b24 <AMCOM_Deserialize+0x24>
                    receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
 8000c48:	2100      	movs	r1, #0
 8000c4a:	f884 10d4 	strb.w	r1, [r4, #212]	@ 0xd4
                    memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
 8000c4e:	22cd      	movs	r2, #205	@ 0xcd
 8000c50:	4620      	mov	r0, r4
 8000c52:	f00e f82f 	bl	800ecb4 <memset>
 8000c56:	e765      	b.n	8000b24 <AMCOM_Deserialize+0x24>
            if ( receiver->packetHandler != NULL /* && crc == receiver->receivedPacket.header.crc */) {
 8000c58:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
 8000c5c:	b11b      	cbz	r3, 8000c66 <AMCOM_Deserialize+0x166>
                receiver->packetHandler(&receiver->receivedPacket, receiver->userContext);
 8000c5e:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
 8000c62:	4620      	mov	r0, r4
 8000c64:	4798      	blx	r3
            }
            receiver->receivedPacketState = AMCOM_PACKET_STATE_EMPTY;
 8000c66:	2100      	movs	r1, #0
 8000c68:	f884 10d4 	strb.w	r1, [r4, #212]	@ 0xd4
            memset(&receiver->receivedPacket, 0, sizeof(receiver->receivedPacket));
 8000c6c:	22cd      	movs	r2, #205	@ 0xcd
 8000c6e:	4620      	mov	r0, r4
 8000c70:	f00e f820 	bl	800ecb4 <memset>
 8000c74:	e75b      	b.n	8000b2e <AMCOM_Deserialize+0x2e>
        }
    }
 8000c76:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000c7a:	bf00      	nop
 8000c7c:	0000      	movs	r0, r0
	...

08000c80 <computeMoveDirection>:
#include <FreeRTOS_Sockets.h>

/**
 * This function is used when AMCOM_MOVE_REQUEST is received
 */
float computeMoveDirection(const GameState* state) {
 8000c80:	b570      	push	{r4, r5, r6, lr}
 8000c82:	ed2d 8b0a 	vpush	{d8-d12}
 8000c86:	b084      	sub	sp, #16
 8000c88:	4605      	mov	r5, r0
    float worstDist = 1e9f;
	// used for determining danger's acceptable distance
	float dangerOffset = 50.0f;

	// checking all objects on map
    for (size_t i = 0; i < state->objectCount; i++) {
 8000c8a:	2400      	movs	r4, #0
    float worstDist = 1e9f;
 8000c8c:	ed9f aa7a 	vldr	s20, [pc, #488]	@ 8000e78 <computeMoveDirection+0x1f8>
    float bestDist = 1e9f;
 8000c90:	eeb0 ca4a 	vmov.f32	s24, s20
    float worstDx = 0, worstDy = 0;
 8000c94:	eddf 9a79 	vldr	s19, [pc, #484]	@ 8000e7c <computeMoveDirection+0x1fc>
 8000c98:	eef0 ba69 	vmov.f32	s23, s19
    float bestDx = 0, bestDy = 0;
 8000c9c:	eeb0 ba69 	vmov.f32	s22, s19
 8000ca0:	eef0 aa69 	vmov.f32	s21, s19
    for (size_t i = 0; i < state->objectCount; i++) {
 8000ca4:	e02f      	b.n	8000d06 <computeMoveDirection+0x86>
                break;
            case 1: // transistor
                isTarget = 1;
                break;
            case 2: // spark
                danger_zone = 12.5f + 12.5f + state->myHp/2.0f + dangerOffset;
 8000ca6:	f995 35e0 	ldrsb.w	r3, [r5, #1504]	@ 0x5e0
 8000caa:	ee07 3a90 	vmov	s15, r3
 8000cae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000cb2:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 8000cb6:	ee67 7a87 	vmul.f32	s15, s15, s14
 8000cba:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8000cbe:	ee77 7a87 	vadd.f32	s15, s15, s14
 8000cc2:	ed9f 7a6f 	vldr	s14, [pc, #444]	@ 8000e80 <computeMoveDirection+0x200>
 8000cc6:	ee77 7a87 	vadd.f32	s15, s15, s14
                if (dist2 <= danger_zone * danger_zone)
 8000cca:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8000cce:	eef4 7ac9 	vcmpe.f32	s15, s18
 8000cd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000cd6:	da7b      	bge.n	8000dd0 <computeMoveDirection+0x150>
        int isDanger = 0;
 8000cd8:	2300      	movs	r3, #0
 8000cda:	e007      	b.n	8000cec <computeMoveDirection+0x6c>
                break;
			// glue not taken into account as transistor location may overlap with glue's surface and thus be unapproachable
        }

		// closest Target and closest possible danger relative location update
        if (isTarget && dist2 < bestDist) {
 8000cdc:	eeb4 cac9 	vcmpe.f32	s24, s18
 8000ce0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000ce4:	dc76      	bgt.n	8000dd4 <computeMoveDirection+0x154>
 8000ce6:	2300      	movs	r3, #0
 8000ce8:	e000      	b.n	8000cec <computeMoveDirection+0x6c>
        switch (obj.objectType) {
 8000cea:	2300      	movs	r3, #0
            bestDx = dx;
            bestDy = dy;
            bestDist = dist2;
        }
        if (isDanger && dist2 < worstDist) {
 8000cec:	b153      	cbz	r3, 8000d04 <computeMoveDirection+0x84>
 8000cee:	eeb4 aac9 	vcmpe.f32	s20, s18
 8000cf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000cf6:	dd05      	ble.n	8000d04 <computeMoveDirection+0x84>
            worstDx = dx;
            worstDy = dy;
            worstDist = dist2;
 8000cf8:	eeb0 aa49 	vmov.f32	s20, s18
            worstDy = dy;
 8000cfc:	eef0 9a68 	vmov.f32	s19, s17
            worstDx = dx;
 8000d00:	eef0 ba48 	vmov.f32	s23, s16
    for (size_t i = 0; i < state->objectCount; i++) {
 8000d04:	3401      	adds	r4, #1
 8000d06:	f8d5 35d0 	ldr.w	r3, [r5, #1488]	@ 0x5d0
 8000d0a:	42a3      	cmp	r3, r4
 8000d0c:	d96a      	bls.n	8000de4 <computeMoveDirection+0x164>
        AMCOM_ObjectState obj = state->objects[i];
 8000d0e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8000d12:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8000d16:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8000d1a:	ab04      	add	r3, sp, #16
 8000d1c:	e903 0007 	stmdb	r3, {r0, r1, r2}
        if (obj.hp <= 0)
 8000d20:	f99d 6007 	ldrsb.w	r6, [sp, #7]
 8000d24:	2e00      	cmp	r6, #0
 8000d26:	dded      	ble.n	8000d04 <computeMoveDirection+0x84>
        float dx = obj.x - state->myX;
 8000d28:	f505 63bb 	add.w	r3, r5, #1496	@ 0x5d8
 8000d2c:	edd3 7a00 	vldr	s15, [r3]
 8000d30:	ed9d 8a02 	vldr	s16, [sp, #8]
 8000d34:	ee38 8a67 	vsub.f32	s16, s16, s15
        float dy = obj.y - state->myY;
 8000d38:	f205 53dc 	addw	r3, r5, #1500	@ 0x5dc
 8000d3c:	edd3 7a00 	vldr	s15, [r3]
 8000d40:	eddd 8a03 	vldr	s17, [sp, #12]
 8000d44:	ee78 8ae7 	vsub.f32	s17, s17, s15
        float dist2 = dx * dx + dy * dy;
 8000d48:	ee28 9a08 	vmul.f32	s18, s16, s16
 8000d4c:	ee68 7aa8 	vmul.f32	s15, s17, s17
 8000d50:	ee39 9a27 	vadd.f32	s18, s18, s15
        if (dist2 < 1e-3)
 8000d54:	ee19 0a10 	vmov	r0, s18
 8000d58:	f7ff fbfe 	bl	8000558 <__aeabi_f2d>
 8000d5c:	a344      	add	r3, pc, #272	@ (adr r3, 8000e70 <computeMoveDirection+0x1f0>)
 8000d5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000d62:	f7ff fcb1 	bl	80006c8 <__aeabi_dcmplt>
 8000d66:	2800      	cmp	r0, #0
 8000d68:	d1cc      	bne.n	8000d04 <computeMoveDirection+0x84>
        switch (obj.objectType) {
 8000d6a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8000d6e:	2b01      	cmp	r3, #1
 8000d70:	d0b4      	beq.n	8000cdc <computeMoveDirection+0x5c>
 8000d72:	2b02      	cmp	r3, #2
 8000d74:	d097      	beq.n	8000ca6 <computeMoveDirection+0x26>
 8000d76:	2b00      	cmp	r3, #0
 8000d78:	d1b7      	bne.n	8000cea <computeMoveDirection+0x6a>
                danger_zone = 12.5f + obj.hp/2.0f + 12.5f + state->myHp/2.0f + dangerOffset;
 8000d7a:	ee07 6a90 	vmov	s15, r6
 8000d7e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000d82:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
 8000d86:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8000d8a:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 8000d8e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8000d92:	ee77 7a87 	vadd.f32	s15, s15, s14
 8000d96:	f995 35e0 	ldrsb.w	r3, [r5, #1504]	@ 0x5e0
 8000d9a:	ee07 3a10 	vmov	s14, r3
 8000d9e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8000da2:	ee27 7a26 	vmul.f32	s14, s14, s13
 8000da6:	ee77 7a87 	vadd.f32	s15, s15, s14
 8000daa:	ed9f 7a35 	vldr	s14, [pc, #212]	@ 8000e80 <computeMoveDirection+0x200>
 8000dae:	ee77 7a87 	vadd.f32	s15, s15, s14
                if (obj.hp >= state->myHp && dist2 <= danger_zone * danger_zone)
 8000db2:	429e      	cmp	r6, r3
 8000db4:	db06      	blt.n	8000dc4 <computeMoveDirection+0x144>
 8000db6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8000dba:	eef4 7ac9 	vcmpe.f32	s15, s18
 8000dbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000dc2:	da03      	bge.n	8000dcc <computeMoveDirection+0x14c>
                else if (obj.hp < state->myHp)
 8000dc4:	429e      	cmp	r6, r3
 8000dc6:	db89      	blt.n	8000cdc <computeMoveDirection+0x5c>
        int isDanger = 0;
 8000dc8:	2300      	movs	r3, #0
 8000dca:	e78f      	b.n	8000cec <computeMoveDirection+0x6c>
                    isDanger = 1;
 8000dcc:	2301      	movs	r3, #1
 8000dce:	e78d      	b.n	8000cec <computeMoveDirection+0x6c>
                    isDanger = 1;
 8000dd0:	2301      	movs	r3, #1
 8000dd2:	e78b      	b.n	8000cec <computeMoveDirection+0x6c>
            bestDist = dist2;
 8000dd4:	eeb0 ca49 	vmov.f32	s24, s18
            bestDy = dy;
 8000dd8:	eeb0 ba68 	vmov.f32	s22, s17
            bestDx = dx;
 8000ddc:	eef0 aa48 	vmov.f32	s21, s16
 8000de0:	2300      	movs	r3, #0
 8000de2:	e783      	b.n	8000cec <computeMoveDirection+0x6c>
        }
    }

    // no targets left - go right
    if (bestDx == 0 && bestDy == 0)
 8000de4:	eef5 aa40 	vcmp.f32	s21, #0.0
 8000de8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000dec:	d104      	bne.n	8000df8 <computeMoveDirection+0x178>
 8000dee:	eeb5 ba40 	vcmp.f32	s22, #0.0
 8000df2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000df6:	d036      	beq.n	8000e66 <computeMoveDirection+0x1e6>
        return 0.0f;

    // target's direction normalization
    float bestLen = sqrtf(bestDx * bestDx + bestDy * bestDy);
 8000df8:	ee2a 0aaa 	vmul.f32	s0, s21, s21
 8000dfc:	ee6b 7a0b 	vmul.f32	s15, s22, s22
 8000e00:	ee30 0a27 	vadd.f32	s0, s0, s15
 8000e04:	f00e fed4 	bl	800fbb0 <sqrtf>
    float goalX = bestDx / bestLen;
 8000e08:	eeca 8a80 	vdiv.f32	s17, s21, s0
    float goalY = bestDy / bestLen;
 8000e0c:	ee8b 8a00 	vdiv.f32	s16, s22, s0

	// danger's direction normalization
    float dangerX = 0.0f, dangerY = 0.0f;
    if (worstDx != 0 || worstDy != 0) {
 8000e10:	eef5 ba40 	vcmp.f32	s23, #0.0
 8000e14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000e18:	d104      	bne.n	8000e24 <computeMoveDirection+0x1a4>
 8000e1a:	eef5 9a40 	vcmp.f32	s19, #0.0
 8000e1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000e22:	d01b      	beq.n	8000e5c <computeMoveDirection+0x1dc>
        float worstLen = sqrtf(worstDx * worstDx + worstDy * worstDy);
 8000e24:	ee2b 0aab 	vmul.f32	s0, s23, s23
 8000e28:	ee69 7aa9 	vmul.f32	s15, s19, s19
 8000e2c:	ee30 0a27 	vadd.f32	s0, s0, s15
 8000e30:	f00e febe 	bl	800fbb0 <sqrtf>
        dangerX = worstDx / worstLen;
 8000e34:	eecb 0a80 	vdiv.f32	s1, s23, s0
        dangerY = worstDy / worstLen;
 8000e38:	eec9 7a80 	vdiv.f32	s15, s19, s0
    }

    // target's and danger's directions combination, altered by fear
    float fear = 1.5f;
    float moveX = goalX - dangerX * fear;
 8000e3c:	eeb7 7a08 	vmov.f32	s14, #120	@ 0x3fc00000  1.5
 8000e40:	ee60 0a87 	vmul.f32	s1, s1, s14
    float moveY = goalY - dangerY * fear;
 8000e44:	ee27 0a87 	vmul.f32	s0, s15, s14

    return atan2f(moveY, moveX);
 8000e48:	ee78 0ae0 	vsub.f32	s1, s17, s1
 8000e4c:	ee38 0a40 	vsub.f32	s0, s16, s0
 8000e50:	f00e feac 	bl	800fbac <atan2f>
}
 8000e54:	b004      	add	sp, #16
 8000e56:	ecbd 8b0a 	vpop	{d8-d12}
 8000e5a:	bd70      	pop	{r4, r5, r6, pc}
    float dangerX = 0.0f, dangerY = 0.0f;
 8000e5c:	eddf 7a07 	vldr	s15, [pc, #28]	@ 8000e7c <computeMoveDirection+0x1fc>
 8000e60:	eef0 0a67 	vmov.f32	s1, s15
 8000e64:	e7ea      	b.n	8000e3c <computeMoveDirection+0x1bc>
        return 0.0f;
 8000e66:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 8000e7c <computeMoveDirection+0x1fc>
 8000e6a:	e7f3      	b.n	8000e54 <computeMoveDirection+0x1d4>
 8000e6c:	f3af 8000 	nop.w
 8000e70:	d2f1a9fc 	.word	0xd2f1a9fc
 8000e74:	3f50624d 	.word	0x3f50624d
 8000e78:	4e6e6b28 	.word	0x4e6e6b28
 8000e7c:	00000000 	.word	0x00000000
 8000e80:	42480000 	.word	0x42480000

08000e84 <amcomPacketHandler>:


/**
 * This function will be called each time a valid AMCOM packet is received
 */
void amcomPacketHandler(const AMCOM_Packet* packet, void* userContext) {
 8000e84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000e88:	b0a5      	sub	sp, #148	@ 0x94
 8000e8a:	4607      	mov	r7, r0
 8000e8c:	460e      	mov	r6, r1
	Socket_t socket = (Socket_t)userContext;    // socket used for communication with the server

	// gameState init
	static GameState gameState = {0};

	switch (packet->header.type) {
 8000e8e:	7843      	ldrb	r3, [r0, #1]
 8000e90:	3b01      	subs	r3, #1
 8000e92:	2b07      	cmp	r3, #7
 8000e94:	d817      	bhi.n	8000ec6 <amcomPacketHandler+0x42>
 8000e96:	e8df f003 	tbb	[pc, r3]
 8000e9a:	1604      	.short	0x1604
 8000e9c:	a1301619 	.word	0xa1301619
 8000ea0:	b516      	.short	0xb516
	case AMCOM_IDENTIFY_REQUEST:
		printf("Got IDENTIFY.request. Responding with IDENTIFY.response\n");
 8000ea2:	4865      	ldr	r0, [pc, #404]	@ (8001038 <amcomPacketHandler+0x1b4>)
 8000ea4:	f00d fdc6 	bl	800ea34 <puts>
		AMCOM_IdentifyResponsePayload identifyResponse;
		sprintf(identifyResponse.playerName, "KupiecZieba");
 8000ea8:	ac04      	add	r4, sp, #16
 8000eaa:	4b64      	ldr	r3, [pc, #400]	@ (800103c <amcomPacketHandler+0x1b8>)
 8000eac:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8000eb0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
		toSend = AMCOM_Serialize(AMCOM_IDENTIFY_RESPONSE, &identifyResponse, sizeof(identifyResponse), buf);
 8000eb4:	4b62      	ldr	r3, [pc, #392]	@ (8001040 <amcomPacketHandler+0x1bc>)
 8000eb6:	2218      	movs	r2, #24
 8000eb8:	4621      	mov	r1, r4
 8000eba:	2002      	movs	r0, #2
 8000ebc:	f7ff fde4 	bl	8000a88 <AMCOM_Serialize>
	default:
		break;
	}

	// if there is something to send back - do it
	if (toSend > 0) {
 8000ec0:	2800      	cmp	r0, #0
 8000ec2:	f040 80b1 	bne.w	8001028 <amcomPacketHandler+0x1a4>
		FreeRTOS_send(socket, buf, toSend, 0);
	}
}
 8000ec6:	b025      	add	sp, #148	@ 0x94
 8000ec8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        gameState.playerNumber = newGameRequest->playerNumber;
 8000ecc:	7941      	ldrb	r1, [r0, #5]
 8000ece:	4b5d      	ldr	r3, [pc, #372]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000ed0:	f883 15d4 	strb.w	r1, [r3, #1492]	@ 0x5d4
        printf("NEW_GAME: I'm player #%d of %d\n", newGameRequest->playerNumber, newGameRequest->numberOfPlayers);
 8000ed4:	7982      	ldrb	r2, [r0, #6]
 8000ed6:	485c      	ldr	r0, [pc, #368]	@ (8001048 <amcomPacketHandler+0x1c4>)
 8000ed8:	f00d fd44 	bl	800e964 <iprintf>
        sprintf(newGameResponse.helloMessage, "Fine dining, here I come!");
 8000edc:	ac04      	add	r4, sp, #16
 8000ede:	4d5b      	ldr	r5, [pc, #364]	@ (800104c <amcomPacketHandler+0x1c8>)
 8000ee0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000ee2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000ee4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8000ee8:	c403      	stmia	r4!, {r0, r1}
 8000eea:	8022      	strh	r2, [r4, #0]
        toSend = AMCOM_Serialize(AMCOM_NEW_GAME_RESPONSE, &newGameResponse, sizeof(newGameResponse), buf);
 8000eec:	4b54      	ldr	r3, [pc, #336]	@ (8001040 <amcomPacketHandler+0x1bc>)
 8000eee:	227f      	movs	r2, #127	@ 0x7f
 8000ef0:	a904      	add	r1, sp, #16
 8000ef2:	2004      	movs	r0, #4
 8000ef4:	f7ff fdc8 	bl	8000a88 <AMCOM_Serialize>
        break;
 8000ef8:	e7e2      	b.n	8000ec0 <amcomPacketHandler+0x3c>
        int count = packet->header.length / sizeof(AMCOM_ObjectState);
 8000efa:	f890 9002 	ldrb.w	r9, [r0, #2]
 8000efe:	4b54      	ldr	r3, [pc, #336]	@ (8001050 <amcomPacketHandler+0x1cc>)
 8000f00:	fba3 3909 	umull	r3, r9, r3, r9
 8000f04:	ea4f 09d9 	mov.w	r9, r9, lsr #3
        for (size_t i = 0; i < count && gameState.objectCount < MAX_ALL_OBJECTS; i++) {
 8000f08:	2500      	movs	r5, #0
 8000f0a:	e040      	b.n	8000f8e <amcomPacketHandler+0x10a>
			for (size_t j = 0; j < gameState.objectCount; j++)
 8000f0c:	f10c 0c01 	add.w	ip, ip, #1
 8000f10:	4564      	cmp	r4, ip
 8000f12:	d922      	bls.n	8000f5a <amcomPacketHandler+0xd6>
				AMCOM_ObjectState obj2 = gameState.objects[j];
 8000f14:	eb0c 024c 	add.w	r2, ip, ip, lsl #1
 8000f18:	4b4a      	ldr	r3, [pc, #296]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000f1a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8000f1e:	f10d 0e10 	add.w	lr, sp, #16
 8000f22:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8000f26:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
				if(obj2.objectNo == obj.objectNo && obj2.objectType == obj.objectType)
 8000f2a:	f8bd 2011 	ldrh.w	r2, [sp, #17]
 8000f2e:	f8bd 3005 	ldrh.w	r3, [sp, #5]
 8000f32:	429a      	cmp	r2, r3
 8000f34:	d1ea      	bne.n	8000f0c <amcomPacketHandler+0x88>
 8000f36:	f89d 2010 	ldrb.w	r2, [sp, #16]
 8000f3a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8000f3e:	429a      	cmp	r2, r3
 8000f40:	d1e4      	bne.n	8000f0c <amcomPacketHandler+0x88>
					gameState.objects[j] = obj;
 8000f42:	eb0c 024c 	add.w	r2, ip, ip, lsl #1
 8000f46:	4b3f      	ldr	r3, [pc, #252]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000f48:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8000f4c:	aa01      	add	r2, sp, #4
 8000f4e:	ca07      	ldmia	r2, {r0, r1, r2}
 8000f50:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					swapped = 1;
 8000f54:	f04f 0801 	mov.w	r8, #1
 8000f58:	e7d8      	b.n	8000f0c <amcomPacketHandler+0x88>
			if(swapped == 0) gameState.objects[gameState.objectCount++] = obj;
 8000f5a:	f1b8 0f00 	cmp.w	r8, #0
 8000f5e:	d10b      	bne.n	8000f78 <amcomPacketHandler+0xf4>
 8000f60:	4b38      	ldr	r3, [pc, #224]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000f62:	1c62      	adds	r2, r4, #1
 8000f64:	f8c3 25d0 	str.w	r2, [r3, #1488]	@ 0x5d0
 8000f68:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8000f6c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8000f70:	aa01      	add	r2, sp, #4
 8000f72:	ca07      	ldmia	r2, {r0, r1, r2}
 8000f74:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            if (obj.objectType == 0 && obj.objectNo == gameState.playerNumber) {
 8000f78:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8000f7c:	b933      	cbnz	r3, 8000f8c <amcomPacketHandler+0x108>
 8000f7e:	f8bd 2005 	ldrh.w	r2, [sp, #5]
 8000f82:	4b30      	ldr	r3, [pc, #192]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000f84:	f893 35d4 	ldrb.w	r3, [r3, #1492]	@ 0x5d4
 8000f88:	429a      	cmp	r2, r3
 8000f8a:	d017      	beq.n	8000fbc <amcomPacketHandler+0x138>
        for (size_t i = 0; i < count && gameState.objectCount < MAX_ALL_OBJECTS; i++) {
 8000f8c:	3501      	adds	r5, #1
 8000f8e:	45a9      	cmp	r9, r5
 8000f90:	d948      	bls.n	8001024 <amcomPacketHandler+0x1a0>
 8000f92:	4b2c      	ldr	r3, [pc, #176]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000f94:	f8d3 45d0 	ldr.w	r4, [r3, #1488]	@ 0x5d0
 8000f98:	2c7b      	cmp	r4, #123	@ 0x7b
 8000f9a:	dc1d      	bgt.n	8000fd8 <amcomPacketHandler+0x154>
            AMCOM_ObjectState obj = updateRequest->objectState[i];
 8000f9c:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8000fa0:	eb07 0282 	add.w	r2, r7, r2, lsl #2
 8000fa4:	ab01      	add	r3, sp, #4
 8000fa6:	f8d2 0005 	ldr.w	r0, [r2, #5]
 8000faa:	f8d2 1009 	ldr.w	r1, [r2, #9]
 8000fae:	f8d2 200d 	ldr.w	r2, [r2, #13]
 8000fb2:	c307      	stmia	r3!, {r0, r1, r2}
			for (size_t j = 0; j < gameState.objectCount; j++)
 8000fb4:	f04f 0c00 	mov.w	ip, #0
			uint8_t swapped = 0;
 8000fb8:	46e0      	mov	r8, ip
			for (size_t j = 0; j < gameState.objectCount; j++)
 8000fba:	e7a9      	b.n	8000f10 <amcomPacketHandler+0x8c>
                gameState.myX = obj.x;
 8000fbc:	4b21      	ldr	r3, [pc, #132]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000fbe:	f503 62bb 	add.w	r2, r3, #1496	@ 0x5d8
 8000fc2:	9902      	ldr	r1, [sp, #8]
 8000fc4:	6011      	str	r1, [r2, #0]
                gameState.myY = obj.y;
 8000fc6:	f203 52dc 	addw	r2, r3, #1500	@ 0x5dc
 8000fca:	9903      	ldr	r1, [sp, #12]
 8000fcc:	6011      	str	r1, [r2, #0]
                gameState.myHp = obj.hp;
 8000fce:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 8000fd2:	f883 25e0 	strb.w	r2, [r3, #1504]	@ 0x5e0
 8000fd6:	e7d9      	b.n	8000f8c <amcomPacketHandler+0x108>
	size_t toSend = 0;                          // size of the outgoing packet
 8000fd8:	2000      	movs	r0, #0
 8000fda:	e771      	b.n	8000ec0 <amcomPacketHandler+0x3c>
        printf("MOVE.request (time=%u) - processing %d objects\n", moveRequest->gameTime, gameState.objectCount);
 8000fdc:	4c19      	ldr	r4, [pc, #100]	@ (8001044 <amcomPacketHandler+0x1c0>)
 8000fde:	f8d4 25d0 	ldr.w	r2, [r4, #1488]	@ 0x5d0
 8000fe2:	f8d0 1005 	ldr.w	r1, [r0, #5]
 8000fe6:	481b      	ldr	r0, [pc, #108]	@ (8001054 <amcomPacketHandler+0x1d0>)
 8000fe8:	f00d fcbc 	bl	800e964 <iprintf>
        float angle = computeMoveDirection(&gameState);
 8000fec:	4620      	mov	r0, r4
 8000fee:	f7ff fe47 	bl	8000c80 <computeMoveDirection>
        AMCOM_MoveResponsePayload moveResponse = { .angle = angle };
 8000ff2:	ed8d 0a04 	vstr	s0, [sp, #16]
        toSend = AMCOM_Serialize(AMCOM_MOVE_RESPONSE, &moveResponse, sizeof(moveResponse), buf);
 8000ff6:	4b12      	ldr	r3, [pc, #72]	@ (8001040 <amcomPacketHandler+0x1bc>)
 8000ff8:	2204      	movs	r2, #4
 8000ffa:	a904      	add	r1, sp, #16
 8000ffc:	2007      	movs	r0, #7
 8000ffe:	f7ff fd43 	bl	8000a88 <AMCOM_Serialize>
        break;
 8001002:	e75d      	b.n	8000ec0 <amcomPacketHandler+0x3c>
        printf("GAME_OVER.request received. Sending final message.\n");
 8001004:	4814      	ldr	r0, [pc, #80]	@ (8001058 <amcomPacketHandler+0x1d4>)
 8001006:	f00d fd15 	bl	800ea34 <puts>
        sprintf(gameOverResponse.endMessage, "Thanks for the meal");
 800100a:	ac04      	add	r4, sp, #16
 800100c:	4d13      	ldr	r5, [pc, #76]	@ (800105c <amcomPacketHandler+0x1d8>)
 800100e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001010:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001012:	682b      	ldr	r3, [r5, #0]
 8001014:	6023      	str	r3, [r4, #0]
        toSend = AMCOM_Serialize(AMCOM_GAME_OVER_RESPONSE, &gameOverResponse, sizeof(gameOverResponse), buf);
 8001016:	4b0a      	ldr	r3, [pc, #40]	@ (8001040 <amcomPacketHandler+0x1bc>)
 8001018:	227f      	movs	r2, #127	@ 0x7f
 800101a:	a904      	add	r1, sp, #16
 800101c:	2009      	movs	r0, #9
 800101e:	f7ff fd33 	bl	8000a88 <AMCOM_Serialize>
        break;
 8001022:	e74d      	b.n	8000ec0 <amcomPacketHandler+0x3c>
	size_t toSend = 0;                          // size of the outgoing packet
 8001024:	2000      	movs	r0, #0
 8001026:	e74b      	b.n	8000ec0 <amcomPacketHandler+0x3c>
		FreeRTOS_send(socket, buf, toSend, 0);
 8001028:	2300      	movs	r3, #0
 800102a:	4602      	mov	r2, r0
 800102c:	4904      	ldr	r1, [pc, #16]	@ (8001040 <amcomPacketHandler+0x1bc>)
 800102e:	4630      	mov	r0, r6
 8001030:	f009 fecf 	bl	800add2 <FreeRTOS_send>
}
 8001034:	e747      	b.n	8000ec6 <amcomPacketHandler+0x42>
 8001036:	bf00      	nop
 8001038:	0800ff64 	.word	0x0800ff64
 800103c:	0800ff9c 	.word	0x0800ff9c
 8001040:	20000680 	.word	0x20000680
 8001044:	2000009c 	.word	0x2000009c
 8001048:	0800ffa8 	.word	0x0800ffa8
 800104c:	0800ffc8 	.word	0x0800ffc8
 8001050:	aaaaaaab 	.word	0xaaaaaaab
 8001054:	0800ffe4 	.word	0x0800ffe4
 8001058:	08010014 	.word	0x08010014
 800105c:	08010048 	.word	0x08010048

08001060 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001060:	b500      	push	{lr}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001062:	f000 0007 	and.w	r0, r0, #7
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001066:	f1c0 0c07 	rsb	ip, r0, #7
 800106a:	f1bc 0f04 	cmp.w	ip, #4
 800106e:	bf28      	it	cs
 8001070:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001074:	1d03      	adds	r3, r0, #4
 8001076:	2b06      	cmp	r3, #6
 8001078:	d90f      	bls.n	800109a <NVIC_EncodePriority+0x3a>
 800107a:	1ec3      	subs	r3, r0, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800107c:	f04f 3eff 	mov.w	lr, #4294967295
 8001080:	fa0e f00c 	lsl.w	r0, lr, ip
 8001084:	ea21 0100 	bic.w	r1, r1, r0
 8001088:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800108a:	fa0e fe03 	lsl.w	lr, lr, r3
 800108e:	ea22 020e 	bic.w	r2, r2, lr
         );
}
 8001092:	ea41 0002 	orr.w	r0, r1, r2
 8001096:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800109a:	2300      	movs	r3, #0
 800109c:	e7ee      	b.n	800107c <NVIC_EncodePriority+0x1c>

0800109e <ITM_SendChar>:
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
{
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
 800109e:	f04f 4360 	mov.w	r3, #3758096384	@ 0xe0000000
 80010a2:	f8d3 3e80 	ldr.w	r3, [r3, #3712]	@ 0xe80
 80010a6:	f013 0f01 	tst.w	r3, #1
 80010aa:	d011      	beq.n	80010d0 <ITM_SendChar+0x32>
      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
 80010ac:	f04f 4360 	mov.w	r3, #3758096384	@ 0xe0000000
 80010b0:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	@ 0xe00
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
 80010b4:	f013 0f01 	tst.w	r3, #1
 80010b8:	d101      	bne.n	80010be <ITM_SendChar+0x20>
 80010ba:	4770      	bx	lr
  {
    while (ITM->PORT[0U].u32 == 0UL)
    {
      __NOP();
 80010bc:	bf00      	nop
    while (ITM->PORT[0U].u32 == 0UL)
 80010be:	f04f 4360 	mov.w	r3, #3758096384	@ 0xe0000000
 80010c2:	681b      	ldr	r3, [r3, #0]
 80010c4:	2b00      	cmp	r3, #0
 80010c6:	d0f9      	beq.n	80010bc <ITM_SendChar+0x1e>
    }
    ITM->PORT[0U].u8 = (uint8_t)ch;
 80010c8:	b2c3      	uxtb	r3, r0
 80010ca:	f04f 4260 	mov.w	r2, #3758096384	@ 0xe0000000
 80010ce:	7013      	strb	r3, [r2, #0]
  }
  return (ch);
}
 80010d0:	4770      	bx	lr
	...

080010d4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80010d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80010d6:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80010d8:	2400      	movs	r4, #0
 80010da:	9405      	str	r4, [sp, #20]
 80010dc:	9406      	str	r4, [sp, #24]
 80010de:	9407      	str	r4, [sp, #28]
 80010e0:	9408      	str	r4, [sp, #32]
 80010e2:	9409      	str	r4, [sp, #36]	@ 0x24
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80010e4:	9401      	str	r4, [sp, #4]
 80010e6:	4b26      	ldr	r3, [pc, #152]	@ (8001180 <MX_GPIO_Init+0xac>)
 80010e8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80010ea:	f042 0210 	orr.w	r2, r2, #16
 80010ee:	631a      	str	r2, [r3, #48]	@ 0x30
 80010f0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80010f2:	f002 0210 	and.w	r2, r2, #16
 80010f6:	9201      	str	r2, [sp, #4]
 80010f8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80010fa:	9402      	str	r4, [sp, #8]
 80010fc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80010fe:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8001102:	631a      	str	r2, [r3, #48]	@ 0x30
 8001104:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001106:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 800110a:	9202      	str	r2, [sp, #8]
 800110c:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800110e:	9403      	str	r4, [sp, #12]
 8001110:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001112:	f042 0201 	orr.w	r2, r2, #1
 8001116:	631a      	str	r2, [r3, #48]	@ 0x30
 8001118:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800111a:	f002 0201 	and.w	r2, r2, #1
 800111e:	9203      	str	r2, [sp, #12]
 8001120:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8001122:	9404      	str	r4, [sp, #16]
 8001124:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001126:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800112a:	631a      	str	r2, [r3, #48]	@ 0x30
 800112c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800112e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8001132:	9304      	str	r3, [sp, #16]
 8001134:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);
 8001136:	4f13      	ldr	r7, [pc, #76]	@ (8001184 <MX_GPIO_Init+0xb0>)
 8001138:	2201      	movs	r2, #1
 800113a:	2110      	movs	r1, #16
 800113c:	4638      	mov	r0, r7
 800113e:	f000 fd49 	bl	8001bd4 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, LED_GREEN_Pin|LED_RED_Pin, GPIO_PIN_RESET);
 8001142:	4d11      	ldr	r5, [pc, #68]	@ (8001188 <MX_GPIO_Init+0xb4>)
 8001144:	4622      	mov	r2, r4
 8001146:	f44f 41c0 	mov.w	r1, #24576	@ 0x6000
 800114a:	4628      	mov	r0, r5
 800114c:	f000 fd42 	bl	8001bd4 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : SPI_CS_Pin */
  GPIO_InitStruct.Pin = SPI_CS_Pin;
 8001150:	2310      	movs	r3, #16
 8001152:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 8001154:	2311      	movs	r3, #17
 8001156:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001158:	2601      	movs	r6, #1
 800115a:	9607      	str	r6, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800115c:	2302      	movs	r3, #2
 800115e:	9308      	str	r3, [sp, #32]
  HAL_GPIO_Init(SPI_CS_GPIO_Port, &GPIO_InitStruct);
 8001160:	a905      	add	r1, sp, #20
 8001162:	4638      	mov	r0, r7
 8001164:	f000 fc32 	bl	80019cc <HAL_GPIO_Init>

  /*Configure GPIO pins : LED_GREEN_Pin LED_RED_Pin */
  GPIO_InitStruct.Pin = LED_GREEN_Pin|LED_RED_Pin;
 8001168:	f44f 43c0 	mov.w	r3, #24576	@ 0x6000
 800116c:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800116e:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001170:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001172:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8001174:	a905      	add	r1, sp, #20
 8001176:	4628      	mov	r0, r5
 8001178:	f000 fc28 	bl	80019cc <HAL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 800117c:	b00b      	add	sp, #44	@ 0x2c
 800117e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001180:	40023800 	.word	0x40023800
 8001184:	40021000 	.word	0x40021000
 8001188:	40021800 	.word	0x40021800

0800118c <MX_USART1_UART_Init>:
{
 800118c:	b510      	push	{r4, lr}
 800118e:	b090      	sub	sp, #64	@ 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8001190:	2400      	movs	r4, #0
 8001192:	9409      	str	r4, [sp, #36]	@ 0x24
 8001194:	940a      	str	r4, [sp, #40]	@ 0x28
 8001196:	940b      	str	r4, [sp, #44]	@ 0x2c
 8001198:	940c      	str	r4, [sp, #48]	@ 0x30
 800119a:	940d      	str	r4, [sp, #52]	@ 0x34
 800119c:	940e      	str	r4, [sp, #56]	@ 0x38
 800119e:	940f      	str	r4, [sp, #60]	@ 0x3c
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 80011a0:	9403      	str	r4, [sp, #12]
 80011a2:	9404      	str	r4, [sp, #16]
 80011a4:	9405      	str	r4, [sp, #20]
 80011a6:	9406      	str	r4, [sp, #24]
 80011a8:	9407      	str	r4, [sp, #28]
 80011aa:	9408      	str	r4, [sp, #32]
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 80011ac:	4b27      	ldr	r3, [pc, #156]	@ (800124c <MX_USART1_UART_Init+0xc0>)
 80011ae:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80011b0:	f042 0210 	orr.w	r2, r2, #16
 80011b4:	645a      	str	r2, [r3, #68]	@ 0x44
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 80011b6:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80011b8:	f002 0210 	and.w	r2, r2, #16
 80011bc:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 80011be:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB1ENR, Periphs);
 80011c0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80011c2:	f042 0201 	orr.w	r2, r2, #1
 80011c6:	631a      	str	r2, [r3, #48]	@ 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80011c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80011ca:	f003 0301 	and.w	r3, r3, #1
 80011ce:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80011d0:	9b01      	ldr	r3, [sp, #4]
  GPIO_InitStruct.Pin = LL_GPIO_PIN_9|LL_GPIO_PIN_10;
 80011d2:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
 80011d6:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 80011d8:	2302      	movs	r3, #2
 80011da:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 80011dc:	2303      	movs	r3, #3
 80011de:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 80011e0:	2307      	movs	r3, #7
 80011e2:	9308      	str	r3, [sp, #32]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80011e4:	a903      	add	r1, sp, #12
 80011e6:	481a      	ldr	r0, [pc, #104]	@ (8001250 <MX_USART1_UART_Init+0xc4>)
 80011e8:	f001 fed5 	bl	8002f96 <LL_GPIO_Init>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80011ec:	4b19      	ldr	r3, [pc, #100]	@ (8001254 <MX_USART1_UART_Init+0xc8>)
 80011ee:	68d8      	ldr	r0, [r3, #12]
  NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),5, 0));
 80011f0:	4622      	mov	r2, r4
 80011f2:	2105      	movs	r1, #5
 80011f4:	f3c0 2002 	ubfx	r0, r0, #8, #3
 80011f8:	f7ff ff32 	bl	8001060 <NVIC_EncodePriority>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80011fc:	0100      	lsls	r0, r0, #4
 80011fe:	b2c0      	uxtb	r0, r0
 8001200:	4b15      	ldr	r3, [pc, #84]	@ (8001258 <MX_USART1_UART_Init+0xcc>)
 8001202:	f883 0325 	strb.w	r0, [r3, #805]	@ 0x325
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001206:	2220      	movs	r2, #32
 8001208:	605a      	str	r2, [r3, #4]
  USART_InitStruct.BaudRate = 115200;
 800120a:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 800120e:	9309      	str	r3, [sp, #36]	@ 0x24
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 8001210:	940a      	str	r4, [sp, #40]	@ 0x28
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 8001212:	940b      	str	r4, [sp, #44]	@ 0x2c
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 8001214:	940c      	str	r4, [sp, #48]	@ 0x30
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8001216:	230c      	movs	r3, #12
 8001218:	930d      	str	r3, [sp, #52]	@ 0x34
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 800121a:	940e      	str	r4, [sp, #56]	@ 0x38
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 800121c:	940f      	str	r4, [sp, #60]	@ 0x3c
  LL_USART_Init(USART1, &USART_InitStruct);
 800121e:	f104 4480 	add.w	r4, r4, #1073741824	@ 0x40000000
 8001222:	f504 3488 	add.w	r4, r4, #69632	@ 0x11000
 8001226:	a909      	add	r1, sp, #36	@ 0x24
 8001228:	4620      	mov	r0, r4
 800122a:	f001 ffd5 	bl	80031d8 <LL_USART_Init>
__STATIC_INLINE void LL_USART_ConfigAsyncMode(USART_TypeDef *USARTx)
{
  /* In Asynchronous mode, the following bits must be kept cleared:
  - LINEN, CLKEN bits in the USART_CR2 register,
  - SCEN, IREN and HDSEL bits in the USART_CR3 register.*/
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800122e:	6923      	ldr	r3, [r4, #16]
 8001230:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 8001234:	6123      	str	r3, [r4, #16]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 8001236:	6963      	ldr	r3, [r4, #20]
 8001238:	f023 032a 	bic.w	r3, r3, #42	@ 0x2a
 800123c:	6163      	str	r3, [r4, #20]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 800123e:	68e3      	ldr	r3, [r4, #12]
 8001240:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8001244:	60e3      	str	r3, [r4, #12]
}
 8001246:	b010      	add	sp, #64	@ 0x40
 8001248:	bd10      	pop	{r4, pc}
 800124a:	bf00      	nop
 800124c:	40023800 	.word	0x40023800
 8001250:	40020000 	.word	0x40020000
 8001254:	e000ed00 	.word	0xe000ed00
 8001258:	e000e100 	.word	0xe000e100

0800125c <defaultTaskFunc>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_defaultTaskFunc */
void defaultTaskFunc(void *argument)
{
 800125c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
	HAL_GPIO_TogglePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin);
 800125e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8001262:	4803      	ldr	r0, [pc, #12]	@ (8001270 <defaultTaskFunc+0x14>)
 8001264:	f000 fcbc 	bl	8001be0 <HAL_GPIO_TogglePin>
    osDelay(100);
 8001268:	2064      	movs	r0, #100	@ 0x64
 800126a:	f002 fc4b 	bl	8003b04 <osDelay>
  for(;;)
 800126e:	e7f6      	b.n	800125e <defaultTaskFunc+0x2>
 8001270:	40021800 	.word	0x40021800

08001274 <__io_putchar>:
int __io_putchar(int ch) {
 8001274:	b508      	push	{r3, lr}
	return ITM_SendChar(ch);
 8001276:	f7ff ff12 	bl	800109e <ITM_SendChar>
}
 800127a:	bd08      	pop	{r3, pc}

0800127c <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800127c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1)
 800127e:	6802      	ldr	r2, [r0, #0]
 8001280:	4b03      	ldr	r3, [pc, #12]	@ (8001290 <HAL_TIM_PeriodElapsedCallback+0x14>)
 8001282:	429a      	cmp	r2, r3
 8001284:	d000      	beq.n	8001288 <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8001286:	bd08      	pop	{r3, pc}
    HAL_IncTick();
 8001288:	f000 fb20 	bl	80018cc <HAL_IncTick>
}
 800128c:	e7fb      	b.n	8001286 <HAL_TIM_PeriodElapsedCallback+0xa>
 800128e:	bf00      	nop
 8001290:	40010000 	.word	0x40010000

08001294 <Error_Handler>:
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001294:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8001296:	e7fe      	b.n	8001296 <Error_Handler+0x2>

08001298 <MX_SPI4_Init>:
{
 8001298:	b508      	push	{r3, lr}
  hspi4.Instance = SPI4;
 800129a:	480d      	ldr	r0, [pc, #52]	@ (80012d0 <MX_SPI4_Init+0x38>)
 800129c:	4b0d      	ldr	r3, [pc, #52]	@ (80012d4 <MX_SPI4_Init+0x3c>)
 800129e:	6003      	str	r3, [r0, #0]
  hspi4.Init.Mode = SPI_MODE_MASTER;
 80012a0:	f44f 7382 	mov.w	r3, #260	@ 0x104
 80012a4:	6043      	str	r3, [r0, #4]
  hspi4.Init.Direction = SPI_DIRECTION_2LINES;
 80012a6:	2300      	movs	r3, #0
 80012a8:	6083      	str	r3, [r0, #8]
  hspi4.Init.DataSize = SPI_DATASIZE_8BIT;
 80012aa:	60c3      	str	r3, [r0, #12]
  hspi4.Init.CLKPolarity = SPI_POLARITY_LOW;
 80012ac:	6103      	str	r3, [r0, #16]
  hspi4.Init.CLKPhase = SPI_PHASE_1EDGE;
 80012ae:	6143      	str	r3, [r0, #20]
  hspi4.Init.NSS = SPI_NSS_SOFT;
 80012b0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80012b4:	6182      	str	r2, [r0, #24]
  hspi4.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80012b6:	61c3      	str	r3, [r0, #28]
  hspi4.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80012b8:	6203      	str	r3, [r0, #32]
  hspi4.Init.TIMode = SPI_TIMODE_DISABLE;
 80012ba:	6243      	str	r3, [r0, #36]	@ 0x24
  hspi4.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80012bc:	6283      	str	r3, [r0, #40]	@ 0x28
  hspi4.Init.CRCPolynomial = 10;
 80012be:	230a      	movs	r3, #10
 80012c0:	62c3      	str	r3, [r0, #44]	@ 0x2c
  if (HAL_SPI_Init(&hspi4) != HAL_OK)
 80012c2:	f001 f8cf 	bl	8002464 <HAL_SPI_Init>
 80012c6:	b900      	cbnz	r0, 80012ca <MX_SPI4_Init+0x32>
}
 80012c8:	bd08      	pop	{r3, pc}
    Error_Handler();
 80012ca:	f7ff ffe3 	bl	8001294 <Error_Handler>
 80012ce:	bf00      	nop
 80012d0:	2000079c 	.word	0x2000079c
 80012d4:	40013400 	.word	0x40013400

080012d8 <MX_TIM14_Init>:
{
 80012d8:	b508      	push	{r3, lr}
  htim14.Instance = TIM14;
 80012da:	480a      	ldr	r0, [pc, #40]	@ (8001304 <MX_TIM14_Init+0x2c>)
 80012dc:	4b0a      	ldr	r3, [pc, #40]	@ (8001308 <MX_TIM14_Init+0x30>)
 80012de:	6003      	str	r3, [r0, #0]
  htim14.Init.Prescaler = 159;
 80012e0:	239f      	movs	r3, #159	@ 0x9f
 80012e2:	6043      	str	r3, [r0, #4]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 80012e4:	2300      	movs	r3, #0
 80012e6:	6083      	str	r3, [r0, #8]
  htim14.Init.Period = 65535;
 80012e8:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80012ec:	60c2      	str	r2, [r0, #12]
  htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80012ee:	6103      	str	r3, [r0, #16]
  htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80012f0:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 80012f2:	f001 fd8b 	bl	8002e0c <HAL_TIM_Base_Init>
 80012f6:	b918      	cbnz	r0, 8001300 <MX_TIM14_Init+0x28>
  HAL_TIM_Base_Start(&htim14);
 80012f8:	4802      	ldr	r0, [pc, #8]	@ (8001304 <MX_TIM14_Init+0x2c>)
 80012fa:	f001 fbe5 	bl	8002ac8 <HAL_TIM_Base_Start>
}
 80012fe:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001300:	f7ff ffc8 	bl	8001294 <Error_Handler>
 8001304:	20000754 	.word	0x20000754
 8001308:	40002000 	.word	0x40002000

0800130c <SystemClock_Config>:
{
 800130c:	b500      	push	{lr}
 800130e:	b095      	sub	sp, #84	@ 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001310:	2230      	movs	r2, #48	@ 0x30
 8001312:	2100      	movs	r1, #0
 8001314:	a808      	add	r0, sp, #32
 8001316:	f00d fccd 	bl	800ecb4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800131a:	2300      	movs	r3, #0
 800131c:	9303      	str	r3, [sp, #12]
 800131e:	9304      	str	r3, [sp, #16]
 8001320:	9305      	str	r3, [sp, #20]
 8001322:	9306      	str	r3, [sp, #24]
 8001324:	9307      	str	r3, [sp, #28]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001326:	9301      	str	r3, [sp, #4]
 8001328:	4a20      	ldr	r2, [pc, #128]	@ (80013ac <SystemClock_Config+0xa0>)
 800132a:	6c11      	ldr	r1, [r2, #64]	@ 0x40
 800132c:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
 8001330:	6411      	str	r1, [r2, #64]	@ 0x40
 8001332:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 8001334:	f002 5280 	and.w	r2, r2, #268435456	@ 0x10000000
 8001338:	9201      	str	r2, [sp, #4]
 800133a:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800133c:	9302      	str	r3, [sp, #8]
 800133e:	4b1c      	ldr	r3, [pc, #112]	@ (80013b0 <SystemClock_Config+0xa4>)
 8001340:	681a      	ldr	r2, [r3, #0]
 8001342:	f442 4240 	orr.w	r2, r2, #49152	@ 0xc000
 8001346:	601a      	str	r2, [r3, #0]
 8001348:	681b      	ldr	r3, [r3, #0]
 800134a:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 800134e:	9302      	str	r3, [sp, #8]
 8001350:	9b02      	ldr	r3, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001352:	2301      	movs	r3, #1
 8001354:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001356:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800135a:	9309      	str	r3, [sp, #36]	@ 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800135c:	2202      	movs	r2, #2
 800135e:	920e      	str	r2, [sp, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001360:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8001364:	930f      	str	r3, [sp, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLM = 4;
 8001366:	2304      	movs	r3, #4
 8001368:	9310      	str	r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLN = 160;
 800136a:	21a0      	movs	r1, #160	@ 0xa0
 800136c:	9111      	str	r1, [sp, #68]	@ 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800136e:	9212      	str	r2, [sp, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8001370:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001372:	a808      	add	r0, sp, #32
 8001374:	f000 fc3e 	bl	8001bf4 <HAL_RCC_OscConfig>
 8001378:	b998      	cbnz	r0, 80013a2 <SystemClock_Config+0x96>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800137a:	230f      	movs	r3, #15
 800137c:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800137e:	2302      	movs	r3, #2
 8001380:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001382:	2300      	movs	r3, #0
 8001384:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8001386:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 800138a:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800138c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001390:	9307      	str	r3, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8001392:	2105      	movs	r1, #5
 8001394:	a803      	add	r0, sp, #12
 8001396:	f000 fe97 	bl	80020c8 <HAL_RCC_ClockConfig>
 800139a:	b920      	cbnz	r0, 80013a6 <SystemClock_Config+0x9a>
}
 800139c:	b015      	add	sp, #84	@ 0x54
 800139e:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 80013a2:	f7ff ff77 	bl	8001294 <Error_Handler>
    Error_Handler();
 80013a6:	f7ff ff75 	bl	8001294 <Error_Handler>
 80013aa:	bf00      	nop
 80013ac:	40023800 	.word	0x40023800
 80013b0:	40007000 	.word	0x40007000

080013b4 <main>:
{
 80013b4:	b508      	push	{r3, lr}
  HAL_Init();
 80013b6:	f000 fa6f 	bl	8001898 <HAL_Init>
  SystemClock_Config();
 80013ba:	f7ff ffa7 	bl	800130c <SystemClock_Config>
  MX_GPIO_Init();
 80013be:	f7ff fe89 	bl	80010d4 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 80013c2:	f7ff fee3 	bl	800118c <MX_USART1_UART_Init>
  MX_SPI4_Init();
 80013c6:	f7ff ff67 	bl	8001298 <MX_SPI4_Init>
  MX_TIM14_Init();
 80013ca:	f7ff ff85 	bl	80012d8 <MX_TIM14_Init>
  osKernelInitialize();
 80013ce:	f002 fb11 	bl	80039f4 <osKernelInitialize>
  defaultTaskHandle = osThreadNew(defaultTaskFunc, NULL, &defaultTask_attributes);
 80013d2:	4a0a      	ldr	r2, [pc, #40]	@ (80013fc <main+0x48>)
 80013d4:	2100      	movs	r1, #0
 80013d6:	480a      	ldr	r0, [pc, #40]	@ (8001400 <main+0x4c>)
 80013d8:	f002 fb3a 	bl	8003a50 <osThreadNew>
 80013dc:	4b09      	ldr	r3, [pc, #36]	@ (8001404 <main+0x50>)
 80013de:	6018      	str	r0, [r3, #0]
  osThreadNew(NET_MACThread, NULL, &netMacThreadAttributes);
 80013e0:	4a09      	ldr	r2, [pc, #36]	@ (8001408 <main+0x54>)
 80013e2:	2100      	movs	r1, #0
 80013e4:	4809      	ldr	r0, [pc, #36]	@ (800140c <main+0x58>)
 80013e6:	f002 fb33 	bl	8003a50 <osThreadNew>
  osThreadNew(NET_APPThread, NULL, &netAppThreadAttributes);
 80013ea:	4a09      	ldr	r2, [pc, #36]	@ (8001410 <main+0x5c>)
 80013ec:	2100      	movs	r1, #0
 80013ee:	4809      	ldr	r0, [pc, #36]	@ (8001414 <main+0x60>)
 80013f0:	f002 fb2e 	bl	8003a50 <osThreadNew>
  osKernelStart();
 80013f4:	f002 fb10 	bl	8003a18 <osKernelStart>
  while (1)
 80013f8:	e7fe      	b.n	80013f8 <main+0x44>
 80013fa:	bf00      	nop
 80013fc:	08010254 	.word	0x08010254
 8001400:	0800125d 	.word	0x0800125d
 8001404:	20000750 	.word	0x20000750
 8001408:	08010230 	.word	0x08010230
 800140c:	08001515 	.word	0x08001515
 8001410:	0801020c 	.word	0x0801020c
 8001414:	08001419 	.word	0x08001419

08001418 <NET_APPThread>:
#include <enc28j60_net_interface.h>
#include <enc28j60_eth_phy.h>
#include "amcom.h"
#include "game.h"

void NET_APPThread(void* arg) {
 8001418:	b530      	push	{r4, r5, lr}
 800141a:	b087      	sub	sp, #28

	// Set the IP address and port of the server
	struct freertos_sockaddr serverAddress;
	memset( &serverAddress, 0, sizeof(serverAddress) );
 800141c:	2300      	movs	r3, #0
 800141e:	9300      	str	r3, [sp, #0]
 8001420:	9301      	str	r3, [sp, #4]
 8001422:	9302      	str	r3, [sp, #8]
 8001424:	9303      	str	r3, [sp, #12]
 8001426:	9304      	str	r3, [sp, #16]
 8001428:	9305      	str	r3, [sp, #20]
	serverAddress.sin_port = FreeRTOS_htons( 2001 );
 800142a:	f24d 1307 	movw	r3, #53511	@ 0xd107
 800142e:	f8ad 3002 	strh.w	r3, [sp, #2]
	serverAddress.sin_address.ulIP_IPv4 = FreeRTOS_inet_addr_quick( 192, 168, 40, 1 );
 8001432:	4b24      	ldr	r3, [pc, #144]	@ (80014c4 <NET_APPThread+0xac>)
 8001434:	9302      	str	r3, [sp, #8]
	serverAddress.sin_family = FREERTOS_AF_INET4;
 8001436:	2302      	movs	r3, #2
 8001438:	f88d 3001 	strb.w	r3, [sp, #1]

	osDelay(1000);
 800143c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8001440:	f002 fb60 	bl	8003b04 <osDelay>
 8001444:	e025      	b.n	8001492 <NET_APPThread+0x7a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8001446:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800144a:	f383 8811 	msr	BASEPRI, r3
 800144e:	f3bf 8f6f 	isb	sy
 8001452:	f3bf 8f4f 	dsb	sy

	while (1) {
		// Create a socket
		Socket_t socket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP);
		configASSERT( socket != FREERTOS_INVALID_SOCKET );
 8001456:	e7fe      	b.n	8001456 <NET_APPThread+0x3e>
			// Receive data from socket until the peer shuts down the connection
			do {
				// Fetch received bytes from socket into buf
				receivedBytesCount = FreeRTOS_recv(socket, buf, sizeof(buf), 0);
				if (receivedBytesCount > 0) {
					printf("Received %d bytes in socket\n", receivedBytesCount);
 8001458:	4621      	mov	r1, r4
 800145a:	481b      	ldr	r0, [pc, #108]	@ (80014c8 <NET_APPThread+0xb0>)
 800145c:	f00d fa82 	bl	800e964 <iprintf>
					// Try to deserialize the incoming data
					AMCOM_Deserialize(&amcomReceiver, buf, receivedBytesCount);
 8001460:	4622      	mov	r2, r4
 8001462:	491a      	ldr	r1, [pc, #104]	@ (80014cc <NET_APPThread+0xb4>)
 8001464:	481a      	ldr	r0, [pc, #104]	@ (80014d0 <NET_APPThread+0xb8>)
 8001466:	f7ff fb4b 	bl	8000b00 <AMCOM_Deserialize>
					// Negative result indicates that there was socket communication error
					// Initiate graceful shutdown
					FreeRTOS_shutdown( socket, FREERTOS_SHUT_RDWR );
					break;
				}
			} while (receivedBytesCount > 0);
 800146a:	2c00      	cmp	r4, #0
 800146c:	dd0e      	ble.n	800148c <NET_APPThread+0x74>
				receivedBytesCount = FreeRTOS_recv(socket, buf, sizeof(buf), 0);
 800146e:	2300      	movs	r3, #0
 8001470:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8001474:	4915      	ldr	r1, [pc, #84]	@ (80014cc <NET_APPThread+0xb4>)
 8001476:	4628      	mov	r0, r5
 8001478:	f009 fbc7 	bl	800ac0a <FreeRTOS_recv>
				if (receivedBytesCount > 0) {
 800147c:	1e04      	subs	r4, r0, #0
 800147e:	dceb      	bgt.n	8001458 <NET_APPThread+0x40>
				} else if (receivedBytesCount < 0) {
 8001480:	2c00      	cmp	r4, #0
 8001482:	daf2      	bge.n	800146a <NET_APPThread+0x52>
					FreeRTOS_shutdown( socket, FREERTOS_SHUT_RDWR );
 8001484:	2102      	movs	r1, #2
 8001486:	4628      	mov	r0, r5
 8001488:	f009 fd03 	bl	800ae92 <FreeRTOS_shutdown>
		}

		/* The socket has shut down and is safe to close. */
		FreeRTOS_closesocket( socket );
 800148c:	4628      	mov	r0, r5
 800148e:	f009 fecf 	bl	800b230 <FreeRTOS_closesocket>
		Socket_t socket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP);
 8001492:	2206      	movs	r2, #6
 8001494:	2101      	movs	r1, #1
 8001496:	2002      	movs	r0, #2
 8001498:	f009 f840 	bl	800a51c <FreeRTOS_socket>
 800149c:	4605      	mov	r5, r0
		configASSERT( socket != FREERTOS_INVALID_SOCKET );
 800149e:	f1b0 3fff 	cmp.w	r0, #4294967295
 80014a2:	d0d0      	beq.n	8001446 <NET_APPThread+0x2e>
		if( FreeRTOS_connect( socket, &serverAddress, sizeof( serverAddress ) ) == 0 )
 80014a4:	2218      	movs	r2, #24
 80014a6:	4669      	mov	r1, sp
 80014a8:	f009 fe47 	bl	800b13a <FreeRTOS_connect>
 80014ac:	2800      	cmp	r0, #0
 80014ae:	d1ed      	bne.n	800148c <NET_APPThread+0x74>
			printf("Connected to server!\n");
 80014b0:	4808      	ldr	r0, [pc, #32]	@ (80014d4 <NET_APPThread+0xbc>)
 80014b2:	f00d fabf 	bl	800ea34 <puts>
			AMCOM_InitReceiver(&amcomReceiver, amcomPacketHandler, (void*)socket);
 80014b6:	462a      	mov	r2, r5
 80014b8:	4907      	ldr	r1, [pc, #28]	@ (80014d8 <NET_APPThread+0xc0>)
 80014ba:	4805      	ldr	r0, [pc, #20]	@ (80014d0 <NET_APPThread+0xb8>)
 80014bc:	f7ff fad2 	bl	8000a64 <AMCOM_InitReceiver>
 80014c0:	e7d5      	b.n	800146e <NET_APPThread+0x56>
 80014c2:	bf00      	nop
 80014c4:	0128a8c0 	.word	0x0128a8c0
 80014c8:	080100a0 	.word	0x080100a0
 80014cc:	200007f4 	.word	0x200007f4
 80014d0:	200009f4 	.word	0x200009f4
 80014d4:	08010088 	.word	0x08010088
 80014d8:	08000e85 	.word	0x08000e85

080014dc <vApplicationIPNetworkEventHook_Multi>:
#include "enc28j60_net_interface.h"

/**
 * This function reacts to network events.
 */
void vApplicationIPNetworkEventHook_Multi(eIPCallbackEvent_t eNetworkEvent, struct xNetworkEndPoint *pxEndPoint) {
 80014dc:	b508      	push	{r3, lr}
  (void)eNetworkEvent;
  (void)pxEndPoint;
  switch(eNetworkEvent) {
 80014de:	b128      	cbz	r0, 80014ec <vApplicationIPNetworkEventHook_Multi+0x10>
 80014e0:	2801      	cmp	r0, #1
 80014e2:	d106      	bne.n	80014f2 <vApplicationIPNetworkEventHook_Multi+0x16>
  case eNetworkUp:
    // network comes up immediately at Ethernet driver initialization independently on the link status
    printf("Network up\n");
    break;
  case eNetworkDown:
    printf("Network down\n");
 80014e4:	4803      	ldr	r0, [pc, #12]	@ (80014f4 <vApplicationIPNetworkEventHook_Multi+0x18>)
 80014e6:	f00d faa5 	bl	800ea34 <puts>
    break;
  }
}
 80014ea:	e002      	b.n	80014f2 <vApplicationIPNetworkEventHook_Multi+0x16>
    printf("Network up\n");
 80014ec:	4802      	ldr	r0, [pc, #8]	@ (80014f8 <vApplicationIPNetworkEventHook_Multi+0x1c>)
 80014ee:	f00d faa1 	bl	800ea34 <puts>
}
 80014f2:	bd08      	pop	{r3, pc}
 80014f4:	080100cc 	.word	0x080100cc
 80014f8:	080100c0 	.word	0x080100c0

080014fc <xApplicationGetRandomNumber>:

BaseType_t xApplicationGetRandomNumber(uint32_t *pulNumber) {
  static uint32_t cnt = 0;
  *pulNumber = ++cnt;
 80014fc:	4a03      	ldr	r2, [pc, #12]	@ (800150c <xApplicationGetRandomNumber+0x10>)
 80014fe:	6813      	ldr	r3, [r2, #0]
 8001500:	3301      	adds	r3, #1
 8001502:	6013      	str	r3, [r2, #0]
 8001504:	6003      	str	r3, [r0, #0]
  return pdTRUE;
}
 8001506:	2001      	movs	r0, #1
 8001508:	4770      	bx	lr
 800150a:	bf00      	nop
 800150c:	20000ad4 	.word	0x20000ad4

08001510 <ulApplicationGetNextSequenceNumber>:
  (void)usSourcePort;
  (void)ulDestinationAddress;
  (void)usDestinationPort;
  uint32_t seq = 123;
  return seq++;
}
 8001510:	207b      	movs	r0, #123	@ 0x7b
 8001512:	4770      	bx	lr

08001514 <NET_MACThread>:
#include <enc28j60_net_interface.h>
#include <enc28j60_eth_phy.h>



void NET_MACThread(void *arg) {
 8001514:	b570      	push	{r4, r5, r6, lr}
 8001516:	b08c      	sub	sp, #48	@ 0x30

	static NetworkInterface_t netInterface;
	static NetworkEndPoint_t netEndpoint;

	// The last 4 bytes of the MAC address will be read from the chip
	uint8_t ucMACAddress[6] = {0xaa, 0xbb, 0x00, 0x00, 0x00, 0x00};
 8001518:	f64b 33aa 	movw	r3, #48042	@ 0xbbaa
 800151c:	930a      	str	r3, [sp, #40]	@ 0x28
 800151e:	2300      	movs	r3, #0
 8001520:	f8ad 302c 	strh.w	r3, [sp, #44]	@ 0x2c
	uint32_t uid = HAL_GetUIDw0();
 8001524:	f000 f9e4 	bl	80018f0 <HAL_GetUIDw0>
	memcpy(ucMACAddress+2, &uid, 4);
 8001528:	f8cd 002a 	str.w	r0, [sp, #42]	@ 0x2a
	MAC_SetMACAddress(ucMACAddress);
 800152c:	ae0a      	add	r6, sp, #40	@ 0x28
 800152e:	4630      	mov	r0, r6
 8001530:	f002 fa0a 	bl	8003948 <MAC_SetMACAddress>


	// Prepare the network interface
	pxFillInterfaceDescriptor(&netInterface);
 8001534:	4d25      	ldr	r5, [pc, #148]	@ (80015cc <NET_MACThread+0xb8>)
 8001536:	4628      	mov	r0, r5
 8001538:	f002 fa38 	bl	80039ac <pxFillInterfaceDescriptor>

	// These will only be used if DHCP fails:
	uint8_t ip[4] = {192, 168, 12, 2};
 800153c:	4b24      	ldr	r3, [pc, #144]	@ (80015d0 <NET_MACThread+0xbc>)
 800153e:	9309      	str	r3, [sp, #36]	@ 0x24
	uint8_t mask[4] = {255,255,255,0};
 8001540:	f06f 437f 	mvn.w	r3, #4278190080	@ 0xff000000
 8001544:	9308      	str	r3, [sp, #32]
	uint8_t gateway[4] = {192,168,12,1};
 8001546:	f503 234a 	add.w	r3, r3, #827392	@ 0xca000
 800154a:	f603 03c1 	addw	r3, r3, #2241	@ 0x8c1
 800154e:	9307      	str	r3, [sp, #28]
	uint8_t dns[4] = {8,8,8,8};
 8001550:	f04f 3308 	mov.w	r3, #134744072	@ 0x8080808
 8001554:	9306      	str	r3, [sp, #24]

	// Before initialization at least one endpoint must be set
	FreeRTOS_FillEndPoint(&netInterface, &netEndpoint, ip, mask, gateway, dns, ucMACAddress);
 8001556:	4c1f      	ldr	r4, [pc, #124]	@ (80015d4 <NET_MACThread+0xc0>)
 8001558:	9602      	str	r6, [sp, #8]
 800155a:	ab06      	add	r3, sp, #24
 800155c:	9301      	str	r3, [sp, #4]
 800155e:	ab07      	add	r3, sp, #28
 8001560:	9300      	str	r3, [sp, #0]
 8001562:	ab08      	add	r3, sp, #32
 8001564:	aa09      	add	r2, sp, #36	@ 0x24
 8001566:	4621      	mov	r1, r4
 8001568:	4628      	mov	r0, r5
 800156a:	f008 f9cd 	bl	8009908 <FreeRTOS_FillEndPoint>
	#if ( ipconfigUSE_DHCP != 0 )
		{
			/* End-point 0 wants to use DHCPv4. */
		netEndpoint.bits.bWantDHCP = pdTRUE;
 800156e:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8001572:	f043 0302 	orr.w	r3, r3, #2
 8001576:	f884 30f0 	strb.w	r3, [r4, #240]	@ 0xf0
		}
	#endif /* ( ipconfigUSE_DHCP != 0 ) */
	FreeRTOS_IPInit_Multi();
 800157a:	f005 fe49 	bl	8007210 <FreeRTOS_IPInit_Multi>
 800157e:	e002      	b.n	8001586 <NET_MACThread+0x72>
			} else {
				// The event was lost because a network buffer was not available. Call the standard trace macro to log the occurrence.
				iptraceETHERNET_RX_EVENT_LOST();
			}
		} else {
			osDelay(1);
 8001580:	2001      	movs	r0, #1
 8001582:	f002 fabf 	bl	8003b04 <osDelay>
		size_t xBytesReceived = MAC_GetRxFrameSize();
 8001586:	f002 f9c1 	bl	800390c <MAC_GetRxFrameSize>
		if (xBytesReceived > 0) {
 800158a:	4605      	mov	r5, r0
 800158c:	2800      	cmp	r0, #0
 800158e:	d0f7      	beq.n	8001580 <NET_MACThread+0x6c>
			pxBufferDescriptor = pxGetNetworkBufferWithDescriptor( xBytesReceived, 0 );
 8001590:	2100      	movs	r1, #0
 8001592:	f00d f8ab 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
			if( pxBufferDescriptor != NULL ) {
 8001596:	4604      	mov	r4, r0
 8001598:	2800      	cmp	r0, #0
 800159a:	d0f4      	beq.n	8001586 <NET_MACThread+0x72>
				MAC_ReadFrame(pxBufferDescriptor->pucEthernetBuffer, xBytesReceived);
 800159c:	4629      	mov	r1, r5
 800159e:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 80015a0:	f002 f970 	bl	8003884 <MAC_ReadFrame>
				pxBufferDescriptor->xDataLength = xBytesReceived;
 80015a4:	62a5      	str	r5, [r4, #40]	@ 0x28
				pxBufferDescriptor->pxInterface = &netInterface;
 80015a6:	4b09      	ldr	r3, [pc, #36]	@ (80015cc <NET_MACThread+0xb8>)
 80015a8:	62e3      	str	r3, [r4, #44]	@ 0x2c
				pxBufferDescriptor->pxEndPoint = &netEndpoint;
 80015aa:	4b0a      	ldr	r3, [pc, #40]	@ (80015d4 <NET_MACThread+0xc0>)
 80015ac:	6323      	str	r3, [r4, #48]	@ 0x30
				xRxEvent.eEventType = eNetworkRxEvent;
 80015ae:	2301      	movs	r3, #1
 80015b0:	f88d 3010 	strb.w	r3, [sp, #16]
				xRxEvent.pvData = ( void * ) pxBufferDescriptor;
 80015b4:	9405      	str	r4, [sp, #20]
				if( xSendEventStructToIPTask( &xRxEvent, 0 ) == pdFALSE ) {
 80015b6:	2100      	movs	r1, #0
 80015b8:	a804      	add	r0, sp, #16
 80015ba:	f005 fe93 	bl	80072e4 <xSendEventStructToIPTask>
 80015be:	2800      	cmp	r0, #0
 80015c0:	d1e1      	bne.n	8001586 <NET_MACThread+0x72>
					vReleaseNetworkBufferAndDescriptor( pxBufferDescriptor );
 80015c2:	4620      	mov	r0, r4
 80015c4:	f00d f86c 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
					iptraceNETWORK_INTERFACE_RECEIVE();
 80015c8:	e7dd      	b.n	8001586 <NET_MACThread+0x72>
 80015ca:	bf00      	nop
 80015cc:	20000c38 	.word	0x20000c38
 80015d0:	020ca8c0 	.word	0x020ca8c0
 80015d4:	20000ad8 	.word	0x20000ad8

080015d8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80015d8:	b500      	push	{lr}
 80015da:	b083      	sub	sp, #12

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80015dc:	2200      	movs	r2, #0
 80015de:	9200      	str	r2, [sp, #0]
 80015e0:	4b0d      	ldr	r3, [pc, #52]	@ (8001618 <HAL_MspInit+0x40>)
 80015e2:	6c59      	ldr	r1, [r3, #68]	@ 0x44
 80015e4:	f441 4180 	orr.w	r1, r1, #16384	@ 0x4000
 80015e8:	6459      	str	r1, [r3, #68]	@ 0x44
 80015ea:	6c59      	ldr	r1, [r3, #68]	@ 0x44
 80015ec:	f401 4180 	and.w	r1, r1, #16384	@ 0x4000
 80015f0:	9100      	str	r1, [sp, #0]
 80015f2:	9900      	ldr	r1, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80015f4:	9201      	str	r2, [sp, #4]
 80015f6:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 80015f8:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
 80015fc:	6419      	str	r1, [r3, #64]	@ 0x40
 80015fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001600:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001604:	9301      	str	r3, [sp, #4]
 8001606:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8001608:	210f      	movs	r1, #15
 800160a:	f06f 0001 	mvn.w	r0, #1
 800160e:	f000 f9c9 	bl	80019a4 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001612:	b003      	add	sp, #12
 8001614:	f85d fb04 	ldr.w	pc, [sp], #4
 8001618:	40023800 	.word	0x40023800

0800161c <HAL_SPI_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 800161c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001620:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001622:	2300      	movs	r3, #0
 8001624:	9303      	str	r3, [sp, #12]
 8001626:	9304      	str	r3, [sp, #16]
 8001628:	9305      	str	r3, [sp, #20]
 800162a:	9306      	str	r3, [sp, #24]
 800162c:	9307      	str	r3, [sp, #28]
  if(hspi->Instance==SPI4)
 800162e:	6802      	ldr	r2, [r0, #0]
 8001630:	4b1c      	ldr	r3, [pc, #112]	@ (80016a4 <HAL_SPI_MspInit+0x88>)
 8001632:	429a      	cmp	r2, r3
 8001634:	d002      	beq.n	800163c <HAL_SPI_MspInit+0x20>

    /* USER CODE END SPI4_MspInit 1 */

  }

}
 8001636:	b008      	add	sp, #32
 8001638:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_SPI4_CLK_ENABLE();
 800163c:	2400      	movs	r4, #0
 800163e:	9401      	str	r4, [sp, #4]
 8001640:	f503 3382 	add.w	r3, r3, #66560	@ 0x10400
 8001644:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8001646:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 800164a:	645a      	str	r2, [r3, #68]	@ 0x44
 800164c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800164e:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8001652:	9201      	str	r2, [sp, #4]
 8001654:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8001656:	9402      	str	r4, [sp, #8]
 8001658:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800165a:	f042 0210 	orr.w	r2, r2, #16
 800165e:	631a      	str	r2, [r3, #48]	@ 0x30
 8001660:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001662:	f003 0310 	and.w	r3, r3, #16
 8001666:	9302      	str	r3, [sp, #8]
 8001668:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800166a:	2304      	movs	r3, #4
 800166c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800166e:	2502      	movs	r5, #2
 8001670:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8001672:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001674:	f04f 0803 	mov.w	r8, #3
 8001678:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
 800167c:	2705      	movs	r7, #5
 800167e:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001680:	4e09      	ldr	r6, [pc, #36]	@ (80016a8 <HAL_SPI_MspInit+0x8c>)
 8001682:	a903      	add	r1, sp, #12
 8001684:	4630      	mov	r0, r6
 8001686:	f000 f9a1 	bl	80019cc <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
 800168a:	2360      	movs	r3, #96	@ 0x60
 800168c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800168e:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001690:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001692:	f8cd 8018 	str.w	r8, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
 8001696:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001698:	a903      	add	r1, sp, #12
 800169a:	4630      	mov	r0, r6
 800169c:	f000 f996 	bl	80019cc <HAL_GPIO_Init>
}
 80016a0:	e7c9      	b.n	8001636 <HAL_SPI_MspInit+0x1a>
 80016a2:	bf00      	nop
 80016a4:	40013400 	.word	0x40013400
 80016a8:	40021000 	.word	0x40021000

080016ac <HAL_TIM_Base_MspInit>:
  * @param htim_base: TIM_Base handle pointer
  * @retval None
  */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM14)
 80016ac:	6802      	ldr	r2, [r0, #0]
 80016ae:	4b09      	ldr	r3, [pc, #36]	@ (80016d4 <HAL_TIM_Base_MspInit+0x28>)
 80016b0:	429a      	cmp	r2, r3
 80016b2:	d000      	beq.n	80016b6 <HAL_TIM_Base_MspInit+0xa>
 80016b4:	4770      	bx	lr
{
 80016b6:	b082      	sub	sp, #8
  {
    /* USER CODE BEGIN TIM14_MspInit 0 */

    /* USER CODE END TIM14_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM14_CLK_ENABLE();
 80016b8:	2300      	movs	r3, #0
 80016ba:	9301      	str	r3, [sp, #4]
 80016bc:	4b06      	ldr	r3, [pc, #24]	@ (80016d8 <HAL_TIM_Base_MspInit+0x2c>)
 80016be:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80016c0:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80016c4:	641a      	str	r2, [r3, #64]	@ 0x40
 80016c6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80016c8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80016cc:	9301      	str	r3, [sp, #4]
 80016ce:	9b01      	ldr	r3, [sp, #4]

    /* USER CODE END TIM14_MspInit 1 */

  }

}
 80016d0:	b002      	add	sp, #8
 80016d2:	4770      	bx	lr
 80016d4:	40002000 	.word	0x40002000
 80016d8:	40023800 	.word	0x40023800

080016dc <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80016dc:	b530      	push	{r4, r5, lr}
 80016de:	b089      	sub	sp, #36	@ 0x24
 80016e0:	4605      	mov	r5, r0
  uint32_t              pFLatency;

  HAL_StatusTypeDef     status;

  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 80016e2:	2400      	movs	r4, #0
 80016e4:	9401      	str	r4, [sp, #4]
 80016e6:	4b1e      	ldr	r3, [pc, #120]	@ (8001760 <HAL_InitTick+0x84>)
 80016e8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80016ea:	f042 0201 	orr.w	r2, r2, #1
 80016ee:	645a      	str	r2, [r3, #68]	@ 0x44
 80016f0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80016f2:	f003 0301 	and.w	r3, r3, #1
 80016f6:	9301      	str	r3, [sp, #4]
 80016f8:	9b01      	ldr	r3, [sp, #4]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80016fa:	a902      	add	r1, sp, #8
 80016fc:	a803      	add	r0, sp, #12
 80016fe:	f000 fda9 	bl	8002254 <HAL_RCC_GetClockConfig>

  /* Compute TIM1 clock */
      uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 8001702:	f000 fd97 	bl	8002234 <HAL_RCC_GetPCLK2Freq>
 8001706:	0043      	lsls	r3, r0, #1

  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8001708:	4a16      	ldr	r2, [pc, #88]	@ (8001764 <HAL_InitTick+0x88>)
 800170a:	fba2 2303 	umull	r2, r3, r2, r3
 800170e:	0c9b      	lsrs	r3, r3, #18
 8001710:	3b01      	subs	r3, #1

  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8001712:	4815      	ldr	r0, [pc, #84]	@ (8001768 <HAL_InitTick+0x8c>)
 8001714:	4a15      	ldr	r2, [pc, #84]	@ (800176c <HAL_InitTick+0x90>)
 8001716:	6002      	str	r2, [r0, #0]
   * Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
   * Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
   * ClockDivision = 0
   * Counter direction = Up
   */
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 8001718:	f240 32e7 	movw	r2, #999	@ 0x3e7
 800171c:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 800171e:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 8001720:	6104      	str	r4, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001722:	6084      	str	r4, [r0, #8]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001724:	6184      	str	r4, [r0, #24]

  status = HAL_TIM_Base_Init(&htim1);
 8001726:	f001 fb71 	bl	8002e0c <HAL_TIM_Base_Init>
  if (status == HAL_OK)
 800172a:	4604      	mov	r4, r0
 800172c:	b110      	cbz	r0, 8001734 <HAL_InitTick+0x58>
    }
  }

 /* Return function status */
  return status;
}
 800172e:	4620      	mov	r0, r4
 8001730:	b009      	add	sp, #36	@ 0x24
 8001732:	bd30      	pop	{r4, r5, pc}
    status = HAL_TIM_Base_Start_IT(&htim1);
 8001734:	480c      	ldr	r0, [pc, #48]	@ (8001768 <HAL_InitTick+0x8c>)
 8001736:	f001 fa05 	bl	8002b44 <HAL_TIM_Base_Start_IT>
    if (status == HAL_OK)
 800173a:	4604      	mov	r4, r0
 800173c:	2800      	cmp	r0, #0
 800173e:	d1f6      	bne.n	800172e <HAL_InitTick+0x52>
        HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
 8001740:	2019      	movs	r0, #25
 8001742:	f000 f93f 	bl	80019c4 <HAL_NVIC_EnableIRQ>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001746:	2d0f      	cmp	r5, #15
 8001748:	d901      	bls.n	800174e <HAL_InitTick+0x72>
        status = HAL_ERROR;
 800174a:	2401      	movs	r4, #1
 800174c:	e7ef      	b.n	800172e <HAL_InitTick+0x52>
        HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, TickPriority, 0U);
 800174e:	2200      	movs	r2, #0
 8001750:	4629      	mov	r1, r5
 8001752:	2019      	movs	r0, #25
 8001754:	f000 f926 	bl	80019a4 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8001758:	4b05      	ldr	r3, [pc, #20]	@ (8001770 <HAL_InitTick+0x94>)
 800175a:	601d      	str	r5, [r3, #0]
 800175c:	e7e7      	b.n	800172e <HAL_InitTick+0x52>
 800175e:	bf00      	nop
 8001760:	40023800 	.word	0x40023800
 8001764:	431bde83 	.word	0x431bde83
 8001768:	20000c60 	.word	0x20000c60
 800176c:	40010000 	.word	0x40010000
 8001770:	20000008 	.word	0x20000008

08001774 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8001774:	e7fe      	b.n	8001774 <NMI_Handler>

08001776 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001776:	e7fe      	b.n	8001776 <HardFault_Handler>

08001778 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001778:	e7fe      	b.n	8001778 <MemManage_Handler>

0800177a <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800177a:	e7fe      	b.n	800177a <BusFault_Handler>

0800177c <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800177c:	e7fe      	b.n	800177c <UsageFault_Handler>

0800177e <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800177e:	4770      	bx	lr

08001780 <TIM1_UP_TIM10_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM10 global interrupt.
  */
void TIM1_UP_TIM10_IRQHandler(void)
{
 8001780:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8001782:	4802      	ldr	r0, [pc, #8]	@ (800178c <TIM1_UP_TIM10_IRQHandler+0xc>)
 8001784:	f001 fa26 	bl	8002bd4 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM10_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM10_IRQn 1 */
}
 8001788:	bd08      	pop	{r3, pc}
 800178a:	bf00      	nop
 800178c:	20000c60 	.word	0x20000c60

08001790 <USART1_IRQHandler>:

  /* USER CODE END USART1_IRQn 0 */
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8001790:	4770      	bx	lr

08001792 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001792:	b570      	push	{r4, r5, r6, lr}
 8001794:	460c      	mov	r4, r1
 8001796:	4616      	mov	r6, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001798:	2500      	movs	r5, #0
 800179a:	e006      	b.n	80017aa <_read+0x18>
  {
    *ptr++ = __io_getchar();
 800179c:	f3af 8000 	nop.w
 80017a0:	4621      	mov	r1, r4
 80017a2:	f801 0b01 	strb.w	r0, [r1], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80017a6:	3501      	adds	r5, #1
    *ptr++ = __io_getchar();
 80017a8:	460c      	mov	r4, r1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80017aa:	42b5      	cmp	r5, r6
 80017ac:	dbf6      	blt.n	800179c <_read+0xa>
  }

  return len;
}
 80017ae:	4630      	mov	r0, r6
 80017b0:	bd70      	pop	{r4, r5, r6, pc}

080017b2 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80017b2:	b570      	push	{r4, r5, r6, lr}
 80017b4:	460c      	mov	r4, r1
 80017b6:	4616      	mov	r6, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80017b8:	2500      	movs	r5, #0
 80017ba:	e004      	b.n	80017c6 <_write+0x14>
  {
    __io_putchar(*ptr++);
 80017bc:	f814 0b01 	ldrb.w	r0, [r4], #1
 80017c0:	f7ff fd58 	bl	8001274 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80017c4:	3501      	adds	r5, #1
 80017c6:	42b5      	cmp	r5, r6
 80017c8:	dbf8      	blt.n	80017bc <_write+0xa>
  }
  return len;
}
 80017ca:	4630      	mov	r0, r6
 80017cc:	bd70      	pop	{r4, r5, r6, pc}

080017ce <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
 80017ce:	f04f 30ff 	mov.w	r0, #4294967295
 80017d2:	4770      	bx	lr

080017d4 <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
 80017d4:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80017d8:	604b      	str	r3, [r1, #4]
  return 0;
}
 80017da:	2000      	movs	r0, #0
 80017dc:	4770      	bx	lr

080017de <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
 80017de:	2001      	movs	r0, #1
 80017e0:	4770      	bx	lr

080017e2 <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
 80017e2:	2000      	movs	r0, #0
 80017e4:	4770      	bx	lr
	...

080017e8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80017e8:	b510      	push	{r4, lr}
 80017ea:	4603      	mov	r3, r0
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80017ec:	4a0c      	ldr	r2, [pc, #48]	@ (8001820 <_sbrk+0x38>)
 80017ee:	490d      	ldr	r1, [pc, #52]	@ (8001824 <_sbrk+0x3c>)
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80017f0:	480d      	ldr	r0, [pc, #52]	@ (8001828 <_sbrk+0x40>)
 80017f2:	6800      	ldr	r0, [r0, #0]
 80017f4:	b140      	cbz	r0, 8001808 <_sbrk+0x20>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80017f6:	480c      	ldr	r0, [pc, #48]	@ (8001828 <_sbrk+0x40>)
 80017f8:	6800      	ldr	r0, [r0, #0]
 80017fa:	4403      	add	r3, r0
 80017fc:	1a52      	subs	r2, r2, r1
 80017fe:	4293      	cmp	r3, r2
 8001800:	d806      	bhi.n	8001810 <_sbrk+0x28>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8001802:	4a09      	ldr	r2, [pc, #36]	@ (8001828 <_sbrk+0x40>)
 8001804:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
}
 8001806:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8001808:	4807      	ldr	r0, [pc, #28]	@ (8001828 <_sbrk+0x40>)
 800180a:	4c08      	ldr	r4, [pc, #32]	@ (800182c <_sbrk+0x44>)
 800180c:	6004      	str	r4, [r0, #0]
 800180e:	e7f2      	b.n	80017f6 <_sbrk+0xe>
    errno = ENOMEM;
 8001810:	f00d fafc 	bl	800ee0c <__errno>
 8001814:	230c      	movs	r3, #12
 8001816:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8001818:	f04f 30ff 	mov.w	r0, #4294967295
 800181c:	e7f3      	b.n	8001806 <_sbrk+0x1e>
 800181e:	bf00      	nop
 8001820:	20030000 	.word	0x20030000
 8001824:	00000400 	.word	0x00000400
 8001828:	20000ca8 	.word	0x20000ca8
 800182c:	200146a8 	.word	0x200146a8

08001830 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001830:	4a03      	ldr	r2, [pc, #12]	@ (8001840 <SystemInit+0x10>)
 8001832:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8001836:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800183a:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800183e:	4770      	bx	lr
 8001840:	e000ed00 	.word	0xe000ed00

08001844 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 8001844:	f8df d034 	ldr.w	sp, [pc, #52]	@ 800187c <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8001848:	f7ff fff2 	bl	8001830 <SystemInit>
 
/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 800184c:	480c      	ldr	r0, [pc, #48]	@ (8001880 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800184e:	490d      	ldr	r1, [pc, #52]	@ (8001884 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001850:	4a0d      	ldr	r2, [pc, #52]	@ (8001888 <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001852:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001854:	e002      	b.n	800185c <LoopCopyDataInit>

08001856 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001856:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001858:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800185a:	3304      	adds	r3, #4

0800185c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800185c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800185e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001860:	d3f9      	bcc.n	8001856 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001862:	4a0a      	ldr	r2, [pc, #40]	@ (800188c <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001864:	4c0a      	ldr	r4, [pc, #40]	@ (8001890 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001866:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001868:	e001      	b.n	800186e <LoopFillZerobss>

0800186a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800186a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800186c:	3204      	adds	r2, #4

0800186e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800186e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001870:	d3fb      	bcc.n	800186a <FillZerobss>
  
/* Call static constructors */
    bl __libc_init_array
 8001872:	f00d fad1 	bl	800ee18 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001876:	f7ff fd9d 	bl	80013b4 <main>
  bx  lr    
 800187a:	4770      	bx	lr
  ldr   sp, =_estack       /* set stack pointer */
 800187c:	20030000 	.word	0x20030000
  ldr r0, =_sdata
 8001880:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001884:	20000080 	.word	0x20000080
  ldr r2, =_sidata
 8001888:	080103bc 	.word	0x080103bc
  ldr r2, =_sbss
 800188c:	20000080 	.word	0x20000080
  ldr r4, =_ebss
 8001890:	200146a4 	.word	0x200146a4

08001894 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001894:	e7fe      	b.n	8001894 <ADC_IRQHandler>
	...

08001898 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001898:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800189a:	4b0b      	ldr	r3, [pc, #44]	@ (80018c8 <HAL_Init+0x30>)
 800189c:	681a      	ldr	r2, [r3, #0]
 800189e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80018a2:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 80018a4:	681a      	ldr	r2, [r3, #0]
 80018a6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80018aa:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80018ac:	681a      	ldr	r2, [r3, #0]
 80018ae:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80018b2:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80018b4:	2003      	movs	r0, #3
 80018b6:	f000 f863 	bl	8001980 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80018ba:	200f      	movs	r0, #15
 80018bc:	f7ff ff0e 	bl	80016dc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 80018c0:	f7ff fe8a 	bl	80015d8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 80018c4:	2000      	movs	r0, #0
 80018c6:	bd08      	pop	{r3, pc}
 80018c8:	40023c00 	.word	0x40023c00

080018cc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80018cc:	4a03      	ldr	r2, [pc, #12]	@ (80018dc <HAL_IncTick+0x10>)
 80018ce:	6811      	ldr	r1, [r2, #0]
 80018d0:	4b03      	ldr	r3, [pc, #12]	@ (80018e0 <HAL_IncTick+0x14>)
 80018d2:	781b      	ldrb	r3, [r3, #0]
 80018d4:	440b      	add	r3, r1
 80018d6:	6013      	str	r3, [r2, #0]
}
 80018d8:	4770      	bx	lr
 80018da:	bf00      	nop
 80018dc:	20000cac 	.word	0x20000cac
 80018e0:	20000004 	.word	0x20000004

080018e4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80018e4:	4b01      	ldr	r3, [pc, #4]	@ (80018ec <HAL_GetTick+0x8>)
 80018e6:	6818      	ldr	r0, [r3, #0]
}
 80018e8:	4770      	bx	lr
 80018ea:	bf00      	nop
 80018ec:	20000cac 	.word	0x20000cac

080018f0 <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
}
 80018f0:	4b01      	ldr	r3, [pc, #4]	@ (80018f8 <HAL_GetUIDw0+0x8>)
 80018f2:	f8d3 0a10 	ldr.w	r0, [r3, #2576]	@ 0xa10
 80018f6:	4770      	bx	lr
 80018f8:	1fff7000 	.word	0x1fff7000

080018fc <__NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80018fc:	2800      	cmp	r0, #0
 80018fe:	db07      	blt.n	8001910 <__NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001900:	f000 021f 	and.w	r2, r0, #31
 8001904:	0940      	lsrs	r0, r0, #5
 8001906:	2301      	movs	r3, #1
 8001908:	4093      	lsls	r3, r2
 800190a:	4a02      	ldr	r2, [pc, #8]	@ (8001914 <__NVIC_EnableIRQ+0x18>)
 800190c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
}
 8001910:	4770      	bx	lr
 8001912:	bf00      	nop
 8001914:	e000e100 	.word	0xe000e100

08001918 <__NVIC_SetPriority>:
  if ((int32_t)(IRQn) >= 0)
 8001918:	2800      	cmp	r0, #0
 800191a:	db08      	blt.n	800192e <__NVIC_SetPriority+0x16>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800191c:	0109      	lsls	r1, r1, #4
 800191e:	b2c9      	uxtb	r1, r1
 8001920:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8001924:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 8001928:	f880 1300 	strb.w	r1, [r0, #768]	@ 0x300
 800192c:	4770      	bx	lr
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800192e:	f000 000f 	and.w	r0, r0, #15
 8001932:	0109      	lsls	r1, r1, #4
 8001934:	b2c9      	uxtb	r1, r1
 8001936:	4b01      	ldr	r3, [pc, #4]	@ (800193c <__NVIC_SetPriority+0x24>)
 8001938:	5419      	strb	r1, [r3, r0]
}
 800193a:	4770      	bx	lr
 800193c:	e000ed14 	.word	0xe000ed14

08001940 <NVIC_EncodePriority>:
{
 8001940:	b500      	push	{lr}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001942:	f000 0007 	and.w	r0, r0, #7
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001946:	f1c0 0c07 	rsb	ip, r0, #7
 800194a:	f1bc 0f04 	cmp.w	ip, #4
 800194e:	bf28      	it	cs
 8001950:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001954:	1d03      	adds	r3, r0, #4
 8001956:	2b06      	cmp	r3, #6
 8001958:	d90f      	bls.n	800197a <NVIC_EncodePriority+0x3a>
 800195a:	1ec3      	subs	r3, r0, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800195c:	f04f 3eff 	mov.w	lr, #4294967295
 8001960:	fa0e f00c 	lsl.w	r0, lr, ip
 8001964:	ea21 0100 	bic.w	r1, r1, r0
 8001968:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800196a:	fa0e fe03 	lsl.w	lr, lr, r3
 800196e:	ea22 020e 	bic.w	r2, r2, lr
}
 8001972:	ea41 0002 	orr.w	r0, r1, r2
 8001976:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800197a:	2300      	movs	r3, #0
 800197c:	e7ee      	b.n	800195c <NVIC_EncodePriority+0x1c>
	...

08001980 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001980:	4a07      	ldr	r2, [pc, #28]	@ (80019a0 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001982:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001984:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 8001988:	041b      	lsls	r3, r3, #16
 800198a:	0c1b      	lsrs	r3, r3, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800198c:	0200      	lsls	r0, r0, #8
 800198e:	f400 60e0 	and.w	r0, r0, #1792	@ 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001992:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8001994:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001998:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800199c:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800199e:	4770      	bx	lr
 80019a0:	e000ed00 	.word	0xe000ed00

080019a4 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80019a4:	b510      	push	{r4, lr}
 80019a6:	4604      	mov	r4, r0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80019a8:	4b05      	ldr	r3, [pc, #20]	@ (80019c0 <HAL_NVIC_SetPriority+0x1c>)
 80019aa:	68d8      	ldr	r0, [r3, #12]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80019ac:	f3c0 2002 	ubfx	r0, r0, #8, #3
 80019b0:	f7ff ffc6 	bl	8001940 <NVIC_EncodePriority>
 80019b4:	4601      	mov	r1, r0
 80019b6:	4620      	mov	r0, r4
 80019b8:	f7ff ffae 	bl	8001918 <__NVIC_SetPriority>
}
 80019bc:	bd10      	pop	{r4, pc}
 80019be:	bf00      	nop
 80019c0:	e000ed00 	.word	0xe000ed00

080019c4 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80019c4:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80019c6:	f7ff ff99 	bl	80018fc <__NVIC_EnableIRQ>
}
 80019ca:	bd08      	pop	{r3, pc}

080019cc <HAL_GPIO_Init>:
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 80019cc:	2300      	movs	r3, #0
 80019ce:	2b0f      	cmp	r3, #15
 80019d0:	f200 80f6 	bhi.w	8001bc0 <HAL_GPIO_Init+0x1f4>
{
 80019d4:	b570      	push	{r4, r5, r6, lr}
 80019d6:	b082      	sub	sp, #8
 80019d8:	e066      	b.n	8001aa8 <HAL_GPIO_Init+0xdc>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 80019da:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80019dc:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 80019e0:	2403      	movs	r4, #3
 80019e2:	fa04 f40e 	lsl.w	r4, r4, lr
 80019e6:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 80019ea:	68cc      	ldr	r4, [r1, #12]
 80019ec:	fa04 f40e 	lsl.w	r4, r4, lr
 80019f0:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 80019f2:	6084      	str	r4, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80019f4:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80019f6:	ea24 0402 	bic.w	r4, r4, r2
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80019fa:	684a      	ldr	r2, [r1, #4]
 80019fc:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8001a00:	409a      	lsls	r2, r3
 8001a02:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 8001a04:	6042      	str	r2, [r0, #4]
 8001a06:	e05d      	b.n	8001ac4 <HAL_GPIO_Init+0xf8>
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001a08:	08dc      	lsrs	r4, r3, #3
 8001a0a:	3408      	adds	r4, #8
 8001a0c:	f850 2024 	ldr.w	r2, [r0, r4, lsl #2]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001a10:	f003 0507 	and.w	r5, r3, #7
 8001a14:	00ad      	lsls	r5, r5, #2
 8001a16:	f04f 0e0f 	mov.w	lr, #15
 8001a1a:	fa0e fe05 	lsl.w	lr, lr, r5
 8001a1e:	ea22 0e0e 	bic.w	lr, r2, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8001a22:	690a      	ldr	r2, [r1, #16]
 8001a24:	40aa      	lsls	r2, r5
 8001a26:	ea42 020e 	orr.w	r2, r2, lr
        GPIOx->AFR[position >> 3U] = temp;
 8001a2a:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8001a2e:	e05d      	b.n	8001aec <HAL_GPIO_Init+0x120>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001a30:	2209      	movs	r2, #9
 8001a32:	e000      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001a34:	2200      	movs	r2, #0
 8001a36:	fa02 f20e 	lsl.w	r2, r2, lr
 8001a3a:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001a3c:	3402      	adds	r4, #2
 8001a3e:	4d61      	ldr	r5, [pc, #388]	@ (8001bc4 <HAL_GPIO_Init+0x1f8>)
 8001a40:	f845 2024 	str.w	r2, [r5, r4, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001a44:	4a60      	ldr	r2, [pc, #384]	@ (8001bc8 <HAL_GPIO_Init+0x1fc>)
 8001a46:	6894      	ldr	r4, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 8001a48:	ea6f 020c 	mvn.w	r2, ip
 8001a4c:	ea24 050c 	bic.w	r5, r4, ip
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8001a50:	684e      	ldr	r6, [r1, #4]
 8001a52:	f416 1f80 	tst.w	r6, #1048576	@ 0x100000
 8001a56:	d001      	beq.n	8001a5c <HAL_GPIO_Init+0x90>
        {
          temp |= iocurrent;
 8001a58:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->RTSR = temp;
 8001a5c:	4c5a      	ldr	r4, [pc, #360]	@ (8001bc8 <HAL_GPIO_Init+0x1fc>)
 8001a5e:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR;
 8001a60:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8001a62:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8001a66:	684e      	ldr	r6, [r1, #4]
 8001a68:	f416 1f00 	tst.w	r6, #2097152	@ 0x200000
 8001a6c:	d001      	beq.n	8001a72 <HAL_GPIO_Init+0xa6>
        {
          temp |= iocurrent;
 8001a6e:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->FTSR = temp;
 8001a72:	4c55      	ldr	r4, [pc, #340]	@ (8001bc8 <HAL_GPIO_Init+0x1fc>)
 8001a74:	60e5      	str	r5, [r4, #12]

        temp = EXTI->EMR;
 8001a76:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 8001a78:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8001a7c:	684e      	ldr	r6, [r1, #4]
 8001a7e:	f416 3f00 	tst.w	r6, #131072	@ 0x20000
 8001a82:	d001      	beq.n	8001a88 <HAL_GPIO_Init+0xbc>
        {
          temp |= iocurrent;
 8001a84:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->EMR = temp;
 8001a88:	4c4f      	ldr	r4, [pc, #316]	@ (8001bc8 <HAL_GPIO_Init+0x1fc>)
 8001a8a:	6065      	str	r5, [r4, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001a8c:	6824      	ldr	r4, [r4, #0]
        temp &= ~((uint32_t)iocurrent);
 8001a8e:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8001a90:	684d      	ldr	r5, [r1, #4]
 8001a92:	f415 3f80 	tst.w	r5, #65536	@ 0x10000
 8001a96:	d001      	beq.n	8001a9c <HAL_GPIO_Init+0xd0>
        {
          temp |= iocurrent;
 8001a98:	ea4c 0204 	orr.w	r2, ip, r4
        }
        EXTI->IMR = temp;
 8001a9c:	4c4a      	ldr	r4, [pc, #296]	@ (8001bc8 <HAL_GPIO_Init+0x1fc>)
 8001a9e:	6022      	str	r2, [r4, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001aa0:	3301      	adds	r3, #1
 8001aa2:	2b0f      	cmp	r3, #15
 8001aa4:	f200 808a 	bhi.w	8001bbc <HAL_GPIO_Init+0x1f0>
    ioposition = 0x01U << position;
 8001aa8:	2201      	movs	r2, #1
 8001aaa:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001aac:	680c      	ldr	r4, [r1, #0]
 8001aae:	ea04 0c02 	and.w	ip, r4, r2
    if(iocurrent == ioposition)
 8001ab2:	ea32 0404 	bics.w	r4, r2, r4
 8001ab6:	d1f3      	bne.n	8001aa0 <HAL_GPIO_Init+0xd4>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8001ab8:	684c      	ldr	r4, [r1, #4]
 8001aba:	f004 0403 	and.w	r4, r4, #3
 8001abe:	3c01      	subs	r4, #1
 8001ac0:	2c01      	cmp	r4, #1
 8001ac2:	d98a      	bls.n	80019da <HAL_GPIO_Init+0xe>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8001ac4:	684a      	ldr	r2, [r1, #4]
 8001ac6:	f002 0203 	and.w	r2, r2, #3
 8001aca:	2a03      	cmp	r2, #3
 8001acc:	d009      	beq.n	8001ae2 <HAL_GPIO_Init+0x116>
        temp = GPIOx->PUPDR;
 8001ace:	68c4      	ldr	r4, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8001ad0:	005d      	lsls	r5, r3, #1
 8001ad2:	2203      	movs	r2, #3
 8001ad4:	40aa      	lsls	r2, r5
 8001ad6:	ea24 0402 	bic.w	r4, r4, r2
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001ada:	688a      	ldr	r2, [r1, #8]
 8001adc:	40aa      	lsls	r2, r5
 8001ade:	4322      	orrs	r2, r4
        GPIOx->PUPDR = temp;
 8001ae0:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8001ae2:	684a      	ldr	r2, [r1, #4]
 8001ae4:	f002 0203 	and.w	r2, r2, #3
 8001ae8:	2a02      	cmp	r2, #2
 8001aea:	d08d      	beq.n	8001a08 <HAL_GPIO_Init+0x3c>
      temp = GPIOx->MODER;
 8001aec:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001aee:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8001af2:	2203      	movs	r2, #3
 8001af4:	fa02 f20e 	lsl.w	r2, r2, lr
 8001af8:	ea24 0402 	bic.w	r4, r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001afc:	684a      	ldr	r2, [r1, #4]
 8001afe:	f002 0203 	and.w	r2, r2, #3
 8001b02:	fa02 f20e 	lsl.w	r2, r2, lr
 8001b06:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 8001b08:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8001b0a:	684a      	ldr	r2, [r1, #4]
 8001b0c:	f412 3f40 	tst.w	r2, #196608	@ 0x30000
 8001b10:	d0c6      	beq.n	8001aa0 <HAL_GPIO_Init+0xd4>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b12:	2200      	movs	r2, #0
 8001b14:	9201      	str	r2, [sp, #4]
 8001b16:	4a2d      	ldr	r2, [pc, #180]	@ (8001bcc <HAL_GPIO_Init+0x200>)
 8001b18:	6c54      	ldr	r4, [r2, #68]	@ 0x44
 8001b1a:	f444 4480 	orr.w	r4, r4, #16384	@ 0x4000
 8001b1e:	6454      	str	r4, [r2, #68]	@ 0x44
 8001b20:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 8001b22:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 8001b26:	9201      	str	r2, [sp, #4]
 8001b28:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8001b2a:	089c      	lsrs	r4, r3, #2
 8001b2c:	1ca5      	adds	r5, r4, #2
 8001b2e:	4a25      	ldr	r2, [pc, #148]	@ (8001bc4 <HAL_GPIO_Init+0x1f8>)
 8001b30:	f852 5025 	ldr.w	r5, [r2, r5, lsl #2]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8001b34:	f003 0e03 	and.w	lr, r3, #3
 8001b38:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8001b3c:	220f      	movs	r2, #15
 8001b3e:	fa02 f20e 	lsl.w	r2, r2, lr
 8001b42:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001b46:	4a22      	ldr	r2, [pc, #136]	@ (8001bd0 <HAL_GPIO_Init+0x204>)
 8001b48:	4290      	cmp	r0, r2
 8001b4a:	f43f af73 	beq.w	8001a34 <HAL_GPIO_Init+0x68>
 8001b4e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b52:	4290      	cmp	r0, r2
 8001b54:	d022      	beq.n	8001b9c <HAL_GPIO_Init+0x1d0>
 8001b56:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b5a:	4290      	cmp	r0, r2
 8001b5c:	d020      	beq.n	8001ba0 <HAL_GPIO_Init+0x1d4>
 8001b5e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b62:	4290      	cmp	r0, r2
 8001b64:	d01e      	beq.n	8001ba4 <HAL_GPIO_Init+0x1d8>
 8001b66:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b6a:	4290      	cmp	r0, r2
 8001b6c:	d01c      	beq.n	8001ba8 <HAL_GPIO_Init+0x1dc>
 8001b6e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b72:	4290      	cmp	r0, r2
 8001b74:	d01a      	beq.n	8001bac <HAL_GPIO_Init+0x1e0>
 8001b76:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b7a:	4290      	cmp	r0, r2
 8001b7c:	d018      	beq.n	8001bb0 <HAL_GPIO_Init+0x1e4>
 8001b7e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b82:	4290      	cmp	r0, r2
 8001b84:	d016      	beq.n	8001bb4 <HAL_GPIO_Init+0x1e8>
 8001b86:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b8a:	4290      	cmp	r0, r2
 8001b8c:	d014      	beq.n	8001bb8 <HAL_GPIO_Init+0x1ec>
 8001b8e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8001b92:	4290      	cmp	r0, r2
 8001b94:	f43f af4c 	beq.w	8001a30 <HAL_GPIO_Init+0x64>
 8001b98:	220a      	movs	r2, #10
 8001b9a:	e74c      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001b9c:	2201      	movs	r2, #1
 8001b9e:	e74a      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001ba0:	2202      	movs	r2, #2
 8001ba2:	e748      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001ba4:	2203      	movs	r2, #3
 8001ba6:	e746      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001ba8:	2204      	movs	r2, #4
 8001baa:	e744      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001bac:	2205      	movs	r2, #5
 8001bae:	e742      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001bb0:	2206      	movs	r2, #6
 8001bb2:	e740      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001bb4:	2207      	movs	r2, #7
 8001bb6:	e73e      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
 8001bb8:	2208      	movs	r2, #8
 8001bba:	e73c      	b.n	8001a36 <HAL_GPIO_Init+0x6a>
      }
    }
  }
}
 8001bbc:	b002      	add	sp, #8
 8001bbe:	bd70      	pop	{r4, r5, r6, pc}
 8001bc0:	4770      	bx	lr
 8001bc2:	bf00      	nop
 8001bc4:	40013800 	.word	0x40013800
 8001bc8:	40013c00 	.word	0x40013c00
 8001bcc:	40023800 	.word	0x40023800
 8001bd0:	40020000 	.word	0x40020000

08001bd4 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001bd4:	b10a      	cbz	r2, 8001bda <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8001bd6:	6181      	str	r1, [r0, #24]
 8001bd8:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8001bda:	0409      	lsls	r1, r1, #16
 8001bdc:	6181      	str	r1, [r0, #24]
  }
}
 8001bde:	4770      	bx	lr

08001be0 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 8001be0:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8001be2:	ea01 0203 	and.w	r2, r1, r3
 8001be6:	ea21 0103 	bic.w	r1, r1, r3
 8001bea:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8001bee:	6181      	str	r1, [r0, #24]
}
 8001bf0:	4770      	bx	lr
	...

08001bf4 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;
  uint32_t pll_config;
  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8001bf4:	2800      	cmp	r0, #0
 8001bf6:	f000 81e0 	beq.w	8001fba <HAL_RCC_OscConfig+0x3c6>
{
 8001bfa:	b570      	push	{r4, r5, r6, lr}
 8001bfc:	b082      	sub	sp, #8
 8001bfe:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001c00:	6803      	ldr	r3, [r0, #0]
 8001c02:	f013 0f01 	tst.w	r3, #1
 8001c06:	d03b      	beq.n	8001c80 <HAL_RCC_OscConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 8001c08:	4b9f      	ldr	r3, [pc, #636]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c0a:	689b      	ldr	r3, [r3, #8]
 8001c0c:	f003 030c 	and.w	r3, r3, #12
 8001c10:	2b04      	cmp	r3, #4
 8001c12:	d02c      	beq.n	8001c6e <HAL_RCC_OscConfig+0x7a>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001c14:	4b9c      	ldr	r3, [pc, #624]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c16:	689b      	ldr	r3, [r3, #8]
 8001c18:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 8001c1c:	2b08      	cmp	r3, #8
 8001c1e:	d021      	beq.n	8001c64 <HAL_RCC_OscConfig+0x70>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001c20:	6863      	ldr	r3, [r4, #4]
 8001c22:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001c26:	d04f      	beq.n	8001cc8 <HAL_RCC_OscConfig+0xd4>
 8001c28:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8001c2c:	d052      	beq.n	8001cd4 <HAL_RCC_OscConfig+0xe0>
 8001c2e:	4b96      	ldr	r3, [pc, #600]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c30:	681a      	ldr	r2, [r3, #0]
 8001c32:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8001c36:	601a      	str	r2, [r3, #0]
 8001c38:	681a      	ldr	r2, [r3, #0]
 8001c3a:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8001c3e:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if ((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001c40:	6863      	ldr	r3, [r4, #4]
 8001c42:	2b00      	cmp	r3, #0
 8001c44:	d050      	beq.n	8001ce8 <HAL_RCC_OscConfig+0xf4>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001c46:	f7ff fe4d 	bl	80018e4 <HAL_GetTick>
 8001c4a:	4605      	mov	r5, r0

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001c4c:	4b8e      	ldr	r3, [pc, #568]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c4e:	681b      	ldr	r3, [r3, #0]
 8001c50:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8001c54:	d114      	bne.n	8001c80 <HAL_RCC_OscConfig+0x8c>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001c56:	f7ff fe45 	bl	80018e4 <HAL_GetTick>
 8001c5a:	1b40      	subs	r0, r0, r5
 8001c5c:	2864      	cmp	r0, #100	@ 0x64
 8001c5e:	d9f5      	bls.n	8001c4c <HAL_RCC_OscConfig+0x58>
          {
            return HAL_TIMEOUT;
 8001c60:	2003      	movs	r0, #3
 8001c62:	e1b1      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001c64:	4b88      	ldr	r3, [pc, #544]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c66:	685b      	ldr	r3, [r3, #4]
 8001c68:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 8001c6c:	d0d8      	beq.n	8001c20 <HAL_RCC_OscConfig+0x2c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001c6e:	4b86      	ldr	r3, [pc, #536]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c70:	681b      	ldr	r3, [r3, #0]
 8001c72:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8001c76:	d003      	beq.n	8001c80 <HAL_RCC_OscConfig+0x8c>
 8001c78:	6863      	ldr	r3, [r4, #4]
 8001c7a:	2b00      	cmp	r3, #0
 8001c7c:	f000 819f 	beq.w	8001fbe <HAL_RCC_OscConfig+0x3ca>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001c80:	6823      	ldr	r3, [r4, #0]
 8001c82:	f013 0f02 	tst.w	r3, #2
 8001c86:	d054      	beq.n	8001d32 <HAL_RCC_OscConfig+0x13e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 8001c88:	4b7f      	ldr	r3, [pc, #508]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c8a:	689b      	ldr	r3, [r3, #8]
 8001c8c:	f013 0f0c 	tst.w	r3, #12
 8001c90:	d03e      	beq.n	8001d10 <HAL_RCC_OscConfig+0x11c>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001c92:	4b7d      	ldr	r3, [pc, #500]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001c94:	689b      	ldr	r3, [r3, #8]
 8001c96:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 8001c9a:	2b08      	cmp	r3, #8
 8001c9c:	d033      	beq.n	8001d06 <HAL_RCC_OscConfig+0x112>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8001c9e:	68e3      	ldr	r3, [r4, #12]
 8001ca0:	2b00      	cmp	r3, #0
 8001ca2:	d068      	beq.n	8001d76 <HAL_RCC_OscConfig+0x182>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001ca4:	4b79      	ldr	r3, [pc, #484]	@ (8001e8c <HAL_RCC_OscConfig+0x298>)
 8001ca6:	2201      	movs	r2, #1
 8001ca8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001caa:	f7ff fe1b 	bl	80018e4 <HAL_GetTick>
 8001cae:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001cb0:	4b75      	ldr	r3, [pc, #468]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001cb2:	681b      	ldr	r3, [r3, #0]
 8001cb4:	f013 0f02 	tst.w	r3, #2
 8001cb8:	d154      	bne.n	8001d64 <HAL_RCC_OscConfig+0x170>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001cba:	f7ff fe13 	bl	80018e4 <HAL_GetTick>
 8001cbe:	1b40      	subs	r0, r0, r5
 8001cc0:	2802      	cmp	r0, #2
 8001cc2:	d9f5      	bls.n	8001cb0 <HAL_RCC_OscConfig+0xbc>
          {
            return HAL_TIMEOUT;
 8001cc4:	2003      	movs	r0, #3
 8001cc6:	e17f      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001cc8:	4a6f      	ldr	r2, [pc, #444]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001cca:	6813      	ldr	r3, [r2, #0]
 8001ccc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001cd0:	6013      	str	r3, [r2, #0]
 8001cd2:	e7b5      	b.n	8001c40 <HAL_RCC_OscConfig+0x4c>
 8001cd4:	4b6c      	ldr	r3, [pc, #432]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001cd6:	681a      	ldr	r2, [r3, #0]
 8001cd8:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8001cdc:	601a      	str	r2, [r3, #0]
 8001cde:	681a      	ldr	r2, [r3, #0]
 8001ce0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8001ce4:	601a      	str	r2, [r3, #0]
 8001ce6:	e7ab      	b.n	8001c40 <HAL_RCC_OscConfig+0x4c>
        tickstart = HAL_GetTick();
 8001ce8:	f7ff fdfc 	bl	80018e4 <HAL_GetTick>
 8001cec:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001cee:	4b66      	ldr	r3, [pc, #408]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001cf0:	681b      	ldr	r3, [r3, #0]
 8001cf2:	f413 3f00 	tst.w	r3, #131072	@ 0x20000
 8001cf6:	d0c3      	beq.n	8001c80 <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001cf8:	f7ff fdf4 	bl	80018e4 <HAL_GetTick>
 8001cfc:	1b40      	subs	r0, r0, r5
 8001cfe:	2864      	cmp	r0, #100	@ 0x64
 8001d00:	d9f5      	bls.n	8001cee <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
 8001d02:	2003      	movs	r0, #3
 8001d04:	e160      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001d06:	4b60      	ldr	r3, [pc, #384]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001d08:	685b      	ldr	r3, [r3, #4]
 8001d0a:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 8001d0e:	d1c6      	bne.n	8001c9e <HAL_RCC_OscConfig+0xaa>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001d10:	4b5d      	ldr	r3, [pc, #372]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001d12:	681b      	ldr	r3, [r3, #0]
 8001d14:	f013 0f02 	tst.w	r3, #2
 8001d18:	d003      	beq.n	8001d22 <HAL_RCC_OscConfig+0x12e>
 8001d1a:	68e3      	ldr	r3, [r4, #12]
 8001d1c:	2b01      	cmp	r3, #1
 8001d1e:	f040 8150 	bne.w	8001fc2 <HAL_RCC_OscConfig+0x3ce>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001d22:	4a59      	ldr	r2, [pc, #356]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001d24:	6813      	ldr	r3, [r2, #0]
 8001d26:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8001d2a:	6921      	ldr	r1, [r4, #16]
 8001d2c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001d30:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001d32:	6823      	ldr	r3, [r4, #0]
 8001d34:	f013 0f08 	tst.w	r3, #8
 8001d38:	d042      	beq.n	8001dc0 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8001d3a:	6963      	ldr	r3, [r4, #20]
 8001d3c:	b36b      	cbz	r3, 8001d9a <HAL_RCC_OscConfig+0x1a6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001d3e:	4b53      	ldr	r3, [pc, #332]	@ (8001e8c <HAL_RCC_OscConfig+0x298>)
 8001d40:	2201      	movs	r2, #1
 8001d42:	f8c3 2e80 	str.w	r2, [r3, #3712]	@ 0xe80

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d46:	f7ff fdcd 	bl	80018e4 <HAL_GetTick>
 8001d4a:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001d4c:	4b4e      	ldr	r3, [pc, #312]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001d4e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8001d50:	f013 0f02 	tst.w	r3, #2
 8001d54:	d134      	bne.n	8001dc0 <HAL_RCC_OscConfig+0x1cc>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001d56:	f7ff fdc5 	bl	80018e4 <HAL_GetTick>
 8001d5a:	1b40      	subs	r0, r0, r5
 8001d5c:	2802      	cmp	r0, #2
 8001d5e:	d9f5      	bls.n	8001d4c <HAL_RCC_OscConfig+0x158>
        {
          return HAL_TIMEOUT;
 8001d60:	2003      	movs	r0, #3
 8001d62:	e131      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001d64:	4a48      	ldr	r2, [pc, #288]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001d66:	6813      	ldr	r3, [r2, #0]
 8001d68:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8001d6c:	6921      	ldr	r1, [r4, #16]
 8001d6e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001d72:	6013      	str	r3, [r2, #0]
 8001d74:	e7dd      	b.n	8001d32 <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_HSI_DISABLE();
 8001d76:	4b45      	ldr	r3, [pc, #276]	@ (8001e8c <HAL_RCC_OscConfig+0x298>)
 8001d78:	2200      	movs	r2, #0
 8001d7a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001d7c:	f7ff fdb2 	bl	80018e4 <HAL_GetTick>
 8001d80:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001d82:	4b41      	ldr	r3, [pc, #260]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001d84:	681b      	ldr	r3, [r3, #0]
 8001d86:	f013 0f02 	tst.w	r3, #2
 8001d8a:	d0d2      	beq.n	8001d32 <HAL_RCC_OscConfig+0x13e>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001d8c:	f7ff fdaa 	bl	80018e4 <HAL_GetTick>
 8001d90:	1b40      	subs	r0, r0, r5
 8001d92:	2802      	cmp	r0, #2
 8001d94:	d9f5      	bls.n	8001d82 <HAL_RCC_OscConfig+0x18e>
            return HAL_TIMEOUT;
 8001d96:	2003      	movs	r0, #3
 8001d98:	e116      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001d9a:	4b3c      	ldr	r3, [pc, #240]	@ (8001e8c <HAL_RCC_OscConfig+0x298>)
 8001d9c:	2200      	movs	r2, #0
 8001d9e:	f8c3 2e80 	str.w	r2, [r3, #3712]	@ 0xe80

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001da2:	f7ff fd9f 	bl	80018e4 <HAL_GetTick>
 8001da6:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001da8:	4b37      	ldr	r3, [pc, #220]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001daa:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8001dac:	f013 0f02 	tst.w	r3, #2
 8001db0:	d006      	beq.n	8001dc0 <HAL_RCC_OscConfig+0x1cc>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001db2:	f7ff fd97 	bl	80018e4 <HAL_GetTick>
 8001db6:	1b40      	subs	r0, r0, r5
 8001db8:	2802      	cmp	r0, #2
 8001dba:	d9f5      	bls.n	8001da8 <HAL_RCC_OscConfig+0x1b4>
        {
          return HAL_TIMEOUT;
 8001dbc:	2003      	movs	r0, #3
 8001dbe:	e103      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001dc0:	6823      	ldr	r3, [r4, #0]
 8001dc2:	f013 0f04 	tst.w	r3, #4
 8001dc6:	d077      	beq.n	8001eb8 <HAL_RCC_OscConfig+0x2c4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001dc8:	4b2f      	ldr	r3, [pc, #188]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001dca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001dcc:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 8001dd0:	d133      	bne.n	8001e3a <HAL_RCC_OscConfig+0x246>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001dd2:	2300      	movs	r3, #0
 8001dd4:	9301      	str	r3, [sp, #4]
 8001dd6:	4b2c      	ldr	r3, [pc, #176]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001dd8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8001dda:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8001dde:	641a      	str	r2, [r3, #64]	@ 0x40
 8001de0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001de2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001de6:	9301      	str	r3, [sp, #4]
 8001de8:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001dea:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001dec:	4b28      	ldr	r3, [pc, #160]	@ (8001e90 <HAL_RCC_OscConfig+0x29c>)
 8001dee:	681b      	ldr	r3, [r3, #0]
 8001df0:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8001df4:	d023      	beq.n	8001e3e <HAL_RCC_OscConfig+0x24a>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001df6:	68a3      	ldr	r3, [r4, #8]
 8001df8:	2b01      	cmp	r3, #1
 8001dfa:	d034      	beq.n	8001e66 <HAL_RCC_OscConfig+0x272>
 8001dfc:	2b05      	cmp	r3, #5
 8001dfe:	d038      	beq.n	8001e72 <HAL_RCC_OscConfig+0x27e>
 8001e00:	4b21      	ldr	r3, [pc, #132]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001e02:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8001e04:	f022 0201 	bic.w	r2, r2, #1
 8001e08:	671a      	str	r2, [r3, #112]	@ 0x70
 8001e0a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8001e0c:	f022 0204 	bic.w	r2, r2, #4
 8001e10:	671a      	str	r2, [r3, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001e12:	68a3      	ldr	r3, [r4, #8]
 8001e14:	2b00      	cmp	r3, #0
 8001e16:	d03d      	beq.n	8001e94 <HAL_RCC_OscConfig+0x2a0>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001e18:	f7ff fd64 	bl	80018e4 <HAL_GetTick>
 8001e1c:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001e1e:	4b1a      	ldr	r3, [pc, #104]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001e20:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001e22:	f013 0f02 	tst.w	r3, #2
 8001e26:	d146      	bne.n	8001eb6 <HAL_RCC_OscConfig+0x2c2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001e28:	f7ff fd5c 	bl	80018e4 <HAL_GetTick>
 8001e2c:	1b80      	subs	r0, r0, r6
 8001e2e:	f241 3388 	movw	r3, #5000	@ 0x1388
 8001e32:	4298      	cmp	r0, r3
 8001e34:	d9f3      	bls.n	8001e1e <HAL_RCC_OscConfig+0x22a>
        {
          return HAL_TIMEOUT;
 8001e36:	2003      	movs	r0, #3
 8001e38:	e0c6      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
    FlagStatus       pwrclkchanged = RESET;
 8001e3a:	2500      	movs	r5, #0
 8001e3c:	e7d6      	b.n	8001dec <HAL_RCC_OscConfig+0x1f8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001e3e:	4a14      	ldr	r2, [pc, #80]	@ (8001e90 <HAL_RCC_OscConfig+0x29c>)
 8001e40:	6813      	ldr	r3, [r2, #0]
 8001e42:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001e46:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8001e48:	f7ff fd4c 	bl	80018e4 <HAL_GetTick>
 8001e4c:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001e4e:	4b10      	ldr	r3, [pc, #64]	@ (8001e90 <HAL_RCC_OscConfig+0x29c>)
 8001e50:	681b      	ldr	r3, [r3, #0]
 8001e52:	f413 7f80 	tst.w	r3, #256	@ 0x100
 8001e56:	d1ce      	bne.n	8001df6 <HAL_RCC_OscConfig+0x202>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001e58:	f7ff fd44 	bl	80018e4 <HAL_GetTick>
 8001e5c:	1b80      	subs	r0, r0, r6
 8001e5e:	2802      	cmp	r0, #2
 8001e60:	d9f5      	bls.n	8001e4e <HAL_RCC_OscConfig+0x25a>
          return HAL_TIMEOUT;
 8001e62:	2003      	movs	r0, #3
 8001e64:	e0b0      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001e66:	4a08      	ldr	r2, [pc, #32]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001e68:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8001e6a:	f043 0301 	orr.w	r3, r3, #1
 8001e6e:	6713      	str	r3, [r2, #112]	@ 0x70
 8001e70:	e7cf      	b.n	8001e12 <HAL_RCC_OscConfig+0x21e>
 8001e72:	4b05      	ldr	r3, [pc, #20]	@ (8001e88 <HAL_RCC_OscConfig+0x294>)
 8001e74:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8001e76:	f042 0204 	orr.w	r2, r2, #4
 8001e7a:	671a      	str	r2, [r3, #112]	@ 0x70
 8001e7c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8001e7e:	f042 0201 	orr.w	r2, r2, #1
 8001e82:	671a      	str	r2, [r3, #112]	@ 0x70
 8001e84:	e7c5      	b.n	8001e12 <HAL_RCC_OscConfig+0x21e>
 8001e86:	bf00      	nop
 8001e88:	40023800 	.word	0x40023800
 8001e8c:	42470000 	.word	0x42470000
 8001e90:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001e94:	f7ff fd26 	bl	80018e4 <HAL_GetTick>
 8001e98:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001e9a:	4b52      	ldr	r3, [pc, #328]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001e9c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001e9e:	f013 0f02 	tst.w	r3, #2
 8001ea2:	d008      	beq.n	8001eb6 <HAL_RCC_OscConfig+0x2c2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001ea4:	f7ff fd1e 	bl	80018e4 <HAL_GetTick>
 8001ea8:	1b80      	subs	r0, r0, r6
 8001eaa:	f241 3388 	movw	r3, #5000	@ 0x1388
 8001eae:	4298      	cmp	r0, r3
 8001eb0:	d9f3      	bls.n	8001e9a <HAL_RCC_OscConfig+0x2a6>
        {
          return HAL_TIMEOUT;
 8001eb2:	2003      	movs	r0, #3
 8001eb4:	e088      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8001eb6:	b9ed      	cbnz	r5, 8001ef4 <HAL_RCC_OscConfig+0x300>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001eb8:	69a3      	ldr	r3, [r4, #24]
 8001eba:	2b00      	cmp	r3, #0
 8001ebc:	f000 8083 	beq.w	8001fc6 <HAL_RCC_OscConfig+0x3d2>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001ec0:	4a48      	ldr	r2, [pc, #288]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001ec2:	6892      	ldr	r2, [r2, #8]
 8001ec4:	f002 020c 	and.w	r2, r2, #12
 8001ec8:	2a08      	cmp	r2, #8
 8001eca:	d051      	beq.n	8001f70 <HAL_RCC_OscConfig+0x37c>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001ecc:	2b02      	cmp	r3, #2
 8001ece:	d017      	beq.n	8001f00 <HAL_RCC_OscConfig+0x30c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001ed0:	4b45      	ldr	r3, [pc, #276]	@ (8001fe8 <HAL_RCC_OscConfig+0x3f4>)
 8001ed2:	2200      	movs	r2, #0
 8001ed4:	661a      	str	r2, [r3, #96]	@ 0x60

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001ed6:	f7ff fd05 	bl	80018e4 <HAL_GetTick>
 8001eda:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001edc:	4b41      	ldr	r3, [pc, #260]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001ede:	681b      	ldr	r3, [r3, #0]
 8001ee0:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8001ee4:	d042      	beq.n	8001f6c <HAL_RCC_OscConfig+0x378>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001ee6:	f7ff fcfd 	bl	80018e4 <HAL_GetTick>
 8001eea:	1b00      	subs	r0, r0, r4
 8001eec:	2802      	cmp	r0, #2
 8001eee:	d9f5      	bls.n	8001edc <HAL_RCC_OscConfig+0x2e8>
          {
            return HAL_TIMEOUT;
 8001ef0:	2003      	movs	r0, #3
 8001ef2:	e069      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001ef4:	4a3b      	ldr	r2, [pc, #236]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001ef6:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8001ef8:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8001efc:	6413      	str	r3, [r2, #64]	@ 0x40
 8001efe:	e7db      	b.n	8001eb8 <HAL_RCC_OscConfig+0x2c4>
        __HAL_RCC_PLL_DISABLE();
 8001f00:	4b39      	ldr	r3, [pc, #228]	@ (8001fe8 <HAL_RCC_OscConfig+0x3f4>)
 8001f02:	2200      	movs	r2, #0
 8001f04:	661a      	str	r2, [r3, #96]	@ 0x60
        tickstart = HAL_GetTick();
 8001f06:	f7ff fced 	bl	80018e4 <HAL_GetTick>
 8001f0a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001f0c:	4b35      	ldr	r3, [pc, #212]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001f0e:	681b      	ldr	r3, [r3, #0]
 8001f10:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8001f14:	d006      	beq.n	8001f24 <HAL_RCC_OscConfig+0x330>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001f16:	f7ff fce5 	bl	80018e4 <HAL_GetTick>
 8001f1a:	1b40      	subs	r0, r0, r5
 8001f1c:	2802      	cmp	r0, #2
 8001f1e:	d9f5      	bls.n	8001f0c <HAL_RCC_OscConfig+0x318>
            return HAL_TIMEOUT;
 8001f20:	2003      	movs	r0, #3
 8001f22:	e051      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001f24:	69e3      	ldr	r3, [r4, #28]
 8001f26:	6a22      	ldr	r2, [r4, #32]
 8001f28:	4313      	orrs	r3, r2
 8001f2a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8001f2c:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001f30:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8001f32:	0852      	lsrs	r2, r2, #1
 8001f34:	3a01      	subs	r2, #1
 8001f36:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001f3a:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8001f3c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001f40:	4a28      	ldr	r2, [pc, #160]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001f42:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 8001f44:	4b28      	ldr	r3, [pc, #160]	@ (8001fe8 <HAL_RCC_OscConfig+0x3f4>)
 8001f46:	2201      	movs	r2, #1
 8001f48:	661a      	str	r2, [r3, #96]	@ 0x60
        tickstart = HAL_GetTick();
 8001f4a:	f7ff fccb 	bl	80018e4 <HAL_GetTick>
 8001f4e:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001f50:	4b24      	ldr	r3, [pc, #144]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001f52:	681b      	ldr	r3, [r3, #0]
 8001f54:	f013 7f00 	tst.w	r3, #33554432	@ 0x2000000
 8001f58:	d106      	bne.n	8001f68 <HAL_RCC_OscConfig+0x374>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001f5a:	f7ff fcc3 	bl	80018e4 <HAL_GetTick>
 8001f5e:	1b00      	subs	r0, r0, r4
 8001f60:	2802      	cmp	r0, #2
 8001f62:	d9f5      	bls.n	8001f50 <HAL_RCC_OscConfig+0x35c>
            return HAL_TIMEOUT;
 8001f64:	2003      	movs	r0, #3
 8001f66:	e02f      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 8001f68:	2000      	movs	r0, #0
 8001f6a:	e02d      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
 8001f6c:	2000      	movs	r0, #0
 8001f6e:	e02b      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8001f70:	2b01      	cmp	r3, #1
 8001f72:	d02b      	beq.n	8001fcc <HAL_RCC_OscConfig+0x3d8>
        pll_config = RCC->PLLCFGR;
 8001f74:	4b1b      	ldr	r3, [pc, #108]	@ (8001fe4 <HAL_RCC_OscConfig+0x3f0>)
 8001f76:	685b      	ldr	r3, [r3, #4]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001f78:	f403 0180 	and.w	r1, r3, #4194304	@ 0x400000
 8001f7c:	69e2      	ldr	r2, [r4, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8001f7e:	4291      	cmp	r1, r2
 8001f80:	d126      	bne.n	8001fd0 <HAL_RCC_OscConfig+0x3dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8001f82:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 8001f86:	6a21      	ldr	r1, [r4, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001f88:	428a      	cmp	r2, r1
 8001f8a:	d123      	bne.n	8001fd4 <HAL_RCC_OscConfig+0x3e0>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8001f8c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8001f8e:	f647 72c0 	movw	r2, #32704	@ 0x7fc0
 8001f92:	401a      	ands	r2, r3
 8001f94:	ebb2 1f81 	cmp.w	r2, r1, lsl #6
 8001f98:	d11e      	bne.n	8001fd8 <HAL_RCC_OscConfig+0x3e4>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8001f9a:	f403 3140 	and.w	r1, r3, #196608	@ 0x30000
 8001f9e:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8001fa0:	0852      	lsrs	r2, r2, #1
 8001fa2:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8001fa4:	ebb1 4f02 	cmp.w	r1, r2, lsl #16
 8001fa8:	d118      	bne.n	8001fdc <HAL_RCC_OscConfig+0x3e8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8001faa:	f003 6370 	and.w	r3, r3, #251658240	@ 0xf000000
 8001fae:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8001fb0:	ebb3 6f02 	cmp.w	r3, r2, lsl #24
 8001fb4:	d114      	bne.n	8001fe0 <HAL_RCC_OscConfig+0x3ec>
  return HAL_OK;
 8001fb6:	2000      	movs	r0, #0
 8001fb8:	e006      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
    return HAL_ERROR;
 8001fba:	2001      	movs	r0, #1
}
 8001fbc:	4770      	bx	lr
        return HAL_ERROR;
 8001fbe:	2001      	movs	r0, #1
 8001fc0:	e002      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
        return HAL_ERROR;
 8001fc2:	2001      	movs	r0, #1
 8001fc4:	e000      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
  return HAL_OK;
 8001fc6:	2000      	movs	r0, #0
}
 8001fc8:	b002      	add	sp, #8
 8001fca:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8001fcc:	2001      	movs	r0, #1
 8001fce:	e7fb      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
          return HAL_ERROR;
 8001fd0:	2001      	movs	r0, #1
 8001fd2:	e7f9      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
 8001fd4:	2001      	movs	r0, #1
 8001fd6:	e7f7      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
 8001fd8:	2001      	movs	r0, #1
 8001fda:	e7f5      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
 8001fdc:	2001      	movs	r0, #1
 8001fde:	e7f3      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
 8001fe0:	2001      	movs	r0, #1
 8001fe2:	e7f1      	b.n	8001fc8 <HAL_RCC_OscConfig+0x3d4>
 8001fe4:	40023800 	.word	0x40023800
 8001fe8:	42470000 	.word	0x42470000

08001fec <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001fec:	b508      	push	{r3, lr}
  uint32_t pllvco = 0U;
  uint32_t pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001fee:	4b33      	ldr	r3, [pc, #204]	@ (80020bc <HAL_RCC_GetSysClockFreq+0xd0>)
 8001ff0:	689b      	ldr	r3, [r3, #8]
 8001ff2:	f003 030c 	and.w	r3, r3, #12
 8001ff6:	2b04      	cmp	r3, #4
 8001ff8:	d05b      	beq.n	80020b2 <HAL_RCC_GetSysClockFreq+0xc6>
 8001ffa:	2b08      	cmp	r3, #8
 8001ffc:	d15b      	bne.n	80020b6 <HAL_RCC_GetSysClockFreq+0xca>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001ffe:	4b2f      	ldr	r3, [pc, #188]	@ (80020bc <HAL_RCC_GetSysClockFreq+0xd0>)
 8002000:	685a      	ldr	r2, [r3, #4]
 8002002:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002006:	685b      	ldr	r3, [r3, #4]
 8002008:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
 800200c:	d02c      	beq.n	8002068 <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800200e:	4b2b      	ldr	r3, [pc, #172]	@ (80020bc <HAL_RCC_GetSysClockFreq+0xd0>)
 8002010:	6858      	ldr	r0, [r3, #4]
 8002012:	f3c0 1088 	ubfx	r0, r0, #6, #9
 8002016:	ea4f 1c40 	mov.w	ip, r0, lsl #5
 800201a:	ebbc 0c00 	subs.w	ip, ip, r0
 800201e:	eb6e 0e0e 	sbc.w	lr, lr, lr
 8002022:	ea4f 138e 	mov.w	r3, lr, lsl #6
 8002026:	ea43 639c 	orr.w	r3, r3, ip, lsr #26
 800202a:	ea4f 118c 	mov.w	r1, ip, lsl #6
 800202e:	ebb1 010c 	subs.w	r1, r1, ip
 8002032:	eb63 030e 	sbc.w	r3, r3, lr
 8002036:	00db      	lsls	r3, r3, #3
 8002038:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800203c:	00c9      	lsls	r1, r1, #3
 800203e:	eb11 0c00 	adds.w	ip, r1, r0
 8002042:	f143 0300 	adc.w	r3, r3, #0
 8002046:	0259      	lsls	r1, r3, #9
 8002048:	2300      	movs	r3, #0
 800204a:	ea4f 204c 	mov.w	r0, ip, lsl #9
 800204e:	ea41 51dc 	orr.w	r1, r1, ip, lsr #23
 8002052:	f7fe fb61 	bl	8000718 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 8002056:	4b19      	ldr	r3, [pc, #100]	@ (80020bc <HAL_RCC_GetSysClockFreq+0xd0>)
 8002058:	685b      	ldr	r3, [r3, #4]
 800205a:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800205e:	3301      	adds	r3, #1
 8002060:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 8002062:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002066:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002068:	4b14      	ldr	r3, [pc, #80]	@ (80020bc <HAL_RCC_GetSysClockFreq+0xd0>)
 800206a:	6858      	ldr	r0, [r3, #4]
 800206c:	f3c0 1088 	ubfx	r0, r0, #6, #9
 8002070:	ea4f 1c40 	mov.w	ip, r0, lsl #5
 8002074:	ebbc 0c00 	subs.w	ip, ip, r0
 8002078:	eb6e 0e0e 	sbc.w	lr, lr, lr
 800207c:	ea4f 138e 	mov.w	r3, lr, lsl #6
 8002080:	ea43 639c 	orr.w	r3, r3, ip, lsr #26
 8002084:	ea4f 118c 	mov.w	r1, ip, lsl #6
 8002088:	ebb1 010c 	subs.w	r1, r1, ip
 800208c:	eb63 030e 	sbc.w	r3, r3, lr
 8002090:	00db      	lsls	r3, r3, #3
 8002092:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8002096:	00c9      	lsls	r1, r1, #3
 8002098:	eb11 0c00 	adds.w	ip, r1, r0
 800209c:	f143 0300 	adc.w	r3, r3, #0
 80020a0:	0299      	lsls	r1, r3, #10
 80020a2:	2300      	movs	r3, #0
 80020a4:	ea4f 208c 	mov.w	r0, ip, lsl #10
 80020a8:	ea41 519c 	orr.w	r1, r1, ip, lsr #22
 80020ac:	f7fe fb34 	bl	8000718 <__aeabi_uldivmod>
 80020b0:	e7d1      	b.n	8002056 <HAL_RCC_GetSysClockFreq+0x6a>
      sysclockfreq = HSE_VALUE;
 80020b2:	4803      	ldr	r0, [pc, #12]	@ (80020c0 <HAL_RCC_GetSysClockFreq+0xd4>)
 80020b4:	e7d7      	b.n	8002066 <HAL_RCC_GetSysClockFreq+0x7a>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80020b6:	4803      	ldr	r0, [pc, #12]	@ (80020c4 <HAL_RCC_GetSysClockFreq+0xd8>)
  return sysclockfreq;
 80020b8:	e7d5      	b.n	8002066 <HAL_RCC_GetSysClockFreq+0x7a>
 80020ba:	bf00      	nop
 80020bc:	40023800 	.word	0x40023800
 80020c0:	007a1200 	.word	0x007a1200
 80020c4:	00f42400 	.word	0x00f42400

080020c8 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 80020c8:	2800      	cmp	r0, #0
 80020ca:	f000 809b 	beq.w	8002204 <HAL_RCC_ClockConfig+0x13c>
{
 80020ce:	b570      	push	{r4, r5, r6, lr}
 80020d0:	460d      	mov	r5, r1
 80020d2:	4604      	mov	r4, r0
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 80020d4:	4b4f      	ldr	r3, [pc, #316]	@ (8002214 <HAL_RCC_ClockConfig+0x14c>)
 80020d6:	681b      	ldr	r3, [r3, #0]
 80020d8:	f003 030f 	and.w	r3, r3, #15
 80020dc:	428b      	cmp	r3, r1
 80020de:	d208      	bcs.n	80020f2 <HAL_RCC_ClockConfig+0x2a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80020e0:	b2cb      	uxtb	r3, r1
 80020e2:	4a4c      	ldr	r2, [pc, #304]	@ (8002214 <HAL_RCC_ClockConfig+0x14c>)
 80020e4:	7013      	strb	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80020e6:	6813      	ldr	r3, [r2, #0]
 80020e8:	f003 030f 	and.w	r3, r3, #15
 80020ec:	428b      	cmp	r3, r1
 80020ee:	f040 808b 	bne.w	8002208 <HAL_RCC_ClockConfig+0x140>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80020f2:	6823      	ldr	r3, [r4, #0]
 80020f4:	f013 0f02 	tst.w	r3, #2
 80020f8:	d017      	beq.n	800212a <HAL_RCC_ClockConfig+0x62>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80020fa:	f013 0f04 	tst.w	r3, #4
 80020fe:	d004      	beq.n	800210a <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002100:	4a45      	ldr	r2, [pc, #276]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 8002102:	6893      	ldr	r3, [r2, #8]
 8002104:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 8002108:	6093      	str	r3, [r2, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800210a:	6823      	ldr	r3, [r4, #0]
 800210c:	f013 0f08 	tst.w	r3, #8
 8002110:	d004      	beq.n	800211c <HAL_RCC_ClockConfig+0x54>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8002112:	4a41      	ldr	r2, [pc, #260]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 8002114:	6893      	ldr	r3, [r2, #8]
 8002116:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 800211a:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800211c:	4a3e      	ldr	r2, [pc, #248]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 800211e:	6893      	ldr	r3, [r2, #8]
 8002120:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8002124:	68a1      	ldr	r1, [r4, #8]
 8002126:	430b      	orrs	r3, r1
 8002128:	6093      	str	r3, [r2, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800212a:	6823      	ldr	r3, [r4, #0]
 800212c:	f013 0f01 	tst.w	r3, #1
 8002130:	d032      	beq.n	8002198 <HAL_RCC_ClockConfig+0xd0>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002132:	6863      	ldr	r3, [r4, #4]
 8002134:	2b01      	cmp	r3, #1
 8002136:	d021      	beq.n	800217c <HAL_RCC_ClockConfig+0xb4>
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8002138:	1e9a      	subs	r2, r3, #2
 800213a:	2a01      	cmp	r2, #1
 800213c:	d925      	bls.n	800218a <HAL_RCC_ClockConfig+0xc2>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800213e:	4a36      	ldr	r2, [pc, #216]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 8002140:	6812      	ldr	r2, [r2, #0]
 8002142:	f012 0f02 	tst.w	r2, #2
 8002146:	d061      	beq.n	800220c <HAL_RCC_ClockConfig+0x144>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002148:	4933      	ldr	r1, [pc, #204]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 800214a:	688a      	ldr	r2, [r1, #8]
 800214c:	f022 0203 	bic.w	r2, r2, #3
 8002150:	4313      	orrs	r3, r2
 8002152:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8002154:	f7ff fbc6 	bl	80018e4 <HAL_GetTick>
 8002158:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800215a:	4b2f      	ldr	r3, [pc, #188]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 800215c:	689b      	ldr	r3, [r3, #8]
 800215e:	f003 030c 	and.w	r3, r3, #12
 8002162:	6862      	ldr	r2, [r4, #4]
 8002164:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8002168:	d016      	beq.n	8002198 <HAL_RCC_ClockConfig+0xd0>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800216a:	f7ff fbbb 	bl	80018e4 <HAL_GetTick>
 800216e:	1b80      	subs	r0, r0, r6
 8002170:	f241 3388 	movw	r3, #5000	@ 0x1388
 8002174:	4298      	cmp	r0, r3
 8002176:	d9f0      	bls.n	800215a <HAL_RCC_ClockConfig+0x92>
        return HAL_TIMEOUT;
 8002178:	2003      	movs	r0, #3
 800217a:	e042      	b.n	8002202 <HAL_RCC_ClockConfig+0x13a>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800217c:	4a26      	ldr	r2, [pc, #152]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 800217e:	6812      	ldr	r2, [r2, #0]
 8002180:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
 8002184:	d1e0      	bne.n	8002148 <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 8002186:	2001      	movs	r0, #1
 8002188:	e03b      	b.n	8002202 <HAL_RCC_ClockConfig+0x13a>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800218a:	4a23      	ldr	r2, [pc, #140]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 800218c:	6812      	ldr	r2, [r2, #0]
 800218e:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
 8002192:	d1d9      	bne.n	8002148 <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 8002194:	2001      	movs	r0, #1
 8002196:	e034      	b.n	8002202 <HAL_RCC_ClockConfig+0x13a>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8002198:	4b1e      	ldr	r3, [pc, #120]	@ (8002214 <HAL_RCC_ClockConfig+0x14c>)
 800219a:	681b      	ldr	r3, [r3, #0]
 800219c:	f003 030f 	and.w	r3, r3, #15
 80021a0:	42ab      	cmp	r3, r5
 80021a2:	d907      	bls.n	80021b4 <HAL_RCC_ClockConfig+0xec>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80021a4:	b2ea      	uxtb	r2, r5
 80021a6:	4b1b      	ldr	r3, [pc, #108]	@ (8002214 <HAL_RCC_ClockConfig+0x14c>)
 80021a8:	701a      	strb	r2, [r3, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80021aa:	681b      	ldr	r3, [r3, #0]
 80021ac:	f003 030f 	and.w	r3, r3, #15
 80021b0:	42ab      	cmp	r3, r5
 80021b2:	d12d      	bne.n	8002210 <HAL_RCC_ClockConfig+0x148>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80021b4:	6823      	ldr	r3, [r4, #0]
 80021b6:	f013 0f04 	tst.w	r3, #4
 80021ba:	d006      	beq.n	80021ca <HAL_RCC_ClockConfig+0x102>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80021bc:	4a16      	ldr	r2, [pc, #88]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 80021be:	6893      	ldr	r3, [r2, #8]
 80021c0:	f423 53e0 	bic.w	r3, r3, #7168	@ 0x1c00
 80021c4:	68e1      	ldr	r1, [r4, #12]
 80021c6:	430b      	orrs	r3, r1
 80021c8:	6093      	str	r3, [r2, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80021ca:	6823      	ldr	r3, [r4, #0]
 80021cc:	f013 0f08 	tst.w	r3, #8
 80021d0:	d007      	beq.n	80021e2 <HAL_RCC_ClockConfig+0x11a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80021d2:	4a11      	ldr	r2, [pc, #68]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 80021d4:	6893      	ldr	r3, [r2, #8]
 80021d6:	f423 4360 	bic.w	r3, r3, #57344	@ 0xe000
 80021da:	6921      	ldr	r1, [r4, #16]
 80021dc:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80021e0:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 80021e2:	f7ff ff03 	bl	8001fec <HAL_RCC_GetSysClockFreq>
 80021e6:	4b0c      	ldr	r3, [pc, #48]	@ (8002218 <HAL_RCC_ClockConfig+0x150>)
 80021e8:	689b      	ldr	r3, [r3, #8]
 80021ea:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80021ee:	4a0b      	ldr	r2, [pc, #44]	@ (800221c <HAL_RCC_ClockConfig+0x154>)
 80021f0:	5cd3      	ldrb	r3, [r2, r3]
 80021f2:	40d8      	lsrs	r0, r3
 80021f4:	4b0a      	ldr	r3, [pc, #40]	@ (8002220 <HAL_RCC_ClockConfig+0x158>)
 80021f6:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
 80021f8:	4b0a      	ldr	r3, [pc, #40]	@ (8002224 <HAL_RCC_ClockConfig+0x15c>)
 80021fa:	6818      	ldr	r0, [r3, #0]
 80021fc:	f7ff fa6e 	bl	80016dc <HAL_InitTick>
  return HAL_OK;
 8002200:	2000      	movs	r0, #0
}
 8002202:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8002204:	2001      	movs	r0, #1
}
 8002206:	4770      	bx	lr
      return HAL_ERROR;
 8002208:	2001      	movs	r0, #1
 800220a:	e7fa      	b.n	8002202 <HAL_RCC_ClockConfig+0x13a>
        return HAL_ERROR;
 800220c:	2001      	movs	r0, #1
 800220e:	e7f8      	b.n	8002202 <HAL_RCC_ClockConfig+0x13a>
      return HAL_ERROR;
 8002210:	2001      	movs	r0, #1
 8002212:	e7f6      	b.n	8002202 <HAL_RCC_ClockConfig+0x13a>
 8002214:	40023c00 	.word	0x40023c00
 8002218:	40023800 	.word	0x40023800
 800221c:	08010280 	.word	0x08010280
 8002220:	20000000 	.word	0x20000000
 8002224:	20000008 	.word	0x20000008

08002228 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8002228:	4b01      	ldr	r3, [pc, #4]	@ (8002230 <HAL_RCC_GetHCLKFreq+0x8>)
 800222a:	6818      	ldr	r0, [r3, #0]
 800222c:	4770      	bx	lr
 800222e:	bf00      	nop
 8002230:	20000000 	.word	0x20000000

08002234 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8002234:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002236:	f7ff fff7 	bl	8002228 <HAL_RCC_GetHCLKFreq>
 800223a:	4b04      	ldr	r3, [pc, #16]	@ (800224c <HAL_RCC_GetPCLK2Freq+0x18>)
 800223c:	689b      	ldr	r3, [r3, #8]
 800223e:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8002242:	4a03      	ldr	r2, [pc, #12]	@ (8002250 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002244:	5cd3      	ldrb	r3, [r2, r3]
}
 8002246:	40d8      	lsrs	r0, r3
 8002248:	bd08      	pop	{r3, pc}
 800224a:	bf00      	nop
 800224c:	40023800 	.word	0x40023800
 8002250:	08010278 	.word	0x08010278

08002254 <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8002254:	230f      	movs	r3, #15
 8002256:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8002258:	4b0b      	ldr	r3, [pc, #44]	@ (8002288 <HAL_RCC_GetClockConfig+0x34>)
 800225a:	689a      	ldr	r2, [r3, #8]
 800225c:	f002 0203 	and.w	r2, r2, #3
 8002260:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8002262:	689a      	ldr	r2, [r3, #8]
 8002264:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
 8002268:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 800226a:	689a      	ldr	r2, [r3, #8]
 800226c:	f402 52e0 	and.w	r2, r2, #7168	@ 0x1c00
 8002270:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 8002272:	689b      	ldr	r3, [r3, #8]
 8002274:	08db      	lsrs	r3, r3, #3
 8002276:	f403 53e0 	and.w	r3, r3, #7168	@ 0x1c00
 800227a:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800227c:	4b03      	ldr	r3, [pc, #12]	@ (800228c <HAL_RCC_GetClockConfig+0x38>)
 800227e:	681b      	ldr	r3, [r3, #0]
 8002280:	f003 030f 	and.w	r3, r3, #15
 8002284:	600b      	str	r3, [r1, #0]
}
 8002286:	4770      	bx	lr
 8002288:	40023800 	.word	0x40023800
 800228c:	40023c00 	.word	0x40023c00

08002290 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8002290:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002294:	b082      	sub	sp, #8
 8002296:	4605      	mov	r5, r0
 8002298:	4688      	mov	r8, r1
 800229a:	4617      	mov	r7, r2
 800229c:	461e      	mov	r6, r3
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 800229e:	f7ff fb21 	bl	80018e4 <HAL_GetTick>
 80022a2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80022a4:	1a1b      	subs	r3, r3, r0
 80022a6:	eb03 0906 	add.w	r9, r3, r6
  tmp_tickstart = HAL_GetTick();
 80022aa:	f7ff fb1b 	bl	80018e4 <HAL_GetTick>
 80022ae:	4682      	mov	sl, r0

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 80022b0:	4b28      	ldr	r3, [pc, #160]	@ (8002354 <SPI_WaitFlagStateUntilTimeout+0xc4>)
 80022b2:	681b      	ldr	r3, [r3, #0]
 80022b4:	f3c3 33cb 	ubfx	r3, r3, #15, #12
 80022b8:	fb09 f303 	mul.w	r3, r9, r3
 80022bc:	9301      	str	r3, [sp, #4]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80022be:	682b      	ldr	r3, [r5, #0]
 80022c0:	689c      	ldr	r4, [r3, #8]
 80022c2:	ea38 0404 	bics.w	r4, r8, r4
 80022c6:	bf0c      	ite	eq
 80022c8:	2301      	moveq	r3, #1
 80022ca:	2300      	movne	r3, #0
 80022cc:	42bb      	cmp	r3, r7
 80022ce:	d03d      	beq.n	800234c <SPI_WaitFlagStateUntilTimeout+0xbc>
  {
    if (Timeout != HAL_MAX_DELAY)
 80022d0:	f1b6 3fff 	cmp.w	r6, #4294967295
 80022d4:	d0f3      	beq.n	80022be <SPI_WaitFlagStateUntilTimeout+0x2e>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 80022d6:	f7ff fb05 	bl	80018e4 <HAL_GetTick>
 80022da:	eba0 000a 	sub.w	r0, r0, sl
 80022de:	4548      	cmp	r0, r9
 80022e0:	d207      	bcs.n	80022f2 <SPI_WaitFlagStateUntilTimeout+0x62>
        __HAL_UNLOCK(hspi);

        return HAL_TIMEOUT;
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 80022e2:	9a01      	ldr	r2, [sp, #4]
 80022e4:	b102      	cbz	r2, 80022e8 <SPI_WaitFlagStateUntilTimeout+0x58>
 80022e6:	464a      	mov	r2, r9
      {
        tmp_timeout = 0U;
      }
      count--;
 80022e8:	9b01      	ldr	r3, [sp, #4]
 80022ea:	3b01      	subs	r3, #1
 80022ec:	9301      	str	r3, [sp, #4]
 80022ee:	4691      	mov	r9, r2
 80022f0:	e7e5      	b.n	80022be <SPI_WaitFlagStateUntilTimeout+0x2e>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80022f2:	682a      	ldr	r2, [r5, #0]
 80022f4:	6853      	ldr	r3, [r2, #4]
 80022f6:	f023 03e0 	bic.w	r3, r3, #224	@ 0xe0
 80022fa:	6053      	str	r3, [r2, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80022fc:	686b      	ldr	r3, [r5, #4]
 80022fe:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8002302:	d00b      	beq.n	800231c <SPI_WaitFlagStateUntilTimeout+0x8c>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002304:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8002306:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800230a:	d014      	beq.n	8002336 <SPI_WaitFlagStateUntilTimeout+0xa6>
        hspi->State = HAL_SPI_STATE_READY;
 800230c:	2301      	movs	r3, #1
 800230e:	f885 3051 	strb.w	r3, [r5, #81]	@ 0x51
        __HAL_UNLOCK(hspi);
 8002312:	2300      	movs	r3, #0
 8002314:	f885 3050 	strb.w	r3, [r5, #80]	@ 0x50
        return HAL_TIMEOUT;
 8002318:	2003      	movs	r0, #3
 800231a:	e018      	b.n	800234e <SPI_WaitFlagStateUntilTimeout+0xbe>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800231c:	68ab      	ldr	r3, [r5, #8]
 800231e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8002322:	d002      	beq.n	800232a <SPI_WaitFlagStateUntilTimeout+0x9a>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002324:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8002328:	d1ec      	bne.n	8002304 <SPI_WaitFlagStateUntilTimeout+0x74>
          __HAL_SPI_DISABLE(hspi);
 800232a:	682a      	ldr	r2, [r5, #0]
 800232c:	6813      	ldr	r3, [r2, #0]
 800232e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8002332:	6013      	str	r3, [r2, #0]
 8002334:	e7e6      	b.n	8002304 <SPI_WaitFlagStateUntilTimeout+0x74>
          SPI_RESET_CRC(hspi);
 8002336:	682a      	ldr	r2, [r5, #0]
 8002338:	6813      	ldr	r3, [r2, #0]
 800233a:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 800233e:	6013      	str	r3, [r2, #0]
 8002340:	682a      	ldr	r2, [r5, #0]
 8002342:	6813      	ldr	r3, [r2, #0]
 8002344:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002348:	6013      	str	r3, [r2, #0]
 800234a:	e7df      	b.n	800230c <SPI_WaitFlagStateUntilTimeout+0x7c>
    }
  }

  return HAL_OK;
 800234c:	2000      	movs	r0, #0
}
 800234e:	b002      	add	sp, #8
 8002350:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002354:	20000000 	.word	0x20000000

08002358 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8002358:	b570      	push	{r4, r5, r6, lr}
 800235a:	b084      	sub	sp, #16
 800235c:	4604      	mov	r4, r0
 800235e:	460d      	mov	r5, r1
 8002360:	4616      	mov	r6, r2
  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, Tickstart) != HAL_OK)
 8002362:	9200      	str	r2, [sp, #0]
 8002364:	460b      	mov	r3, r1
 8002366:	2201      	movs	r2, #1
 8002368:	2102      	movs	r1, #2
 800236a:	f7ff ff91 	bl	8002290 <SPI_WaitFlagStateUntilTimeout>
 800236e:	b9d0      	cbnz	r0, 80023a6 <SPI_EndRxTxTransaction+0x4e>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  /* Timeout in s */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 8002370:	4b17      	ldr	r3, [pc, #92]	@ (80023d0 <SPI_EndRxTxTransaction+0x78>)
 8002372:	681b      	ldr	r3, [r3, #0]
 8002374:	4a17      	ldr	r2, [pc, #92]	@ (80023d4 <SPI_EndRxTxTransaction+0x7c>)
 8002376:	fba2 2303 	umull	r2, r3, r2, r3
 800237a:	0d5b      	lsrs	r3, r3, #21
 800237c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8002380:	fb02 f303 	mul.w	r3, r2, r3
 8002384:	9303      	str	r3, [sp, #12]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 8002386:	6863      	ldr	r3, [r4, #4]
 8002388:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 800238c:	d011      	beq.n	80023b2 <SPI_EndRxTxTransaction+0x5a>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 800238e:	9b03      	ldr	r3, [sp, #12]
 8002390:	b13b      	cbz	r3, 80023a2 <SPI_EndRxTxTransaction+0x4a>
      {
        break;
      }
      count--;
 8002392:	9b03      	ldr	r3, [sp, #12]
 8002394:	3b01      	subs	r3, #1
 8002396:	9303      	str	r3, [sp, #12]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 8002398:	6823      	ldr	r3, [r4, #0]
 800239a:	689b      	ldr	r3, [r3, #8]
 800239c:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80023a0:	d1f5      	bne.n	800238e <SPI_EndRxTxTransaction+0x36>
  }

  return HAL_OK;
}
 80023a2:	b004      	add	sp, #16
 80023a4:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80023a6:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 80023a8:	f043 0320 	orr.w	r3, r3, #32
 80023ac:	6563      	str	r3, [r4, #84]	@ 0x54
    return HAL_TIMEOUT;
 80023ae:	2003      	movs	r0, #3
 80023b0:	e7f7      	b.n	80023a2 <SPI_EndRxTxTransaction+0x4a>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80023b2:	9600      	str	r6, [sp, #0]
 80023b4:	462b      	mov	r3, r5
 80023b6:	2200      	movs	r2, #0
 80023b8:	2180      	movs	r1, #128	@ 0x80
 80023ba:	4620      	mov	r0, r4
 80023bc:	f7ff ff68 	bl	8002290 <SPI_WaitFlagStateUntilTimeout>
 80023c0:	2800      	cmp	r0, #0
 80023c2:	d0ee      	beq.n	80023a2 <SPI_EndRxTxTransaction+0x4a>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80023c4:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 80023c6:	f043 0320 	orr.w	r3, r3, #32
 80023ca:	6563      	str	r3, [r4, #84]	@ 0x54
      return HAL_TIMEOUT;
 80023cc:	2003      	movs	r0, #3
 80023ce:	e7e8      	b.n	80023a2 <SPI_EndRxTxTransaction+0x4a>
 80023d0:	20000000 	.word	0x20000000
 80023d4:	165e9f81 	.word	0x165e9f81

080023d8 <SPI_EndRxTransaction>:
{
 80023d8:	b510      	push	{r4, lr}
 80023da:	b082      	sub	sp, #8
 80023dc:	4604      	mov	r4, r0
 80023de:	460b      	mov	r3, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80023e0:	6841      	ldr	r1, [r0, #4]
 80023e2:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
 80023e6:	d014      	beq.n	8002412 <SPI_EndRxTransaction+0x3a>
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80023e8:	6861      	ldr	r1, [r4, #4]
 80023ea:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
 80023ee:	d12a      	bne.n	8002446 <SPI_EndRxTransaction+0x6e>
    if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
 80023f0:	68a1      	ldr	r1, [r4, #8]
 80023f2:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
 80023f6:	d019      	beq.n	800242c <SPI_EndRxTransaction+0x54>
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80023f8:	9200      	str	r2, [sp, #0]
 80023fa:	2200      	movs	r2, #0
 80023fc:	2180      	movs	r1, #128	@ 0x80
 80023fe:	4620      	mov	r0, r4
 8002400:	f7ff ff46 	bl	8002290 <SPI_WaitFlagStateUntilTimeout>
 8002404:	b330      	cbz	r0, 8002454 <SPI_EndRxTransaction+0x7c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002406:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8002408:	f043 0320 	orr.w	r3, r3, #32
 800240c:	6563      	str	r3, [r4, #84]	@ 0x54
        return HAL_TIMEOUT;
 800240e:	2003      	movs	r0, #3
 8002410:	e020      	b.n	8002454 <SPI_EndRxTransaction+0x7c>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002412:	6881      	ldr	r1, [r0, #8]
 8002414:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
 8002418:	d002      	beq.n	8002420 <SPI_EndRxTransaction+0x48>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800241a:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
 800241e:	d1e3      	bne.n	80023e8 <SPI_EndRxTransaction+0x10>
    __HAL_SPI_DISABLE(hspi);
 8002420:	6820      	ldr	r0, [r4, #0]
 8002422:	6801      	ldr	r1, [r0, #0]
 8002424:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
 8002428:	6001      	str	r1, [r0, #0]
 800242a:	e7dd      	b.n	80023e8 <SPI_EndRxTransaction+0x10>
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 800242c:	9200      	str	r2, [sp, #0]
 800242e:	2200      	movs	r2, #0
 8002430:	2101      	movs	r1, #1
 8002432:	4620      	mov	r0, r4
 8002434:	f7ff ff2c 	bl	8002290 <SPI_WaitFlagStateUntilTimeout>
 8002438:	b160      	cbz	r0, 8002454 <SPI_EndRxTransaction+0x7c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800243a:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 800243c:	f043 0320 	orr.w	r3, r3, #32
 8002440:	6563      	str	r3, [r4, #84]	@ 0x54
        return HAL_TIMEOUT;
 8002442:	2003      	movs	r0, #3
 8002444:	e006      	b.n	8002454 <SPI_EndRxTransaction+0x7c>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 8002446:	9200      	str	r2, [sp, #0]
 8002448:	2200      	movs	r2, #0
 800244a:	2101      	movs	r1, #1
 800244c:	4620      	mov	r0, r4
 800244e:	f7ff ff1f 	bl	8002290 <SPI_WaitFlagStateUntilTimeout>
 8002452:	b908      	cbnz	r0, 8002458 <SPI_EndRxTransaction+0x80>
}
 8002454:	b002      	add	sp, #8
 8002456:	bd10      	pop	{r4, pc}
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002458:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 800245a:	f043 0320 	orr.w	r3, r3, #32
 800245e:	6563      	str	r3, [r4, #84]	@ 0x54
      return HAL_TIMEOUT;
 8002460:	2003      	movs	r0, #3
 8002462:	e7f7      	b.n	8002454 <SPI_EndRxTransaction+0x7c>

08002464 <HAL_SPI_Init>:
  if (hspi == NULL)
 8002464:	2800      	cmp	r0, #0
 8002466:	d05a      	beq.n	800251e <HAL_SPI_Init+0xba>
{
 8002468:	b510      	push	{r4, lr}
 800246a:	4604      	mov	r4, r0
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800246c:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 800246e:	b933      	cbnz	r3, 800247e <HAL_SPI_Init+0x1a>
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8002470:	6843      	ldr	r3, [r0, #4]
 8002472:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8002476:	d005      	beq.n	8002484 <HAL_SPI_Init+0x20>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8002478:	2300      	movs	r3, #0
 800247a:	61c3      	str	r3, [r0, #28]
 800247c:	e002      	b.n	8002484 <HAL_SPI_Init+0x20>
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 800247e:	2300      	movs	r3, #0
 8002480:	6103      	str	r3, [r0, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8002482:	6143      	str	r3, [r0, #20]
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002484:	2300      	movs	r3, #0
 8002486:	62a3      	str	r3, [r4, #40]	@ 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002488:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 800248c:	2b00      	cmp	r3, #0
 800248e:	d040      	beq.n	8002512 <HAL_SPI_Init+0xae>
  hspi->State = HAL_SPI_STATE_BUSY;
 8002490:	2302      	movs	r3, #2
 8002492:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  __HAL_SPI_DISABLE(hspi);
 8002496:	6822      	ldr	r2, [r4, #0]
 8002498:	6813      	ldr	r3, [r2, #0]
 800249a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800249e:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80024a0:	6863      	ldr	r3, [r4, #4]
 80024a2:	f403 7382 	and.w	r3, r3, #260	@ 0x104
 80024a6:	68a2      	ldr	r2, [r4, #8]
 80024a8:	f402 4204 	and.w	r2, r2, #33792	@ 0x8400
 80024ac:	4313      	orrs	r3, r2
 80024ae:	68e2      	ldr	r2, [r4, #12]
 80024b0:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 80024b4:	4313      	orrs	r3, r2
 80024b6:	6922      	ldr	r2, [r4, #16]
 80024b8:	f002 0202 	and.w	r2, r2, #2
 80024bc:	4313      	orrs	r3, r2
 80024be:	6962      	ldr	r2, [r4, #20]
 80024c0:	f002 0201 	and.w	r2, r2, #1
 80024c4:	4313      	orrs	r3, r2
 80024c6:	69a2      	ldr	r2, [r4, #24]
 80024c8:	f402 7200 	and.w	r2, r2, #512	@ 0x200
 80024cc:	4313      	orrs	r3, r2
 80024ce:	69e2      	ldr	r2, [r4, #28]
 80024d0:	f002 0238 	and.w	r2, r2, #56	@ 0x38
 80024d4:	4313      	orrs	r3, r2
 80024d6:	6a22      	ldr	r2, [r4, #32]
 80024d8:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 80024dc:	4313      	orrs	r3, r2
 80024de:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 80024e0:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 80024e4:	6821      	ldr	r1, [r4, #0]
 80024e6:	4313      	orrs	r3, r2
 80024e8:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 80024ea:	8b63      	ldrh	r3, [r4, #26]
 80024ec:	f003 0304 	and.w	r3, r3, #4
 80024f0:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 80024f2:	f002 0210 	and.w	r2, r2, #16
 80024f6:	6821      	ldr	r1, [r4, #0]
 80024f8:	4313      	orrs	r3, r2
 80024fa:	604b      	str	r3, [r1, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80024fc:	6822      	ldr	r2, [r4, #0]
 80024fe:	69d3      	ldr	r3, [r2, #28]
 8002500:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8002504:	61d3      	str	r3, [r2, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002506:	2000      	movs	r0, #0
 8002508:	6560      	str	r0, [r4, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 800250a:	2301      	movs	r3, #1
 800250c:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
}
 8002510:	bd10      	pop	{r4, pc}
    hspi->Lock = HAL_UNLOCKED;
 8002512:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
    HAL_SPI_MspInit(hspi);
 8002516:	4620      	mov	r0, r4
 8002518:	f7ff f880 	bl	800161c <HAL_SPI_MspInit>
 800251c:	e7b8      	b.n	8002490 <HAL_SPI_Init+0x2c>
    return HAL_ERROR;
 800251e:	2001      	movs	r0, #1
}
 8002520:	4770      	bx	lr

08002522 <HAL_SPI_Transmit>:
{
 8002522:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002526:	b083      	sub	sp, #12
 8002528:	4604      	mov	r4, r0
 800252a:	4689      	mov	r9, r1
 800252c:	4690      	mov	r8, r2
 800252e:	461d      	mov	r5, r3
  tickstart = HAL_GetTick();
 8002530:	f7ff f9d8 	bl	80018e4 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8002534:	f894 6051 	ldrb.w	r6, [r4, #81]	@ 0x51
 8002538:	b2f6      	uxtb	r6, r6
 800253a:	2e01      	cmp	r6, #1
 800253c:	f040 80cc 	bne.w	80026d8 <HAL_SPI_Transmit+0x1b6>
 8002540:	4607      	mov	r7, r0
  if ((pData == NULL) || (Size == 0U))
 8002542:	f1b9 0f00 	cmp.w	r9, #0
 8002546:	f000 80c8 	beq.w	80026da <HAL_SPI_Transmit+0x1b8>
 800254a:	f1b8 0f00 	cmp.w	r8, #0
 800254e:	f000 80c4 	beq.w	80026da <HAL_SPI_Transmit+0x1b8>
  __HAL_LOCK(hspi);
 8002552:	f894 3050 	ldrb.w	r3, [r4, #80]	@ 0x50
 8002556:	2b01      	cmp	r3, #1
 8002558:	f000 80c3 	beq.w	80026e2 <HAL_SPI_Transmit+0x1c0>
 800255c:	2301      	movs	r3, #1
 800255e:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002562:	2303      	movs	r3, #3
 8002564:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002568:	2300      	movs	r3, #0
 800256a:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->pTxBuffPtr  = (const uint8_t *)pData;
 800256c:	f8c4 9030 	str.w	r9, [r4, #48]	@ 0x30
  hspi->TxXferSize  = Size;
 8002570:	f8a4 8034 	strh.w	r8, [r4, #52]	@ 0x34
  hspi->TxXferCount = Size;
 8002574:	f8a4 8036 	strh.w	r8, [r4, #54]	@ 0x36
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002578:	63a3      	str	r3, [r4, #56]	@ 0x38
  hspi->RxXferSize  = 0U;
 800257a:	87a3      	strh	r3, [r4, #60]	@ 0x3c
  hspi->RxXferCount = 0U;
 800257c:	87e3      	strh	r3, [r4, #62]	@ 0x3e
  hspi->TxISR       = NULL;
 800257e:	6463      	str	r3, [r4, #68]	@ 0x44
  hspi->RxISR       = NULL;
 8002580:	6423      	str	r3, [r4, #64]	@ 0x40
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002582:	68a3      	ldr	r3, [r4, #8]
 8002584:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8002588:	d01e      	beq.n	80025c8 <HAL_SPI_Transmit+0xa6>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800258a:	6823      	ldr	r3, [r4, #0]
 800258c:	681a      	ldr	r2, [r3, #0]
 800258e:	f012 0f40 	tst.w	r2, #64	@ 0x40
 8002592:	d103      	bne.n	800259c <HAL_SPI_Transmit+0x7a>
    __HAL_SPI_ENABLE(hspi);
 8002594:	681a      	ldr	r2, [r3, #0]
 8002596:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800259a:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800259c:	68e3      	ldr	r3, [r4, #12]
 800259e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80025a2:	d01c      	beq.n	80025de <HAL_SPI_Transmit+0xbc>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80025a4:	6863      	ldr	r3, [r4, #4]
 80025a6:	b113      	cbz	r3, 80025ae <HAL_SPI_Transmit+0x8c>
 80025a8:	f1b8 0f01 	cmp.w	r8, #1
 80025ac:	d15f      	bne.n	800266e <HAL_SPI_Transmit+0x14c>
      *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
 80025ae:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80025b0:	6823      	ldr	r3, [r4, #0]
 80025b2:	7812      	ldrb	r2, [r2, #0]
 80025b4:	731a      	strb	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 80025b6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80025b8:	3301      	adds	r3, #1
 80025ba:	6323      	str	r3, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 80025bc:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80025be:	b29b      	uxth	r3, r3
 80025c0:	3b01      	subs	r3, #1
 80025c2:	b29b      	uxth	r3, r3
 80025c4:	86e3      	strh	r3, [r4, #54]	@ 0x36
 80025c6:	e052      	b.n	800266e <HAL_SPI_Transmit+0x14c>
    __HAL_SPI_DISABLE(hspi);
 80025c8:	6822      	ldr	r2, [r4, #0]
 80025ca:	6813      	ldr	r3, [r2, #0]
 80025cc:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80025d0:	6013      	str	r3, [r2, #0]
    SPI_1LINE_TX(hspi);
 80025d2:	6822      	ldr	r2, [r4, #0]
 80025d4:	6813      	ldr	r3, [r2, #0]
 80025d6:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80025da:	6013      	str	r3, [r2, #0]
 80025dc:	e7d5      	b.n	800258a <HAL_SPI_Transmit+0x68>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80025de:	6863      	ldr	r3, [r4, #4]
 80025e0:	b113      	cbz	r3, 80025e8 <HAL_SPI_Transmit+0xc6>
 80025e2:	f1b8 0f01 	cmp.w	r8, #1
 80025e6:	d115      	bne.n	8002614 <HAL_SPI_Transmit+0xf2>
      hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
 80025e8:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80025ea:	6823      	ldr	r3, [r4, #0]
 80025ec:	8812      	ldrh	r2, [r2, #0]
 80025ee:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 80025f0:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80025f2:	3302      	adds	r3, #2
 80025f4:	6323      	str	r3, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 80025f6:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80025f8:	b29b      	uxth	r3, r3
 80025fa:	3b01      	subs	r3, #1
 80025fc:	b29b      	uxth	r3, r3
 80025fe:	86e3      	strh	r3, [r4, #54]	@ 0x36
 8002600:	e008      	b.n	8002614 <HAL_SPI_Transmit+0xf2>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002602:	f7ff f96f 	bl	80018e4 <HAL_GetTick>
 8002606:	1bc0      	subs	r0, r0, r7
 8002608:	42a8      	cmp	r0, r5
 800260a:	d302      	bcc.n	8002612 <HAL_SPI_Transmit+0xf0>
 800260c:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002610:	d115      	bne.n	800263e <HAL_SPI_Transmit+0x11c>
 8002612:	b1a5      	cbz	r5, 800263e <HAL_SPI_Transmit+0x11c>
    while (hspi->TxXferCount > 0U)
 8002614:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8002616:	b29b      	uxth	r3, r3
 8002618:	2b00      	cmp	r3, #0
 800261a:	d042      	beq.n	80026a2 <HAL_SPI_Transmit+0x180>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 800261c:	6823      	ldr	r3, [r4, #0]
 800261e:	689a      	ldr	r2, [r3, #8]
 8002620:	f012 0f02 	tst.w	r2, #2
 8002624:	d0ed      	beq.n	8002602 <HAL_SPI_Transmit+0xe0>
        hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
 8002626:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8002628:	8812      	ldrh	r2, [r2, #0]
 800262a:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800262c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800262e:	3302      	adds	r3, #2
 8002630:	6323      	str	r3, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8002632:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8002634:	b29b      	uxth	r3, r3
 8002636:	3b01      	subs	r3, #1
 8002638:	b29b      	uxth	r3, r3
 800263a:	86e3      	strh	r3, [r4, #54]	@ 0x36
 800263c:	e7ea      	b.n	8002614 <HAL_SPI_Transmit+0xf2>
          hspi->State = HAL_SPI_STATE_READY;
 800263e:	2301      	movs	r3, #1
 8002640:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
          __HAL_UNLOCK(hspi);
 8002644:	2300      	movs	r3, #0
 8002646:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
          return HAL_TIMEOUT;
 800264a:	2603      	movs	r6, #3
 800264c:	e045      	b.n	80026da <HAL_SPI_Transmit+0x1b8>
        *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
 800264e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8002650:	7812      	ldrb	r2, [r2, #0]
 8002652:	731a      	strb	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8002654:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8002656:	3301      	adds	r3, #1
 8002658:	6323      	str	r3, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 800265a:	f8b4 c036 	ldrh.w	ip, [r4, #54]	@ 0x36
 800265e:	fa1f fc8c 	uxth.w	ip, ip
 8002662:	f10c 3cff 	add.w	ip, ip, #4294967295
 8002666:	fa1f fc8c 	uxth.w	ip, ip
 800266a:	f8a4 c036 	strh.w	ip, [r4, #54]	@ 0x36
    while (hspi->TxXferCount > 0U)
 800266e:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8002670:	b29b      	uxth	r3, r3
 8002672:	b1b3      	cbz	r3, 80026a2 <HAL_SPI_Transmit+0x180>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002674:	6823      	ldr	r3, [r4, #0]
 8002676:	689a      	ldr	r2, [r3, #8]
 8002678:	f012 0f02 	tst.w	r2, #2
 800267c:	d1e7      	bne.n	800264e <HAL_SPI_Transmit+0x12c>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 800267e:	f7ff f931 	bl	80018e4 <HAL_GetTick>
 8002682:	1bc0      	subs	r0, r0, r7
 8002684:	42a8      	cmp	r0, r5
 8002686:	d302      	bcc.n	800268e <HAL_SPI_Transmit+0x16c>
 8002688:	f1b5 3fff 	cmp.w	r5, #4294967295
 800268c:	d101      	bne.n	8002692 <HAL_SPI_Transmit+0x170>
 800268e:	2d00      	cmp	r5, #0
 8002690:	d1ed      	bne.n	800266e <HAL_SPI_Transmit+0x14c>
          hspi->State = HAL_SPI_STATE_READY;
 8002692:	2301      	movs	r3, #1
 8002694:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
          __HAL_UNLOCK(hspi);
 8002698:	2300      	movs	r3, #0
 800269a:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
          return HAL_TIMEOUT;
 800269e:	2603      	movs	r6, #3
 80026a0:	e01b      	b.n	80026da <HAL_SPI_Transmit+0x1b8>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80026a2:	463a      	mov	r2, r7
 80026a4:	4629      	mov	r1, r5
 80026a6:	4620      	mov	r0, r4
 80026a8:	f7ff fe56 	bl	8002358 <SPI_EndRxTxTransaction>
 80026ac:	b108      	cbz	r0, 80026b2 <HAL_SPI_Transmit+0x190>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80026ae:	2320      	movs	r3, #32
 80026b0:	6563      	str	r3, [r4, #84]	@ 0x54
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80026b2:	68a3      	ldr	r3, [r4, #8]
 80026b4:	b933      	cbnz	r3, 80026c4 <HAL_SPI_Transmit+0x1a2>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80026b6:	9301      	str	r3, [sp, #4]
 80026b8:	6823      	ldr	r3, [r4, #0]
 80026ba:	68da      	ldr	r2, [r3, #12]
 80026bc:	9201      	str	r2, [sp, #4]
 80026be:	689b      	ldr	r3, [r3, #8]
 80026c0:	9301      	str	r3, [sp, #4]
 80026c2:	9b01      	ldr	r3, [sp, #4]
  hspi->State = HAL_SPI_STATE_READY;
 80026c4:	2301      	movs	r3, #1
 80026c6:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  __HAL_UNLOCK(hspi);
 80026ca:	2300      	movs	r3, #0
 80026cc:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80026d0:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 80026d2:	b913      	cbnz	r3, 80026da <HAL_SPI_Transmit+0x1b8>
    return HAL_OK;
 80026d4:	2600      	movs	r6, #0
 80026d6:	e000      	b.n	80026da <HAL_SPI_Transmit+0x1b8>
    return HAL_BUSY;
 80026d8:	2602      	movs	r6, #2
}
 80026da:	4630      	mov	r0, r6
 80026dc:	b003      	add	sp, #12
 80026de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  __HAL_LOCK(hspi);
 80026e2:	2602      	movs	r6, #2
 80026e4:	e7f9      	b.n	80026da <HAL_SPI_Transmit+0x1b8>

080026e6 <HAL_SPI_TransmitReceive>:
{
 80026e6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80026ea:	b083      	sub	sp, #12
 80026ec:	4604      	mov	r4, r0
 80026ee:	4688      	mov	r8, r1
 80026f0:	4691      	mov	r9, r2
 80026f2:	461f      	mov	r7, r3
 80026f4:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
  tickstart = HAL_GetTick();
 80026f6:	f7ff f8f5 	bl	80018e4 <HAL_GetTick>
 80026fa:	4606      	mov	r6, r0
  tmp_state           = hspi->State;
 80026fc:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 8002700:	b2db      	uxtb	r3, r3
  tmp_mode            = hspi->Init.Mode;
 8002702:	6862      	ldr	r2, [r4, #4]
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8002704:	2b01      	cmp	r3, #1
 8002706:	d00a      	beq.n	800271e <HAL_SPI_TransmitReceive+0x38>
 8002708:	f5b2 7f82 	cmp.w	r2, #260	@ 0x104
 800270c:	f040 8105 	bne.w	800291a <HAL_SPI_TransmitReceive+0x234>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8002710:	68a2      	ldr	r2, [r4, #8]
 8002712:	2a00      	cmp	r2, #0
 8002714:	f040 8105 	bne.w	8002922 <HAL_SPI_TransmitReceive+0x23c>
 8002718:	2b04      	cmp	r3, #4
 800271a:	f040 8104 	bne.w	8002926 <HAL_SPI_TransmitReceive+0x240>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800271e:	f1b8 0f00 	cmp.w	r8, #0
 8002722:	f000 8102 	beq.w	800292a <HAL_SPI_TransmitReceive+0x244>
 8002726:	f1b9 0f00 	cmp.w	r9, #0
 800272a:	f000 8100 	beq.w	800292e <HAL_SPI_TransmitReceive+0x248>
 800272e:	2f00      	cmp	r7, #0
 8002730:	f000 80ff 	beq.w	8002932 <HAL_SPI_TransmitReceive+0x24c>
  __HAL_LOCK(hspi);
 8002734:	f894 3050 	ldrb.w	r3, [r4, #80]	@ 0x50
 8002738:	2b01      	cmp	r3, #1
 800273a:	f000 80fc 	beq.w	8002936 <HAL_SPI_TransmitReceive+0x250>
 800273e:	2301      	movs	r3, #1
 8002740:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8002744:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 8002748:	b2db      	uxtb	r3, r3
 800274a:	2b04      	cmp	r3, #4
 800274c:	d002      	beq.n	8002754 <HAL_SPI_TransmitReceive+0x6e>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800274e:	2305      	movs	r3, #5
 8002750:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002754:	2300      	movs	r3, #0
 8002756:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8002758:	f8c4 9038 	str.w	r9, [r4, #56]	@ 0x38
  hspi->RxXferCount = Size;
 800275c:	87e7      	strh	r7, [r4, #62]	@ 0x3e
  hspi->RxXferSize  = Size;
 800275e:	87a7      	strh	r7, [r4, #60]	@ 0x3c
  hspi->pTxBuffPtr  = (const uint8_t *)pTxData;
 8002760:	f8c4 8030 	str.w	r8, [r4, #48]	@ 0x30
  hspi->TxXferCount = Size;
 8002764:	86e7      	strh	r7, [r4, #54]	@ 0x36
  hspi->TxXferSize  = Size;
 8002766:	86a7      	strh	r7, [r4, #52]	@ 0x34
  hspi->RxISR       = NULL;
 8002768:	6423      	str	r3, [r4, #64]	@ 0x40
  hspi->TxISR       = NULL;
 800276a:	6463      	str	r3, [r4, #68]	@ 0x44
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800276c:	6823      	ldr	r3, [r4, #0]
 800276e:	681a      	ldr	r2, [r3, #0]
 8002770:	f012 0f40 	tst.w	r2, #64	@ 0x40
 8002774:	d103      	bne.n	800277e <HAL_SPI_TransmitReceive+0x98>
    __HAL_SPI_ENABLE(hspi);
 8002776:	681a      	ldr	r2, [r3, #0]
 8002778:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800277c:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800277e:	68e3      	ldr	r3, [r4, #12]
 8002780:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8002784:	d011      	beq.n	80027aa <HAL_SPI_TransmitReceive+0xc4>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002786:	6863      	ldr	r3, [r4, #4]
 8002788:	b10b      	cbz	r3, 800278e <HAL_SPI_TransmitReceive+0xa8>
 800278a:	2f01      	cmp	r7, #1
 800278c:	d10b      	bne.n	80027a6 <HAL_SPI_TransmitReceive+0xc0>
      *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
 800278e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8002790:	6823      	ldr	r3, [r4, #0]
 8002792:	7812      	ldrb	r2, [r2, #0]
 8002794:	731a      	strb	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8002796:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8002798:	3301      	adds	r3, #1
 800279a:	6323      	str	r3, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 800279c:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 800279e:	b29b      	uxth	r3, r3
 80027a0:	3b01      	subs	r3, #1
 80027a2:	b29b      	uxth	r3, r3
 80027a4:	86e3      	strh	r3, [r4, #54]	@ 0x36
        txallowed = 1U;
 80027a6:	2701      	movs	r7, #1
 80027a8:	e071      	b.n	800288e <HAL_SPI_TransmitReceive+0x1a8>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80027aa:	6863      	ldr	r3, [r4, #4]
 80027ac:	b10b      	cbz	r3, 80027b2 <HAL_SPI_TransmitReceive+0xcc>
 80027ae:	2f01      	cmp	r7, #1
 80027b0:	d10b      	bne.n	80027ca <HAL_SPI_TransmitReceive+0xe4>
      hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
 80027b2:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80027b4:	6823      	ldr	r3, [r4, #0]
 80027b6:	8812      	ldrh	r2, [r2, #0]
 80027b8:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 80027ba:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80027bc:	3302      	adds	r3, #2
 80027be:	6323      	str	r3, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 80027c0:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80027c2:	b29b      	uxth	r3, r3
 80027c4:	3b01      	subs	r3, #1
 80027c6:	b29b      	uxth	r3, r3
 80027c8:	86e3      	strh	r3, [r4, #54]	@ 0x36
        txallowed = 1U;
 80027ca:	2701      	movs	r7, #1
 80027cc:	e01b      	b.n	8002806 <HAL_SPI_TransmitReceive+0x120>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80027ce:	6823      	ldr	r3, [r4, #0]
 80027d0:	689a      	ldr	r2, [r3, #8]
 80027d2:	f012 0f01 	tst.w	r2, #1
 80027d6:	d00e      	beq.n	80027f6 <HAL_SPI_TransmitReceive+0x110>
 80027d8:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
 80027da:	b292      	uxth	r2, r2
 80027dc:	b15a      	cbz	r2, 80027f6 <HAL_SPI_TransmitReceive+0x110>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 80027de:	68da      	ldr	r2, [r3, #12]
 80027e0:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80027e2:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 80027e4:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80027e6:	3302      	adds	r3, #2
 80027e8:	63a3      	str	r3, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 80027ea:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 80027ec:	b29b      	uxth	r3, r3
 80027ee:	3b01      	subs	r3, #1
 80027f0:	b29b      	uxth	r3, r3
 80027f2:	87e3      	strh	r3, [r4, #62]	@ 0x3e
        txallowed = 1U;
 80027f4:	2701      	movs	r7, #1
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 80027f6:	f7ff f875 	bl	80018e4 <HAL_GetTick>
 80027fa:	1b80      	subs	r0, r0, r6
 80027fc:	42a8      	cmp	r0, r5
 80027fe:	d302      	bcc.n	8002806 <HAL_SPI_TransmitReceive+0x120>
 8002800:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002804:	d11e      	bne.n	8002844 <HAL_SPI_TransmitReceive+0x15e>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002806:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8002808:	b29b      	uxth	r3, r3
 800280a:	b91b      	cbnz	r3, 8002814 <HAL_SPI_TransmitReceive+0x12e>
 800280c:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 800280e:	b29b      	uxth	r3, r3
 8002810:	2b00      	cmp	r3, #0
 8002812:	d062      	beq.n	80028da <HAL_SPI_TransmitReceive+0x1f4>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002814:	6823      	ldr	r3, [r4, #0]
 8002816:	689a      	ldr	r2, [r3, #8]
 8002818:	f012 0f02 	tst.w	r2, #2
 800281c:	d0d7      	beq.n	80027ce <HAL_SPI_TransmitReceive+0xe8>
 800281e:	8ee2      	ldrh	r2, [r4, #54]	@ 0x36
 8002820:	b292      	uxth	r2, r2
 8002822:	2a00      	cmp	r2, #0
 8002824:	d0d3      	beq.n	80027ce <HAL_SPI_TransmitReceive+0xe8>
 8002826:	2f00      	cmp	r7, #0
 8002828:	d0d1      	beq.n	80027ce <HAL_SPI_TransmitReceive+0xe8>
        hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
 800282a:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800282c:	8812      	ldrh	r2, [r2, #0]
 800282e:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002830:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8002832:	3302      	adds	r3, #2
 8002834:	6323      	str	r3, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8002836:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8002838:	b29b      	uxth	r3, r3
 800283a:	3b01      	subs	r3, #1
 800283c:	b29b      	uxth	r3, r3
 800283e:	86e3      	strh	r3, [r4, #54]	@ 0x36
        txallowed = 0U;
 8002840:	2700      	movs	r7, #0
 8002842:	e7c4      	b.n	80027ce <HAL_SPI_TransmitReceive+0xe8>
        hspi->State = HAL_SPI_STATE_READY;
 8002844:	2301      	movs	r3, #1
 8002846:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
        __HAL_UNLOCK(hspi);
 800284a:	2300      	movs	r3, #0
 800284c:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
        return HAL_TIMEOUT;
 8002850:	2003      	movs	r0, #3
 8002852:	e063      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002854:	6823      	ldr	r3, [r4, #0]
 8002856:	689a      	ldr	r2, [r3, #8]
 8002858:	f012 0f01 	tst.w	r2, #1
 800285c:	d00e      	beq.n	800287c <HAL_SPI_TransmitReceive+0x196>
 800285e:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
 8002860:	b292      	uxth	r2, r2
 8002862:	b15a      	cbz	r2, 800287c <HAL_SPI_TransmitReceive+0x196>
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8002864:	68da      	ldr	r2, [r3, #12]
 8002866:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002868:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 800286a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 800286c:	3301      	adds	r3, #1
 800286e:	63a3      	str	r3, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8002870:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002872:	b29b      	uxth	r3, r3
 8002874:	3b01      	subs	r3, #1
 8002876:	b29b      	uxth	r3, r3
 8002878:	87e3      	strh	r3, [r4, #62]	@ 0x3e
        txallowed = 1U;
 800287a:	2701      	movs	r7, #1
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 800287c:	f7ff f832 	bl	80018e4 <HAL_GetTick>
 8002880:	1b83      	subs	r3, r0, r6
 8002882:	42ab      	cmp	r3, r5
 8002884:	d302      	bcc.n	800288c <HAL_SPI_TransmitReceive+0x1a6>
 8002886:	f1b5 3fff 	cmp.w	r5, #4294967295
 800288a:	d11e      	bne.n	80028ca <HAL_SPI_TransmitReceive+0x1e4>
 800288c:	b1ed      	cbz	r5, 80028ca <HAL_SPI_TransmitReceive+0x1e4>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800288e:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8002890:	b29b      	uxth	r3, r3
 8002892:	b913      	cbnz	r3, 800289a <HAL_SPI_TransmitReceive+0x1b4>
 8002894:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002896:	b29b      	uxth	r3, r3
 8002898:	b1fb      	cbz	r3, 80028da <HAL_SPI_TransmitReceive+0x1f4>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800289a:	6823      	ldr	r3, [r4, #0]
 800289c:	689a      	ldr	r2, [r3, #8]
 800289e:	f012 0f02 	tst.w	r2, #2
 80028a2:	d0d7      	beq.n	8002854 <HAL_SPI_TransmitReceive+0x16e>
 80028a4:	8ee2      	ldrh	r2, [r4, #54]	@ 0x36
 80028a6:	b292      	uxth	r2, r2
 80028a8:	2a00      	cmp	r2, #0
 80028aa:	d0d3      	beq.n	8002854 <HAL_SPI_TransmitReceive+0x16e>
 80028ac:	2f00      	cmp	r7, #0
 80028ae:	d0d1      	beq.n	8002854 <HAL_SPI_TransmitReceive+0x16e>
        *(__IO uint8_t *)&hspi->Instance->DR = *((const uint8_t *)hspi->pTxBuffPtr);
 80028b0:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80028b2:	7812      	ldrb	r2, [r2, #0]
 80028b4:	731a      	strb	r2, [r3, #12]
        hspi->pTxBuffPtr++;
 80028b6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80028b8:	3301      	adds	r3, #1
 80028ba:	6323      	str	r3, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 80028bc:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80028be:	b29b      	uxth	r3, r3
 80028c0:	3b01      	subs	r3, #1
 80028c2:	b29b      	uxth	r3, r3
 80028c4:	86e3      	strh	r3, [r4, #54]	@ 0x36
        txallowed = 0U;
 80028c6:	2700      	movs	r7, #0
 80028c8:	e7c4      	b.n	8002854 <HAL_SPI_TransmitReceive+0x16e>
        hspi->State = HAL_SPI_STATE_READY;
 80028ca:	2301      	movs	r3, #1
 80028cc:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
        __HAL_UNLOCK(hspi);
 80028d0:	2300      	movs	r3, #0
 80028d2:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
        return HAL_TIMEOUT;
 80028d6:	2003      	movs	r0, #3
 80028d8:	e020      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80028da:	4632      	mov	r2, r6
 80028dc:	4629      	mov	r1, r5
 80028de:	4620      	mov	r0, r4
 80028e0:	f7ff fd3a 	bl	8002358 <SPI_EndRxTxTransaction>
 80028e4:	b990      	cbnz	r0, 800290c <HAL_SPI_TransmitReceive+0x226>
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80028e6:	68a3      	ldr	r3, [r4, #8]
 80028e8:	b933      	cbnz	r3, 80028f8 <HAL_SPI_TransmitReceive+0x212>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80028ea:	9301      	str	r3, [sp, #4]
 80028ec:	6823      	ldr	r3, [r4, #0]
 80028ee:	68da      	ldr	r2, [r3, #12]
 80028f0:	9201      	str	r2, [sp, #4]
 80028f2:	689b      	ldr	r3, [r3, #8]
 80028f4:	9301      	str	r3, [sp, #4]
 80028f6:	9b01      	ldr	r3, [sp, #4]
  hspi->State = HAL_SPI_STATE_READY;
 80028f8:	2301      	movs	r3, #1
 80028fa:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  __HAL_UNLOCK(hspi);
 80028fe:	2300      	movs	r3, #0
 8002900:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002904:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8002906:	b14b      	cbz	r3, 800291c <HAL_SPI_TransmitReceive+0x236>
    return HAL_ERROR;
 8002908:	2001      	movs	r0, #1
 800290a:	e007      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800290c:	2320      	movs	r3, #32
 800290e:	6563      	str	r3, [r4, #84]	@ 0x54
    __HAL_UNLOCK(hspi);
 8002910:	2300      	movs	r3, #0
 8002912:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
    return HAL_ERROR;
 8002916:	2001      	movs	r0, #1
 8002918:	e000      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
    return HAL_BUSY;
 800291a:	2002      	movs	r0, #2
}
 800291c:	b003      	add	sp, #12
 800291e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return HAL_BUSY;
 8002922:	2002      	movs	r0, #2
 8002924:	e7fa      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
 8002926:	2002      	movs	r0, #2
 8002928:	e7f8      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
    return HAL_ERROR;
 800292a:	2001      	movs	r0, #1
 800292c:	e7f6      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
 800292e:	2001      	movs	r0, #1
 8002930:	e7f4      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
 8002932:	2001      	movs	r0, #1
 8002934:	e7f2      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>
  __HAL_LOCK(hspi);
 8002936:	2002      	movs	r0, #2
 8002938:	e7f0      	b.n	800291c <HAL_SPI_TransmitReceive+0x236>

0800293a <HAL_SPI_Receive>:
{
 800293a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800293e:	b083      	sub	sp, #12
  if (hspi->State != HAL_SPI_STATE_READY)
 8002940:	f890 6051 	ldrb.w	r6, [r0, #81]	@ 0x51
 8002944:	b2f6      	uxtb	r6, r6
 8002946:	2e01      	cmp	r6, #1
 8002948:	f040 80b4 	bne.w	8002ab4 <HAL_SPI_Receive+0x17a>
 800294c:	4604      	mov	r4, r0
 800294e:	4689      	mov	r9, r1
 8002950:	4690      	mov	r8, r2
 8002952:	461d      	mov	r5, r3
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8002954:	6843      	ldr	r3, [r0, #4]
 8002956:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 800295a:	d101      	bne.n	8002960 <HAL_SPI_Receive+0x26>
 800295c:	6883      	ldr	r3, [r0, #8]
 800295e:	b393      	cbz	r3, 80029c6 <HAL_SPI_Receive+0x8c>
  tickstart = HAL_GetTick();
 8002960:	f7fe ffc0 	bl	80018e4 <HAL_GetTick>
 8002964:	4607      	mov	r7, r0
  if ((pData == NULL) || (Size == 0U))
 8002966:	f1b9 0f00 	cmp.w	r9, #0
 800296a:	f000 80a4 	beq.w	8002ab6 <HAL_SPI_Receive+0x17c>
 800296e:	f1b8 0f00 	cmp.w	r8, #0
 8002972:	f000 80a0 	beq.w	8002ab6 <HAL_SPI_Receive+0x17c>
  __HAL_LOCK(hspi);
 8002976:	f894 3050 	ldrb.w	r3, [r4, #80]	@ 0x50
 800297a:	2b01      	cmp	r3, #1
 800297c:	f000 809f 	beq.w	8002abe <HAL_SPI_Receive+0x184>
 8002980:	2301      	movs	r3, #1
 8002982:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8002986:	2304      	movs	r3, #4
 8002988:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800298c:	2300      	movs	r3, #0
 800298e:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8002990:	f8c4 9038 	str.w	r9, [r4, #56]	@ 0x38
  hspi->RxXferSize  = Size;
 8002994:	f8a4 803c 	strh.w	r8, [r4, #60]	@ 0x3c
  hspi->RxXferCount = Size;
 8002998:	f8a4 803e 	strh.w	r8, [r4, #62]	@ 0x3e
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 800299c:	6323      	str	r3, [r4, #48]	@ 0x30
  hspi->TxXferSize  = 0U;
 800299e:	86a3      	strh	r3, [r4, #52]	@ 0x34
  hspi->TxXferCount = 0U;
 80029a0:	86e3      	strh	r3, [r4, #54]	@ 0x36
  hspi->RxISR       = NULL;
 80029a2:	6423      	str	r3, [r4, #64]	@ 0x40
  hspi->TxISR       = NULL;
 80029a4:	6463      	str	r3, [r4, #68]	@ 0x44
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80029a6:	68a3      	ldr	r3, [r4, #8]
 80029a8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80029ac:	d015      	beq.n	80029da <HAL_SPI_Receive+0xa0>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80029ae:	6823      	ldr	r3, [r4, #0]
 80029b0:	681a      	ldr	r2, [r3, #0]
 80029b2:	f012 0f40 	tst.w	r2, #64	@ 0x40
 80029b6:	d103      	bne.n	80029c0 <HAL_SPI_Receive+0x86>
    __HAL_SPI_ENABLE(hspi);
 80029b8:	681a      	ldr	r2, [r3, #0]
 80029ba:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80029be:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 80029c0:	68e3      	ldr	r3, [r4, #12]
 80029c2:	b1f3      	cbz	r3, 8002a02 <HAL_SPI_Receive+0xc8>
 80029c4:	e043      	b.n	8002a4e <HAL_SPI_Receive+0x114>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 80029c6:	2304      	movs	r3, #4
 80029c8:	f880 3051 	strb.w	r3, [r0, #81]	@ 0x51
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 80029cc:	9500      	str	r5, [sp, #0]
 80029ce:	4613      	mov	r3, r2
 80029d0:	460a      	mov	r2, r1
 80029d2:	f7ff fe88 	bl	80026e6 <HAL_SPI_TransmitReceive>
 80029d6:	4606      	mov	r6, r0
 80029d8:	e06d      	b.n	8002ab6 <HAL_SPI_Receive+0x17c>
    __HAL_SPI_DISABLE(hspi);
 80029da:	6822      	ldr	r2, [r4, #0]
 80029dc:	6813      	ldr	r3, [r2, #0]
 80029de:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80029e2:	6013      	str	r3, [r2, #0]
    SPI_1LINE_RX(hspi);
 80029e4:	6822      	ldr	r2, [r4, #0]
 80029e6:	6813      	ldr	r3, [r2, #0]
 80029e8:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 80029ec:	6013      	str	r3, [r2, #0]
 80029ee:	e7de      	b.n	80029ae <HAL_SPI_Receive+0x74>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80029f0:	f7fe ff78 	bl	80018e4 <HAL_GetTick>
 80029f4:	1bc0      	subs	r0, r0, r7
 80029f6:	42a8      	cmp	r0, r5
 80029f8:	d302      	bcc.n	8002a00 <HAL_SPI_Receive+0xc6>
 80029fa:	f1b5 3fff 	cmp.w	r5, #4294967295
 80029fe:	d115      	bne.n	8002a2c <HAL_SPI_Receive+0xf2>
 8002a00:	b1a5      	cbz	r5, 8002a2c <HAL_SPI_Receive+0xf2>
    while (hspi->RxXferCount > 0U)
 8002a02:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002a04:	b29b      	uxth	r3, r3
 8002a06:	2b00      	cmp	r3, #0
 8002a08:	d042      	beq.n	8002a90 <HAL_SPI_Receive+0x156>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8002a0a:	6823      	ldr	r3, [r4, #0]
 8002a0c:	689a      	ldr	r2, [r3, #8]
 8002a0e:	f012 0f01 	tst.w	r2, #1
 8002a12:	d0ed      	beq.n	80029f0 <HAL_SPI_Receive+0xb6>
        (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8002a14:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8002a16:	7b1b      	ldrb	r3, [r3, #12]
 8002a18:	7013      	strb	r3, [r2, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8002a1a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002a1c:	3301      	adds	r3, #1
 8002a1e:	63a3      	str	r3, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8002a20:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002a22:	b29b      	uxth	r3, r3
 8002a24:	3b01      	subs	r3, #1
 8002a26:	b29b      	uxth	r3, r3
 8002a28:	87e3      	strh	r3, [r4, #62]	@ 0x3e
 8002a2a:	e7ea      	b.n	8002a02 <HAL_SPI_Receive+0xc8>
          hspi->State = HAL_SPI_STATE_READY;
 8002a2c:	2301      	movs	r3, #1
 8002a2e:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
          __HAL_UNLOCK(hspi);
 8002a32:	2300      	movs	r3, #0
 8002a34:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
          return HAL_TIMEOUT;
 8002a38:	2603      	movs	r6, #3
 8002a3a:	e03c      	b.n	8002ab6 <HAL_SPI_Receive+0x17c>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002a3c:	f7fe ff52 	bl	80018e4 <HAL_GetTick>
 8002a40:	1bc0      	subs	r0, r0, r7
 8002a42:	42a8      	cmp	r0, r5
 8002a44:	d302      	bcc.n	8002a4c <HAL_SPI_Receive+0x112>
 8002a46:	f1b5 3fff 	cmp.w	r5, #4294967295
 8002a4a:	d119      	bne.n	8002a80 <HAL_SPI_Receive+0x146>
 8002a4c:	b1c5      	cbz	r5, 8002a80 <HAL_SPI_Receive+0x146>
    while (hspi->RxXferCount > 0U)
 8002a4e:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002a50:	b29b      	uxth	r3, r3
 8002a52:	b1eb      	cbz	r3, 8002a90 <HAL_SPI_Receive+0x156>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8002a54:	6823      	ldr	r3, [r4, #0]
 8002a56:	689a      	ldr	r2, [r3, #8]
 8002a58:	f012 0f01 	tst.w	r2, #1
 8002a5c:	d0ee      	beq.n	8002a3c <HAL_SPI_Receive+0x102>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8002a5e:	68da      	ldr	r2, [r3, #12]
 8002a60:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002a62:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8002a64:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002a66:	3302      	adds	r3, #2
 8002a68:	63a3      	str	r3, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8002a6a:	f8b4 c03e 	ldrh.w	ip, [r4, #62]	@ 0x3e
 8002a6e:	fa1f fc8c 	uxth.w	ip, ip
 8002a72:	f10c 3cff 	add.w	ip, ip, #4294967295
 8002a76:	fa1f fc8c 	uxth.w	ip, ip
 8002a7a:	f8a4 c03e 	strh.w	ip, [r4, #62]	@ 0x3e
 8002a7e:	e7e6      	b.n	8002a4e <HAL_SPI_Receive+0x114>
          hspi->State = HAL_SPI_STATE_READY;
 8002a80:	2301      	movs	r3, #1
 8002a82:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
          __HAL_UNLOCK(hspi);
 8002a86:	2300      	movs	r3, #0
 8002a88:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
          return HAL_TIMEOUT;
 8002a8c:	2603      	movs	r6, #3
 8002a8e:	e012      	b.n	8002ab6 <HAL_SPI_Receive+0x17c>
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002a90:	463a      	mov	r2, r7
 8002a92:	4629      	mov	r1, r5
 8002a94:	4620      	mov	r0, r4
 8002a96:	f7ff fc9f 	bl	80023d8 <SPI_EndRxTransaction>
 8002a9a:	b108      	cbz	r0, 8002aa0 <HAL_SPI_Receive+0x166>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002a9c:	2320      	movs	r3, #32
 8002a9e:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->State = HAL_SPI_STATE_READY;
 8002aa0:	2301      	movs	r3, #1
 8002aa2:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
  __HAL_UNLOCK(hspi);
 8002aa6:	2300      	movs	r3, #0
 8002aa8:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002aac:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8002aae:	b913      	cbnz	r3, 8002ab6 <HAL_SPI_Receive+0x17c>
    return HAL_OK;
 8002ab0:	2600      	movs	r6, #0
 8002ab2:	e000      	b.n	8002ab6 <HAL_SPI_Receive+0x17c>
    return HAL_BUSY;
 8002ab4:	2602      	movs	r6, #2
}
 8002ab6:	4630      	mov	r0, r6
 8002ab8:	b003      	add	sp, #12
 8002aba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  __HAL_LOCK(hspi);
 8002abe:	2602      	movs	r6, #2
 8002ac0:	e7f9      	b.n	8002ab6 <HAL_SPI_Receive+0x17c>

08002ac2 <HAL_SPI_GetState>:
  return hspi->State;
 8002ac2:	f890 0051 	ldrb.w	r0, [r0, #81]	@ 0x51
}
 8002ac6:	4770      	bx	lr

08002ac8 <HAL_TIM_Base_Start>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8002ac8:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8002acc:	b2db      	uxtb	r3, r3
 8002ace:	2b01      	cmp	r3, #1
 8002ad0:	d132      	bne.n	8002b38 <HAL_TIM_Base_Start+0x70>
  {
    return HAL_ERROR;
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8002ad2:	2302      	movs	r3, #2
 8002ad4:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002ad8:	6803      	ldr	r3, [r0, #0]
 8002ada:	4a19      	ldr	r2, [pc, #100]	@ (8002b40 <HAL_TIM_Base_Start+0x78>)
 8002adc:	4293      	cmp	r3, r2
 8002ade:	d020      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002ae0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8002ae4:	d01d      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002ae6:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 8002aea:	4293      	cmp	r3, r2
 8002aec:	d019      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002aee:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002af2:	4293      	cmp	r3, r2
 8002af4:	d015      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002af6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002afa:	4293      	cmp	r3, r2
 8002afc:	d011      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002afe:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
 8002b02:	4293      	cmp	r3, r2
 8002b04:	d00d      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002b06:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
 8002b0a:	4293      	cmp	r3, r2
 8002b0c:	d009      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
 8002b0e:	f5a2 3294 	sub.w	r2, r2, #75776	@ 0x12800
 8002b12:	4293      	cmp	r3, r2
 8002b14:	d005      	beq.n	8002b22 <HAL_TIM_Base_Start+0x5a>
      __HAL_TIM_ENABLE(htim);
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8002b16:	681a      	ldr	r2, [r3, #0]
 8002b18:	f042 0201 	orr.w	r2, r2, #1
 8002b1c:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8002b1e:	2000      	movs	r0, #0
 8002b20:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002b22:	689a      	ldr	r2, [r3, #8]
 8002b24:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002b28:	2a06      	cmp	r2, #6
 8002b2a:	d007      	beq.n	8002b3c <HAL_TIM_Base_Start+0x74>
      __HAL_TIM_ENABLE(htim);
 8002b2c:	681a      	ldr	r2, [r3, #0]
 8002b2e:	f042 0201 	orr.w	r2, r2, #1
 8002b32:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8002b34:	2000      	movs	r0, #0
 8002b36:	4770      	bx	lr
    return HAL_ERROR;
 8002b38:	2001      	movs	r0, #1
 8002b3a:	4770      	bx	lr
  return HAL_OK;
 8002b3c:	2000      	movs	r0, #0
}
 8002b3e:	4770      	bx	lr
 8002b40:	40010000 	.word	0x40010000

08002b44 <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8002b44:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8002b48:	b2db      	uxtb	r3, r3
 8002b4a:	2b01      	cmp	r3, #1
 8002b4c:	d137      	bne.n	8002bbe <HAL_TIM_Base_Start_IT+0x7a>
  {
    return HAL_ERROR;
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8002b4e:	2302      	movs	r3, #2
 8002b50:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002b54:	6802      	ldr	r2, [r0, #0]
 8002b56:	68d3      	ldr	r3, [r2, #12]
 8002b58:	f043 0301 	orr.w	r3, r3, #1
 8002b5c:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002b5e:	6803      	ldr	r3, [r0, #0]
 8002b60:	4a19      	ldr	r2, [pc, #100]	@ (8002bc8 <HAL_TIM_Base_Start_IT+0x84>)
 8002b62:	4293      	cmp	r3, r2
 8002b64:	d020      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b66:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8002b6a:	d01d      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b6c:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 8002b70:	4293      	cmp	r3, r2
 8002b72:	d019      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b74:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002b78:	4293      	cmp	r3, r2
 8002b7a:	d015      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b7c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002b80:	4293      	cmp	r3, r2
 8002b82:	d011      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b84:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
 8002b88:	4293      	cmp	r3, r2
 8002b8a:	d00d      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b8c:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
 8002b90:	4293      	cmp	r3, r2
 8002b92:	d009      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
 8002b94:	f5a2 3294 	sub.w	r2, r2, #75776	@ 0x12800
 8002b98:	4293      	cmp	r3, r2
 8002b9a:	d005      	beq.n	8002ba8 <HAL_TIM_Base_Start_IT+0x64>
      __HAL_TIM_ENABLE(htim);
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8002b9c:	681a      	ldr	r2, [r3, #0]
 8002b9e:	f042 0201 	orr.w	r2, r2, #1
 8002ba2:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8002ba4:	2000      	movs	r0, #0
 8002ba6:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002ba8:	689a      	ldr	r2, [r3, #8]
 8002baa:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002bae:	2a06      	cmp	r2, #6
 8002bb0:	d007      	beq.n	8002bc2 <HAL_TIM_Base_Start_IT+0x7e>
      __HAL_TIM_ENABLE(htim);
 8002bb2:	681a      	ldr	r2, [r3, #0]
 8002bb4:	f042 0201 	orr.w	r2, r2, #1
 8002bb8:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8002bba:	2000      	movs	r0, #0
 8002bbc:	4770      	bx	lr
    return HAL_ERROR;
 8002bbe:	2001      	movs	r0, #1
 8002bc0:	4770      	bx	lr
  return HAL_OK;
 8002bc2:	2000      	movs	r0, #0
}
 8002bc4:	4770      	bx	lr
 8002bc6:	bf00      	nop
 8002bc8:	40010000 	.word	0x40010000

08002bcc <HAL_TIM_OC_DelayElapsedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8002bcc:	4770      	bx	lr

08002bce <HAL_TIM_IC_CaptureCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8002bce:	4770      	bx	lr

08002bd0 <HAL_TIM_PWM_PulseFinishedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8002bd0:	4770      	bx	lr

08002bd2 <HAL_TIM_TriggerCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8002bd2:	4770      	bx	lr

08002bd4 <HAL_TIM_IRQHandler>:
{
 8002bd4:	b570      	push	{r4, r5, r6, lr}
 8002bd6:	4604      	mov	r4, r0
  uint32_t itsource = htim->Instance->DIER;
 8002bd8:	6803      	ldr	r3, [r0, #0]
 8002bda:	68de      	ldr	r6, [r3, #12]
  uint32_t itflag   = htim->Instance->SR;
 8002bdc:	691d      	ldr	r5, [r3, #16]
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8002bde:	f015 0f02 	tst.w	r5, #2
 8002be2:	d010      	beq.n	8002c06 <HAL_TIM_IRQHandler+0x32>
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 8002be4:	f016 0f02 	tst.w	r6, #2
 8002be8:	d00d      	beq.n	8002c06 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8002bea:	f06f 0202 	mvn.w	r2, #2
 8002bee:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002bf0:	2301      	movs	r3, #1
 8002bf2:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002bf4:	6803      	ldr	r3, [r0, #0]
 8002bf6:	699b      	ldr	r3, [r3, #24]
 8002bf8:	f013 0f03 	tst.w	r3, #3
 8002bfc:	d05e      	beq.n	8002cbc <HAL_TIM_IRQHandler+0xe8>
          HAL_TIM_IC_CaptureCallback(htim);
 8002bfe:	f7ff ffe6 	bl	8002bce <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002c02:	2300      	movs	r3, #0
 8002c04:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8002c06:	f015 0f04 	tst.w	r5, #4
 8002c0a:	d012      	beq.n	8002c32 <HAL_TIM_IRQHandler+0x5e>
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 8002c0c:	f016 0f04 	tst.w	r6, #4
 8002c10:	d00f      	beq.n	8002c32 <HAL_TIM_IRQHandler+0x5e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8002c12:	6823      	ldr	r3, [r4, #0]
 8002c14:	f06f 0204 	mvn.w	r2, #4
 8002c18:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002c1a:	2302      	movs	r3, #2
 8002c1c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002c1e:	6823      	ldr	r3, [r4, #0]
 8002c20:	699b      	ldr	r3, [r3, #24]
 8002c22:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8002c26:	d04f      	beq.n	8002cc8 <HAL_TIM_IRQHandler+0xf4>
        HAL_TIM_IC_CaptureCallback(htim);
 8002c28:	4620      	mov	r0, r4
 8002c2a:	f7ff ffd0 	bl	8002bce <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002c2e:	2300      	movs	r3, #0
 8002c30:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8002c32:	f015 0f08 	tst.w	r5, #8
 8002c36:	d012      	beq.n	8002c5e <HAL_TIM_IRQHandler+0x8a>
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8002c38:	f016 0f08 	tst.w	r6, #8
 8002c3c:	d00f      	beq.n	8002c5e <HAL_TIM_IRQHandler+0x8a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8002c3e:	6823      	ldr	r3, [r4, #0]
 8002c40:	f06f 0208 	mvn.w	r2, #8
 8002c44:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002c46:	2304      	movs	r3, #4
 8002c48:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002c4a:	6823      	ldr	r3, [r4, #0]
 8002c4c:	69db      	ldr	r3, [r3, #28]
 8002c4e:	f013 0f03 	tst.w	r3, #3
 8002c52:	d040      	beq.n	8002cd6 <HAL_TIM_IRQHandler+0x102>
        HAL_TIM_IC_CaptureCallback(htim);
 8002c54:	4620      	mov	r0, r4
 8002c56:	f7ff ffba 	bl	8002bce <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002c5a:	2300      	movs	r3, #0
 8002c5c:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 8002c5e:	f015 0f10 	tst.w	r5, #16
 8002c62:	d012      	beq.n	8002c8a <HAL_TIM_IRQHandler+0xb6>
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8002c64:	f016 0f10 	tst.w	r6, #16
 8002c68:	d00f      	beq.n	8002c8a <HAL_TIM_IRQHandler+0xb6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8002c6a:	6823      	ldr	r3, [r4, #0]
 8002c6c:	f06f 0210 	mvn.w	r2, #16
 8002c70:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002c72:	2308      	movs	r3, #8
 8002c74:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002c76:	6823      	ldr	r3, [r4, #0]
 8002c78:	69db      	ldr	r3, [r3, #28]
 8002c7a:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8002c7e:	d031      	beq.n	8002ce4 <HAL_TIM_IRQHandler+0x110>
        HAL_TIM_IC_CaptureCallback(htim);
 8002c80:	4620      	mov	r0, r4
 8002c82:	f7ff ffa4 	bl	8002bce <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002c86:	2300      	movs	r3, #0
 8002c88:	7723      	strb	r3, [r4, #28]
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8002c8a:	f015 0f01 	tst.w	r5, #1
 8002c8e:	d002      	beq.n	8002c96 <HAL_TIM_IRQHandler+0xc2>
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 8002c90:	f016 0f01 	tst.w	r6, #1
 8002c94:	d12d      	bne.n	8002cf2 <HAL_TIM_IRQHandler+0x11e>
  if ((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK))
 8002c96:	f015 0f80 	tst.w	r5, #128	@ 0x80
 8002c9a:	d002      	beq.n	8002ca2 <HAL_TIM_IRQHandler+0xce>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8002c9c:	f016 0f80 	tst.w	r6, #128	@ 0x80
 8002ca0:	d12f      	bne.n	8002d02 <HAL_TIM_IRQHandler+0x12e>
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 8002ca2:	f015 0f40 	tst.w	r5, #64	@ 0x40
 8002ca6:	d002      	beq.n	8002cae <HAL_TIM_IRQHandler+0xda>
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8002ca8:	f016 0f40 	tst.w	r6, #64	@ 0x40
 8002cac:	d131      	bne.n	8002d12 <HAL_TIM_IRQHandler+0x13e>
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 8002cae:	f015 0f20 	tst.w	r5, #32
 8002cb2:	d002      	beq.n	8002cba <HAL_TIM_IRQHandler+0xe6>
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 8002cb4:	f016 0f20 	tst.w	r6, #32
 8002cb8:	d133      	bne.n	8002d22 <HAL_TIM_IRQHandler+0x14e>
}
 8002cba:	bd70      	pop	{r4, r5, r6, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8002cbc:	f7ff ff86 	bl	8002bcc <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002cc0:	4620      	mov	r0, r4
 8002cc2:	f7ff ff85 	bl	8002bd0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002cc6:	e79c      	b.n	8002c02 <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002cc8:	4620      	mov	r0, r4
 8002cca:	f7ff ff7f 	bl	8002bcc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002cce:	4620      	mov	r0, r4
 8002cd0:	f7ff ff7e 	bl	8002bd0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002cd4:	e7ab      	b.n	8002c2e <HAL_TIM_IRQHandler+0x5a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002cd6:	4620      	mov	r0, r4
 8002cd8:	f7ff ff78 	bl	8002bcc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002cdc:	4620      	mov	r0, r4
 8002cde:	f7ff ff77 	bl	8002bd0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002ce2:	e7ba      	b.n	8002c5a <HAL_TIM_IRQHandler+0x86>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002ce4:	4620      	mov	r0, r4
 8002ce6:	f7ff ff71 	bl	8002bcc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002cea:	4620      	mov	r0, r4
 8002cec:	f7ff ff70 	bl	8002bd0 <HAL_TIM_PWM_PulseFinishedCallback>
 8002cf0:	e7c9      	b.n	8002c86 <HAL_TIM_IRQHandler+0xb2>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8002cf2:	6823      	ldr	r3, [r4, #0]
 8002cf4:	f06f 0201 	mvn.w	r2, #1
 8002cf8:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8002cfa:	4620      	mov	r0, r4
 8002cfc:	f7fe fabe 	bl	800127c <HAL_TIM_PeriodElapsedCallback>
 8002d00:	e7c9      	b.n	8002c96 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
 8002d02:	6823      	ldr	r3, [r4, #0]
 8002d04:	f06f 0280 	mvn.w	r2, #128	@ 0x80
 8002d08:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8002d0a:	4620      	mov	r0, r4
 8002d0c:	f000 f8ab 	bl	8002e66 <HAL_TIMEx_BreakCallback>
 8002d10:	e7c7      	b.n	8002ca2 <HAL_TIM_IRQHandler+0xce>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8002d12:	6823      	ldr	r3, [r4, #0]
 8002d14:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 8002d18:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8002d1a:	4620      	mov	r0, r4
 8002d1c:	f7ff ff59 	bl	8002bd2 <HAL_TIM_TriggerCallback>
 8002d20:	e7c5      	b.n	8002cae <HAL_TIM_IRQHandler+0xda>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8002d22:	6823      	ldr	r3, [r4, #0]
 8002d24:	f06f 0220 	mvn.w	r2, #32
 8002d28:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8002d2a:	4620      	mov	r0, r4
 8002d2c:	f000 f89a 	bl	8002e64 <HAL_TIMEx_CommutCallback>
}
 8002d30:	e7c3      	b.n	8002cba <HAL_TIM_IRQHandler+0xe6>
	...

08002d34 <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8002d34:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002d36:	4a34      	ldr	r2, [pc, #208]	@ (8002e08 <TIM_Base_SetConfig+0xd4>)
 8002d38:	4290      	cmp	r0, r2
 8002d3a:	d012      	beq.n	8002d62 <TIM_Base_SetConfig+0x2e>
 8002d3c:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 8002d40:	d00f      	beq.n	8002d62 <TIM_Base_SetConfig+0x2e>
 8002d42:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 8002d46:	4290      	cmp	r0, r2
 8002d48:	d00b      	beq.n	8002d62 <TIM_Base_SetConfig+0x2e>
 8002d4a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002d4e:	4290      	cmp	r0, r2
 8002d50:	d007      	beq.n	8002d62 <TIM_Base_SetConfig+0x2e>
 8002d52:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002d56:	4290      	cmp	r0, r2
 8002d58:	d003      	beq.n	8002d62 <TIM_Base_SetConfig+0x2e>
 8002d5a:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
 8002d5e:	4290      	cmp	r0, r2
 8002d60:	d103      	bne.n	8002d6a <TIM_Base_SetConfig+0x36>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002d62:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8002d66:	684a      	ldr	r2, [r1, #4]
 8002d68:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002d6a:	4a27      	ldr	r2, [pc, #156]	@ (8002e08 <TIM_Base_SetConfig+0xd4>)
 8002d6c:	4290      	cmp	r0, r2
 8002d6e:	d02a      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d70:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 8002d74:	d027      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d76:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
 8002d7a:	4290      	cmp	r0, r2
 8002d7c:	d023      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d7e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002d82:	4290      	cmp	r0, r2
 8002d84:	d01f      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d86:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002d8a:	4290      	cmp	r0, r2
 8002d8c:	d01b      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d8e:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
 8002d92:	4290      	cmp	r0, r2
 8002d94:	d017      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d96:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
 8002d9a:	4290      	cmp	r0, r2
 8002d9c:	d013      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002d9e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002da2:	4290      	cmp	r0, r2
 8002da4:	d00f      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002da6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002daa:	4290      	cmp	r0, r2
 8002dac:	d00b      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002dae:	f5a2 3298 	sub.w	r2, r2, #77824	@ 0x13000
 8002db2:	4290      	cmp	r0, r2
 8002db4:	d007      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002db6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002dba:	4290      	cmp	r0, r2
 8002dbc:	d003      	beq.n	8002dc6 <TIM_Base_SetConfig+0x92>
 8002dbe:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002dc2:	4290      	cmp	r0, r2
 8002dc4:	d103      	bne.n	8002dce <TIM_Base_SetConfig+0x9a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8002dc6:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002dca:	68ca      	ldr	r2, [r1, #12]
 8002dcc:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002dce:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8002dd2:	694a      	ldr	r2, [r1, #20]
 8002dd4:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8002dd6:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002dd8:	688b      	ldr	r3, [r1, #8]
 8002dda:	62c3      	str	r3, [r0, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8002ddc:	680b      	ldr	r3, [r1, #0]
 8002dde:	6283      	str	r3, [r0, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002de0:	4b09      	ldr	r3, [pc, #36]	@ (8002e08 <TIM_Base_SetConfig+0xd4>)
 8002de2:	4298      	cmp	r0, r3
 8002de4:	d003      	beq.n	8002dee <TIM_Base_SetConfig+0xba>
 8002de6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002dea:	4298      	cmp	r0, r3
 8002dec:	d101      	bne.n	8002df2 <TIM_Base_SetConfig+0xbe>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8002dee:	690b      	ldr	r3, [r1, #16]
 8002df0:	6303      	str	r3, [r0, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002df2:	2301      	movs	r3, #1
 8002df4:	6143      	str	r3, [r0, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8002df6:	6903      	ldr	r3, [r0, #16]
 8002df8:	f013 0f01 	tst.w	r3, #1
 8002dfc:	d003      	beq.n	8002e06 <TIM_Base_SetConfig+0xd2>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 8002dfe:	6903      	ldr	r3, [r0, #16]
 8002e00:	f023 0301 	bic.w	r3, r3, #1
 8002e04:	6103      	str	r3, [r0, #16]
  }
}
 8002e06:	4770      	bx	lr
 8002e08:	40010000 	.word	0x40010000

08002e0c <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8002e0c:	b340      	cbz	r0, 8002e60 <HAL_TIM_Base_Init+0x54>
{
 8002e0e:	b510      	push	{r4, lr}
 8002e10:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8002e12:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8002e16:	b1f3      	cbz	r3, 8002e56 <HAL_TIM_Base_Init+0x4a>
  htim->State = HAL_TIM_STATE_BUSY;
 8002e18:	2302      	movs	r3, #2
 8002e1a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002e1e:	4621      	mov	r1, r4
 8002e20:	f851 0b04 	ldr.w	r0, [r1], #4
 8002e24:	f7ff ff86 	bl	8002d34 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8002e28:	2301      	movs	r3, #1
 8002e2a:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002e2e:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 8002e32:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8002e36:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8002e3a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002e3e:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8002e42:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8002e46:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8002e4a:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
  htim->State = HAL_TIM_STATE_READY;
 8002e4e:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8002e52:	2000      	movs	r0, #0
}
 8002e54:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8002e56:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 8002e5a:	f7fe fc27 	bl	80016ac <HAL_TIM_Base_MspInit>
 8002e5e:	e7db      	b.n	8002e18 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8002e60:	2001      	movs	r0, #1
}
 8002e62:	4770      	bx	lr

08002e64 <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8002e64:	4770      	bx	lr

08002e66 <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8002e66:	4770      	bx	lr

08002e68 <LL_GPIO_SetPinMode>:
  *         @arg @ref LL_GPIO_MODE_ALTERNATE
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
 8002e68:	b410      	push	{r4}
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8002e6a:	6804      	ldr	r4, [r0, #0]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002e6c:	fa91 f3a1 	rbit	r3, r1
  if (value == 0U)
 8002e70:	b1a3      	cbz	r3, 8002e9c <LL_GPIO_SetPinMode+0x34>
  return __builtin_clz(value);
 8002e72:	fab3 f383 	clz	r3, r3
 8002e76:	005b      	lsls	r3, r3, #1
 8002e78:	f04f 0c03 	mov.w	ip, #3
 8002e7c:	fa0c f303 	lsl.w	r3, ip, r3
 8002e80:	ea24 0303 	bic.w	r3, r4, r3
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002e84:	fa91 f1a1 	rbit	r1, r1
  if (value == 0U)
 8002e88:	b151      	cbz	r1, 8002ea0 <LL_GPIO_SetPinMode+0x38>
  return __builtin_clz(value);
 8002e8a:	fab1 f181 	clz	r1, r1
 8002e8e:	0049      	lsls	r1, r1, #1
 8002e90:	408a      	lsls	r2, r1
 8002e92:	4313      	orrs	r3, r2
 8002e94:	6003      	str	r3, [r0, #0]
}
 8002e96:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e9a:	4770      	bx	lr
    return 32U;
 8002e9c:	2320      	movs	r3, #32
 8002e9e:	e7ea      	b.n	8002e76 <LL_GPIO_SetPinMode+0xe>
 8002ea0:	2120      	movs	r1, #32
 8002ea2:	e7f4      	b.n	8002e8e <LL_GPIO_SetPinMode+0x26>

08002ea4 <LL_GPIO_SetPinSpeed>:
  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
 8002ea4:	b410      	push	{r4}
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8002ea6:	6884      	ldr	r4, [r0, #8]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002ea8:	fa91 f3a1 	rbit	r3, r1
  if (value == 0U)
 8002eac:	b1a3      	cbz	r3, 8002ed8 <LL_GPIO_SetPinSpeed+0x34>
  return __builtin_clz(value);
 8002eae:	fab3 f383 	clz	r3, r3
 8002eb2:	005b      	lsls	r3, r3, #1
 8002eb4:	f04f 0c03 	mov.w	ip, #3
 8002eb8:	fa0c f303 	lsl.w	r3, ip, r3
 8002ebc:	ea24 0303 	bic.w	r3, r4, r3
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002ec0:	fa91 f1a1 	rbit	r1, r1
  if (value == 0U)
 8002ec4:	b151      	cbz	r1, 8002edc <LL_GPIO_SetPinSpeed+0x38>
  return __builtin_clz(value);
 8002ec6:	fab1 f181 	clz	r1, r1
 8002eca:	0049      	lsls	r1, r1, #1
 8002ecc:	408a      	lsls	r2, r1
 8002ece:	4313      	orrs	r3, r2
 8002ed0:	6083      	str	r3, [r0, #8]
             (Speed << (POSITION_VAL(Pin) * 2U)));
}
 8002ed2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002ed6:	4770      	bx	lr
    return 32U;
 8002ed8:	2320      	movs	r3, #32
 8002eda:	e7ea      	b.n	8002eb2 <LL_GPIO_SetPinSpeed+0xe>
 8002edc:	2120      	movs	r1, #32
 8002ede:	e7f4      	b.n	8002eca <LL_GPIO_SetPinSpeed+0x26>

08002ee0 <LL_GPIO_SetPinPull>:
  *         @arg @ref LL_GPIO_PULL_UP
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
 8002ee0:	b410      	push	{r4}
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8002ee2:	68c4      	ldr	r4, [r0, #12]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002ee4:	fa91 f3a1 	rbit	r3, r1
  if (value == 0U)
 8002ee8:	b1a3      	cbz	r3, 8002f14 <LL_GPIO_SetPinPull+0x34>
  return __builtin_clz(value);
 8002eea:	fab3 f383 	clz	r3, r3
 8002eee:	005b      	lsls	r3, r3, #1
 8002ef0:	f04f 0c03 	mov.w	ip, #3
 8002ef4:	fa0c f303 	lsl.w	r3, ip, r3
 8002ef8:	ea24 0303 	bic.w	r3, r4, r3
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002efc:	fa91 f1a1 	rbit	r1, r1
  if (value == 0U)
 8002f00:	b151      	cbz	r1, 8002f18 <LL_GPIO_SetPinPull+0x38>
  return __builtin_clz(value);
 8002f02:	fab1 f181 	clz	r1, r1
 8002f06:	0049      	lsls	r1, r1, #1
 8002f08:	408a      	lsls	r2, r1
 8002f0a:	4313      	orrs	r3, r2
 8002f0c:	60c3      	str	r3, [r0, #12]
}
 8002f0e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002f12:	4770      	bx	lr
    return 32U;
 8002f14:	2320      	movs	r3, #32
 8002f16:	e7ea      	b.n	8002eee <LL_GPIO_SetPinPull+0xe>
 8002f18:	2120      	movs	r1, #32
 8002f1a:	e7f4      	b.n	8002f06 <LL_GPIO_SetPinPull+0x26>

08002f1c <LL_GPIO_SetAFPin_0_7>:
  *         @arg @ref LL_GPIO_AF_14
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
 8002f1c:	b410      	push	{r4}
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8002f1e:	6a04      	ldr	r4, [r0, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002f20:	fa91 f3a1 	rbit	r3, r1
  if (value == 0U)
 8002f24:	b1a3      	cbz	r3, 8002f50 <LL_GPIO_SetAFPin_0_7+0x34>
  return __builtin_clz(value);
 8002f26:	fab3 f383 	clz	r3, r3
 8002f2a:	009b      	lsls	r3, r3, #2
 8002f2c:	f04f 0c0f 	mov.w	ip, #15
 8002f30:	fa0c f303 	lsl.w	r3, ip, r3
 8002f34:	ea24 0303 	bic.w	r3, r4, r3
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002f38:	fa91 f1a1 	rbit	r1, r1
  if (value == 0U)
 8002f3c:	b151      	cbz	r1, 8002f54 <LL_GPIO_SetAFPin_0_7+0x38>
  return __builtin_clz(value);
 8002f3e:	fab1 f181 	clz	r1, r1
 8002f42:	0089      	lsls	r1, r1, #2
 8002f44:	408a      	lsls	r2, r1
 8002f46:	4313      	orrs	r3, r2
 8002f48:	6203      	str	r3, [r0, #32]
             (Alternate << (POSITION_VAL(Pin) * 4U)));
}
 8002f4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002f4e:	4770      	bx	lr
    return 32U;
 8002f50:	2320      	movs	r3, #32
 8002f52:	e7ea      	b.n	8002f2a <LL_GPIO_SetAFPin_0_7+0xe>
 8002f54:	2120      	movs	r1, #32
 8002f56:	e7f4      	b.n	8002f42 <LL_GPIO_SetAFPin_0_7+0x26>

08002f58 <LL_GPIO_SetAFPin_8_15>:
  *         @arg @ref LL_GPIO_AF_14
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
 8002f58:	b410      	push	{r4}
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8002f5a:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 8002f5c:	0a09      	lsrs	r1, r1, #8
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002f5e:	fa91 f3a1 	rbit	r3, r1
  if (value == 0U)
 8002f62:	b1a3      	cbz	r3, 8002f8e <LL_GPIO_SetAFPin_8_15+0x36>
  return __builtin_clz(value);
 8002f64:	fab3 f383 	clz	r3, r3
 8002f68:	009b      	lsls	r3, r3, #2
 8002f6a:	f04f 0c0f 	mov.w	ip, #15
 8002f6e:	fa0c f303 	lsl.w	r3, ip, r3
 8002f72:	ea24 0403 	bic.w	r4, r4, r3
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002f76:	fa91 f1a1 	rbit	r1, r1
  if (value == 0U)
 8002f7a:	b151      	cbz	r1, 8002f92 <LL_GPIO_SetAFPin_8_15+0x3a>
  return __builtin_clz(value);
 8002f7c:	fab1 f181 	clz	r1, r1
 8002f80:	0089      	lsls	r1, r1, #2
 8002f82:	408a      	lsls	r2, r1
 8002f84:	4314      	orrs	r4, r2
 8002f86:	6244      	str	r4, [r0, #36]	@ 0x24
             (Alternate << (POSITION_VAL(Pin >> 8U) * 4U)));
}
 8002f88:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002f8c:	4770      	bx	lr
    return 32U;
 8002f8e:	2320      	movs	r3, #32
 8002f90:	e7ea      	b.n	8002f68 <LL_GPIO_SetAFPin_8_15+0x10>
 8002f92:	2120      	movs	r1, #32
 8002f94:	e7f4      	b.n	8002f80 <LL_GPIO_SetAFPin_8_15+0x28>

08002f96 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8002f96:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002f98:	4607      	mov	r7, r0
 8002f9a:	460e      	mov	r6, r1
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8002f9c:	680d      	ldr	r5, [r1, #0]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002f9e:	fa95 f5a5 	rbit	r5, r5
  if (value == 0U)
 8002fa2:	b115      	cbz	r5, 8002faa <LL_GPIO_Init+0x14>
  return __builtin_clz(value);
 8002fa4:	fab5 f585 	clz	r5, r5
 8002fa8:	e01a      	b.n	8002fe0 <LL_GPIO_Init+0x4a>
    return 32U;
 8002faa:	2520      	movs	r5, #32
  
  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8002fac:	e018      	b.n	8002fe0 <LL_GPIO_Init+0x4a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
        
        /* Speed mode configuration */
        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
 8002fae:	68b2      	ldr	r2, [r6, #8]
 8002fb0:	4621      	mov	r1, r4
 8002fb2:	4638      	mov	r0, r7
 8002fb4:	f7ff ff76 	bl	8002ea4 <LL_GPIO_SetPinSpeed>
        
        /* Check Output mode parameters */
        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
        
        /* Output mode configuration*/
        LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
 8002fb8:	68f2      	ldr	r2, [r6, #12]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8002fba:	687b      	ldr	r3, [r7, #4]
 8002fbc:	ea23 0304 	bic.w	r3, r3, r4
 8002fc0:	fb04 f202 	mul.w	r2, r4, r2
 8002fc4:	4313      	orrs	r3, r2
 8002fc6:	607b      	str	r3, [r7, #4]
}
 8002fc8:	e016      	b.n	8002ff8 <LL_GPIO_Init+0x62>
        {
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
        }
        else
        {
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8002fca:	6972      	ldr	r2, [r6, #20]
 8002fcc:	4621      	mov	r1, r4
 8002fce:	4638      	mov	r0, r7
 8002fd0:	f7ff ffc2 	bl	8002f58 <LL_GPIO_SetAFPin_8_15>
        }
      }
      
      /* Pin Mode configuration */
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 8002fd4:	6872      	ldr	r2, [r6, #4]
 8002fd6:	4621      	mov	r1, r4
 8002fd8:	4638      	mov	r0, r7
 8002fda:	f7ff ff45 	bl	8002e68 <LL_GPIO_SetPinMode>
    }
    pinpos++;
 8002fde:	3501      	adds	r5, #1
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8002fe0:	6834      	ldr	r4, [r6, #0]
 8002fe2:	fa34 f205 	lsrs.w	r2, r4, r5
 8002fe6:	d01d      	beq.n	8003024 <LL_GPIO_Init+0x8e>
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8002fe8:	2201      	movs	r2, #1
 8002fea:	40aa      	lsls	r2, r5
    if (currentpin)
 8002fec:	4014      	ands	r4, r2
 8002fee:	d0f6      	beq.n	8002fde <LL_GPIO_Init+0x48>
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8002ff0:	6873      	ldr	r3, [r6, #4]
 8002ff2:	3b01      	subs	r3, #1
 8002ff4:	2b01      	cmp	r3, #1
 8002ff6:	d9da      	bls.n	8002fae <LL_GPIO_Init+0x18>
      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
 8002ff8:	6932      	ldr	r2, [r6, #16]
 8002ffa:	4621      	mov	r1, r4
 8002ffc:	4638      	mov	r0, r7
 8002ffe:	f7ff ff6f 	bl	8002ee0 <LL_GPIO_SetPinPull>
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8003002:	6873      	ldr	r3, [r6, #4]
 8003004:	2b02      	cmp	r3, #2
 8003006:	d1e5      	bne.n	8002fd4 <LL_GPIO_Init+0x3e>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003008:	fa94 f3a4 	rbit	r3, r4
  if (value == 0U)
 800300c:	2b00      	cmp	r3, #0
 800300e:	d0dc      	beq.n	8002fca <LL_GPIO_Init+0x34>
  return __builtin_clz(value);
 8003010:	fab3 f383 	clz	r3, r3
        if (POSITION_VAL(currentpin) < 0x00000008U)
 8003014:	2b07      	cmp	r3, #7
 8003016:	d8d8      	bhi.n	8002fca <LL_GPIO_Init+0x34>
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8003018:	6972      	ldr	r2, [r6, #20]
 800301a:	4621      	mov	r1, r4
 800301c:	4638      	mov	r0, r7
 800301e:	f7ff ff7d 	bl	8002f1c <LL_GPIO_SetAFPin_0_7>
 8003022:	e7d7      	b.n	8002fd4 <LL_GPIO_Init+0x3e>
  }

  return (SUCCESS);
}
 8003024:	2000      	movs	r0, #0
 8003026:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003028 <RCC_GetHCLKClockFreq>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8003028:	4b03      	ldr	r3, [pc, #12]	@ (8003038 <RCC_GetHCLKClockFreq+0x10>)
 800302a:	689b      	ldr	r3, [r3, #8]
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 800302c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8003030:	4a02      	ldr	r2, [pc, #8]	@ (800303c <RCC_GetHCLKClockFreq+0x14>)
 8003032:	5cd3      	ldrb	r3, [r2, r3]
}
 8003034:	40d8      	lsrs	r0, r3
 8003036:	4770      	bx	lr
 8003038:	40023800 	.word	0x40023800
 800303c:	08010280 	.word	0x08010280

08003040 <RCC_GetPCLK1ClockFreq>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8003040:	4b03      	ldr	r3, [pc, #12]	@ (8003050 <RCC_GetPCLK1ClockFreq+0x10>)
 8003042:	689b      	ldr	r3, [r3, #8]
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8003044:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8003048:	4a02      	ldr	r2, [pc, #8]	@ (8003054 <RCC_GetPCLK1ClockFreq+0x14>)
 800304a:	5cd3      	ldrb	r3, [r2, r3]
}
 800304c:	40d8      	lsrs	r0, r3
 800304e:	4770      	bx	lr
 8003050:	40023800 	.word	0x40023800
 8003054:	08010278 	.word	0x08010278

08003058 <RCC_GetPCLK2ClockFreq>:
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8003058:	4b03      	ldr	r3, [pc, #12]	@ (8003068 <RCC_GetPCLK2ClockFreq+0x10>)
 800305a:	689b      	ldr	r3, [r3, #8]
  * @retval PCLK2 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK2 clock frequency */
  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 800305c:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8003060:	4a02      	ldr	r2, [pc, #8]	@ (800306c <RCC_GetPCLK2ClockFreq+0x14>)
 8003062:	5cd3      	ldrb	r3, [r2, r3]
}
 8003064:	40d8      	lsrs	r0, r3
 8003066:	4770      	bx	lr
 8003068:	40023800 	.word	0x40023800
 800306c:	08010278 	.word	0x08010278

08003070 <RCC_PLL_GetFreqDomain_SYS>:
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8003070:	4b0f      	ldr	r3, [pc, #60]	@ (80030b0 <RCC_PLL_GetFreqDomain_SYS+0x40>)
 8003072:	685b      	ldr	r3, [r3, #4]
 8003074:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
     SYSCLK = PLL_VCO / (PLLP or PLLR)
  */
  pllsource = LL_RCC_PLL_GetMainSource();

  switch (pllsource)
 8003078:	b923      	cbnz	r3, 8003084 <RCC_PLL_GetFreqDomain_SYS+0x14>
  {
    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
 800307a:	4b0e      	ldr	r3, [pc, #56]	@ (80030b4 <RCC_PLL_GetFreqDomain_SYS+0x44>)
    default:
      pllinputfreq = HSI_VALUE;
      break;
  }

  if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 800307c:	2808      	cmp	r0, #8
 800307e:	d003      	beq.n	8003088 <RCC_PLL_GetFreqDomain_SYS+0x18>
  uint32_t plloutputfreq = 0U;
 8003080:	2000      	movs	r0, #0
                                               LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }
#endif /* RCC_PLLR_SYSCLK_SUPPORT */

  return plloutputfreq;
}
 8003082:	4770      	bx	lr
      pllinputfreq = HSE_VALUE;
 8003084:	4b0c      	ldr	r3, [pc, #48]	@ (80030b8 <RCC_PLL_GetFreqDomain_SYS+0x48>)
 8003086:	e7f9      	b.n	800307c <RCC_PLL_GetFreqDomain_SYS+0xc>
  *         @arg @ref LL_RCC_PLLM_DIV_62
  *         @arg @ref LL_RCC_PLLM_DIV_63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8003088:	4a09      	ldr	r2, [pc, #36]	@ (80030b0 <RCC_PLL_GetFreqDomain_SYS+0x40>)
 800308a:	6851      	ldr	r1, [r2, #4]
 800308c:	f001 013f 	and.w	r1, r1, #63	@ 0x3f
    plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8003090:	fbb3 f0f1 	udiv	r0, r3, r1
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8003094:	6853      	ldr	r3, [r2, #4]
 8003096:	f3c3 1388 	ubfx	r3, r3, #6, #9
 800309a:	fb03 f000 	mul.w	r0, r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP));
 800309e:	6853      	ldr	r3, [r2, #4]
 80030a0:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80030a4:	3301      	adds	r3, #1
 80030a6:	005b      	lsls	r3, r3, #1
 80030a8:	fbb0 f0f3 	udiv	r0, r0, r3
 80030ac:	4770      	bx	lr
 80030ae:	bf00      	nop
 80030b0:	40023800 	.word	0x40023800
 80030b4:	00f42400 	.word	0x00f42400
 80030b8:	007a1200 	.word	0x007a1200

080030bc <RCC_GetSystemClockFreq>:
{
 80030bc:	b508      	push	{r3, lr}
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80030be:	4b08      	ldr	r3, [pc, #32]	@ (80030e0 <RCC_GetSystemClockFreq+0x24>)
 80030c0:	689b      	ldr	r3, [r3, #8]
 80030c2:	f003 030c 	and.w	r3, r3, #12
  switch (LL_RCC_GetSysClkSource())
 80030c6:	2b04      	cmp	r3, #4
 80030c8:	d005      	beq.n	80030d6 <RCC_GetSystemClockFreq+0x1a>
 80030ca:	2b08      	cmp	r3, #8
 80030cc:	d105      	bne.n	80030da <RCC_GetSystemClockFreq+0x1e>
      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);
 80030ce:	2008      	movs	r0, #8
 80030d0:	f7ff ffce 	bl	8003070 <RCC_PLL_GetFreqDomain_SYS>
}
 80030d4:	bd08      	pop	{r3, pc}
      frequency = HSE_VALUE;
 80030d6:	4803      	ldr	r0, [pc, #12]	@ (80030e4 <RCC_GetSystemClockFreq+0x28>)
 80030d8:	e7fc      	b.n	80030d4 <RCC_GetSystemClockFreq+0x18>
  switch (LL_RCC_GetSysClkSource())
 80030da:	4803      	ldr	r0, [pc, #12]	@ (80030e8 <RCC_GetSystemClockFreq+0x2c>)
  return frequency;
 80030dc:	e7fa      	b.n	80030d4 <RCC_GetSystemClockFreq+0x18>
 80030de:	bf00      	nop
 80030e0:	40023800 	.word	0x40023800
 80030e4:	007a1200 	.word	0x007a1200
 80030e8:	00f42400 	.word	0x00f42400

080030ec <LL_RCC_GetSystemClocksFreq>:
{
 80030ec:	b510      	push	{r4, lr}
 80030ee:	4604      	mov	r4, r0
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
 80030f0:	f7ff ffe4 	bl	80030bc <RCC_GetSystemClockFreq>
 80030f4:	6020      	str	r0, [r4, #0]
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
 80030f6:	f7ff ff97 	bl	8003028 <RCC_GetHCLKClockFreq>
 80030fa:	6060      	str	r0, [r4, #4]
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
 80030fc:	f7ff ffa0 	bl	8003040 <RCC_GetPCLK1ClockFreq>
 8003100:	60a0      	str	r0, [r4, #8]
  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
 8003102:	6860      	ldr	r0, [r4, #4]
 8003104:	f7ff ffa8 	bl	8003058 <RCC_GetPCLK2ClockFreq>
 8003108:	60e0      	str	r0, [r4, #12]
}
 800310a:	bd10      	pop	{r4, pc}

0800310c <LL_USART_SetBaudRate>:
{
 800310c:	b510      	push	{r4, lr}
 800310e:	4604      	mov	r4, r0
  if (OverSampling == LL_USART_OVERSAMPLING_8)
 8003110:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8003114:	d02f      	beq.n	8003176 <LL_USART_SetBaudRate+0x6a>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 8003116:	f04f 0c00 	mov.w	ip, #0
 800311a:	1848      	adds	r0, r1, r1
 800311c:	eb4c 0c0c 	adc.w	ip, ip, ip
 8003120:	1840      	adds	r0, r0, r1
 8003122:	f14c 0c00 	adc.w	ip, ip, #0
 8003126:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800312a:	ea4c 7c50 	orr.w	ip, ip, r0, lsr #29
 800312e:	00c0      	lsls	r0, r0, #3
 8003130:	1840      	adds	r0, r0, r1
 8003132:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8003136:	ea4f 7393 	mov.w	r3, r3, lsr #30
 800313a:	f14c 0100 	adc.w	r1, ip, #0
 800313e:	f7fd faeb 	bl	8000718 <__aeabi_uldivmod>
 8003142:	4924      	ldr	r1, [pc, #144]	@ (80031d4 <LL_USART_SetBaudRate+0xc8>)
 8003144:	fba1 2300 	umull	r2, r3, r1, r0
 8003148:	095b      	lsrs	r3, r3, #5
 800314a:	011a      	lsls	r2, r3, #4
 800314c:	b292      	uxth	r2, r2
 800314e:	f04f 0c64 	mov.w	ip, #100	@ 0x64
 8003152:	fb0c 0313 	mls	r3, ip, r3, r0
 8003156:	011b      	lsls	r3, r3, #4
 8003158:	3332      	adds	r3, #50	@ 0x32
 800315a:	fba1 1303 	umull	r1, r3, r1, r3
 800315e:	f3c3 134f 	ubfx	r3, r3, #5, #16
 8003162:	f003 01f0 	and.w	r1, r3, #240	@ 0xf0
 8003166:	440a      	add	r2, r1
 8003168:	b292      	uxth	r2, r2
 800316a:	f003 030f 	and.w	r3, r3, #15
 800316e:	4413      	add	r3, r2
 8003170:	b29b      	uxth	r3, r3
 8003172:	60a3      	str	r3, [r4, #8]
}
 8003174:	bd10      	pop	{r4, pc}
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 8003176:	f04f 0c00 	mov.w	ip, #0
 800317a:	1848      	adds	r0, r1, r1
 800317c:	eb4c 020c 	adc.w	r2, ip, ip
 8003180:	1840      	adds	r0, r0, r1
 8003182:	f142 0200 	adc.w	r2, r2, #0
 8003186:	00d2      	lsls	r2, r2, #3
 8003188:	ea42 7250 	orr.w	r2, r2, r0, lsr #29
 800318c:	00c0      	lsls	r0, r0, #3
 800318e:	1840      	adds	r0, r0, r1
 8003190:	f142 0100 	adc.w	r1, r2, #0
 8003194:	18da      	adds	r2, r3, r3
 8003196:	eb4c 030c 	adc.w	r3, ip, ip
 800319a:	f7fd fabd 	bl	8000718 <__aeabi_uldivmod>
 800319e:	490d      	ldr	r1, [pc, #52]	@ (80031d4 <LL_USART_SetBaudRate+0xc8>)
 80031a0:	fba1 2300 	umull	r2, r3, r1, r0
 80031a4:	095b      	lsrs	r3, r3, #5
 80031a6:	011a      	lsls	r2, r3, #4
 80031a8:	b292      	uxth	r2, r2
 80031aa:	f04f 0c64 	mov.w	ip, #100	@ 0x64
 80031ae:	fb0c 0313 	mls	r3, ip, r3, r0
 80031b2:	00db      	lsls	r3, r3, #3
 80031b4:	3332      	adds	r3, #50	@ 0x32
 80031b6:	fba1 1303 	umull	r1, r3, r1, r3
 80031ba:	f3c3 134f 	ubfx	r3, r3, #5, #16
 80031be:	0059      	lsls	r1, r3, #1
 80031c0:	f401 71f8 	and.w	r1, r1, #496	@ 0x1f0
 80031c4:	440a      	add	r2, r1
 80031c6:	b292      	uxth	r2, r2
 80031c8:	f003 0307 	and.w	r3, r3, #7
 80031cc:	4413      	add	r3, r2
 80031ce:	b29b      	uxth	r3, r3
 80031d0:	60a3      	str	r3, [r4, #8]
 80031d2:	e7cf      	b.n	8003174 <LL_USART_SetBaudRate+0x68>
 80031d4:	51eb851f 	.word	0x51eb851f

080031d8 <LL_USART_Init>:
  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
 80031d8:	68c3      	ldr	r3, [r0, #12]
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
 80031da:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 80031de:	d001      	beq.n	80031e4 <LL_USART_Init+0xc>
  ErrorStatus status = ERROR;
 80031e0:	2001      	movs	r0, #1
    }
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 80031e2:	4770      	bx	lr
{
 80031e4:	b530      	push	{r4, r5, lr}
 80031e6:	b085      	sub	sp, #20
 80031e8:	4604      	mov	r4, r0
 80031ea:	460d      	mov	r5, r1
    MODIFY_REG(USARTx->CR1,
 80031ec:	68c3      	ldr	r3, [r0, #12]
 80031ee:	f423 4316 	bic.w	r3, r3, #38400	@ 0x9600
 80031f2:	f023 030c 	bic.w	r3, r3, #12
 80031f6:	684a      	ldr	r2, [r1, #4]
 80031f8:	68c9      	ldr	r1, [r1, #12]
 80031fa:	430a      	orrs	r2, r1
 80031fc:	6929      	ldr	r1, [r5, #16]
 80031fe:	430a      	orrs	r2, r1
 8003200:	69a9      	ldr	r1, [r5, #24]
 8003202:	430a      	orrs	r2, r1
 8003204:	4313      	orrs	r3, r2
 8003206:	60c3      	str	r3, [r0, #12]
    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
 8003208:	68ab      	ldr	r3, [r5, #8]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 800320a:	6902      	ldr	r2, [r0, #16]
 800320c:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 8003210:	4313      	orrs	r3, r2
 8003212:	6103      	str	r3, [r0, #16]
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
 8003214:	696b      	ldr	r3, [r5, #20]
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 8003216:	6942      	ldr	r2, [r0, #20]
 8003218:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 800321c:	4313      	orrs	r3, r2
 800321e:	6143      	str	r3, [r0, #20]
    LL_RCC_GetSystemClocksFreq(&rcc_clocks);
 8003220:	4668      	mov	r0, sp
 8003222:	f7ff ff63 	bl	80030ec <LL_RCC_GetSystemClocksFreq>
    if (USARTx == USART1)
 8003226:	4b1b      	ldr	r3, [pc, #108]	@ (8003294 <LL_USART_Init+0xbc>)
 8003228:	429c      	cmp	r4, r3
 800322a:	d016      	beq.n	800325a <LL_USART_Init+0x82>
    else if (USARTx == USART2)
 800322c:	4b1a      	ldr	r3, [pc, #104]	@ (8003298 <LL_USART_Init+0xc0>)
 800322e:	429c      	cmp	r4, r3
 8003230:	d019      	beq.n	8003266 <LL_USART_Init+0x8e>
    else if (USARTx == USART3)
 8003232:	4b1a      	ldr	r3, [pc, #104]	@ (800329c <LL_USART_Init+0xc4>)
 8003234:	429c      	cmp	r4, r3
 8003236:	d018      	beq.n	800326a <LL_USART_Init+0x92>
    else if (USARTx == USART6)
 8003238:	4b19      	ldr	r3, [pc, #100]	@ (80032a0 <LL_USART_Init+0xc8>)
 800323a:	429c      	cmp	r4, r3
 800323c:	d017      	beq.n	800326e <LL_USART_Init+0x96>
    else if (USARTx == UART4)
 800323e:	4b19      	ldr	r3, [pc, #100]	@ (80032a4 <LL_USART_Init+0xcc>)
 8003240:	429c      	cmp	r4, r3
 8003242:	d016      	beq.n	8003272 <LL_USART_Init+0x9a>
    else if (USARTx == UART5)
 8003244:	4b18      	ldr	r3, [pc, #96]	@ (80032a8 <LL_USART_Init+0xd0>)
 8003246:	429c      	cmp	r4, r3
 8003248:	d015      	beq.n	8003276 <LL_USART_Init+0x9e>
    else if (USARTx == UART7)
 800324a:	4b18      	ldr	r3, [pc, #96]	@ (80032ac <LL_USART_Init+0xd4>)
 800324c:	429c      	cmp	r4, r3
 800324e:	d014      	beq.n	800327a <LL_USART_Init+0xa2>
    else if (USARTx == UART8)
 8003250:	4b17      	ldr	r3, [pc, #92]	@ (80032b0 <LL_USART_Init+0xd8>)
 8003252:	429c      	cmp	r4, r3
 8003254:	d013      	beq.n	800327e <LL_USART_Init+0xa6>
  ErrorStatus status = ERROR;
 8003256:	2001      	movs	r0, #1
 8003258:	e01a      	b.n	8003290 <LL_USART_Init+0xb8>
      periphclk = rcc_clocks.PCLK2_Frequency;
 800325a:	9903      	ldr	r1, [sp, #12]
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 800325c:	b1b9      	cbz	r1, 800328e <LL_USART_Init+0xb6>
        && (USART_InitStruct->BaudRate != 0U))
 800325e:	682b      	ldr	r3, [r5, #0]
 8003260:	b97b      	cbnz	r3, 8003282 <LL_USART_Init+0xaa>
  ErrorStatus status = ERROR;
 8003262:	2001      	movs	r0, #1
 8003264:	e014      	b.n	8003290 <LL_USART_Init+0xb8>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8003266:	9902      	ldr	r1, [sp, #8]
 8003268:	e7f8      	b.n	800325c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 800326a:	9902      	ldr	r1, [sp, #8]
 800326c:	e7f6      	b.n	800325c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK2_Frequency;
 800326e:	9903      	ldr	r1, [sp, #12]
 8003270:	e7f4      	b.n	800325c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8003272:	9902      	ldr	r1, [sp, #8]
 8003274:	e7f2      	b.n	800325c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8003276:	9902      	ldr	r1, [sp, #8]
 8003278:	e7f0      	b.n	800325c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 800327a:	9902      	ldr	r1, [sp, #8]
 800327c:	e7ee      	b.n	800325c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 800327e:	9902      	ldr	r1, [sp, #8]
 8003280:	e7ec      	b.n	800325c <LL_USART_Init+0x84>
      LL_USART_SetBaudRate(USARTx,
 8003282:	69aa      	ldr	r2, [r5, #24]
 8003284:	4620      	mov	r0, r4
 8003286:	f7ff ff41 	bl	800310c <LL_USART_SetBaudRate>
      status = SUCCESS;
 800328a:	2000      	movs	r0, #0
 800328c:	e000      	b.n	8003290 <LL_USART_Init+0xb8>
  ErrorStatus status = ERROR;
 800328e:	2001      	movs	r0, #1
}
 8003290:	b005      	add	sp, #20
 8003292:	bd30      	pop	{r4, r5, pc}
 8003294:	40011000 	.word	0x40011000
 8003298:	40004400 	.word	0x40004400
 800329c:	40004800 	.word	0x40004800
 80032a0:	40011400 	.word	0x40011400
 80032a4:	40004c00 	.word	0x40004c00
 80032a8:	40005000 	.word	0x40005000
 80032ac:	40007800 	.word	0x40007800
 80032b0:	40007c00 	.word	0x40007c00

080032b4 <delay_us>:

extern SPI_HandleTypeDef hspi4;
extern TIM_HandleTypeDef htim14;
static const TIM_HandleTypeDef* tim_handle = &htim14;

static inline void delay_us(uint32_t us) {
 80032b4:	b082      	sub	sp, #8
	__HAL_TIM_SetCounter(tim_handle, 0);
 80032b6:	4b0c      	ldr	r3, [pc, #48]	@ (80032e8 <delay_us+0x34>)
 80032b8:	681a      	ldr	r2, [r3, #0]
 80032ba:	2300      	movs	r3, #0
 80032bc:	6253      	str	r3, [r2, #36]	@ 0x24
	volatile uint16_t count_to = us;
 80032be:	b280      	uxth	r0, r0
 80032c0:	f8ad 0006 	strh.w	r0, [sp, #6]
	volatile uint16_t counter = 0;
 80032c4:	f8ad 3004 	strh.w	r3, [sp, #4]
	while (1) {
		counter = __HAL_TIM_GetCounter(tim_handle);
 80032c8:	4b07      	ldr	r3, [pc, #28]	@ (80032e8 <delay_us+0x34>)
 80032ca:	681b      	ldr	r3, [r3, #0]
 80032cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80032ce:	b29b      	uxth	r3, r3
 80032d0:	f8ad 3004 	strh.w	r3, [sp, #4]
		if(counter >= count_to) {
 80032d4:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80032d8:	b292      	uxth	r2, r2
 80032da:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80032de:	b29b      	uxth	r3, r3
 80032e0:	429a      	cmp	r2, r3
 80032e2:	d3f1      	bcc.n	80032c8 <delay_us+0x14>
			break;
		}
	}
}
 80032e4:	b002      	add	sp, #8
 80032e6:	4770      	bx	lr
 80032e8:	20000754 	.word	0x20000754

080032ec <SPI_CS_Deassert>:

static inline void SPI_CS_Assert(void) {
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
}

static inline void SPI_CS_Deassert(void) {
 80032ec:	b508      	push	{r3, lr}
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);
 80032ee:	2201      	movs	r2, #1
 80032f0:	2110      	movs	r1, #16
 80032f2:	4803      	ldr	r0, [pc, #12]	@ (8003300 <SPI_CS_Deassert+0x14>)
 80032f4:	f7fe fc6e 	bl	8001bd4 <HAL_GPIO_WritePin>
	delay_us(1);
 80032f8:	2001      	movs	r0, #1
 80032fa:	f7ff ffdb 	bl	80032b4 <delay_us>
}
 80032fe:	bd08      	pop	{r3, pc}
 8003300:	40021000 	.word	0x40021000

08003304 <softReset>:
static uint16_t gNextPacketPtr;
static uint8_t  erxfcon;
static uint8_t  macaddr[6] = {0xaa, 0xbb, 0xcc, 0xee, 0x11, 0x22};


void softReset(void) {
 8003304:	b500      	push	{lr}
 8003306:	b083      	sub	sp, #12
	uint8_t cmd = 0xFF;
 8003308:	23ff      	movs	r3, #255	@ 0xff
 800330a:	f88d 3007 	strb.w	r3, [sp, #7]
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
 800330e:	2200      	movs	r2, #0
 8003310:	2110      	movs	r1, #16
 8003312:	4808      	ldr	r0, [pc, #32]	@ (8003334 <softReset+0x30>)
 8003314:	f7fe fc5e 	bl	8001bd4 <HAL_GPIO_WritePin>
	//  ptrSPI->Control (ARM_SPI_CONTROL_SS, ARM_SPI_SS_ACTIVE)
	SPI_CS_Assert();
	;
	HAL_SPI_Transmit(&hspi4, &cmd, 1, HAL_MAX_DELAY);
 8003318:	f04f 33ff 	mov.w	r3, #4294967295
 800331c:	2201      	movs	r2, #1
 800331e:	f10d 0107 	add.w	r1, sp, #7
 8003322:	4805      	ldr	r0, [pc, #20]	@ (8003338 <softReset+0x34>)
 8003324:	f7ff f8fd 	bl	8002522 <HAL_SPI_Transmit>

	SPI_CS_Deassert();
 8003328:	f7ff ffe0 	bl	80032ec <SPI_CS_Deassert>
}
 800332c:	b003      	add	sp, #12
 800332e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003332:	bf00      	nop
 8003334:	40021000 	.word	0x40021000
 8003338:	2000079c 	.word	0x2000079c

0800333c <writeOperation>:



void writeOperation(uint8_t operation, uint8_t address, uint8_t data) {
 800333c:	b500      	push	{lr}
 800333e:	b083      	sub	sp, #12
	uint8_t out[2];
	out[0] = operation | (address & ADDR_MASK);
 8003340:	f001 011f 	and.w	r1, r1, #31
 8003344:	4308      	orrs	r0, r1
 8003346:	f88d 0004 	strb.w	r0, [sp, #4]
	out[1] = data;
 800334a:	f88d 2005 	strb.w	r2, [sp, #5]
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
 800334e:	2200      	movs	r2, #0
 8003350:	2110      	movs	r1, #16
 8003352:	480b      	ldr	r0, [pc, #44]	@ (8003380 <writeOperation+0x44>)
 8003354:	f7fe fc3e 	bl	8001bd4 <HAL_GPIO_WritePin>

	SPI_CS_Assert();
	//  ptrSPI->Send (&out, 2);
	HAL_SPI_Transmit(&hspi4, out, 2, HAL_MAX_DELAY);
 8003358:	f04f 33ff 	mov.w	r3, #4294967295
 800335c:	2202      	movs	r2, #2
 800335e:	a901      	add	r1, sp, #4
 8003360:	4808      	ldr	r0, [pc, #32]	@ (8003384 <writeOperation+0x48>)
 8003362:	f7ff f8de 	bl	8002522 <HAL_SPI_Transmit>

	while (HAL_SPI_GetState(&hspi4) != HAL_SPI_STATE_READY) { // may be BUSY_TX as well
 8003366:	4807      	ldr	r0, [pc, #28]	@ (8003384 <writeOperation+0x48>)
 8003368:	f7ff fbab 	bl	8002ac2 <HAL_SPI_GetState>
 800336c:	2801      	cmp	r0, #1
 800336e:	d1fa      	bne.n	8003366 <writeOperation+0x2a>
		;
	}

	SPI_CS_Deassert();
 8003370:	f7ff ffbc 	bl	80032ec <SPI_CS_Deassert>
	delay_us(1);
 8003374:	2001      	movs	r0, #1
 8003376:	f7ff ff9d 	bl	80032b4 <delay_us>
}
 800337a:	b003      	add	sp, #12
 800337c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003380:	40021000 	.word	0x40021000
 8003384:	2000079c 	.word	0x2000079c

08003388 <readOperation>:

uint8_t readOperation(uint8_t operation, uint8_t address) {
 8003388:	b510      	push	{r4, lr}
 800338a:	b082      	sub	sp, #8
 800338c:	460c      	mov	r4, r1
	uint8_t result;
	uint8_t out = (operation | (address & ADDR_MASK));
 800338e:	f001 031f 	and.w	r3, r1, #31
 8003392:	4318      	orrs	r0, r3
 8003394:	f88d 0007 	strb.w	r0, [sp, #7]
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
 8003398:	2200      	movs	r2, #0
 800339a:	2110      	movs	r1, #16
 800339c:	4822      	ldr	r0, [pc, #136]	@ (8003428 <readOperation+0xa0>)
 800339e:	f7fe fc19 	bl	8001bd4 <HAL_GPIO_WritePin>
	uint8_t in[2];

	SPI_CS_Assert();

	// issue read command
	if (address & 0x80) {
 80033a2:	f014 0f80 	tst.w	r4, #128	@ 0x80
 80033a6:	d122      	bne.n	80033ee <readOperation+0x66>
		while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
			;
		}
		result = in[1];
	} else{
		HAL_SPI_Transmit(&hspi4, &out, 1, HAL_MAX_DELAY);
 80033a8:	f04f 33ff 	mov.w	r3, #4294967295
 80033ac:	2201      	movs	r2, #1
 80033ae:	f10d 0107 	add.w	r1, sp, #7
 80033b2:	481e      	ldr	r0, [pc, #120]	@ (800342c <readOperation+0xa4>)
 80033b4:	f7ff f8b5 	bl	8002522 <HAL_SPI_Transmit>
		while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
 80033b8:	481c      	ldr	r0, [pc, #112]	@ (800342c <readOperation+0xa4>)
 80033ba:	f7ff fb82 	bl	8002ac2 <HAL_SPI_GetState>
 80033be:	2803      	cmp	r0, #3
 80033c0:	d0fa      	beq.n	80033b8 <readOperation+0x30>
			;
		}
		HAL_SPI_Receive(&hspi4, in, 1, HAL_MAX_DELAY);
 80033c2:	f04f 33ff 	mov.w	r3, #4294967295
 80033c6:	2201      	movs	r2, #1
 80033c8:	a901      	add	r1, sp, #4
 80033ca:	4818      	ldr	r0, [pc, #96]	@ (800342c <readOperation+0xa4>)
 80033cc:	f7ff fab5 	bl	800293a <HAL_SPI_Receive>
		while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
 80033d0:	4816      	ldr	r0, [pc, #88]	@ (800342c <readOperation+0xa4>)
 80033d2:	f7ff fb76 	bl	8002ac2 <HAL_SPI_GetState>
 80033d6:	2803      	cmp	r0, #3
 80033d8:	d0fa      	beq.n	80033d0 <readOperation+0x48>
			;
		}
		result = in[0];
 80033da:	f89d 4004 	ldrb.w	r4, [sp, #4]
	}
	SPI_CS_Deassert();
 80033de:	f7ff ff85 	bl	80032ec <SPI_CS_Deassert>
	delay_us(1);
 80033e2:	2001      	movs	r0, #1
 80033e4:	f7ff ff66 	bl	80032b4 <delay_us>
	return result;
}
 80033e8:	4620      	mov	r0, r4
 80033ea:	b002      	add	sp, #8
 80033ec:	bd10      	pop	{r4, pc}
		HAL_SPI_Transmit(&hspi4, &out, 1, HAL_MAX_DELAY);
 80033ee:	f04f 33ff 	mov.w	r3, #4294967295
 80033f2:	2201      	movs	r2, #1
 80033f4:	f10d 0107 	add.w	r1, sp, #7
 80033f8:	480c      	ldr	r0, [pc, #48]	@ (800342c <readOperation+0xa4>)
 80033fa:	f7ff f892 	bl	8002522 <HAL_SPI_Transmit>
		while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
 80033fe:	480b      	ldr	r0, [pc, #44]	@ (800342c <readOperation+0xa4>)
 8003400:	f7ff fb5f 	bl	8002ac2 <HAL_SPI_GetState>
 8003404:	2803      	cmp	r0, #3
 8003406:	d0fa      	beq.n	80033fe <readOperation+0x76>
		HAL_SPI_Receive(&hspi4, in, 2, HAL_MAX_DELAY);
 8003408:	f04f 33ff 	mov.w	r3, #4294967295
 800340c:	2202      	movs	r2, #2
 800340e:	a901      	add	r1, sp, #4
 8003410:	4806      	ldr	r0, [pc, #24]	@ (800342c <readOperation+0xa4>)
 8003412:	f7ff fa92 	bl	800293a <HAL_SPI_Receive>
		while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
 8003416:	4805      	ldr	r0, [pc, #20]	@ (800342c <readOperation+0xa4>)
 8003418:	f7ff fb53 	bl	8002ac2 <HAL_SPI_GetState>
 800341c:	2803      	cmp	r0, #3
 800341e:	d0fa      	beq.n	8003416 <readOperation+0x8e>
		result = in[1];
 8003420:	f89d 4005 	ldrb.w	r4, [sp, #5]
 8003424:	e7db      	b.n	80033de <readOperation+0x56>
 8003426:	bf00      	nop
 8003428:	40021000 	.word	0x40021000
 800342c:	2000079c 	.word	0x2000079c

08003430 <setBank>:

void setBank(uint8_t address) {
 8003430:	b538      	push	{r3, r4, r5, lr}
	static int currentBank = 0;
	// set the bank (if needed)
	if ((address & BANK_MASK) != currentBank) {
 8003432:	f000 0560 	and.w	r5, r0, #96	@ 0x60
 8003436:	4b0a      	ldr	r3, [pc, #40]	@ (8003460 <setBank+0x30>)
 8003438:	681b      	ldr	r3, [r3, #0]
 800343a:	429d      	cmp	r5, r3
 800343c:	d100      	bne.n	8003440 <setBank+0x10>
		// set the bank
		writeOperation(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1 | ECON1_BSEL0));
		writeOperation(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK) >> 5);
		currentBank = (address & BANK_MASK);
	}
}
 800343e:	bd38      	pop	{r3, r4, r5, pc}
 8003440:	4604      	mov	r4, r0
		writeOperation(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1 | ECON1_BSEL0));
 8003442:	2203      	movs	r2, #3
 8003444:	211f      	movs	r1, #31
 8003446:	20a0      	movs	r0, #160	@ 0xa0
 8003448:	f7ff ff78 	bl	800333c <writeOperation>
		writeOperation(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK) >> 5);
 800344c:	f3c4 1241 	ubfx	r2, r4, #5, #2
 8003450:	211f      	movs	r1, #31
 8003452:	2080      	movs	r0, #128	@ 0x80
 8003454:	f7ff ff72 	bl	800333c <writeOperation>
		currentBank = (address & BANK_MASK);
 8003458:	4b01      	ldr	r3, [pc, #4]	@ (8003460 <setBank+0x30>)
 800345a:	601d      	str	r5, [r3, #0]
}
 800345c:	e7ef      	b.n	800343e <setBank+0xe>
 800345e:	bf00      	nop
 8003460:	20000cb0 	.word	0x20000cb0

08003464 <readControlRegister>:

uint8_t readControlRegister (uint8_t reg) {
 8003464:	b510      	push	{r4, lr}
 8003466:	4604      	mov	r4, r0

	// set the bank (if needed)
	setBank(reg);
 8003468:	f7ff ffe2 	bl	8003430 <setBank>
	// do the read
	return readOperation(ENC28J60_READ_CTRL_REG, reg);
 800346c:	4621      	mov	r1, r4
 800346e:	2000      	movs	r0, #0
 8003470:	f7ff ff8a 	bl	8003388 <readOperation>
}
 8003474:	bd10      	pop	{r4, pc}

08003476 <writeControlRegister8>:

void writeControlRegister8 (uint8_t reg, uint8_t value) {
 8003476:	b538      	push	{r3, r4, r5, lr}
 8003478:	4604      	mov	r4, r0
 800347a:	460d      	mov	r5, r1
	// set the bank (if needed)
	setBank(reg);
 800347c:	f7ff ffd8 	bl	8003430 <setBank>
	// do the write
	writeOperation(ENC28J60_WRITE_CTRL_REG, reg, value);
 8003480:	462a      	mov	r2, r5
 8003482:	4621      	mov	r1, r4
 8003484:	2040      	movs	r0, #64	@ 0x40
 8003486:	f7ff ff59 	bl	800333c <writeOperation>
}
 800348a:	bd38      	pop	{r3, r4, r5, pc}

0800348c <writeControlRegister16>:

void writeControlRegister16(uint8_t reg, uint16_t value) {
 800348c:	b538      	push	{r3, r4, r5, lr}
 800348e:	4604      	mov	r4, r0
 8003490:	460d      	mov	r5, r1
	// set the bank (if needed)
	setBank(reg);
 8003492:	f7ff ffcd 	bl	8003430 <setBank>
	// do the write
	writeOperation(ENC28J60_WRITE_CTRL_REG, reg, value & 0xff);
 8003496:	b2ea      	uxtb	r2, r5
 8003498:	4621      	mov	r1, r4
 800349a:	2040      	movs	r0, #64	@ 0x40
 800349c:	f7ff ff4e 	bl	800333c <writeOperation>
	writeOperation(ENC28J60_WRITE_CTRL_REG, reg+1, (uint8_t)(value >> 8));
 80034a0:	3401      	adds	r4, #1
 80034a2:	0a2a      	lsrs	r2, r5, #8
 80034a4:	b2e1      	uxtb	r1, r4
 80034a6:	2040      	movs	r0, #64	@ 0x40
 80034a8:	f7ff ff48 	bl	800333c <writeOperation>
}
 80034ac:	bd38      	pop	{r3, r4, r5, pc}

080034ae <readPhyRegister>:


uint16_t readPhyRegister(uint8_t address) {
 80034ae:	b510      	push	{r4, lr}
 80034b0:	4601      	mov	r1, r0
	uint16_t value = 0xFFFF;

	writeControlRegister8(MIREGADR, address);
 80034b2:	20d4      	movs	r0, #212	@ 0xd4
 80034b4:	f7ff ffdf 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MICMD, MICMD_MIIRD);
 80034b8:	2101      	movs	r1, #1
 80034ba:	20d2      	movs	r0, #210	@ 0xd2
 80034bc:	f7ff ffdb 	bl	8003476 <writeControlRegister8>
	// wait until the PHY read completes
	while (readControlRegister(MISTAT) & MISTAT_BUSY) {
 80034c0:	20ea      	movs	r0, #234	@ 0xea
 80034c2:	f7ff ffcf 	bl	8003464 <readControlRegister>
 80034c6:	f010 0f01 	tst.w	r0, #1
 80034ca:	d1f9      	bne.n	80034c0 <readPhyRegister+0x12>
		;
	}
	writeControlRegister8(MICMD, 0);
 80034cc:	2100      	movs	r1, #0
 80034ce:	20d2      	movs	r0, #210	@ 0xd2
 80034d0:	f7ff ffd1 	bl	8003476 <writeControlRegister8>
	value = (readControlRegister(MIRDL) | readControlRegister(MIRDH) << 8);
 80034d4:	20d8      	movs	r0, #216	@ 0xd8
 80034d6:	f7ff ffc5 	bl	8003464 <readControlRegister>
 80034da:	b204      	sxth	r4, r0
 80034dc:	20d9      	movs	r0, #217	@ 0xd9
 80034de:	f7ff ffc1 	bl	8003464 <readControlRegister>
 80034e2:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
	return value;
}
 80034e6:	b280      	uxth	r0, r0
 80034e8:	bd10      	pop	{r4, pc}

080034ea <writePhyRegister>:

void writePhyRegister(uint8_t address, uint16_t value) {
 80034ea:	b510      	push	{r4, lr}
 80034ec:	460c      	mov	r4, r1
	// set the PHY register address
	writeControlRegister8(MIREGADR, address);
 80034ee:	4601      	mov	r1, r0
 80034f0:	20d4      	movs	r0, #212	@ 0xd4
 80034f2:	f7ff ffc0 	bl	8003476 <writeControlRegister8>
	// write the PHY data
	writeControlRegister16(MIWRL, value);
 80034f6:	4621      	mov	r1, r4
 80034f8:	20d6      	movs	r0, #214	@ 0xd6
 80034fa:	f7ff ffc7 	bl	800348c <writeControlRegister16>
	// wait until the PHY write completes
	while (readControlRegister(MISTAT) & MISTAT_BUSY) {
 80034fe:	20ea      	movs	r0, #234	@ 0xea
 8003500:	f7ff ffb0 	bl	8003464 <readControlRegister>
 8003504:	f010 0f01 	tst.w	r0, #1
 8003508:	d1f9      	bne.n	80034fe <writePhyRegister+0x14>
		;
	}
}
 800350a:	bd10      	pop	{r4, pc}

0800350c <writeBuffer>:

void writeBuffer(const uint8_t* data, uint32_t len)
{
 800350c:	b530      	push	{r4, r5, lr}
 800350e:	b083      	sub	sp, #12
 8003510:	4604      	mov	r4, r0
 8003512:	460d      	mov	r5, r1
	uint8_t cmd = ENC28J60_WRITE_BUF_MEM;
 8003514:	237a      	movs	r3, #122	@ 0x7a
 8003516:	f88d 3007 	strb.w	r3, [sp, #7]
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
 800351a:	2200      	movs	r2, #0
 800351c:	2110      	movs	r1, #16
 800351e:	4810      	ldr	r0, [pc, #64]	@ (8003560 <writeBuffer+0x54>)
 8003520:	f7fe fb58 	bl	8001bd4 <HAL_GPIO_WritePin>
	//	ptrSPI->Control (ARM_SPI_CONTROL_SS, ARM_SPI_SS_ACTIVE);
	SPI_CS_Assert();
	HAL_SPI_Transmit(&hspi4, &cmd, 1, HAL_MAX_DELAY);
 8003524:	f04f 33ff 	mov.w	r3, #4294967295
 8003528:	2201      	movs	r2, #1
 800352a:	f10d 0107 	add.w	r1, sp, #7
 800352e:	480d      	ldr	r0, [pc, #52]	@ (8003564 <writeBuffer+0x58>)
 8003530:	f7fe fff7 	bl	8002522 <HAL_SPI_Transmit>
	while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
 8003534:	480b      	ldr	r0, [pc, #44]	@ (8003564 <writeBuffer+0x58>)
 8003536:	f7ff fac4 	bl	8002ac2 <HAL_SPI_GetState>
 800353a:	2803      	cmp	r0, #3
 800353c:	d0fa      	beq.n	8003534 <writeBuffer+0x28>
		;
	}
	//	ptrSPI->Send (data, len);
	HAL_SPI_Transmit(&hspi4, data, len, HAL_MAX_DELAY);
 800353e:	f04f 33ff 	mov.w	r3, #4294967295
 8003542:	b2aa      	uxth	r2, r5
 8003544:	4621      	mov	r1, r4
 8003546:	4807      	ldr	r0, [pc, #28]	@ (8003564 <writeBuffer+0x58>)
 8003548:	f7fe ffeb 	bl	8002522 <HAL_SPI_Transmit>
	while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_TX) {
 800354c:	4805      	ldr	r0, [pc, #20]	@ (8003564 <writeBuffer+0x58>)
 800354e:	f7ff fab8 	bl	8002ac2 <HAL_SPI_GetState>
 8003552:	2803      	cmp	r0, #3
 8003554:	d0fa      	beq.n	800354c <writeBuffer+0x40>
		;
	}
	//  ptrSPI->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_INACTIVE);
	SPI_CS_Deassert();
 8003556:	f7ff fec9 	bl	80032ec <SPI_CS_Deassert>
}
 800355a:	b003      	add	sp, #12
 800355c:	bd30      	pop	{r4, r5, pc}
 800355e:	bf00      	nop
 8003560:	40021000 	.word	0x40021000
 8003564:	2000079c 	.word	0x2000079c

08003568 <readBuffer>:

void readBuffer(uint16_t len, uint8_t* data)
{
 8003568:	b570      	push	{r4, r5, r6, lr}
 800356a:	b082      	sub	sp, #8
 800356c:	4605      	mov	r5, r0
 800356e:	460c      	mov	r4, r1
	uint8_t cmd = ENC28J60_READ_BUF_MEM;
 8003570:	233a      	movs	r3, #58	@ 0x3a
 8003572:	f88d 3007 	strb.w	r3, [sp, #7]
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
 8003576:	2200      	movs	r2, #0
 8003578:	2110      	movs	r1, #16
 800357a:	480d      	ldr	r0, [pc, #52]	@ (80035b0 <readBuffer+0x48>)
 800357c:	f7fe fb2a 	bl	8001bd4 <HAL_GPIO_WritePin>
	//	ptrSPI->Control (ARM_SPI_CONTROL_SS, ARM_SPI_SS_ACTIVE);
	SPI_CS_Assert();
	//  ptrSPI->Send (&cmd, 1);
	HAL_SPI_Transmit(&hspi4, &cmd, 1, HAL_MAX_DELAY);
 8003580:	4e0c      	ldr	r6, [pc, #48]	@ (80035b4 <readBuffer+0x4c>)
 8003582:	f04f 33ff 	mov.w	r3, #4294967295
 8003586:	2201      	movs	r2, #1
 8003588:	f10d 0107 	add.w	r1, sp, #7
 800358c:	4630      	mov	r0, r6
 800358e:	f7fe ffc8 	bl	8002522 <HAL_SPI_Transmit>
	//	while (ptrSPI->GetStatus().busy) {
	//		;
	//	}
	//	ptrSPI->Receive(data, len);
	HAL_SPI_Receive(&hspi4, data, len, 100);
 8003592:	2364      	movs	r3, #100	@ 0x64
 8003594:	462a      	mov	r2, r5
 8003596:	4621      	mov	r1, r4
 8003598:	4630      	mov	r0, r6
 800359a:	f7ff f9ce 	bl	800293a <HAL_SPI_Receive>
	while (HAL_SPI_GetState(&hspi4) == HAL_SPI_STATE_BUSY_RX) {
 800359e:	4805      	ldr	r0, [pc, #20]	@ (80035b4 <readBuffer+0x4c>)
 80035a0:	f7ff fa8f 	bl	8002ac2 <HAL_SPI_GetState>
 80035a4:	2804      	cmp	r0, #4
 80035a6:	d0fa      	beq.n	800359e <readBuffer+0x36>
		;
	}
	//  ptrSPI->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_INACTIVE);
	SPI_CS_Deassert();
 80035a8:	f7ff fea0 	bl	80032ec <SPI_CS_Deassert>
}
 80035ac:	b002      	add	sp, #8
 80035ae:	bd70      	pop	{r4, r5, r6, pc}
 80035b0:	40021000 	.word	0x40021000
 80035b4:	2000079c 	.word	0x2000079c

080035b8 <readId>:
	uint16_t result;
	readBuffer(2, (uint8_t*) &result);
	return result;
}

uint32_t readId(void) {
 80035b8:	b510      	push	{r4, lr}
	uint16_t phid1;
	uint16_t phid2;

	phid1 = readPhyRegister(PHID1);
 80035ba:	2002      	movs	r0, #2
 80035bc:	f7ff ff77 	bl	80034ae <readPhyRegister>
 80035c0:	4604      	mov	r4, r0
	phid2 = readPhyRegister(PHID2);
 80035c2:	2003      	movs	r0, #3
 80035c4:	f7ff ff73 	bl	80034ae <readPhyRegister>

	return ((((uint32_t)phid1) << 6) | (phid2 >> 10));
 80035c8:	f3c0 208f 	ubfx	r0, r0, #10, #16
}
 80035cc:	ea40 1084 	orr.w	r0, r0, r4, lsl #6
 80035d0:	bd10      	pop	{r4, pc}
	...

080035d4 <MAC_Initialize>:


/* Ethernet Driver functions */


void MAC_Initialize (void* cb_event) {
 80035d4:	b538      	push	{r3, r4, r5, lr}
	(void)cb_event;

	softReset();
 80035d6:	f7ff fe95 	bl	8003304 <softReset>
	uint8_t estat = readControlRegister(ESTAT);
 80035da:	201d      	movs	r0, #29
 80035dc:	f7ff ff42 	bl	8003464 <readControlRegister>
 80035e0:	4601      	mov	r1, r0
	printf("ESTAT:   0x%x\n", (unsigned int)estat);
 80035e2:	487c      	ldr	r0, [pc, #496]	@ (80037d4 <MAC_Initialize+0x200>)
 80035e4:	f00b f9be 	bl	800e964 <iprintf>
	uint16_t phcon1 = readPhyRegister(PHCON1);
 80035e8:	2000      	movs	r0, #0
 80035ea:	f7ff ff60 	bl	80034ae <readPhyRegister>
 80035ee:	4601      	mov	r1, r0
	printf("PHCON1:  0x%x\n", (unsigned int)phcon1);
 80035f0:	4879      	ldr	r0, [pc, #484]	@ (80037d8 <MAC_Initialize+0x204>)
 80035f2:	f00b f9b7 	bl	800e964 <iprintf>
	uint16_t phcon2 = readPhyRegister(PHCON2);
 80035f6:	2010      	movs	r0, #16
 80035f8:	f7ff ff59 	bl	80034ae <readPhyRegister>
 80035fc:	4601      	mov	r1, r0
	printf("PHCON2:  0x%x\n", (unsigned int)phcon2);
 80035fe:	4877      	ldr	r0, [pc, #476]	@ (80037dc <MAC_Initialize+0x208>)
 8003600:	f00b f9b0 	bl	800e964 <iprintf>
	uint16_t phstat1 = readPhyRegister(PHSTAT1);
 8003604:	2001      	movs	r0, #1
 8003606:	f7ff ff52 	bl	80034ae <readPhyRegister>
 800360a:	4601      	mov	r1, r0
	printf("PHSTAT1: 0x%x\n", (unsigned int)phstat1);
 800360c:	4874      	ldr	r0, [pc, #464]	@ (80037e0 <MAC_Initialize+0x20c>)
 800360e:	f00b f9a9 	bl	800e964 <iprintf>
	uint16_t phstat2 = readPhyRegister(PHSTAT2);
 8003612:	2011      	movs	r0, #17
 8003614:	f7ff ff4b 	bl	80034ae <readPhyRegister>
 8003618:	4601      	mov	r1, r0
	printf("PHSTAT2: 0x%x\n", (unsigned int)phstat2);
 800361a:	4872      	ldr	r0, [pc, #456]	@ (80037e4 <MAC_Initialize+0x210>)
 800361c:	f00b f9a2 	bl	800e964 <iprintf>
	uint16_t phid1 = readPhyRegister(PHID1);
 8003620:	2002      	movs	r0, #2
 8003622:	f7ff ff44 	bl	80034ae <readPhyRegister>
 8003626:	4601      	mov	r1, r0
	printf("PHID1:   0x%x\n", (unsigned int)phid1);
 8003628:	486f      	ldr	r0, [pc, #444]	@ (80037e8 <MAC_Initialize+0x214>)
 800362a:	f00b f99b 	bl	800e964 <iprintf>
	uint16_t phid2 = readPhyRegister(PHID2);
 800362e:	2003      	movs	r0, #3
 8003630:	f7ff ff3d 	bl	80034ae <readPhyRegister>
 8003634:	4601      	mov	r1, r0
	printf("PHID2:   0x%x\n", (unsigned int)phid2);
 8003636:	486d      	ldr	r0, [pc, #436]	@ (80037ec <MAC_Initialize+0x218>)
 8003638:	f00b f994 	bl	800e964 <iprintf>
	uint16_t phie = readPhyRegister(PHIE);
 800363c:	2012      	movs	r0, #18
 800363e:	f7ff ff36 	bl	80034ae <readPhyRegister>
 8003642:	4601      	mov	r1, r0
	printf("PHIE:    0x%x\n", (unsigned int)phie);
 8003644:	486a      	ldr	r0, [pc, #424]	@ (80037f0 <MAC_Initialize+0x21c>)
 8003646:	f00b f98d 	bl	800e964 <iprintf>
	uint16_t phir = readPhyRegister(PHIR);
 800364a:	2013      	movs	r0, #19
 800364c:	f7ff ff2f 	bl	80034ae <readPhyRegister>
 8003650:	4601      	mov	r1, r0
	printf("PHIR:    0x%x\n", (unsigned int)phir);
 8003652:	4868      	ldr	r0, [pc, #416]	@ (80037f4 <MAC_Initialize+0x220>)
 8003654:	f00b f986 	bl	800e964 <iprintf>
	uint16_t phlcon = readPhyRegister(PHLCON);
 8003658:	2014      	movs	r0, #20
 800365a:	f7ff ff28 	bl	80034ae <readPhyRegister>
 800365e:	4601      	mov	r1, r0
	printf("PHLCON:  0x%x\n", (unsigned int)phlcon);
 8003660:	4865      	ldr	r0, [pc, #404]	@ (80037f8 <MAC_Initialize+0x224>)
 8003662:	f00b f97f 	bl	800e964 <iprintf>
	uint32_t phid = readId();
 8003666:	f7ff ffa7 	bl	80035b8 <readId>
 800366a:	4601      	mov	r1, r0
	printf("PHID:    0x%x\n", (unsigned int)phid);
 800366c:	4863      	ldr	r0, [pc, #396]	@ (80037fc <MAC_Initialize+0x228>)
 800366e:	f00b f979 	bl	800e964 <iprintf>

	// set receive buffer start address
	gNextPacketPtr = RXSTART_INIT;
 8003672:	2500      	movs	r5, #0
 8003674:	4b62      	ldr	r3, [pc, #392]	@ (8003800 <MAC_Initialize+0x22c>)
 8003676:	801d      	strh	r5, [r3, #0]
	// Rx start
	writeControlRegister16(ERXSTL, RXSTART_INIT);
 8003678:	4629      	mov	r1, r5
 800367a:	2008      	movs	r0, #8
 800367c:	f7ff ff06 	bl	800348c <writeControlRegister16>
	// set receive pointer address
	writeControlRegister16(ERXRDPTL, RXSTART_INIT);
 8003680:	4629      	mov	r1, r5
 8003682:	200c      	movs	r0, #12
 8003684:	f7ff ff02 	bl	800348c <writeControlRegister16>
	// RX end
	writeControlRegister16(ERXNDL, RXSTOP_INIT);
 8003688:	f241 71ff 	movw	r1, #6143	@ 0x17ff
 800368c:	200a      	movs	r0, #10
 800368e:	f7ff fefd 	bl	800348c <writeControlRegister16>
	// TX start
	writeControlRegister16(ETXSTL, TXSTART_INIT);
 8003692:	f44f 51c0 	mov.w	r1, #6144	@ 0x1800
 8003696:	2004      	movs	r0, #4
 8003698:	f7ff fef8 	bl	800348c <writeControlRegister16>
	// TX end
	writeControlRegister16(ETXNDL, TXSTOP_INIT);
 800369c:	f641 71ff 	movw	r1, #8191	@ 0x1fff
 80036a0:	2006      	movs	r0, #6
 80036a2:	f7ff fef3 	bl	800348c <writeControlRegister16>
	// ARP      BROADCAST
	// 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
	// in binary these poitions are:11 0000 0011 1111
	// This is hex 303F->EPMM0=0x3f,EPMM1=0x30

	erxfcon =  ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN|ERXFCON_BCEN;
 80036a6:	21b1      	movs	r1, #177	@ 0xb1
 80036a8:	4b56      	ldr	r3, [pc, #344]	@ (8003804 <MAC_Initialize+0x230>)
 80036aa:	7019      	strb	r1, [r3, #0]
	writeControlRegister8(ERXFCON, erxfcon );
 80036ac:	2038      	movs	r0, #56	@ 0x38
 80036ae:	f7ff fee2 	bl	8003476 <writeControlRegister8>
	writeControlRegister16(EPMM0, 0x303f);
 80036b2:	f243 013f 	movw	r1, #12351	@ 0x303f
 80036b6:	2028      	movs	r0, #40	@ 0x28
 80036b8:	f7ff fee8 	bl	800348c <writeControlRegister16>
	writeControlRegister16(EPMCSL, 0xf7f9);
 80036bc:	f24f 71f9 	movw	r1, #63481	@ 0xf7f9
 80036c0:	2030      	movs	r0, #48	@ 0x30
 80036c2:	f7ff fee3 	bl	800348c <writeControlRegister16>

	// do bank 2 stuff
	// enable MAC receive
	writeControlRegister8(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
 80036c6:	210d      	movs	r1, #13
 80036c8:	20c0      	movs	r0, #192	@ 0xc0
 80036ca:	f7ff fed4 	bl	8003476 <writeControlRegister8>
	// bring MAC out of reset
	writeControlRegister8(MACON2, 0x00);
 80036ce:	4629      	mov	r1, r5
 80036d0:	20c1      	movs	r0, #193	@ 0xc1
 80036d2:	f7ff fed0 	bl	8003476 <writeControlRegister8>
	// enable automatic padding to 60bytes and CRC operations
	writeOperation(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);  //|MACON3_FULDPX);
 80036d6:	2232      	movs	r2, #50	@ 0x32
 80036d8:	21c2      	movs	r1, #194	@ 0xc2
 80036da:	2080      	movs	r0, #128	@ 0x80
 80036dc:	f7ff fe2e 	bl	800333c <writeOperation>
	// set inter-frame gap (non-back-to-back)
	writeControlRegister16(MAIPGL, 0x0C12);
 80036e0:	f640 4112 	movw	r1, #3090	@ 0xc12
 80036e4:	20c6      	movs	r0, #198	@ 0xc6
 80036e6:	f7ff fed1 	bl	800348c <writeControlRegister16>
	// set inter-frame gap (back-to-back)
	writeControlRegister8(MABBIPG, 0x12);
 80036ea:	2112      	movs	r1, #18
 80036ec:	20c4      	movs	r0, #196	@ 0xc4
 80036ee:	f7ff fec2 	bl	8003476 <writeControlRegister8>
	// Set the maximum packet size which the controller will accept
	// Do not send packets longer than MAX_FRAMELEN:
	writeControlRegister16(MAMXFLL, MAX_FRAMELEN);
 80036f2:	f240 51dc 	movw	r1, #1500	@ 0x5dc
 80036f6:	20ca      	movs	r0, #202	@ 0xca
 80036f8:	f7ff fec8 	bl	800348c <writeControlRegister16>
	// do bank 3 stuff
	// write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	writeControlRegister8(MAADR5, macaddr[0]);
 80036fc:	4c42      	ldr	r4, [pc, #264]	@ (8003808 <MAC_Initialize+0x234>)
 80036fe:	7821      	ldrb	r1, [r4, #0]
 8003700:	20e4      	movs	r0, #228	@ 0xe4
 8003702:	f7ff feb8 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR4, macaddr[1]);
 8003706:	7861      	ldrb	r1, [r4, #1]
 8003708:	20e5      	movs	r0, #229	@ 0xe5
 800370a:	f7ff feb4 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR3, macaddr[2]);
 800370e:	78a1      	ldrb	r1, [r4, #2]
 8003710:	20e2      	movs	r0, #226	@ 0xe2
 8003712:	f7ff feb0 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR2, macaddr[3]);
 8003716:	78e1      	ldrb	r1, [r4, #3]
 8003718:	20e3      	movs	r0, #227	@ 0xe3
 800371a:	f7ff feac 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR1, macaddr[4]);
 800371e:	7921      	ldrb	r1, [r4, #4]
 8003720:	20e0      	movs	r0, #224	@ 0xe0
 8003722:	f7ff fea8 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR0, macaddr[5]);
 8003726:	7961      	ldrb	r1, [r4, #5]
 8003728:	20e1      	movs	r0, #225	@ 0xe1
 800372a:	f7ff fea4 	bl	8003476 <writeControlRegister8>
	// no loopback of transmitted frames
	writePhyRegister(PHCON2, PHCON2_HDLDIS);
 800372e:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8003732:	2010      	movs	r0, #16
 8003734:	f7ff fed9 	bl	80034ea <writePhyRegister>
	// switch to bank 0
	setBank(ECON1);
 8003738:	201f      	movs	r0, #31
 800373a:	f7ff fe79 	bl	8003430 <setBank>
	// enable interrutps
	writeOperation(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
 800373e:	22c0      	movs	r2, #192	@ 0xc0
 8003740:	211b      	movs	r1, #27
 8003742:	2080      	movs	r0, #128	@ 0x80
 8003744:	f7ff fdfa 	bl	800333c <writeOperation>
	// enable packet reception
	writeOperation(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
 8003748:	2204      	movs	r2, #4
 800374a:	211f      	movs	r1, #31
 800374c:	2080      	movs	r0, #128	@ 0x80
 800374e:	f7ff fdf5 	bl	800333c <writeOperation>

	// do bank 2 stuff
	// enable MAC receive
	writeControlRegister8(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
 8003752:	210d      	movs	r1, #13
 8003754:	20c0      	movs	r0, #192	@ 0xc0
 8003756:	f7ff fe8e 	bl	8003476 <writeControlRegister8>
	// bring MAC out of reset
	writeControlRegister8(MACON2, 0x00);
 800375a:	4629      	mov	r1, r5
 800375c:	20c1      	movs	r0, #193	@ 0xc1
 800375e:	f7ff fe8a 	bl	8003476 <writeControlRegister8>
	// enable automatic padding to 60bytes and CRC operations
	writeOperation(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);  //|MACON3_FULDPX);
 8003762:	2232      	movs	r2, #50	@ 0x32
 8003764:	21c2      	movs	r1, #194	@ 0xc2
 8003766:	2080      	movs	r0, #128	@ 0x80
 8003768:	f7ff fde8 	bl	800333c <writeOperation>
	// set inter-frame gap (non-back-to-back)
	writeControlRegister16(MAIPGL, 0x0C12);
 800376c:	f640 4112 	movw	r1, #3090	@ 0xc12
 8003770:	20c6      	movs	r0, #198	@ 0xc6
 8003772:	f7ff fe8b 	bl	800348c <writeControlRegister16>
	// set inter-frame gap (back-to-back)
	writeControlRegister8(MABBIPG, 0x12);
 8003776:	2112      	movs	r1, #18
 8003778:	20c4      	movs	r0, #196	@ 0xc4
 800377a:	f7ff fe7c 	bl	8003476 <writeControlRegister8>
	// Set the maximum packet size which the controller will accept
	// Do not send packets longer than MAX_FRAMELEN:
	writeControlRegister16(MAMXFLL, MAX_FRAMELEN);
 800377e:	f240 51dc 	movw	r1, #1500	@ 0x5dc
 8003782:	20ca      	movs	r0, #202	@ 0xca
 8003784:	f7ff fe82 	bl	800348c <writeControlRegister16>

	// do bank 3 stuff
	// write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	writeControlRegister8(MAADR5, macaddr[0]);
 8003788:	7821      	ldrb	r1, [r4, #0]
 800378a:	20e4      	movs	r0, #228	@ 0xe4
 800378c:	f7ff fe73 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR4, macaddr[1]);
 8003790:	7861      	ldrb	r1, [r4, #1]
 8003792:	20e5      	movs	r0, #229	@ 0xe5
 8003794:	f7ff fe6f 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR3, macaddr[2]);
 8003798:	78a1      	ldrb	r1, [r4, #2]
 800379a:	20e2      	movs	r0, #226	@ 0xe2
 800379c:	f7ff fe6b 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR2, macaddr[3]);
 80037a0:	78e1      	ldrb	r1, [r4, #3]
 80037a2:	20e3      	movs	r0, #227	@ 0xe3
 80037a4:	f7ff fe67 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR1, macaddr[4]);
 80037a8:	7921      	ldrb	r1, [r4, #4]
 80037aa:	20e0      	movs	r0, #224	@ 0xe0
 80037ac:	f7ff fe63 	bl	8003476 <writeControlRegister8>
	writeControlRegister8(MAADR0, macaddr[5]);
 80037b0:	7961      	ldrb	r1, [r4, #5]
 80037b2:	20e1      	movs	r0, #225	@ 0xe1
 80037b4:	f7ff fe5f 	bl	8003476 <writeControlRegister8>

	// switch to bank 0
	setBank(ECON1);
 80037b8:	201f      	movs	r0, #31
 80037ba:	f7ff fe39 	bl	8003430 <setBank>
	// enable interrupt when packet is received
	writeOperation(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
 80037be:	22c0      	movs	r2, #192	@ 0xc0
 80037c0:	211b      	movs	r1, #27
 80037c2:	2080      	movs	r0, #128	@ 0x80
 80037c4:	f7ff fdba 	bl	800333c <writeOperation>
	// enable packet reception
	writeOperation(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
 80037c8:	2204      	movs	r2, #4
 80037ca:	211f      	movs	r1, #31
 80037cc:	2080      	movs	r0, #128	@ 0x80
 80037ce:	f7ff fdb5 	bl	800333c <writeOperation>
}
 80037d2:	bd38      	pop	{r3, r4, r5, pc}
 80037d4:	080100dc 	.word	0x080100dc
 80037d8:	080100ec 	.word	0x080100ec
 80037dc:	080100fc 	.word	0x080100fc
 80037e0:	0801010c 	.word	0x0801010c
 80037e4:	0801011c 	.word	0x0801011c
 80037e8:	0801012c 	.word	0x0801012c
 80037ec:	0801013c 	.word	0x0801013c
 80037f0:	0801014c 	.word	0x0801014c
 80037f4:	0801015c 	.word	0x0801015c
 80037f8:	0801016c 	.word	0x0801016c
 80037fc:	0801017c 	.word	0x0801017c
 8003800:	20000cb6 	.word	0x20000cb6
 8003804:	20000cb4 	.word	0x20000cb4
 8003808:	2000000c 	.word	0x2000000c

0800380c <MAC_SendFrame>:
  \param[in]   flags  Frame transmit flags (see ARM_ETH_MAC_TX_FRAME_...)
  \return      \ref execution_status
 */
bool MAC_SendFrame (const uint8_t *frame, uint32_t len, uint32_t flags) {
	//printf("MAC_SendFrame called: %d\n", (int)len);
	if ((frame == NULL) || (len == 0U)) {
 800380c:	b3b0      	cbz	r0, 800387c <MAC_SendFrame+0x70>
bool MAC_SendFrame (const uint8_t *frame, uint32_t len, uint32_t flags) {
 800380e:	b538      	push	{r3, r4, r5, lr}
 8003810:	460c      	mov	r4, r1
 8003812:	4605      	mov	r5, r0
	if ((frame == NULL) || (len == 0U)) {
 8003814:	b3a1      	cbz	r1, 8003880 <MAC_SendFrame+0x74>
		return false;
	}
	// Check no transmit in progress
	while (readOperation(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
 8003816:	211f      	movs	r1, #31
 8003818:	2000      	movs	r0, #0
 800381a:	f7ff fdb5 	bl	8003388 <readOperation>
 800381e:	f010 0f08 	tst.w	r0, #8
 8003822:	d010      	beq.n	8003846 <MAC_SendFrame+0x3a>
	{
		// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
		if( (readControlRegister(EIR) & EIR_TXERIF) ) {
 8003824:	201c      	movs	r0, #28
 8003826:	f7ff fe1d 	bl	8003464 <readControlRegister>
 800382a:	f010 0f02 	tst.w	r0, #2
 800382e:	d0f2      	beq.n	8003816 <MAC_SendFrame+0xa>
			writeOperation(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
 8003830:	2280      	movs	r2, #128	@ 0x80
 8003832:	211f      	movs	r1, #31
 8003834:	4610      	mov	r0, r2
 8003836:	f7ff fd81 	bl	800333c <writeOperation>
			writeOperation(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
 800383a:	2280      	movs	r2, #128	@ 0x80
 800383c:	211f      	movs	r1, #31
 800383e:	20a0      	movs	r0, #160	@ 0xa0
 8003840:	f7ff fd7c 	bl	800333c <writeOperation>
 8003844:	e7e7      	b.n	8003816 <MAC_SendFrame+0xa>
		}
	}

	// Set the write pointer to start of transmit buffer area
	writeControlRegister16(EWRPTL, TXSTART_INIT);
 8003846:	f44f 51c0 	mov.w	r1, #6144	@ 0x1800
 800384a:	2002      	movs	r0, #2
 800384c:	f7ff fe1e 	bl	800348c <writeControlRegister16>
	// Set the TXND pointer to correspond to the packet size given
	writeControlRegister16(ETXNDL, (TXSTART_INIT+len));
 8003850:	f504 51c0 	add.w	r1, r4, #6144	@ 0x1800
 8003854:	b289      	uxth	r1, r1
 8003856:	2006      	movs	r0, #6
 8003858:	f7ff fe18 	bl	800348c <writeControlRegister16>
	// write per-packet control byte (0x00 means use macon3 settings)
	writeOperation(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
 800385c:	2200      	movs	r2, #0
 800385e:	4611      	mov	r1, r2
 8003860:	207a      	movs	r0, #122	@ 0x7a
 8003862:	f7ff fd6b 	bl	800333c <writeOperation>
	// copy the packet into the transmit buffer
	writeBuffer(frame, len);
 8003866:	4621      	mov	r1, r4
 8003868:	4628      	mov	r0, r5
 800386a:	f7ff fe4f 	bl	800350c <writeBuffer>
	// send the contents of the transmit buffer onto the network
	writeOperation(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
 800386e:	2208      	movs	r2, #8
 8003870:	211f      	movs	r1, #31
 8003872:	2080      	movs	r0, #128	@ 0x80
 8003874:	f7ff fd62 	bl	800333c <writeOperation>
	// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	return true;
 8003878:	2001      	movs	r0, #1
}
 800387a:	bd38      	pop	{r3, r4, r5, pc}
		return false;
 800387c:	2000      	movs	r0, #0
}
 800387e:	4770      	bx	lr
		return false;
 8003880:	2000      	movs	r0, #0
 8003882:	e7fa      	b.n	800387a <MAC_SendFrame+0x6e>

08003884 <MAC_ReadFrame>:
  \param[in]   len    Frame buffer length in bytes
  \return      number of data bytes read or execution status
                 - value >= 0: number of data bytes read
                 - value < 0: error occurred, value is execution status as defined with \ref execution_status 
 */
int32_t MAC_ReadFrame (uint8_t *frame, uint32_t maxlen) {
 8003884:	b570      	push	{r4, r5, r6, lr}
 8003886:	b082      	sub	sp, #8
 8003888:	4605      	mov	r5, r0
 800388a:	460c      	mov	r4, r1

	if(readControlRegister(EPKTCNT) == 0) {
 800388c:	2039      	movs	r0, #57	@ 0x39
 800388e:	f7ff fde9 	bl	8003464 <readControlRegister>
 8003892:	b910      	cbnz	r0, 800389a <MAC_ReadFrame+0x16>
		return 0;
 8003894:	2000      	movs	r0, #0

	// decrement the packet counter indicate we are done with this packet
	writeOperation(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	//  printf("ETHMAC: Got packet with len: %d\n", (unsigned)header.len);
	return header.len;
}
 8003896:	b002      	add	sp, #8
 8003898:	bd70      	pop	{r4, r5, r6, pc}
	writeControlRegister16(ERDPTL, gNextPacketPtr);
 800389a:	4e1b      	ldr	r6, [pc, #108]	@ (8003908 <MAC_ReadFrame+0x84>)
 800389c:	8831      	ldrh	r1, [r6, #0]
 800389e:	2000      	movs	r0, #0
 80038a0:	f7ff fdf4 	bl	800348c <writeControlRegister16>
	readBuffer(6, (uint8_t*)&header);		
 80038a4:	4669      	mov	r1, sp
 80038a6:	2006      	movs	r0, #6
 80038a8:	f7ff fe5e 	bl	8003568 <readBuffer>
	gNextPacketPtr = header.nextPtr;
 80038ac:	f8bd 3000 	ldrh.w	r3, [sp]
 80038b0:	8033      	strh	r3, [r6, #0]
	if (header.len > maxlen - 1){
 80038b2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 80038b6:	1e63      	subs	r3, r4, #1
 80038b8:	429a      	cmp	r2, r3
 80038ba:	d901      	bls.n	80038c0 <MAC_ReadFrame+0x3c>
		header.len = maxlen - 1;
 80038bc:	f8ad 3002 	strh.w	r3, [sp, #2]
	if ((header.status & 0x80)==0){
 80038c0:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 80038c4:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80038c8:	d118      	bne.n	80038fc <MAC_ReadFrame+0x78>
		header.len=0;
 80038ca:	2300      	movs	r3, #0
 80038cc:	f8ad 3002 	strh.w	r3, [sp, #2]
	if ((gNextPacketPtr < RXSTART_INIT)	|| (gNextPacketPtr > RXSTOP_INIT)) {
 80038d0:	4b0d      	ldr	r3, [pc, #52]	@ (8003908 <MAC_ReadFrame+0x84>)
 80038d2:	881b      	ldrh	r3, [r3, #0]
 80038d4:	f5b3 5fc0 	cmp.w	r3, #6144	@ 0x1800
 80038d8:	d303      	bcc.n	80038e2 <MAC_ReadFrame+0x5e>
		gNextPacketPtr = RXSTOP_INIT;
 80038da:	4b0b      	ldr	r3, [pc, #44]	@ (8003908 <MAC_ReadFrame+0x84>)
 80038dc:	f241 72ff 	movw	r2, #6143	@ 0x17ff
 80038e0:	801a      	strh	r2, [r3, #0]
	writeControlRegister16(ERXRDPTL, gNextPacketPtr);
 80038e2:	4b09      	ldr	r3, [pc, #36]	@ (8003908 <MAC_ReadFrame+0x84>)
 80038e4:	8819      	ldrh	r1, [r3, #0]
 80038e6:	200c      	movs	r0, #12
 80038e8:	f7ff fdd0 	bl	800348c <writeControlRegister16>
	writeOperation(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
 80038ec:	2240      	movs	r2, #64	@ 0x40
 80038ee:	211e      	movs	r1, #30
 80038f0:	2080      	movs	r0, #128	@ 0x80
 80038f2:	f7ff fd23 	bl	800333c <writeOperation>
	return header.len;
 80038f6:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 80038fa:	e7cc      	b.n	8003896 <MAC_ReadFrame+0x12>
		readBuffer(header.len, frame);
 80038fc:	4629      	mov	r1, r5
 80038fe:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 8003902:	f7ff fe31 	bl	8003568 <readBuffer>
 8003906:	e7e3      	b.n	80038d0 <MAC_ReadFrame+0x4c>
 8003908:	20000cb6 	.word	0x20000cb6

0800390c <MAC_GetRxFrameSize>:
/**
  \fn          uint32_t GetRxFrameSize (void)
  \brief       Get size of received Ethernet frame.
  \return      number of bytes in received frame
 */
uint32_t MAC_GetRxFrameSize (void) {
 800390c:	b500      	push	{lr}
 800390e:	b083      	sub	sp, #12

	uint8_t pktCnt = readControlRegister(EPKTCNT);
 8003910:	2039      	movs	r0, #57	@ 0x39
 8003912:	f7ff fda7 	bl	8003464 <readControlRegister>

	if(pktCnt == 0) {
 8003916:	b918      	cbnz	r0, 8003920 <MAC_GetRxFrameSize+0x14>
		// no packets in receive queue
		return 0;
 8003918:	2000      	movs	r0, #0
	} header;
	header.len = 0;
	header.nextPtr = 0;
	readBuffer(6, (uint8_t*)&header);	
	return header.len;
}
 800391a:	b003      	add	sp, #12
 800391c:	f85d fb04 	ldr.w	pc, [sp], #4
	writeControlRegister16(ERDPTL, gNextPacketPtr);
 8003920:	4b08      	ldr	r3, [pc, #32]	@ (8003944 <MAC_GetRxFrameSize+0x38>)
 8003922:	8819      	ldrh	r1, [r3, #0]
 8003924:	2000      	movs	r0, #0
 8003926:	f7ff fdb1 	bl	800348c <writeControlRegister16>
	header.len = 0;
 800392a:	2300      	movs	r3, #0
 800392c:	f8ad 3002 	strh.w	r3, [sp, #2]
	header.nextPtr = 0;
 8003930:	f8ad 3000 	strh.w	r3, [sp]
	readBuffer(6, (uint8_t*)&header);	
 8003934:	4669      	mov	r1, sp
 8003936:	2006      	movs	r0, #6
 8003938:	f7ff fe16 	bl	8003568 <readBuffer>
	return header.len;
 800393c:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 8003940:	e7eb      	b.n	800391a <MAC_GetRxFrameSize+0xe>
 8003942:	bf00      	nop
 8003944:	20000cb6 	.word	0x20000cb6

08003948 <MAC_SetMACAddress>:


void MAC_SetMACAddress(uint8_t* macAddr) {
 8003948:	4603      	mov	r3, r0
	memcpy(macaddr, macAddr, 6);
 800394a:	4a03      	ldr	r2, [pc, #12]	@ (8003958 <MAC_SetMACAddress+0x10>)
 800394c:	6800      	ldr	r0, [r0, #0]
 800394e:	6010      	str	r0, [r2, #0]
 8003950:	889b      	ldrh	r3, [r3, #4]
 8003952:	8093      	strh	r3, [r2, #4]
}
 8003954:	4770      	bx	lr
 8003956:	bf00      	nop
 8003958:	2000000c 	.word	0x2000000c

0800395c <PHY_IsLinkUp>:

bool PHY_IsLinkUp (void) {
 800395c:	b508      	push	{r3, lr}
	if (readPhyRegister(PHSTAT2) & PHSTAT2_LSTAT) {
 800395e:	2011      	movs	r0, #17
 8003960:	f7ff fda5 	bl	80034ae <readPhyRegister>
 8003964:	f410 6f80 	tst.w	r0, #1024	@ 0x400
 8003968:	d101      	bne.n	800396e <PHY_IsLinkUp+0x12>
		return true;
	}
	return false;
 800396a:	2000      	movs	r0, #0
}
 800396c:	bd08      	pop	{r3, pc}
		return true;
 800396e:	2001      	movs	r0, #1
 8003970:	e7fc      	b.n	800396c <PHY_IsLinkUp+0x10>

08003972 <netGetPhyLinkStatus>:
    }
    return pdTRUE;
}

static BaseType_t netGetPhyLinkStatus(struct xNetworkInterface *pxDescriptor)
{
 8003972:	b508      	push	{r3, lr}
    (void)pxDescriptor;
    return PHY_IsLinkUp() ? pdTRUE : pdFALSE;
 8003974:	f7ff fff2 	bl	800395c <PHY_IsLinkUp>
 8003978:	b108      	cbz	r0, 800397e <netGetPhyLinkStatus+0xc>
 800397a:	2001      	movs	r0, #1
}
 800397c:	bd08      	pop	{r3, pc}
    return PHY_IsLinkUp() ? pdTRUE : pdFALSE;
 800397e:	2000      	movs	r0, #0
 8003980:	e7fc      	b.n	800397c <netGetPhyLinkStatus+0xa>

08003982 <netOut>:
{
 8003982:	b538      	push	{r3, r4, r5, lr}
 8003984:	460c      	mov	r4, r1
 8003986:	4615      	mov	r5, r2
    MAC_SendFrame(pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength, 0);
 8003988:	2200      	movs	r2, #0
 800398a:	6a89      	ldr	r1, [r1, #40]	@ 0x28
 800398c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 800398e:	f7ff ff3d 	bl	800380c <MAC_SendFrame>
    if(xReleaseAfterSend != pdFALSE) {
 8003992:	b90d      	cbnz	r5, 8003998 <netOut+0x16>
}
 8003994:	2001      	movs	r0, #1
 8003996:	bd38      	pop	{r3, r4, r5, pc}
      vReleaseNetworkBufferAndDescriptor(pxNetworkBuffer);
 8003998:	4620      	mov	r0, r4
 800399a:	f00a fe81 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 800399e:	e7f9      	b.n	8003994 <netOut+0x12>

080039a0 <netInit>:
{
 80039a0:	b508      	push	{r3, lr}
    MAC_Initialize(NULL);
 80039a2:	2000      	movs	r0, #0
 80039a4:	f7ff fe16 	bl	80035d4 <MAC_Initialize>
}
 80039a8:	2001      	movs	r0, #1
 80039aa:	bd08      	pop	{r3, pc}

080039ac <pxFillInterfaceDescriptor>:
bool netInterfaceIsUp(void) {
	return PHY_IsLinkUp() ? pdTRUE : pdFALSE;
}

void pxFillInterfaceDescriptor(NetworkInterface_t *netInterface)
{
 80039ac:	b508      	push	{r3, lr}
    netInterface->pfInitialise = netInit;
 80039ae:	4a07      	ldr	r2, [pc, #28]	@ (80039cc <pxFillInterfaceDescriptor+0x20>)
 80039b0:	6082      	str	r2, [r0, #8]
    netInterface->pfOutput = netOut;
 80039b2:	4a07      	ldr	r2, [pc, #28]	@ (80039d0 <pxFillInterfaceDescriptor+0x24>)
 80039b4:	60c2      	str	r2, [r0, #12]
    netInterface->pfGetPhyLinkStatus = netGetPhyLinkStatus;
 80039b6:	4a07      	ldr	r2, [pc, #28]	@ (80039d4 <pxFillInterfaceDescriptor+0x28>)
 80039b8:	6102      	str	r2, [r0, #16]
    netInterface->pfAddAllowedMAC = NULL;
 80039ba:	2200      	movs	r2, #0
 80039bc:	6142      	str	r2, [r0, #20]
    netInterface->pfRemoveAllowedMAC = NULL;
 80039be:	6182      	str	r2, [r0, #24]
    netInterface->pcName = "ENC28J60";
 80039c0:	4a05      	ldr	r2, [pc, #20]	@ (80039d8 <pxFillInterfaceDescriptor+0x2c>)
 80039c2:	6002      	str	r2, [r0, #0]
    FreeRTOS_AddNetworkInterface(netInterface);
 80039c4:	f006 f80e 	bl	80099e4 <FreeRTOS_AddNetworkInterface>
}
 80039c8:	bd08      	pop	{r3, pc}
 80039ca:	bf00      	nop
 80039cc:	080039a1 	.word	0x080039a1
 80039d0:	08003983 	.word	0x08003983
 80039d4:	08003973 	.word	0x08003973
 80039d8:	0801018c 	.word	0x0801018c

080039dc <SysTick_Handler>:

/*
  SysTick handler implementation that also clears overflow flag.
*/
#if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)
void SysTick_Handler (void) {
 80039dc:	b508      	push	{r3, lr}
  /* Clear overflow flag */
  SysTick->CTRL;
 80039de:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80039e2:	691b      	ldr	r3, [r3, #16]

  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 80039e4:	f001 fc04 	bl	80051f0 <xTaskGetSchedulerState>
 80039e8:	2801      	cmp	r0, #1
 80039ea:	d100      	bne.n	80039ee <SysTick_Handler+0x12>
    /* Call tick handler */
    xPortSysTickHandler();
  }
}
 80039ec:	bd08      	pop	{r3, pc}
    xPortSysTickHandler();
 80039ee:	f002 f811 	bl	8005a14 <xPortSysTickHandler>
}
 80039f2:	e7fb      	b.n	80039ec <SysTick_Handler+0x10>

080039f4 <osKernelInitialize>:
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80039f4:	f3ef 8305 	mrs	r3, IPSR
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
 80039f8:	b92b      	cbnz	r3, 8003a06 <osKernelInitialize+0x12>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelInactive) {
 80039fa:	4b06      	ldr	r3, [pc, #24]	@ (8003a14 <osKernelInitialize+0x20>)
 80039fc:	6818      	ldr	r0, [r3, #0]
 80039fe:	b928      	cbnz	r0, 8003a0c <osKernelInitialize+0x18>
        EvrFreeRTOSSetup(0U);
      #endif
      #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 8003a00:	2201      	movs	r2, #1
 8003a02:	601a      	str	r2, [r3, #0]
      stat = osOK;
 8003a04:	4770      	bx	lr
    stat = osErrorISR;
 8003a06:	f06f 0005 	mvn.w	r0, #5
 8003a0a:	4770      	bx	lr
    } else {
      stat = osError;
 8003a0c:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (stat);
}
 8003a10:	4770      	bx	lr
 8003a12:	bf00      	nop
 8003a14:	20001408 	.word	0x20001408

08003a18 <osKernelStart>:
 8003a18:	f3ef 8305 	mrs	r3, IPSR
}

osStatus_t osKernelStart (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
 8003a1c:	b973      	cbnz	r3, 8003a3c <osKernelStart+0x24>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelReady) {
 8003a1e:	4b0a      	ldr	r3, [pc, #40]	@ (8003a48 <osKernelStart+0x30>)
 8003a20:	681b      	ldr	r3, [r3, #0]
 8003a22:	2b01      	cmp	r3, #1
 8003a24:	d10d      	bne.n	8003a42 <osKernelStart+0x2a>
osStatus_t osKernelStart (void) {
 8003a26:	b510      	push	{r4, lr}
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003a28:	2400      	movs	r4, #0
 8003a2a:	4b08      	ldr	r3, [pc, #32]	@ (8003a4c <osKernelStart+0x34>)
 8003a2c:	77dc      	strb	r4, [r3, #31]
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 8003a2e:	4b06      	ldr	r3, [pc, #24]	@ (8003a48 <osKernelStart+0x30>)
 8003a30:	2202      	movs	r2, #2
 8003a32:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 8003a34:	f001 f898 	bl	8004b68 <vTaskStartScheduler>
      stat = osOK;
 8003a38:	4620      	mov	r0, r4
      stat = osError;
    }
  }

  return (stat);
}
 8003a3a:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 8003a3c:	f06f 0005 	mvn.w	r0, #5
 8003a40:	4770      	bx	lr
      stat = osError;
 8003a42:	f04f 30ff 	mov.w	r0, #4294967295
}
 8003a46:	4770      	bx	lr
 8003a48:	20001408 	.word	0x20001408
 8003a4c:	e000ed00 	.word	0xe000ed00

08003a50 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 8003a50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003a52:	b087      	sub	sp, #28
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 8003a54:	2400      	movs	r4, #0
 8003a56:	9405      	str	r4, [sp, #20]
 8003a58:	f3ef 8405 	mrs	r4, IPSR

  if (!IS_IRQ() && (func != NULL)) {
 8003a5c:	bb04      	cbnz	r4, 8003aa0 <osThreadNew+0x50>
 8003a5e:	b1f8      	cbz	r0, 8003aa0 <osThreadNew+0x50>
    prio  = (UBaseType_t)osPriorityNormal;

    name = NULL;
    mem  = -1;

    if (attr != NULL) {
 8003a60:	2a00      	cmp	r2, #0
 8003a62:	d034      	beq.n	8003ace <osThreadNew+0x7e>
      if (attr->name != NULL) {
 8003a64:	6815      	ldr	r5, [r2, #0]
        name = attr->name;
      }
      if (attr->priority != osPriorityNone) {
 8003a66:	6993      	ldr	r3, [r2, #24]
 8003a68:	b12b      	cbz	r3, 8003a76 <osThreadNew+0x26>
        prio = (UBaseType_t)attr->priority;
 8003a6a:	461e      	mov	r6, r3
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8003a6c:	3b01      	subs	r3, #1
 8003a6e:	2b37      	cmp	r3, #55	@ 0x37
 8003a70:	d902      	bls.n	8003a78 <osThreadNew+0x28>
        return (NULL);
 8003a72:	2000      	movs	r0, #0
 8003a74:	e015      	b.n	8003aa2 <osThreadNew+0x52>
    prio  = (UBaseType_t)osPriorityNormal;
 8003a76:	2618      	movs	r6, #24
      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8003a78:	6853      	ldr	r3, [r2, #4]
 8003a7a:	f013 0f01 	tst.w	r3, #1
 8003a7e:	d13f      	bne.n	8003b00 <osThreadNew+0xb0>
      }

      if (attr->stack_size > 0U) {
 8003a80:	6954      	ldr	r4, [r2, #20]
 8003a82:	b184      	cbz	r4, 8003aa6 <osThreadNew+0x56>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 8003a84:	ea4f 0c94 	mov.w	ip, r4, lsr #2
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8003a88:	6893      	ldr	r3, [r2, #8]
 8003a8a:	b12b      	cbz	r3, 8003a98 <osThreadNew+0x48>
 8003a8c:	68d7      	ldr	r7, [r2, #12]
 8003a8e:	2fa7      	cmp	r7, #167	@ 0xa7
 8003a90:	d902      	bls.n	8003a98 <osThreadNew+0x48>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8003a92:	6917      	ldr	r7, [r2, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8003a94:	b107      	cbz	r7, 8003a98 <osThreadNew+0x48>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8003a96:	b984      	cbnz	r4, 8003aba <osThreadNew+0x6a>
        mem = 1;
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 8003a98:	b143      	cbz	r3, 8003aac <osThreadNew+0x5c>
    mem  = -1;
 8003a9a:	f04f 33ff 	mov.w	r3, #4294967295
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
                                                                                      (StaticTask_t *)attr->cb_mem);
      #endif
    }
    else {
      if (mem == 0) {
 8003a9e:	b30b      	cbz	r3, 8003ae4 <osThreadNew+0x94>
        #endif
      }
    }
  }

  return ((osThreadId_t)hTask);
 8003aa0:	9805      	ldr	r0, [sp, #20]
}
 8003aa2:	b007      	add	sp, #28
 8003aa4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    stack = configMINIMAL_STACK_SIZE;
 8003aa6:	f04f 0c80 	mov.w	ip, #128	@ 0x80
 8003aaa:	e7ed      	b.n	8003a88 <osThreadNew+0x38>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 8003aac:	68d3      	ldr	r3, [r2, #12]
 8003aae:	b9a3      	cbnz	r3, 8003ada <osThreadNew+0x8a>
 8003ab0:	6913      	ldr	r3, [r2, #16]
 8003ab2:	b1ab      	cbz	r3, 8003ae0 <osThreadNew+0x90>
    mem  = -1;
 8003ab4:	f04f 33ff 	mov.w	r3, #4294967295
 8003ab8:	e7f1      	b.n	8003a9e <osThreadNew+0x4e>
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8003aba:	9302      	str	r3, [sp, #8]
 8003abc:	9701      	str	r7, [sp, #4]
 8003abe:	9600      	str	r6, [sp, #0]
 8003ac0:	460b      	mov	r3, r1
 8003ac2:	4662      	mov	r2, ip
 8003ac4:	4629      	mov	r1, r5
 8003ac6:	f000 ffe1 	bl	8004a8c <xTaskCreateStatic>
 8003aca:	9005      	str	r0, [sp, #20]
 8003acc:	e7e8      	b.n	8003aa0 <osThreadNew+0x50>
    name = NULL;
 8003ace:	4615      	mov	r5, r2
      mem = 0;
 8003ad0:	2300      	movs	r3, #0
    prio  = (UBaseType_t)osPriorityNormal;
 8003ad2:	2618      	movs	r6, #24
    stack = configMINIMAL_STACK_SIZE;
 8003ad4:	f04f 0c80 	mov.w	ip, #128	@ 0x80
 8003ad8:	e7e1      	b.n	8003a9e <osThreadNew+0x4e>
    mem  = -1;
 8003ada:	f04f 33ff 	mov.w	r3, #4294967295
 8003ade:	e7de      	b.n	8003a9e <osThreadNew+0x4e>
          mem = 0;
 8003ae0:	2300      	movs	r3, #0
 8003ae2:	e7dc      	b.n	8003a9e <osThreadNew+0x4e>
          if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 8003ae4:	ab05      	add	r3, sp, #20
 8003ae6:	9301      	str	r3, [sp, #4]
 8003ae8:	9600      	str	r6, [sp, #0]
 8003aea:	460b      	mov	r3, r1
 8003aec:	fa1f f28c 	uxth.w	r2, ip
 8003af0:	4629      	mov	r1, r5
 8003af2:	f001 f806 	bl	8004b02 <xTaskCreate>
 8003af6:	2801      	cmp	r0, #1
 8003af8:	d0d2      	beq.n	8003aa0 <osThreadNew+0x50>
            hTask = NULL;
 8003afa:	2300      	movs	r3, #0
 8003afc:	9305      	str	r3, [sp, #20]
 8003afe:	e7cf      	b.n	8003aa0 <osThreadNew+0x50>
        return (NULL);
 8003b00:	2000      	movs	r0, #0
 8003b02:	e7ce      	b.n	8003aa2 <osThreadNew+0x52>

08003b04 <osDelay>:
  /* Return flags before clearing */
  return (rflags);
}
#endif /* (configUSE_OS2_THREAD_FLAGS == 1) */

osStatus_t osDelay (uint32_t ticks) {
 8003b04:	b508      	push	{r3, lr}
 8003b06:	f3ef 8305 	mrs	r3, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
 8003b0a:	b933      	cbnz	r3, 8003b1a <osDelay+0x16>
    stat = osErrorISR;
  }
  else {
    stat = osOK;

    if (ticks != 0U) {
 8003b0c:	b908      	cbnz	r0, 8003b12 <osDelay+0xe>
    stat = osOK;
 8003b0e:	2000      	movs	r0, #0
      vTaskDelay(ticks);
    }
  }

  return (stat);
}
 8003b10:	bd08      	pop	{r3, pc}
      vTaskDelay(ticks);
 8003b12:	f001 f995 	bl	8004e40 <vTaskDelay>
    stat = osOK;
 8003b16:	2000      	movs	r0, #0
 8003b18:	e7fa      	b.n	8003b10 <osDelay+0xc>
    stat = osErrorISR;
 8003b1a:	f06f 0005 	mvn.w	r0, #5
 8003b1e:	e7f7      	b.n	8003b10 <osDelay+0xc>

08003b20 <vApplicationGetIdleTaskMemory>:
__WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  /* Idle task control block and stack */
  static StaticTask_t Idle_TCB;
  static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];

  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 8003b20:	4b03      	ldr	r3, [pc, #12]	@ (8003b30 <vApplicationGetIdleTaskMemory+0x10>)
 8003b22:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 8003b24:	4b03      	ldr	r3, [pc, #12]	@ (8003b34 <vApplicationGetIdleTaskMemory+0x14>)
 8003b26:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 8003b28:	2380      	movs	r3, #128	@ 0x80
 8003b2a:	6013      	str	r3, [r2, #0]
}
 8003b2c:	4770      	bx	lr
 8003b2e:	bf00      	nop
 8003b30:	20001360 	.word	0x20001360
 8003b34:	20001160 	.word	0x20001160

08003b38 <vApplicationGetTimerTaskMemory>:
__WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  /* Timer task control block and stack */
  static StaticTask_t Timer_TCB;
  static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];

  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 8003b38:	4b03      	ldr	r3, [pc, #12]	@ (8003b48 <vApplicationGetTimerTaskMemory+0x10>)
 8003b3a:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 8003b3c:	4b03      	ldr	r3, [pc, #12]	@ (8003b4c <vApplicationGetTimerTaskMemory+0x14>)
 8003b3e:	600b      	str	r3, [r1, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 8003b40:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8003b44:	6013      	str	r3, [r2, #0]
}
 8003b46:	4770      	bx	lr
 8003b48:	200010b8 	.word	0x200010b8
 8003b4c:	20000cb8 	.word	0x20000cb8

08003b50 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
 8003b50:	b91a      	cbnz	r2, 8003b5a <prvTestWaitCondition+0xa>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 8003b52:	4208      	tst	r0, r1
 8003b54:	d105      	bne.n	8003b62 <prvTestWaitCondition+0x12>
BaseType_t xWaitConditionMet = pdFALSE;
 8003b56:	4610      	mov	r0, r2
 8003b58:	4770      	bx	lr
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8003b5a:	4381      	bics	r1, r0
 8003b5c:	d003      	beq.n	8003b66 <prvTestWaitCondition+0x16>
BaseType_t xWaitConditionMet = pdFALSE;
 8003b5e:	2000      	movs	r0, #0
 8003b60:	4770      	bx	lr
			xWaitConditionMet = pdTRUE;
 8003b62:	2001      	movs	r0, #1
 8003b64:	4770      	bx	lr
		{
			xWaitConditionMet = pdTRUE;
 8003b66:	2001      	movs	r0, #1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
 8003b68:	4770      	bx	lr

08003b6a <xEventGroupCreate>:
	{
 8003b6a:	b538      	push	{r3, r4, r5, lr}
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 8003b6c:	2020      	movs	r0, #32
 8003b6e:	f002 f899 	bl	8005ca4 <pvPortMalloc>
		if( pxEventBits != NULL )
 8003b72:	4604      	mov	r4, r0
 8003b74:	b128      	cbz	r0, 8003b82 <xEventGroupCreate+0x18>
			pxEventBits->uxEventBits = 0;
 8003b76:	2500      	movs	r5, #0
 8003b78:	f840 5b04 	str.w	r5, [r0], #4
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 8003b7c:	f000 f914 	bl	8003da8 <vListInitialise>
				pxEventBits->ucStaticallyAllocated = pdFALSE;
 8003b80:	7725      	strb	r5, [r4, #28]
	}
 8003b82:	4620      	mov	r0, r4
 8003b84:	bd38      	pop	{r3, r4, r5, pc}

08003b86 <xEventGroupWaitBits>:
	configASSERT( xEventGroup );
 8003b86:	b188      	cbz	r0, 8003bac <xEventGroupWaitBits+0x26>
{
 8003b88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003b8c:	460c      	mov	r4, r1
 8003b8e:	4616      	mov	r6, r2
 8003b90:	461d      	mov	r5, r3
 8003b92:	4607      	mov	r7, r0
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8003b94:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
 8003b98:	d311      	bcc.n	8003bbe <xEventGroupWaitBits+0x38>
 8003b9a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003b9e:	f383 8811 	msr	BASEPRI, r3
 8003ba2:	f3bf 8f6f 	isb	sy
 8003ba6:	f3bf 8f4f 	dsb	sy
 8003baa:	e7fe      	b.n	8003baa <xEventGroupWaitBits+0x24>
 8003bac:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003bb0:	f383 8811 	msr	BASEPRI, r3
 8003bb4:	f3bf 8f6f 	isb	sy
 8003bb8:	f3bf 8f4f 	dsb	sy
	configASSERT( xEventGroup );
 8003bbc:	e7fe      	b.n	8003bbc <xEventGroupWaitBits+0x36>
	configASSERT( uxBitsToWaitFor != 0 );
 8003bbe:	b941      	cbnz	r1, 8003bd2 <xEventGroupWaitBits+0x4c>
 8003bc0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003bc4:	f383 8811 	msr	BASEPRI, r3
 8003bc8:	f3bf 8f6f 	isb	sy
 8003bcc:	f3bf 8f4f 	dsb	sy
 8003bd0:	e7fe      	b.n	8003bd0 <xEventGroupWaitBits+0x4a>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8003bd2:	f001 fb0d 	bl	80051f0 <xTaskGetSchedulerState>
 8003bd6:	b950      	cbnz	r0, 8003bee <xEventGroupWaitBits+0x68>
 8003bd8:	9b06      	ldr	r3, [sp, #24]
 8003bda:	b143      	cbz	r3, 8003bee <xEventGroupWaitBits+0x68>
 8003bdc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003be0:	f383 8811 	msr	BASEPRI, r3
 8003be4:	f3bf 8f6f 	isb	sy
 8003be8:	f3bf 8f4f 	dsb	sy
 8003bec:	e7fe      	b.n	8003bec <xEventGroupWaitBits+0x66>
	vTaskSuspendAll();
 8003bee:	f001 f811 	bl	8004c14 <vTaskSuspendAll>
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 8003bf2:	f8d7 8000 	ldr.w	r8, [r7]
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 8003bf6:	462a      	mov	r2, r5
 8003bf8:	4621      	mov	r1, r4
 8003bfa:	4640      	mov	r0, r8
 8003bfc:	f7ff ffa8 	bl	8003b50 <prvTestWaitCondition>
		if( xWaitConditionMet != pdFALSE )
 8003c00:	b1f8      	cbz	r0, 8003c42 <xEventGroupWaitBits+0xbc>
			if( xClearOnExit != pdFALSE )
 8003c02:	b38e      	cbz	r6, 8003c68 <xEventGroupWaitBits+0xe2>
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8003c04:	ea28 0304 	bic.w	r3, r8, r4
 8003c08:	603b      	str	r3, [r7, #0]
			xTicksToWait = ( TickType_t ) 0;
 8003c0a:	2300      	movs	r3, #0
 8003c0c:	9306      	str	r3, [sp, #24]
	xAlreadyYielded = xTaskResumeAll();
 8003c0e:	f001 f89b 	bl	8004d48 <xTaskResumeAll>
	if( xTicksToWait != ( TickType_t ) 0 )
 8003c12:	9b06      	ldr	r3, [sp, #24]
 8003c14:	b193      	cbz	r3, 8003c3c <xEventGroupWaitBits+0xb6>
		if( xAlreadyYielded == pdFALSE )
 8003c16:	b948      	cbnz	r0, 8003c2c <xEventGroupWaitBits+0xa6>
			portYIELD_WITHIN_API();
 8003c18:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8003c1c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8003c20:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8003c24:	f3bf 8f4f 	dsb	sy
 8003c28:	f3bf 8f6f 	isb	sy
		uxReturn = uxTaskResetEventItemValue();
 8003c2c:	f001 fbd4 	bl	80053d8 <uxTaskResetEventItemValue>
 8003c30:	4680      	mov	r8, r0
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8003c32:	f010 7f00 	tst.w	r0, #33554432	@ 0x2000000
 8003c36:	d01a      	beq.n	8003c6e <xEventGroupWaitBits+0xe8>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 8003c38:	f028 487f 	bic.w	r8, r8, #4278190080	@ 0xff000000
}
 8003c3c:	4640      	mov	r0, r8
 8003c3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		else if( xTicksToWait == ( TickType_t ) 0 )
 8003c42:	9b06      	ldr	r3, [sp, #24]
 8003c44:	2b00      	cmp	r3, #0
 8003c46:	d0e2      	beq.n	8003c0e <xEventGroupWaitBits+0x88>
			if( xClearOnExit != pdFALSE )
 8003c48:	b95e      	cbnz	r6, 8003c62 <xEventGroupWaitBits+0xdc>
EventBits_t uxReturn, uxControlBits = 0;
 8003c4a:	2100      	movs	r1, #0
			if( xWaitForAllBits != pdFALSE )
 8003c4c:	b10d      	cbz	r5, 8003c52 <xEventGroupWaitBits+0xcc>
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 8003c4e:	f041 6180 	orr.w	r1, r1, #67108864	@ 0x4000000
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 8003c52:	9a06      	ldr	r2, [sp, #24]
 8003c54:	4321      	orrs	r1, r4
 8003c56:	1d38      	adds	r0, r7, #4
 8003c58:	f001 f982 	bl	8004f60 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;
 8003c5c:	f04f 0800 	mov.w	r8, #0
 8003c60:	e7d5      	b.n	8003c0e <xEventGroupWaitBits+0x88>
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 8003c62:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
 8003c66:	e7f1      	b.n	8003c4c <xEventGroupWaitBits+0xc6>
			xTicksToWait = ( TickType_t ) 0;
 8003c68:	2300      	movs	r3, #0
 8003c6a:	9306      	str	r3, [sp, #24]
 8003c6c:	e7cf      	b.n	8003c0e <xEventGroupWaitBits+0x88>
			taskENTER_CRITICAL();
 8003c6e:	f001 fe61 	bl	8005934 <vPortEnterCritical>
				uxReturn = pxEventBits->uxEventBits;
 8003c72:	f8d7 8000 	ldr.w	r8, [r7]
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 8003c76:	462a      	mov	r2, r5
 8003c78:	4621      	mov	r1, r4
 8003c7a:	4640      	mov	r0, r8
 8003c7c:	f7ff ff68 	bl	8003b50 <prvTestWaitCondition>
 8003c80:	b118      	cbz	r0, 8003c8a <xEventGroupWaitBits+0x104>
					if( xClearOnExit != pdFALSE )
 8003c82:	b116      	cbz	r6, 8003c8a <xEventGroupWaitBits+0x104>
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8003c84:	ea28 0404 	bic.w	r4, r8, r4
 8003c88:	603c      	str	r4, [r7, #0]
			taskEXIT_CRITICAL();
 8003c8a:	f001 fe75 	bl	8005978 <vPortExitCritical>
 8003c8e:	e7d3      	b.n	8003c38 <xEventGroupWaitBits+0xb2>

08003c90 <xEventGroupClearBits>:
	configASSERT( xEventGroup );
 8003c90:	b170      	cbz	r0, 8003cb0 <xEventGroupClearBits+0x20>
{
 8003c92:	b570      	push	{r4, r5, r6, lr}
 8003c94:	460c      	mov	r4, r1
 8003c96:	4605      	mov	r5, r0
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8003c98:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
 8003c9c:	d311      	bcc.n	8003cc2 <xEventGroupClearBits+0x32>
 8003c9e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003ca2:	f383 8811 	msr	BASEPRI, r3
 8003ca6:	f3bf 8f6f 	isb	sy
 8003caa:	f3bf 8f4f 	dsb	sy
 8003cae:	e7fe      	b.n	8003cae <xEventGroupClearBits+0x1e>
 8003cb0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003cb4:	f383 8811 	msr	BASEPRI, r3
 8003cb8:	f3bf 8f6f 	isb	sy
 8003cbc:	f3bf 8f4f 	dsb	sy
	configASSERT( xEventGroup );
 8003cc0:	e7fe      	b.n	8003cc0 <xEventGroupClearBits+0x30>
	taskENTER_CRITICAL();
 8003cc2:	f001 fe37 	bl	8005934 <vPortEnterCritical>
		uxReturn = pxEventBits->uxEventBits;
 8003cc6:	682e      	ldr	r6, [r5, #0]
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 8003cc8:	ea26 0404 	bic.w	r4, r6, r4
 8003ccc:	602c      	str	r4, [r5, #0]
	taskEXIT_CRITICAL();
 8003cce:	f001 fe53 	bl	8005978 <vPortExitCritical>
}
 8003cd2:	4630      	mov	r0, r6
 8003cd4:	bd70      	pop	{r4, r5, r6, pc}

08003cd6 <xEventGroupSetBits>:
{
 8003cd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( xEventGroup );
 8003cd8:	b168      	cbz	r0, 8003cf6 <xEventGroupSetBits+0x20>
 8003cda:	460d      	mov	r5, r1
 8003cdc:	4604      	mov	r4, r0
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8003cde:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
 8003ce2:	d311      	bcc.n	8003d08 <xEventGroupSetBits+0x32>
 8003ce4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003ce8:	f383 8811 	msr	BASEPRI, r3
 8003cec:	f3bf 8f6f 	isb	sy
 8003cf0:	f3bf 8f4f 	dsb	sy
 8003cf4:	e7fe      	b.n	8003cf4 <xEventGroupSetBits+0x1e>
 8003cf6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003cfa:	f383 8811 	msr	BASEPRI, r3
 8003cfe:	f3bf 8f6f 	isb	sy
 8003d02:	f3bf 8f4f 	dsb	sy
	configASSERT( xEventGroup );
 8003d06:	e7fe      	b.n	8003d06 <xEventGroupSetBits+0x30>
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003d08:	f100 060c 	add.w	r6, r0, #12
	vTaskSuspendAll();
 8003d0c:	f000 ff82 	bl	8004c14 <vTaskSuspendAll>
		pxListItem = listGET_HEAD_ENTRY( pxList );
 8003d10:	6920      	ldr	r0, [r4, #16]
		pxEventBits->uxEventBits |= uxBitsToSet;
 8003d12:	6823      	ldr	r3, [r4, #0]
 8003d14:	432b      	orrs	r3, r5
 8003d16:	6023      	str	r3, [r4, #0]
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 8003d18:	2700      	movs	r7, #0
		while( pxListItem != pxListEnd )
 8003d1a:	e00a      	b.n	8003d32 <xEventGroupSetBits+0x5c>
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 8003d1c:	6821      	ldr	r1, [r4, #0]
 8003d1e:	ea32 0101 	bics.w	r1, r2, r1
 8003d22:	d105      	bne.n	8003d30 <xEventGroupSetBits+0x5a>
 8003d24:	e011      	b.n	8003d4a <xEventGroupSetBits+0x74>
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8003d26:	6821      	ldr	r1, [r4, #0]
 8003d28:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 8003d2c:	f001 f9a6 	bl	800507c <vTaskRemoveFromUnorderedEventList>
{
 8003d30:	4628      	mov	r0, r5
		while( pxListItem != pxListEnd )
 8003d32:	42b0      	cmp	r0, r6
 8003d34:	d00e      	beq.n	8003d54 <xEventGroupSetBits+0x7e>
			pxNext = listGET_NEXT( pxListItem );
 8003d36:	6845      	ldr	r5, [r0, #4]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 8003d38:	6803      	ldr	r3, [r0, #0]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8003d3a:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 8003d3e:	f013 6f80 	tst.w	r3, #67108864	@ 0x4000000
 8003d42:	d1eb      	bne.n	8003d1c <xEventGroupSetBits+0x46>
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 8003d44:	6821      	ldr	r1, [r4, #0]
 8003d46:	4211      	tst	r1, r2
 8003d48:	d0f2      	beq.n	8003d30 <xEventGroupSetBits+0x5a>
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 8003d4a:	f013 7f80 	tst.w	r3, #16777216	@ 0x1000000
 8003d4e:	d0ea      	beq.n	8003d26 <xEventGroupSetBits+0x50>
					uxBitsToClear |= uxBitsWaitedFor;
 8003d50:	4317      	orrs	r7, r2
 8003d52:	e7e8      	b.n	8003d26 <xEventGroupSetBits+0x50>
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 8003d54:	6823      	ldr	r3, [r4, #0]
 8003d56:	ea23 0307 	bic.w	r3, r3, r7
 8003d5a:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 8003d5c:	f000 fff4 	bl	8004d48 <xTaskResumeAll>
}
 8003d60:	6820      	ldr	r0, [r4, #0]
 8003d62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003d64 <vEventGroupDelete>:
{
 8003d64:	b510      	push	{r4, lr}
 8003d66:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8003d68:	f000 ff54 	bl	8004c14 <vTaskSuspendAll>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8003d6c:	6863      	ldr	r3, [r4, #4]
 8003d6e:	b193      	cbz	r3, 8003d96 <vEventGroupDelete+0x32>
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 8003d70:	6920      	ldr	r0, [r4, #16]
 8003d72:	f104 030c 	add.w	r3, r4, #12
 8003d76:	4298      	cmp	r0, r3
 8003d78:	d004      	beq.n	8003d84 <vEventGroupDelete+0x20>
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 8003d7a:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
 8003d7e:	f001 f97d 	bl	800507c <vTaskRemoveFromUnorderedEventList>
 8003d82:	e7f3      	b.n	8003d6c <vEventGroupDelete+0x8>
 8003d84:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003d88:	f383 8811 	msr	BASEPRI, r3
 8003d8c:	f3bf 8f6f 	isb	sy
 8003d90:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 8003d94:	e7fe      	b.n	8003d94 <vEventGroupDelete+0x30>
			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 8003d96:	7f23      	ldrb	r3, [r4, #28]
 8003d98:	b113      	cbz	r3, 8003da0 <vEventGroupDelete+0x3c>
	( void ) xTaskResumeAll();
 8003d9a:	f000 ffd5 	bl	8004d48 <xTaskResumeAll>
}
 8003d9e:	bd10      	pop	{r4, pc}
				vPortFree( pxEventBits );
 8003da0:	4620      	mov	r0, r4
 8003da2:	f002 f801 	bl	8005da8 <vPortFree>
 8003da6:	e7f8      	b.n	8003d9a <vEventGroupDelete+0x36>

08003da8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003da8:	f100 0308 	add.w	r3, r0, #8
 8003dac:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003dae:	f04f 32ff 	mov.w	r2, #4294967295
 8003db2:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003db4:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003db6:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003db8:	2300      	movs	r3, #0
 8003dba:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8003dbc:	4770      	bx	lr

08003dbe <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8003dbe:	2300      	movs	r3, #0
 8003dc0:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8003dc2:	4770      	bx	lr

08003dc4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8003dc4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003dc6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003dc8:	689a      	ldr	r2, [r3, #8]
 8003dca:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003dcc:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003dce:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 8003dd0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003dd2:	6803      	ldr	r3, [r0, #0]
 8003dd4:	3301      	adds	r3, #1
 8003dd6:	6003      	str	r3, [r0, #0]
}
 8003dd8:	4770      	bx	lr

08003dda <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003dda:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003ddc:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003dde:	f1b5 3fff 	cmp.w	r5, #4294967295
 8003de2:	d011      	beq.n	8003e08 <vListInsert+0x2e>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8003de4:	f100 0308 	add.w	r3, r0, #8
 8003de8:	461c      	mov	r4, r3
 8003dea:	685b      	ldr	r3, [r3, #4]
 8003dec:	681a      	ldr	r2, [r3, #0]
 8003dee:	42aa      	cmp	r2, r5
 8003df0:	d9fa      	bls.n	8003de8 <vListInsert+0xe>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003df2:	6863      	ldr	r3, [r4, #4]
 8003df4:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003df6:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003df8:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8003dfa:	6061      	str	r1, [r4, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 8003dfc:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003dfe:	6803      	ldr	r3, [r0, #0]
 8003e00:	3301      	adds	r3, #1
 8003e02:	6003      	str	r3, [r0, #0]
}
 8003e04:	bc30      	pop	{r4, r5}
 8003e06:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8003e08:	6904      	ldr	r4, [r0, #16]
 8003e0a:	e7f2      	b.n	8003df2 <vListInsert+0x18>

08003e0c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8003e0c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003e0e:	6841      	ldr	r1, [r0, #4]
 8003e10:	6882      	ldr	r2, [r0, #8]
 8003e12:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003e14:	6841      	ldr	r1, [r0, #4]
 8003e16:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003e18:	685a      	ldr	r2, [r3, #4]
 8003e1a:	4282      	cmp	r2, r0
 8003e1c:	d006      	beq.n	8003e2c <uxListRemove+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8003e1e:	2200      	movs	r2, #0
 8003e20:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8003e22:	681a      	ldr	r2, [r3, #0]
 8003e24:	3a01      	subs	r2, #1
 8003e26:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8003e28:	6818      	ldr	r0, [r3, #0]
}
 8003e2a:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003e2c:	6882      	ldr	r2, [r0, #8]
 8003e2e:	605a      	str	r2, [r3, #4]
 8003e30:	e7f5      	b.n	8003e1e <uxListRemove+0x12>

08003e32 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 8003e32:	4603      	mov	r3, r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8003e34:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 8003e36:	b118      	cbz	r0, 8003e40 <prvGetDisinheritPriorityAfterTimeout+0xe>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8003e38:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003e3a:	6818      	ldr	r0, [r3, #0]
 8003e3c:	f1c0 0038 	rsb	r0, r0, #56	@ 0x38
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
		}

		return uxHighestPriorityOfWaitingTasks;
	}
 8003e40:	4770      	bx	lr

08003e42 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 8003e42:	b510      	push	{r4, lr}
 8003e44:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8003e46:	f001 fd75 	bl	8005934 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8003e4a:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8003e4c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003e4e:	429a      	cmp	r2, r3
 8003e50:	d004      	beq.n	8003e5c <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 8003e52:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
 8003e54:	f001 fd90 	bl	8005978 <vPortExitCritical>

	return xReturn;
}
 8003e58:	4620      	mov	r0, r4
 8003e5a:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 8003e5c:	2401      	movs	r4, #1
 8003e5e:	e7f9      	b.n	8003e54 <prvIsQueueFull+0x12>

08003e60 <prvIsQueueEmpty>:
{
 8003e60:	b510      	push	{r4, lr}
 8003e62:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8003e64:	f001 fd66 	bl	8005934 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8003e68:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8003e6a:	b923      	cbnz	r3, 8003e76 <prvIsQueueEmpty+0x16>
			xReturn = pdTRUE;
 8003e6c:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 8003e6e:	f001 fd83 	bl	8005978 <vPortExitCritical>
}
 8003e72:	4620      	mov	r0, r4
 8003e74:	bd10      	pop	{r4, pc}
			xReturn = pdFALSE;
 8003e76:	2400      	movs	r4, #0
 8003e78:	e7f9      	b.n	8003e6e <prvIsQueueEmpty+0xe>

08003e7a <prvCopyDataToQueue>:
{
 8003e7a:	b570      	push	{r4, r5, r6, lr}
 8003e7c:	4604      	mov	r4, r0
 8003e7e:	4615      	mov	r5, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8003e80:	6b86      	ldr	r6, [r0, #56]	@ 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8003e82:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 8003e84:	b95a      	cbnz	r2, 8003e9e <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8003e86:	6803      	ldr	r3, [r0, #0]
 8003e88:	b11b      	cbz	r3, 8003e92 <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
 8003e8a:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8003e8c:	3601      	adds	r6, #1
 8003e8e:	63a6      	str	r6, [r4, #56]	@ 0x38
}
 8003e90:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8003e92:	6880      	ldr	r0, [r0, #8]
 8003e94:	f001 fa08 	bl	80052a8 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8003e98:	2300      	movs	r3, #0
 8003e9a:	60a3      	str	r3, [r4, #8]
 8003e9c:	e7f6      	b.n	8003e8c <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 8003e9e:	b96d      	cbnz	r5, 8003ebc <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8003ea0:	6840      	ldr	r0, [r0, #4]
 8003ea2:	f00a ffe0 	bl	800ee66 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8003ea6:	6863      	ldr	r3, [r4, #4]
 8003ea8:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8003eaa:	4413      	add	r3, r2
 8003eac:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003eae:	68a2      	ldr	r2, [r4, #8]
 8003eb0:	4293      	cmp	r3, r2
 8003eb2:	d319      	bcc.n	8003ee8 <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8003eb4:	6823      	ldr	r3, [r4, #0]
 8003eb6:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
 8003eb8:	4628      	mov	r0, r5
 8003eba:	e7e7      	b.n	8003e8c <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8003ebc:	68c0      	ldr	r0, [r0, #12]
 8003ebe:	f00a ffd2 	bl	800ee66 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8003ec2:	68e3      	ldr	r3, [r4, #12]
 8003ec4:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8003ec6:	4251      	negs	r1, r2
 8003ec8:	1a9b      	subs	r3, r3, r2
 8003eca:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8003ecc:	6822      	ldr	r2, [r4, #0]
 8003ece:	4293      	cmp	r3, r2
 8003ed0:	d202      	bcs.n	8003ed8 <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8003ed2:	68a3      	ldr	r3, [r4, #8]
 8003ed4:	440b      	add	r3, r1
 8003ed6:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8003ed8:	2d02      	cmp	r5, #2
 8003eda:	d001      	beq.n	8003ee0 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 8003edc:	2000      	movs	r0, #0
 8003ede:	e7d5      	b.n	8003e8c <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8003ee0:	b126      	cbz	r6, 8003eec <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 8003ee2:	3e01      	subs	r6, #1
BaseType_t xReturn = pdFALSE;
 8003ee4:	2000      	movs	r0, #0
 8003ee6:	e7d1      	b.n	8003e8c <prvCopyDataToQueue+0x12>
 8003ee8:	4628      	mov	r0, r5
 8003eea:	e7cf      	b.n	8003e8c <prvCopyDataToQueue+0x12>
 8003eec:	2000      	movs	r0, #0
 8003eee:	e7cd      	b.n	8003e8c <prvCopyDataToQueue+0x12>

08003ef0 <prvCopyDataFromQueue>:
{
 8003ef0:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8003ef2:	6c02      	ldr	r2, [r0, #64]	@ 0x40
 8003ef4:	b16a      	cbz	r2, 8003f12 <prvCopyDataFromQueue+0x22>
{
 8003ef6:	b510      	push	{r4, lr}
 8003ef8:	4608      	mov	r0, r1
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8003efa:	68d9      	ldr	r1, [r3, #12]
 8003efc:	4411      	add	r1, r2
 8003efe:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8003f00:	689c      	ldr	r4, [r3, #8]
 8003f02:	42a1      	cmp	r1, r4
 8003f04:	d301      	bcc.n	8003f0a <prvCopyDataFromQueue+0x1a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8003f06:	6819      	ldr	r1, [r3, #0]
 8003f08:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8003f0a:	68d9      	ldr	r1, [r3, #12]
 8003f0c:	f00a ffab 	bl	800ee66 <memcpy>
}
 8003f10:	bd10      	pop	{r4, pc}
 8003f12:	4770      	bx	lr

08003f14 <prvUnlockQueue>:
{
 8003f14:	b538      	push	{r3, r4, r5, lr}
 8003f16:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 8003f18:	f001 fd0c 	bl	8005934 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8003f1c:	f895 4045 	ldrb.w	r4, [r5, #69]	@ 0x45
 8003f20:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8003f22:	e001      	b.n	8003f28 <prvUnlockQueue+0x14>
			--cTxLock;
 8003f24:	3c01      	subs	r4, #1
 8003f26:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8003f28:	2c00      	cmp	r4, #0
 8003f2a:	dd0a      	ble.n	8003f42 <prvUnlockQueue+0x2e>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8003f2c:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 8003f2e:	b143      	cbz	r3, 8003f42 <prvUnlockQueue+0x2e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8003f30:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 8003f34:	f001 f85c 	bl	8004ff0 <xTaskRemoveFromEventList>
 8003f38:	2800      	cmp	r0, #0
 8003f3a:	d0f3      	beq.n	8003f24 <prvUnlockQueue+0x10>
						vTaskMissedYield();
 8003f3c:	f001 f94c 	bl	80051d8 <vTaskMissedYield>
 8003f40:	e7f0      	b.n	8003f24 <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
 8003f42:	23ff      	movs	r3, #255	@ 0xff
 8003f44:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8003f48:	f001 fd16 	bl	8005978 <vPortExitCritical>
	taskENTER_CRITICAL();
 8003f4c:	f001 fcf2 	bl	8005934 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8003f50:	f895 4044 	ldrb.w	r4, [r5, #68]	@ 0x44
 8003f54:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8003f56:	e001      	b.n	8003f5c <prvUnlockQueue+0x48>
				--cRxLock;
 8003f58:	3c01      	subs	r4, #1
 8003f5a:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8003f5c:	2c00      	cmp	r4, #0
 8003f5e:	dd0a      	ble.n	8003f76 <prvUnlockQueue+0x62>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8003f60:	692b      	ldr	r3, [r5, #16]
 8003f62:	b143      	cbz	r3, 8003f76 <prvUnlockQueue+0x62>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003f64:	f105 0010 	add.w	r0, r5, #16
 8003f68:	f001 f842 	bl	8004ff0 <xTaskRemoveFromEventList>
 8003f6c:	2800      	cmp	r0, #0
 8003f6e:	d0f3      	beq.n	8003f58 <prvUnlockQueue+0x44>
					vTaskMissedYield();
 8003f70:	f001 f932 	bl	80051d8 <vTaskMissedYield>
 8003f74:	e7f0      	b.n	8003f58 <prvUnlockQueue+0x44>
		pxQueue->cRxLock = queueUNLOCKED;
 8003f76:	23ff      	movs	r3, #255	@ 0xff
 8003f78:	f885 3044 	strb.w	r3, [r5, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8003f7c:	f001 fcfc 	bl	8005978 <vPortExitCritical>
}
 8003f80:	bd38      	pop	{r3, r4, r5, pc}

08003f82 <xQueueGenericReset>:
{
 8003f82:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 8003f84:	b1e0      	cbz	r0, 8003fc0 <xQueueGenericReset+0x3e>
 8003f86:	460d      	mov	r5, r1
 8003f88:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8003f8a:	f001 fcd3 	bl	8005934 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8003f8e:	6823      	ldr	r3, [r4, #0]
 8003f90:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 8003f92:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8003f94:	fb01 3002 	mla	r0, r1, r2, r3
 8003f98:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8003f9a:	2000      	movs	r0, #0
 8003f9c:	63a0      	str	r0, [r4, #56]	@ 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8003f9e:	6063      	str	r3, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8003fa0:	3a01      	subs	r2, #1
 8003fa2:	fb02 3301 	mla	r3, r2, r1, r3
 8003fa6:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8003fa8:	23ff      	movs	r3, #255	@ 0xff
 8003faa:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8003fae:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
		if( xNewQueue == pdFALSE )
 8003fb2:	b9fd      	cbnz	r5, 8003ff4 <xQueueGenericReset+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8003fb4:	6923      	ldr	r3, [r4, #16]
 8003fb6:	b963      	cbnz	r3, 8003fd2 <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
 8003fb8:	f001 fcde 	bl	8005978 <vPortExitCritical>
}
 8003fbc:	2001      	movs	r0, #1
 8003fbe:	bd38      	pop	{r3, r4, r5, pc}
 8003fc0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003fc4:	f383 8811 	msr	BASEPRI, r3
 8003fc8:	f3bf 8f6f 	isb	sy
 8003fcc:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8003fd0:	e7fe      	b.n	8003fd0 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003fd2:	f104 0010 	add.w	r0, r4, #16
 8003fd6:	f001 f80b 	bl	8004ff0 <xTaskRemoveFromEventList>
 8003fda:	2800      	cmp	r0, #0
 8003fdc:	d0ec      	beq.n	8003fb8 <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 8003fde:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8003fe2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8003fe6:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8003fea:	f3bf 8f4f 	dsb	sy
 8003fee:	f3bf 8f6f 	isb	sy
 8003ff2:	e7e1      	b.n	8003fb8 <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8003ff4:	f104 0010 	add.w	r0, r4, #16
 8003ff8:	f7ff fed6 	bl	8003da8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8003ffc:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8004000:	f7ff fed2 	bl	8003da8 <vListInitialise>
 8004004:	e7d8      	b.n	8003fb8 <xQueueGenericReset+0x36>

08004006 <prvInitialiseNewQueue>:
{
 8004006:	b538      	push	{r3, r4, r5, lr}
 8004008:	461d      	mov	r5, r3
 800400a:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
 800400c:	460b      	mov	r3, r1
 800400e:	b949      	cbnz	r1, 8004024 <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8004010:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8004012:	63e0      	str	r0, [r4, #60]	@ 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8004014:	6423      	str	r3, [r4, #64]	@ 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8004016:	2101      	movs	r1, #1
 8004018:	4620      	mov	r0, r4
 800401a:	f7ff ffb2 	bl	8003f82 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 800401e:	f884 504c 	strb.w	r5, [r4, #76]	@ 0x4c
}
 8004022:	bd38      	pop	{r3, r4, r5, pc}
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8004024:	6022      	str	r2, [r4, #0]
 8004026:	e7f4      	b.n	8004012 <prvInitialiseNewQueue+0xc>

08004028 <xQueueGenericCreateStatic>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8004028:	b940      	cbnz	r0, 800403c <xQueueGenericCreateStatic+0x14>
 800402a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800402e:	f383 8811 	msr	BASEPRI, r3
 8004032:	f3bf 8f6f 	isb	sy
 8004036:	f3bf 8f4f 	dsb	sy
 800403a:	e7fe      	b.n	800403a <xQueueGenericCreateStatic+0x12>
	{
 800403c:	b510      	push	{r4, lr}
 800403e:	b084      	sub	sp, #16
 8004040:	461c      	mov	r4, r3
 8004042:	4684      	mov	ip, r0
		configASSERT( pxStaticQueue != NULL );
 8004044:	b153      	cbz	r3, 800405c <xQueueGenericCreateStatic+0x34>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8004046:	b192      	cbz	r2, 800406e <xQueueGenericCreateStatic+0x46>
 8004048:	b989      	cbnz	r1, 800406e <xQueueGenericCreateStatic+0x46>
 800404a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800404e:	f383 8811 	msr	BASEPRI, r3
 8004052:	f3bf 8f6f 	isb	sy
 8004056:	f3bf 8f4f 	dsb	sy
 800405a:	e7fe      	b.n	800405a <xQueueGenericCreateStatic+0x32>
 800405c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004060:	f383 8811 	msr	BASEPRI, r3
 8004064:	f3bf 8f6f 	isb	sy
 8004068:	f3bf 8f4f 	dsb	sy
		configASSERT( pxStaticQueue != NULL );
 800406c:	e7fe      	b.n	800406c <xQueueGenericCreateStatic+0x44>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 800406e:	b16a      	cbz	r2, 800408c <xQueueGenericCreateStatic+0x64>
			volatile size_t xSize = sizeof( StaticQueue_t );
 8004070:	2350      	movs	r3, #80	@ 0x50
 8004072:	9303      	str	r3, [sp, #12]
			configASSERT( xSize == sizeof( Queue_t ) );
 8004074:	9b03      	ldr	r3, [sp, #12]
 8004076:	2b50      	cmp	r3, #80	@ 0x50
 8004078:	d013      	beq.n	80040a2 <xQueueGenericCreateStatic+0x7a>
 800407a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800407e:	f383 8811 	msr	BASEPRI, r3
 8004082:	f3bf 8f6f 	isb	sy
 8004086:	f3bf 8f4f 	dsb	sy
 800408a:	e7fe      	b.n	800408a <xQueueGenericCreateStatic+0x62>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 800408c:	2900      	cmp	r1, #0
 800408e:	d0ef      	beq.n	8004070 <xQueueGenericCreateStatic+0x48>
 8004090:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004094:	f383 8811 	msr	BASEPRI, r3
 8004098:	f3bf 8f6f 	isb	sy
 800409c:	f3bf 8f4f 	dsb	sy
 80040a0:	e7fe      	b.n	80040a0 <xQueueGenericCreateStatic+0x78>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 80040a2:	9b03      	ldr	r3, [sp, #12]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80040a4:	2301      	movs	r3, #1
 80040a6:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 80040aa:	9400      	str	r4, [sp, #0]
 80040ac:	f89d 3018 	ldrb.w	r3, [sp, #24]
 80040b0:	4660      	mov	r0, ip
 80040b2:	f7ff ffa8 	bl	8004006 <prvInitialiseNewQueue>
	}
 80040b6:	4620      	mov	r0, r4
 80040b8:	b004      	add	sp, #16
 80040ba:	bd10      	pop	{r4, pc}

080040bc <xQueueCreateCountingSemaphoreStatic>:
		configASSERT( uxMaxCount != 0 );
 80040bc:	b940      	cbnz	r0, 80040d0 <xQueueCreateCountingSemaphoreStatic+0x14>
 80040be:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80040c2:	f383 8811 	msr	BASEPRI, r3
 80040c6:	f3bf 8f6f 	isb	sy
 80040ca:	f3bf 8f4f 	dsb	sy
 80040ce:	e7fe      	b.n	80040ce <xQueueCreateCountingSemaphoreStatic+0x12>
	{
 80040d0:	b510      	push	{r4, lr}
 80040d2:	b082      	sub	sp, #8
 80040d4:	460c      	mov	r4, r1
		configASSERT( uxInitialCount <= uxMaxCount );
 80040d6:	4288      	cmp	r0, r1
 80040d8:	d208      	bcs.n	80040ec <xQueueCreateCountingSemaphoreStatic+0x30>
 80040da:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80040de:	f383 8811 	msr	BASEPRI, r3
 80040e2:	f3bf 8f6f 	isb	sy
 80040e6:	f3bf 8f4f 	dsb	sy
 80040ea:	e7fe      	b.n	80040ea <xQueueCreateCountingSemaphoreStatic+0x2e>
		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80040ec:	2302      	movs	r3, #2
 80040ee:	9300      	str	r3, [sp, #0]
 80040f0:	4613      	mov	r3, r2
 80040f2:	2200      	movs	r2, #0
 80040f4:	4611      	mov	r1, r2
 80040f6:	f7ff ff97 	bl	8004028 <xQueueGenericCreateStatic>
		if( xHandle != NULL )
 80040fa:	b100      	cbz	r0, 80040fe <xQueueCreateCountingSemaphoreStatic+0x42>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80040fc:	6384      	str	r4, [r0, #56]	@ 0x38
	}
 80040fe:	b002      	add	sp, #8
 8004100:	bd10      	pop	{r4, pc}

08004102 <xQueueGenericSend>:
{
 8004102:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004104:	b085      	sub	sp, #20
 8004106:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8004108:	b188      	cbz	r0, 800412e <xQueueGenericSend+0x2c>
 800410a:	460f      	mov	r7, r1
 800410c:	461d      	mov	r5, r3
 800410e:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004110:	b1b1      	cbz	r1, 8004140 <xQueueGenericSend+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004112:	2d02      	cmp	r5, #2
 8004114:	d120      	bne.n	8004158 <xQueueGenericSend+0x56>
 8004116:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8004118:	2b01      	cmp	r3, #1
 800411a:	d01d      	beq.n	8004158 <xQueueGenericSend+0x56>
 800411c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004120:	f383 8811 	msr	BASEPRI, r3
 8004124:	f3bf 8f6f 	isb	sy
 8004128:	f3bf 8f4f 	dsb	sy
 800412c:	e7fe      	b.n	800412c <xQueueGenericSend+0x2a>
 800412e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004132:	f383 8811 	msr	BASEPRI, r3
 8004136:	f3bf 8f6f 	isb	sy
 800413a:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 800413e:	e7fe      	b.n	800413e <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004140:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8004142:	2b00      	cmp	r3, #0
 8004144:	d0e5      	beq.n	8004112 <xQueueGenericSend+0x10>
 8004146:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800414a:	f383 8811 	msr	BASEPRI, r3
 800414e:	f3bf 8f6f 	isb	sy
 8004152:	f3bf 8f4f 	dsb	sy
 8004156:	e7fe      	b.n	8004156 <xQueueGenericSend+0x54>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004158:	f001 f84a 	bl	80051f0 <xTaskGetSchedulerState>
 800415c:	4606      	mov	r6, r0
 800415e:	b958      	cbnz	r0, 8004178 <xQueueGenericSend+0x76>
 8004160:	9b01      	ldr	r3, [sp, #4]
 8004162:	2b00      	cmp	r3, #0
 8004164:	d048      	beq.n	80041f8 <xQueueGenericSend+0xf6>
 8004166:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800416a:	f383 8811 	msr	BASEPRI, r3
 800416e:	f3bf 8f6f 	isb	sy
 8004172:	f3bf 8f4f 	dsb	sy
 8004176:	e7fe      	b.n	8004176 <xQueueGenericSend+0x74>
 8004178:	2600      	movs	r6, #0
 800417a:	e03d      	b.n	80041f8 <xQueueGenericSend+0xf6>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800417c:	462a      	mov	r2, r5
 800417e:	4639      	mov	r1, r7
 8004180:	4620      	mov	r0, r4
 8004182:	f7ff fe7a 	bl	8003e7a <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004186:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8004188:	b97b      	cbnz	r3, 80041aa <xQueueGenericSend+0xa8>
					else if( xYieldRequired != pdFALSE )
 800418a:	b148      	cbz	r0, 80041a0 <xQueueGenericSend+0x9e>
						queueYIELD_IF_USING_PREEMPTION();
 800418c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8004190:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8004194:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004198:	f3bf 8f4f 	dsb	sy
 800419c:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80041a0:	f001 fbea 	bl	8005978 <vPortExitCritical>
				return pdPASS;
 80041a4:	2001      	movs	r0, #1
}
 80041a6:	b005      	add	sp, #20
 80041a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80041aa:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 80041ae:	f000 ff1f 	bl	8004ff0 <xTaskRemoveFromEventList>
 80041b2:	2800      	cmp	r0, #0
 80041b4:	d0f4      	beq.n	80041a0 <xQueueGenericSend+0x9e>
							queueYIELD_IF_USING_PREEMPTION();
 80041b6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80041ba:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80041be:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80041c2:	f3bf 8f4f 	dsb	sy
 80041c6:	f3bf 8f6f 	isb	sy
 80041ca:	e7e9      	b.n	80041a0 <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
 80041cc:	f001 fbd4 	bl	8005978 <vPortExitCritical>
					return errQUEUE_FULL;
 80041d0:	2000      	movs	r0, #0
 80041d2:	e7e8      	b.n	80041a6 <xQueueGenericSend+0xa4>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80041d4:	a802      	add	r0, sp, #8
 80041d6:	f000 ffb1 	bl	800513c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80041da:	2601      	movs	r6, #1
 80041dc:	e019      	b.n	8004212 <xQueueGenericSend+0x110>
		prvLockQueue( pxQueue );
 80041de:	2300      	movs	r3, #0
 80041e0:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 80041e4:	e021      	b.n	800422a <xQueueGenericSend+0x128>
 80041e6:	2300      	movs	r3, #0
 80041e8:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 80041ec:	e023      	b.n	8004236 <xQueueGenericSend+0x134>
				prvUnlockQueue( pxQueue );
 80041ee:	4620      	mov	r0, r4
 80041f0:	f7ff fe90 	bl	8003f14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80041f4:	f000 fda8 	bl	8004d48 <xTaskResumeAll>
		taskENTER_CRITICAL();
 80041f8:	f001 fb9c 	bl	8005934 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80041fc:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 80041fe:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8004200:	429a      	cmp	r2, r3
 8004202:	d3bb      	bcc.n	800417c <xQueueGenericSend+0x7a>
 8004204:	2d02      	cmp	r5, #2
 8004206:	d0b9      	beq.n	800417c <xQueueGenericSend+0x7a>
				if( xTicksToWait == ( TickType_t ) 0 )
 8004208:	9b01      	ldr	r3, [sp, #4]
 800420a:	2b00      	cmp	r3, #0
 800420c:	d0de      	beq.n	80041cc <xQueueGenericSend+0xca>
				else if( xEntryTimeSet == pdFALSE )
 800420e:	2e00      	cmp	r6, #0
 8004210:	d0e0      	beq.n	80041d4 <xQueueGenericSend+0xd2>
		taskEXIT_CRITICAL();
 8004212:	f001 fbb1 	bl	8005978 <vPortExitCritical>
		vTaskSuspendAll();
 8004216:	f000 fcfd 	bl	8004c14 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800421a:	f001 fb8b 	bl	8005934 <vPortEnterCritical>
 800421e:	f894 2044 	ldrb.w	r2, [r4, #68]	@ 0x44
 8004222:	b252      	sxtb	r2, r2
 8004224:	f1b2 3fff 	cmp.w	r2, #4294967295
 8004228:	d0d9      	beq.n	80041de <xQueueGenericSend+0xdc>
 800422a:	f894 2045 	ldrb.w	r2, [r4, #69]	@ 0x45
 800422e:	b252      	sxtb	r2, r2
 8004230:	f1b2 3fff 	cmp.w	r2, #4294967295
 8004234:	d0d7      	beq.n	80041e6 <xQueueGenericSend+0xe4>
 8004236:	f001 fb9f 	bl	8005978 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800423a:	a901      	add	r1, sp, #4
 800423c:	a802      	add	r0, sp, #8
 800423e:	f000 ff89 	bl	8005154 <xTaskCheckForTimeOut>
 8004242:	b9d8      	cbnz	r0, 800427c <xQueueGenericSend+0x17a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8004244:	4620      	mov	r0, r4
 8004246:	f7ff fdfc 	bl	8003e42 <prvIsQueueFull>
 800424a:	2800      	cmp	r0, #0
 800424c:	d0cf      	beq.n	80041ee <xQueueGenericSend+0xec>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800424e:	9901      	ldr	r1, [sp, #4]
 8004250:	f104 0010 	add.w	r0, r4, #16
 8004254:	f000 fe6c 	bl	8004f30 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004258:	4620      	mov	r0, r4
 800425a:	f7ff fe5b 	bl	8003f14 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800425e:	f000 fd73 	bl	8004d48 <xTaskResumeAll>
 8004262:	2800      	cmp	r0, #0
 8004264:	d1c8      	bne.n	80041f8 <xQueueGenericSend+0xf6>
					portYIELD_WITHIN_API();
 8004266:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 800426a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800426e:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004272:	f3bf 8f4f 	dsb	sy
 8004276:	f3bf 8f6f 	isb	sy
 800427a:	e7bd      	b.n	80041f8 <xQueueGenericSend+0xf6>
			prvUnlockQueue( pxQueue );
 800427c:	4620      	mov	r0, r4
 800427e:	f7ff fe49 	bl	8003f14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004282:	f000 fd61 	bl	8004d48 <xTaskResumeAll>
			return errQUEUE_FULL;
 8004286:	2000      	movs	r0, #0
 8004288:	e78d      	b.n	80041a6 <xQueueGenericSend+0xa4>

0800428a <xQueueGenericSendFromISR>:
{
 800428a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 800428e:	b190      	cbz	r0, 80042b6 <xQueueGenericSendFromISR+0x2c>
 8004290:	460f      	mov	r7, r1
 8004292:	4616      	mov	r6, r2
 8004294:	461c      	mov	r4, r3
 8004296:	4605      	mov	r5, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004298:	b1b1      	cbz	r1, 80042c8 <xQueueGenericSendFromISR+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800429a:	2c02      	cmp	r4, #2
 800429c:	d120      	bne.n	80042e0 <xQueueGenericSendFromISR+0x56>
 800429e:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 80042a0:	2b01      	cmp	r3, #1
 80042a2:	d01d      	beq.n	80042e0 <xQueueGenericSendFromISR+0x56>
 80042a4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80042a8:	f383 8811 	msr	BASEPRI, r3
 80042ac:	f3bf 8f6f 	isb	sy
 80042b0:	f3bf 8f4f 	dsb	sy
 80042b4:	e7fe      	b.n	80042b4 <xQueueGenericSendFromISR+0x2a>
 80042b6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80042ba:	f383 8811 	msr	BASEPRI, r3
 80042be:	f3bf 8f6f 	isb	sy
 80042c2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80042c6:	e7fe      	b.n	80042c6 <xQueueGenericSendFromISR+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80042c8:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80042ca:	2b00      	cmp	r3, #0
 80042cc:	d0e5      	beq.n	800429a <xQueueGenericSendFromISR+0x10>
 80042ce:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80042d2:	f383 8811 	msr	BASEPRI, r3
 80042d6:	f3bf 8f6f 	isb	sy
 80042da:	f3bf 8f4f 	dsb	sy
 80042de:	e7fe      	b.n	80042de <xQueueGenericSendFromISR+0x54>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80042e0:	f001 fc4e 	bl	8005b80 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80042e4:	f3ef 8811 	mrs	r8, BASEPRI
 80042e8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80042ec:	f383 8811 	msr	BASEPRI, r3
 80042f0:	f3bf 8f6f 	isb	sy
 80042f4:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80042f8:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 80042fa:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
 80042fc:	429a      	cmp	r2, r3
 80042fe:	d306      	bcc.n	800430e <xQueueGenericSendFromISR+0x84>
 8004300:	2c02      	cmp	r4, #2
 8004302:	d004      	beq.n	800430e <xQueueGenericSendFromISR+0x84>
			xReturn = errQUEUE_FULL;
 8004304:	2000      	movs	r0, #0
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8004306:	f388 8811 	msr	BASEPRI, r8
}
 800430a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			const int8_t cTxLock = pxQueue->cTxLock;
 800430e:	f895 9045 	ldrb.w	r9, [r5, #69]	@ 0x45
 8004312:	fa4f f989 	sxtb.w	r9, r9
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004316:	6bab      	ldr	r3, [r5, #56]	@ 0x38
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004318:	4622      	mov	r2, r4
 800431a:	4639      	mov	r1, r7
 800431c:	4628      	mov	r0, r5
 800431e:	f7ff fdac 	bl	8003e7a <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8004322:	f1b9 3fff 	cmp.w	r9, #4294967295
 8004326:	d006      	beq.n	8004336 <xQueueGenericSendFromISR+0xac>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8004328:	f109 0301 	add.w	r3, r9, #1
 800432c:	b25b      	sxtb	r3, r3
 800432e:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
			xReturn = pdPASS;
 8004332:	2001      	movs	r0, #1
 8004334:	e7e7      	b.n	8004306 <xQueueGenericSendFromISR+0x7c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004336:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 8004338:	b90b      	cbnz	r3, 800433e <xQueueGenericSendFromISR+0xb4>
			xReturn = pdPASS;
 800433a:	2001      	movs	r0, #1
 800433c:	e7e3      	b.n	8004306 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800433e:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 8004342:	f000 fe55 	bl	8004ff0 <xTaskRemoveFromEventList>
 8004346:	b118      	cbz	r0, 8004350 <xQueueGenericSendFromISR+0xc6>
							if( pxHigherPriorityTaskWoken != NULL )
 8004348:	b126      	cbz	r6, 8004354 <xQueueGenericSendFromISR+0xca>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800434a:	2001      	movs	r0, #1
 800434c:	6030      	str	r0, [r6, #0]
 800434e:	e7da      	b.n	8004306 <xQueueGenericSendFromISR+0x7c>
			xReturn = pdPASS;
 8004350:	2001      	movs	r0, #1
 8004352:	e7d8      	b.n	8004306 <xQueueGenericSendFromISR+0x7c>
 8004354:	2001      	movs	r0, #1
 8004356:	e7d6      	b.n	8004306 <xQueueGenericSendFromISR+0x7c>

08004358 <xQueueReceive>:
{
 8004358:	b5f0      	push	{r4, r5, r6, r7, lr}
 800435a:	b085      	sub	sp, #20
 800435c:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 800435e:	b190      	cbz	r0, 8004386 <xQueueReceive+0x2e>
 8004360:	460f      	mov	r7, r1
 8004362:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004364:	b1c1      	cbz	r1, 8004398 <xQueueReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004366:	f000 ff43 	bl	80051f0 <xTaskGetSchedulerState>
 800436a:	4606      	mov	r6, r0
 800436c:	bb00      	cbnz	r0, 80043b0 <xQueueReceive+0x58>
 800436e:	9b01      	ldr	r3, [sp, #4]
 8004370:	2b00      	cmp	r3, #0
 8004372:	d05e      	beq.n	8004432 <xQueueReceive+0xda>
	__asm volatile
 8004374:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004378:	f383 8811 	msr	BASEPRI, r3
 800437c:	f3bf 8f6f 	isb	sy
 8004380:	f3bf 8f4f 	dsb	sy
 8004384:	e7fe      	b.n	8004384 <xQueueReceive+0x2c>
 8004386:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800438a:	f383 8811 	msr	BASEPRI, r3
 800438e:	f3bf 8f6f 	isb	sy
 8004392:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8004396:	e7fe      	b.n	8004396 <xQueueReceive+0x3e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004398:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800439a:	2b00      	cmp	r3, #0
 800439c:	d0e3      	beq.n	8004366 <xQueueReceive+0xe>
 800439e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80043a2:	f383 8811 	msr	BASEPRI, r3
 80043a6:	f3bf 8f6f 	isb	sy
 80043aa:	f3bf 8f4f 	dsb	sy
 80043ae:	e7fe      	b.n	80043ae <xQueueReceive+0x56>
 80043b0:	2600      	movs	r6, #0
 80043b2:	e03e      	b.n	8004432 <xQueueReceive+0xda>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80043b4:	4639      	mov	r1, r7
 80043b6:	4620      	mov	r0, r4
 80043b8:	f7ff fd9a 	bl	8003ef0 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80043bc:	3d01      	subs	r5, #1
 80043be:	63a5      	str	r5, [r4, #56]	@ 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80043c0:	6923      	ldr	r3, [r4, #16]
 80043c2:	b923      	cbnz	r3, 80043ce <xQueueReceive+0x76>
				taskEXIT_CRITICAL();
 80043c4:	f001 fad8 	bl	8005978 <vPortExitCritical>
				return pdPASS;
 80043c8:	2001      	movs	r0, #1
}
 80043ca:	b005      	add	sp, #20
 80043cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80043ce:	f104 0010 	add.w	r0, r4, #16
 80043d2:	f000 fe0d 	bl	8004ff0 <xTaskRemoveFromEventList>
 80043d6:	2800      	cmp	r0, #0
 80043d8:	d0f4      	beq.n	80043c4 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
 80043da:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80043de:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80043e2:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80043e6:	f3bf 8f4f 	dsb	sy
 80043ea:	f3bf 8f6f 	isb	sy
 80043ee:	e7e9      	b.n	80043c4 <xQueueReceive+0x6c>
					taskEXIT_CRITICAL();
 80043f0:	f001 fac2 	bl	8005978 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80043f4:	2000      	movs	r0, #0
 80043f6:	e7e8      	b.n	80043ca <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80043f8:	a802      	add	r0, sp, #8
 80043fa:	f000 fe9f 	bl	800513c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80043fe:	2601      	movs	r6, #1
 8004400:	e021      	b.n	8004446 <xQueueReceive+0xee>
		prvLockQueue( pxQueue );
 8004402:	2300      	movs	r3, #0
 8004404:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8004408:	e029      	b.n	800445e <xQueueReceive+0x106>
 800440a:	2300      	movs	r3, #0
 800440c:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004410:	e02b      	b.n	800446a <xQueueReceive+0x112>
				prvUnlockQueue( pxQueue );
 8004412:	4620      	mov	r0, r4
 8004414:	f7ff fd7e 	bl	8003f14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8004418:	f000 fc96 	bl	8004d48 <xTaskResumeAll>
 800441c:	e009      	b.n	8004432 <xQueueReceive+0xda>
			prvUnlockQueue( pxQueue );
 800441e:	4620      	mov	r0, r4
 8004420:	f7ff fd78 	bl	8003f14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004424:	f000 fc90 	bl	8004d48 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004428:	4620      	mov	r0, r4
 800442a:	f7ff fd19 	bl	8003e60 <prvIsQueueEmpty>
 800442e:	2800      	cmp	r0, #0
 8004430:	d13f      	bne.n	80044b2 <xQueueReceive+0x15a>
		taskENTER_CRITICAL();
 8004432:	f001 fa7f 	bl	8005934 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004436:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004438:	2d00      	cmp	r5, #0
 800443a:	d1bb      	bne.n	80043b4 <xQueueReceive+0x5c>
				if( xTicksToWait == ( TickType_t ) 0 )
 800443c:	9b01      	ldr	r3, [sp, #4]
 800443e:	2b00      	cmp	r3, #0
 8004440:	d0d6      	beq.n	80043f0 <xQueueReceive+0x98>
				else if( xEntryTimeSet == pdFALSE )
 8004442:	2e00      	cmp	r6, #0
 8004444:	d0d8      	beq.n	80043f8 <xQueueReceive+0xa0>
		taskEXIT_CRITICAL();
 8004446:	f001 fa97 	bl	8005978 <vPortExitCritical>
		vTaskSuspendAll();
 800444a:	f000 fbe3 	bl	8004c14 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800444e:	f001 fa71 	bl	8005934 <vPortEnterCritical>
 8004452:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8004456:	b25b      	sxtb	r3, r3
 8004458:	f1b3 3fff 	cmp.w	r3, #4294967295
 800445c:	d0d1      	beq.n	8004402 <xQueueReceive+0xaa>
 800445e:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8004462:	b25b      	sxtb	r3, r3
 8004464:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004468:	d0cf      	beq.n	800440a <xQueueReceive+0xb2>
 800446a:	f001 fa85 	bl	8005978 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800446e:	a901      	add	r1, sp, #4
 8004470:	a802      	add	r0, sp, #8
 8004472:	f000 fe6f 	bl	8005154 <xTaskCheckForTimeOut>
 8004476:	2800      	cmp	r0, #0
 8004478:	d1d1      	bne.n	800441e <xQueueReceive+0xc6>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800447a:	4620      	mov	r0, r4
 800447c:	f7ff fcf0 	bl	8003e60 <prvIsQueueEmpty>
 8004480:	2800      	cmp	r0, #0
 8004482:	d0c6      	beq.n	8004412 <xQueueReceive+0xba>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8004484:	9901      	ldr	r1, [sp, #4]
 8004486:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 800448a:	f000 fd51 	bl	8004f30 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800448e:	4620      	mov	r0, r4
 8004490:	f7ff fd40 	bl	8003f14 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004494:	f000 fc58 	bl	8004d48 <xTaskResumeAll>
 8004498:	2800      	cmp	r0, #0
 800449a:	d1ca      	bne.n	8004432 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
 800449c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80044a0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80044a4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80044a8:	f3bf 8f4f 	dsb	sy
 80044ac:	f3bf 8f6f 	isb	sy
 80044b0:	e7bf      	b.n	8004432 <xQueueReceive+0xda>
				return errQUEUE_EMPTY;
 80044b2:	2000      	movs	r0, #0
 80044b4:	e789      	b.n	80043ca <xQueueReceive+0x72>

080044b6 <xQueueSemaphoreTake>:
{
 80044b6:	b570      	push	{r4, r5, r6, lr}
 80044b8:	b084      	sub	sp, #16
 80044ba:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 80044bc:	b158      	cbz	r0, 80044d6 <xQueueSemaphoreTake+0x20>
 80044be:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 80044c0:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80044c2:	b18b      	cbz	r3, 80044e8 <xQueueSemaphoreTake+0x32>
 80044c4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80044c8:	f383 8811 	msr	BASEPRI, r3
 80044cc:	f3bf 8f6f 	isb	sy
 80044d0:	f3bf 8f4f 	dsb	sy
 80044d4:	e7fe      	b.n	80044d4 <xQueueSemaphoreTake+0x1e>
 80044d6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80044da:	f383 8811 	msr	BASEPRI, r3
 80044de:	f3bf 8f6f 	isb	sy
 80044e2:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 80044e6:	e7fe      	b.n	80044e6 <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80044e8:	f000 fe82 	bl	80051f0 <xTaskGetSchedulerState>
 80044ec:	4605      	mov	r5, r0
 80044ee:	b950      	cbnz	r0, 8004506 <xQueueSemaphoreTake+0x50>
 80044f0:	9b01      	ldr	r3, [sp, #4]
 80044f2:	b15b      	cbz	r3, 800450c <xQueueSemaphoreTake+0x56>
 80044f4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80044f8:	f383 8811 	msr	BASEPRI, r3
 80044fc:	f3bf 8f6f 	isb	sy
 8004500:	f3bf 8f4f 	dsb	sy
 8004504:	e7fe      	b.n	8004504 <xQueueSemaphoreTake+0x4e>
 8004506:	2600      	movs	r6, #0
 8004508:	4635      	mov	r5, r6
 800450a:	e055      	b.n	80045b8 <xQueueSemaphoreTake+0x102>
 800450c:	4606      	mov	r6, r0
 800450e:	e053      	b.n	80045b8 <xQueueSemaphoreTake+0x102>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8004510:	3b01      	subs	r3, #1
 8004512:	63a3      	str	r3, [r4, #56]	@ 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004514:	6823      	ldr	r3, [r4, #0]
 8004516:	b13b      	cbz	r3, 8004528 <xQueueSemaphoreTake+0x72>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004518:	6923      	ldr	r3, [r4, #16]
 800451a:	b94b      	cbnz	r3, 8004530 <xQueueSemaphoreTake+0x7a>
				taskEXIT_CRITICAL();
 800451c:	f001 fa2c 	bl	8005978 <vPortExitCritical>
				return pdPASS;
 8004520:	2601      	movs	r6, #1
}
 8004522:	4630      	mov	r0, r6
 8004524:	b004      	add	sp, #16
 8004526:	bd70      	pop	{r4, r5, r6, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8004528:	f000 ff62 	bl	80053f0 <pvTaskIncrementMutexHeldCount>
 800452c:	60a0      	str	r0, [r4, #8]
 800452e:	e7f3      	b.n	8004518 <xQueueSemaphoreTake+0x62>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004530:	f104 0010 	add.w	r0, r4, #16
 8004534:	f000 fd5c 	bl	8004ff0 <xTaskRemoveFromEventList>
 8004538:	2800      	cmp	r0, #0
 800453a:	d0ef      	beq.n	800451c <xQueueSemaphoreTake+0x66>
						queueYIELD_IF_USING_PREEMPTION();
 800453c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8004540:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8004544:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004548:	f3bf 8f4f 	dsb	sy
 800454c:	f3bf 8f6f 	isb	sy
 8004550:	e7e4      	b.n	800451c <xQueueSemaphoreTake+0x66>
						configASSERT( xInheritanceOccurred == pdFALSE );
 8004552:	b146      	cbz	r6, 8004566 <xQueueSemaphoreTake+0xb0>
 8004554:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004558:	f383 8811 	msr	BASEPRI, r3
 800455c:	f3bf 8f6f 	isb	sy
 8004560:	f3bf 8f4f 	dsb	sy
 8004564:	e7fe      	b.n	8004564 <xQueueSemaphoreTake+0xae>
					taskEXIT_CRITICAL();
 8004566:	f001 fa07 	bl	8005978 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800456a:	e7da      	b.n	8004522 <xQueueSemaphoreTake+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800456c:	a802      	add	r0, sp, #8
 800456e:	f000 fde5 	bl	800513c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8004572:	2501      	movs	r5, #1
 8004574:	e02a      	b.n	80045cc <xQueueSemaphoreTake+0x116>
		prvLockQueue( pxQueue );
 8004576:	2300      	movs	r3, #0
 8004578:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 800457c:	e032      	b.n	80045e4 <xQueueSemaphoreTake+0x12e>
 800457e:	2300      	movs	r3, #0
 8004580:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004584:	e034      	b.n	80045f0 <xQueueSemaphoreTake+0x13a>
						taskENTER_CRITICAL();
 8004586:	f001 f9d5 	bl	8005934 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 800458a:	68a0      	ldr	r0, [r4, #8]
 800458c:	f000 fe40 	bl	8005210 <xTaskPriorityInherit>
 8004590:	4606      	mov	r6, r0
						taskEXIT_CRITICAL();
 8004592:	f001 f9f1 	bl	8005978 <vPortExitCritical>
 8004596:	e03b      	b.n	8004610 <xQueueSemaphoreTake+0x15a>
				prvUnlockQueue( pxQueue );
 8004598:	4620      	mov	r0, r4
 800459a:	f7ff fcbb 	bl	8003f14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800459e:	f000 fbd3 	bl	8004d48 <xTaskResumeAll>
 80045a2:	e009      	b.n	80045b8 <xQueueSemaphoreTake+0x102>
			prvUnlockQueue( pxQueue );
 80045a4:	4620      	mov	r0, r4
 80045a6:	f7ff fcb5 	bl	8003f14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80045aa:	f000 fbcd 	bl	8004d48 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80045ae:	4620      	mov	r0, r4
 80045b0:	f7ff fc56 	bl	8003e60 <prvIsQueueEmpty>
 80045b4:	2800      	cmp	r0, #0
 80045b6:	d142      	bne.n	800463e <xQueueSemaphoreTake+0x188>
		taskENTER_CRITICAL();
 80045b8:	f001 f9bc 	bl	8005934 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 80045bc:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 80045be:	2b00      	cmp	r3, #0
 80045c0:	d1a6      	bne.n	8004510 <xQueueSemaphoreTake+0x5a>
				if( xTicksToWait == ( TickType_t ) 0 )
 80045c2:	9b01      	ldr	r3, [sp, #4]
 80045c4:	2b00      	cmp	r3, #0
 80045c6:	d0c4      	beq.n	8004552 <xQueueSemaphoreTake+0x9c>
				else if( xEntryTimeSet == pdFALSE )
 80045c8:	2d00      	cmp	r5, #0
 80045ca:	d0cf      	beq.n	800456c <xQueueSemaphoreTake+0xb6>
		taskEXIT_CRITICAL();
 80045cc:	f001 f9d4 	bl	8005978 <vPortExitCritical>
		vTaskSuspendAll();
 80045d0:	f000 fb20 	bl	8004c14 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80045d4:	f001 f9ae 	bl	8005934 <vPortEnterCritical>
 80045d8:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 80045dc:	b25b      	sxtb	r3, r3
 80045de:	f1b3 3fff 	cmp.w	r3, #4294967295
 80045e2:	d0c8      	beq.n	8004576 <xQueueSemaphoreTake+0xc0>
 80045e4:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 80045e8:	b25b      	sxtb	r3, r3
 80045ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 80045ee:	d0c6      	beq.n	800457e <xQueueSemaphoreTake+0xc8>
 80045f0:	f001 f9c2 	bl	8005978 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80045f4:	a901      	add	r1, sp, #4
 80045f6:	a802      	add	r0, sp, #8
 80045f8:	f000 fdac 	bl	8005154 <xTaskCheckForTimeOut>
 80045fc:	2800      	cmp	r0, #0
 80045fe:	d1d1      	bne.n	80045a4 <xQueueSemaphoreTake+0xee>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004600:	4620      	mov	r0, r4
 8004602:	f7ff fc2d 	bl	8003e60 <prvIsQueueEmpty>
 8004606:	2800      	cmp	r0, #0
 8004608:	d0c6      	beq.n	8004598 <xQueueSemaphoreTake+0xe2>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800460a:	6823      	ldr	r3, [r4, #0]
 800460c:	2b00      	cmp	r3, #0
 800460e:	d0ba      	beq.n	8004586 <xQueueSemaphoreTake+0xd0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8004610:	9901      	ldr	r1, [sp, #4]
 8004612:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8004616:	f000 fc8b 	bl	8004f30 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800461a:	4620      	mov	r0, r4
 800461c:	f7ff fc7a 	bl	8003f14 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004620:	f000 fb92 	bl	8004d48 <xTaskResumeAll>
 8004624:	2800      	cmp	r0, #0
 8004626:	d1c7      	bne.n	80045b8 <xQueueSemaphoreTake+0x102>
					portYIELD_WITHIN_API();
 8004628:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 800462c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8004630:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004634:	f3bf 8f4f 	dsb	sy
 8004638:	f3bf 8f6f 	isb	sy
 800463c:	e7bc      	b.n	80045b8 <xQueueSemaphoreTake+0x102>
					if( xInheritanceOccurred != pdFALSE )
 800463e:	b90e      	cbnz	r6, 8004644 <xQueueSemaphoreTake+0x18e>
				return errQUEUE_EMPTY;
 8004640:	2600      	movs	r6, #0
 8004642:	e76e      	b.n	8004522 <xQueueSemaphoreTake+0x6c>
						taskENTER_CRITICAL();
 8004644:	f001 f976 	bl	8005934 <vPortEnterCritical>
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 8004648:	4620      	mov	r0, r4
 800464a:	f7ff fbf2 	bl	8003e32 <prvGetDisinheritPriorityAfterTimeout>
 800464e:	4601      	mov	r1, r0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8004650:	68a0      	ldr	r0, [r4, #8]
 8004652:	f000 fe71 	bl	8005338 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 8004656:	f001 f98f 	bl	8005978 <vPortExitCritical>
 800465a:	e7f1      	b.n	8004640 <xQueueSemaphoreTake+0x18a>

0800465c <uxQueueMessagesWaiting>:
	configASSERT( xQueue );
 800465c:	b140      	cbz	r0, 8004670 <uxQueueMessagesWaiting+0x14>
{
 800465e:	b510      	push	{r4, lr}
 8004660:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8004662:	f001 f967 	bl	8005934 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8004666:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
	taskEXIT_CRITICAL();
 8004668:	f001 f986 	bl	8005978 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 800466c:	4620      	mov	r0, r4
 800466e:	bd10      	pop	{r4, pc}
 8004670:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004674:	f383 8811 	msr	BASEPRI, r3
 8004678:	f3bf 8f6f 	isb	sy
 800467c:	f3bf 8f4f 	dsb	sy
	configASSERT( xQueue );
 8004680:	e7fe      	b.n	8004680 <uxQueueMessagesWaiting+0x24>
	...

08004684 <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004684:	2300      	movs	r3, #0
 8004686:	2b07      	cmp	r3, #7
 8004688:	d80c      	bhi.n	80046a4 <vQueueAddToRegistry+0x20>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800468a:	4a07      	ldr	r2, [pc, #28]	@ (80046a8 <vQueueAddToRegistry+0x24>)
 800468c:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8004690:	b10a      	cbz	r2, 8004696 <vQueueAddToRegistry+0x12>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004692:	3301      	adds	r3, #1
 8004694:	e7f7      	b.n	8004686 <vQueueAddToRegistry+0x2>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8004696:	4a04      	ldr	r2, [pc, #16]	@ (80046a8 <vQueueAddToRegistry+0x24>)
 8004698:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 800469c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 80046a0:	6050      	str	r0, [r2, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 80046a2:	4770      	bx	lr
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80046a4:	4770      	bx	lr
 80046a6:	bf00      	nop
 80046a8:	2000140c 	.word	0x2000140c

080046ac <vQueueUnregisterQueue>:
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80046ac:	2300      	movs	r3, #0
 80046ae:	2b07      	cmp	r3, #7
 80046b0:	d80f      	bhi.n	80046d2 <vQueueUnregisterQueue+0x26>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80046b2:	4a08      	ldr	r2, [pc, #32]	@ (80046d4 <vQueueUnregisterQueue+0x28>)
 80046b4:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 80046b8:	6852      	ldr	r2, [r2, #4]
 80046ba:	4282      	cmp	r2, r0
 80046bc:	d001      	beq.n	80046c2 <vQueueUnregisterQueue+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80046be:	3301      	adds	r3, #1
 80046c0:	e7f5      	b.n	80046ae <vQueueUnregisterQueue+0x2>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 80046c2:	4a04      	ldr	r2, [pc, #16]	@ (80046d4 <vQueueUnregisterQueue+0x28>)
 80046c4:	2100      	movs	r1, #0
 80046c6:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 80046ca:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 80046ce:	6051      	str	r1, [r2, #4]
				break;
 80046d0:	4770      	bx	lr
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 80046d2:	4770      	bx	lr
 80046d4:	2000140c 	.word	0x2000140c

080046d8 <vQueueDelete>:
	configASSERT( pxQueue );
 80046d8:	b138      	cbz	r0, 80046ea <vQueueDelete+0x12>
{
 80046da:	b510      	push	{r4, lr}
 80046dc:	4604      	mov	r4, r0
		vQueueUnregisterQueue( pxQueue );
 80046de:	f7ff ffe5 	bl	80046ac <vQueueUnregisterQueue>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 80046e2:	f894 3046 	ldrb.w	r3, [r4, #70]	@ 0x46
 80046e6:	b14b      	cbz	r3, 80046fc <vQueueDelete+0x24>
}
 80046e8:	bd10      	pop	{r4, pc}
 80046ea:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80046ee:	f383 8811 	msr	BASEPRI, r3
 80046f2:	f3bf 8f6f 	isb	sy
 80046f6:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80046fa:	e7fe      	b.n	80046fa <vQueueDelete+0x22>
			vPortFree( pxQueue );
 80046fc:	4620      	mov	r0, r4
 80046fe:	f001 fb53 	bl	8005da8 <vPortFree>
}
 8004702:	e7f1      	b.n	80046e8 <vQueueDelete+0x10>

08004704 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8004704:	b570      	push	{r4, r5, r6, lr}
 8004706:	4604      	mov	r4, r0
 8004708:	460d      	mov	r5, r1
 800470a:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800470c:	f001 f912 	bl	8005934 <vPortEnterCritical>
 8004710:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8004714:	b25b      	sxtb	r3, r3
 8004716:	f1b3 3fff 	cmp.w	r3, #4294967295
 800471a:	d00d      	beq.n	8004738 <vQueueWaitForMessageRestricted+0x34>
 800471c:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8004720:	b25b      	sxtb	r3, r3
 8004722:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004726:	d00b      	beq.n	8004740 <vQueueWaitForMessageRestricted+0x3c>
 8004728:	f001 f926 	bl	8005978 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800472c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 800472e:	b15b      	cbz	r3, 8004748 <vQueueWaitForMessageRestricted+0x44>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8004730:	4620      	mov	r0, r4
 8004732:	f7ff fbef 	bl	8003f14 <prvUnlockQueue>
	}
 8004736:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
 8004738:	2300      	movs	r3, #0
 800473a:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 800473e:	e7ed      	b.n	800471c <vQueueWaitForMessageRestricted+0x18>
 8004740:	2300      	movs	r3, #0
 8004742:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004746:	e7ef      	b.n	8004728 <vQueueWaitForMessageRestricted+0x24>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8004748:	4632      	mov	r2, r6
 800474a:	4629      	mov	r1, r5
 800474c:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8004750:	f000 fc32 	bl	8004fb8 <vTaskPlaceOnEventListRestricted>
 8004754:	e7ec      	b.n	8004730 <vQueueWaitForMessageRestricted+0x2c>
	...

08004758 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004758:	4b08      	ldr	r3, [pc, #32]	@ (800477c <prvResetNextTaskUnblockTime+0x24>)
 800475a:	681b      	ldr	r3, [r3, #0]
 800475c:	681b      	ldr	r3, [r3, #0]
 800475e:	b923      	cbnz	r3, 800476a <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8004760:	4b07      	ldr	r3, [pc, #28]	@ (8004780 <prvResetNextTaskUnblockTime+0x28>)
 8004762:	f04f 32ff 	mov.w	r2, #4294967295
 8004766:	601a      	str	r2, [r3, #0]
 8004768:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800476a:	4b04      	ldr	r3, [pc, #16]	@ (800477c <prvResetNextTaskUnblockTime+0x24>)
 800476c:	681b      	ldr	r3, [r3, #0]
 800476e:	68db      	ldr	r3, [r3, #12]
 8004770:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8004772:	685a      	ldr	r2, [r3, #4]
 8004774:	4b02      	ldr	r3, [pc, #8]	@ (8004780 <prvResetNextTaskUnblockTime+0x28>)
 8004776:	601a      	str	r2, [r3, #0]
	}
}
 8004778:	4770      	bx	lr
 800477a:	bf00      	nop
 800477c:	200014bc 	.word	0x200014bc
 8004780:	20001454 	.word	0x20001454

08004784 <prvInitialiseNewTask>:
{
 8004784:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004788:	4680      	mov	r8, r0
 800478a:	460d      	mov	r5, r1
 800478c:	4617      	mov	r7, r2
 800478e:	4699      	mov	r9, r3
 8004790:	9e08      	ldr	r6, [sp, #32]
 8004792:	f8dd a024 	ldr.w	sl, [sp, #36]	@ 0x24
 8004796:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8004798:	0092      	lsls	r2, r2, #2
 800479a:	21a5      	movs	r1, #165	@ 0xa5
 800479c:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 800479e:	f00a fa89 	bl	800ecb4 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80047a2:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80047a4:	f107 4280 	add.w	r2, r7, #1073741824	@ 0x40000000
 80047a8:	3a01      	subs	r2, #1
 80047aa:	eb03 0782 	add.w	r7, r3, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 80047ae:	f027 0707 	bic.w	r7, r7, #7
	if( pcName != NULL )
 80047b2:	2d00      	cmp	r5, #0
 80047b4:	d042      	beq.n	800483c <prvInitialiseNewTask+0xb8>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80047b6:	f04f 0c00 	mov.w	ip, #0
 80047ba:	f1bc 0f0f 	cmp.w	ip, #15
 80047be:	d809      	bhi.n	80047d4 <prvInitialiseNewTask+0x50>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80047c0:	f815 300c 	ldrb.w	r3, [r5, ip]
 80047c4:	eb04 020c 	add.w	r2, r4, ip
 80047c8:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 80047cc:	b113      	cbz	r3, 80047d4 <prvInitialiseNewTask+0x50>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80047ce:	f10c 0c01 	add.w	ip, ip, #1
 80047d2:	e7f2      	b.n	80047ba <prvInitialiseNewTask+0x36>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80047d4:	2300      	movs	r3, #0
 80047d6:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80047da:	2e37      	cmp	r6, #55	@ 0x37
 80047dc:	d900      	bls.n	80047e0 <prvInitialiseNewTask+0x5c>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 80047de:	2637      	movs	r6, #55	@ 0x37
	pxNewTCB->uxPriority = uxPriority;
 80047e0:	62e6      	str	r6, [r4, #44]	@ 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 80047e2:	64e6      	str	r6, [r4, #76]	@ 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 80047e4:	2500      	movs	r5, #0
 80047e6:	6525      	str	r5, [r4, #80]	@ 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80047e8:	1d20      	adds	r0, r4, #4
 80047ea:	f7ff fae8 	bl	8003dbe <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80047ee:	f104 0018 	add.w	r0, r4, #24
 80047f2:	f7ff fae4 	bl	8003dbe <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80047f6:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80047f8:	f1c6 0638 	rsb	r6, r6, #56	@ 0x38
 80047fc:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80047fe:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->ulNotifiedValue = 0;
 8004800:	f8c4 50a0 	str.w	r5, [r4, #160]	@ 0xa0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8004804:	f884 50a4 	strb.w	r5, [r4, #164]	@ 0xa4
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8004808:	224c      	movs	r2, #76	@ 0x4c
 800480a:	4629      	mov	r1, r5
 800480c:	f104 0054 	add.w	r0, r4, #84	@ 0x54
 8004810:	f00a fa50 	bl	800ecb4 <memset>
 8004814:	4b0b      	ldr	r3, [pc, #44]	@ (8004844 <prvInitialiseNewTask+0xc0>)
 8004816:	65a3      	str	r3, [r4, #88]	@ 0x58
 8004818:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 800481c:	65e2      	str	r2, [r4, #92]	@ 0x5c
 800481e:	33d0      	adds	r3, #208	@ 0xd0
 8004820:	6623      	str	r3, [r4, #96]	@ 0x60
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004822:	464a      	mov	r2, r9
 8004824:	4641      	mov	r1, r8
 8004826:	4638      	mov	r0, r7
 8004828:	f001 f858 	bl	80058dc <pxPortInitialiseStack>
 800482c:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 800482e:	f1ba 0f00 	cmp.w	sl, #0
 8004832:	d001      	beq.n	8004838 <prvInitialiseNewTask+0xb4>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8004834:	f8ca 4000 	str.w	r4, [sl]
}
 8004838:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800483c:	2300      	movs	r3, #0
 800483e:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
 8004842:	e7ca      	b.n	80047da <prvInitialiseNewTask+0x56>
 8004844:	20014558 	.word	0x20014558

08004848 <prvInitialiseTaskLists>:
{
 8004848:	b538      	push	{r3, r4, r5, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800484a:	2400      	movs	r4, #0
 800484c:	e007      	b.n	800485e <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800484e:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8004852:	0093      	lsls	r3, r2, #2
 8004854:	480e      	ldr	r0, [pc, #56]	@ (8004890 <prvInitialiseTaskLists+0x48>)
 8004856:	4418      	add	r0, r3
 8004858:	f7ff faa6 	bl	8003da8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800485c:	3401      	adds	r4, #1
 800485e:	2c37      	cmp	r4, #55	@ 0x37
 8004860:	d9f5      	bls.n	800484e <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 8004862:	4d0c      	ldr	r5, [pc, #48]	@ (8004894 <prvInitialiseTaskLists+0x4c>)
 8004864:	4628      	mov	r0, r5
 8004866:	f7ff fa9f 	bl	8003da8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800486a:	4c0b      	ldr	r4, [pc, #44]	@ (8004898 <prvInitialiseTaskLists+0x50>)
 800486c:	4620      	mov	r0, r4
 800486e:	f7ff fa9b 	bl	8003da8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8004872:	480a      	ldr	r0, [pc, #40]	@ (800489c <prvInitialiseTaskLists+0x54>)
 8004874:	f7ff fa98 	bl	8003da8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8004878:	4809      	ldr	r0, [pc, #36]	@ (80048a0 <prvInitialiseTaskLists+0x58>)
 800487a:	f7ff fa95 	bl	8003da8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800487e:	4809      	ldr	r0, [pc, #36]	@ (80048a4 <prvInitialiseTaskLists+0x5c>)
 8004880:	f7ff fa92 	bl	8003da8 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8004884:	4b08      	ldr	r3, [pc, #32]	@ (80048a8 <prvInitialiseTaskLists+0x60>)
 8004886:	601d      	str	r5, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8004888:	4b08      	ldr	r3, [pc, #32]	@ (80048ac <prvInitialiseTaskLists+0x64>)
 800488a:	601c      	str	r4, [r3, #0]
}
 800488c:	bd38      	pop	{r3, r4, r5, pc}
 800488e:	bf00      	nop
 8004890:	200014e8 	.word	0x200014e8
 8004894:	200014d4 	.word	0x200014d4
 8004898:	200014c0 	.word	0x200014c0
 800489c:	200014a4 	.word	0x200014a4
 80048a0:	20001490 	.word	0x20001490
 80048a4:	20001478 	.word	0x20001478
 80048a8:	200014bc 	.word	0x200014bc
 80048ac:	200014b8 	.word	0x200014b8

080048b0 <prvAddNewTaskToReadyList>:
{
 80048b0:	b510      	push	{r4, lr}
 80048b2:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 80048b4:	f001 f83e 	bl	8005934 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 80048b8:	4a22      	ldr	r2, [pc, #136]	@ (8004944 <prvAddNewTaskToReadyList+0x94>)
 80048ba:	6813      	ldr	r3, [r2, #0]
 80048bc:	3301      	adds	r3, #1
 80048be:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 80048c0:	4b21      	ldr	r3, [pc, #132]	@ (8004948 <prvAddNewTaskToReadyList+0x98>)
 80048c2:	681b      	ldr	r3, [r3, #0]
 80048c4:	b15b      	cbz	r3, 80048de <prvAddNewTaskToReadyList+0x2e>
			if( xSchedulerRunning == pdFALSE )
 80048c6:	4b21      	ldr	r3, [pc, #132]	@ (800494c <prvAddNewTaskToReadyList+0x9c>)
 80048c8:	681b      	ldr	r3, [r3, #0]
 80048ca:	b96b      	cbnz	r3, 80048e8 <prvAddNewTaskToReadyList+0x38>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80048cc:	4b1e      	ldr	r3, [pc, #120]	@ (8004948 <prvAddNewTaskToReadyList+0x98>)
 80048ce:	681b      	ldr	r3, [r3, #0]
 80048d0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80048d2:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80048d4:	429a      	cmp	r2, r3
 80048d6:	d807      	bhi.n	80048e8 <prvAddNewTaskToReadyList+0x38>
					pxCurrentTCB = pxNewTCB;
 80048d8:	4b1b      	ldr	r3, [pc, #108]	@ (8004948 <prvAddNewTaskToReadyList+0x98>)
 80048da:	601c      	str	r4, [r3, #0]
 80048dc:	e004      	b.n	80048e8 <prvAddNewTaskToReadyList+0x38>
			pxCurrentTCB = pxNewTCB;
 80048de:	4b1a      	ldr	r3, [pc, #104]	@ (8004948 <prvAddNewTaskToReadyList+0x98>)
 80048e0:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80048e2:	6813      	ldr	r3, [r2, #0]
 80048e4:	2b01      	cmp	r3, #1
 80048e6:	d029      	beq.n	800493c <prvAddNewTaskToReadyList+0x8c>
		uxTaskNumber++;
 80048e8:	4a19      	ldr	r2, [pc, #100]	@ (8004950 <prvAddNewTaskToReadyList+0xa0>)
 80048ea:	6813      	ldr	r3, [r2, #0]
 80048ec:	3301      	adds	r3, #1
 80048ee:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 80048f0:	6463      	str	r3, [r4, #68]	@ 0x44
		prvAddTaskToReadyList( pxNewTCB );
 80048f2:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 80048f4:	4b17      	ldr	r3, [pc, #92]	@ (8004954 <prvAddNewTaskToReadyList+0xa4>)
 80048f6:	681b      	ldr	r3, [r3, #0]
 80048f8:	4298      	cmp	r0, r3
 80048fa:	d901      	bls.n	8004900 <prvAddNewTaskToReadyList+0x50>
 80048fc:	4b15      	ldr	r3, [pc, #84]	@ (8004954 <prvAddNewTaskToReadyList+0xa4>)
 80048fe:	6018      	str	r0, [r3, #0]
 8004900:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004904:	1d21      	adds	r1, r4, #4
 8004906:	4b14      	ldr	r3, [pc, #80]	@ (8004958 <prvAddNewTaskToReadyList+0xa8>)
 8004908:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800490c:	f7ff fa5a 	bl	8003dc4 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8004910:	f001 f832 	bl	8005978 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8004914:	4b0d      	ldr	r3, [pc, #52]	@ (800494c <prvAddNewTaskToReadyList+0x9c>)
 8004916:	681b      	ldr	r3, [r3, #0]
 8004918:	b17b      	cbz	r3, 800493a <prvAddNewTaskToReadyList+0x8a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800491a:	4b0b      	ldr	r3, [pc, #44]	@ (8004948 <prvAddNewTaskToReadyList+0x98>)
 800491c:	681b      	ldr	r3, [r3, #0]
 800491e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8004920:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8004922:	429a      	cmp	r2, r3
 8004924:	d209      	bcs.n	800493a <prvAddNewTaskToReadyList+0x8a>
			taskYIELD_IF_USING_PREEMPTION();
 8004926:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 800492a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800492e:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004932:	f3bf 8f4f 	dsb	sy
 8004936:	f3bf 8f6f 	isb	sy
}
 800493a:	bd10      	pop	{r4, pc}
				prvInitialiseTaskLists();
 800493c:	f7ff ff84 	bl	8004848 <prvInitialiseTaskLists>
 8004940:	e7d2      	b.n	80048e8 <prvAddNewTaskToReadyList+0x38>
 8004942:	bf00      	nop
 8004944:	20001474 	.word	0x20001474
 8004948:	20001948 	.word	0x20001948
 800494c:	20001468 	.word	0x20001468
 8004950:	20001458 	.word	0x20001458
 8004954:	2000146c 	.word	0x2000146c
 8004958:	200014e8 	.word	0x200014e8

0800495c <prvDeleteTCB>:
	{
 800495c:	b510      	push	{r4, lr}
 800495e:	4604      	mov	r4, r0
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
 8004960:	3054      	adds	r0, #84	@ 0x54
 8004962:	f00a f9bf 	bl	800ece4 <_reclaim_reent>
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8004966:	f894 30a5 	ldrb.w	r3, [r4, #165]	@ 0xa5
 800496a:	b163      	cbz	r3, 8004986 <prvDeleteTCB+0x2a>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800496c:	2b01      	cmp	r3, #1
 800496e:	d011      	beq.n	8004994 <prvDeleteTCB+0x38>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8004970:	2b02      	cmp	r3, #2
 8004972:	d00e      	beq.n	8004992 <prvDeleteTCB+0x36>
 8004974:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004978:	f383 8811 	msr	BASEPRI, r3
 800497c:	f3bf 8f6f 	isb	sy
 8004980:	f3bf 8f4f 	dsb	sy
 8004984:	e7fe      	b.n	8004984 <prvDeleteTCB+0x28>
				vPortFree( pxTCB->pxStack );
 8004986:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8004988:	f001 fa0e 	bl	8005da8 <vPortFree>
				vPortFree( pxTCB );
 800498c:	4620      	mov	r0, r4
 800498e:	f001 fa0b 	bl	8005da8 <vPortFree>
	}
 8004992:	bd10      	pop	{r4, pc}
				vPortFree( pxTCB );
 8004994:	4620      	mov	r0, r4
 8004996:	f001 fa07 	bl	8005da8 <vPortFree>
 800499a:	e7fa      	b.n	8004992 <prvDeleteTCB+0x36>

0800499c <prvCheckTasksWaitingTermination>:
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800499c:	4b0f      	ldr	r3, [pc, #60]	@ (80049dc <prvCheckTasksWaitingTermination+0x40>)
 800499e:	681b      	ldr	r3, [r3, #0]
 80049a0:	b1d3      	cbz	r3, 80049d8 <prvCheckTasksWaitingTermination+0x3c>
{
 80049a2:	b510      	push	{r4, lr}
			taskENTER_CRITICAL();
 80049a4:	f000 ffc6 	bl	8005934 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80049a8:	4b0d      	ldr	r3, [pc, #52]	@ (80049e0 <prvCheckTasksWaitingTermination+0x44>)
 80049aa:	68db      	ldr	r3, [r3, #12]
 80049ac:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80049ae:	1d20      	adds	r0, r4, #4
 80049b0:	f7ff fa2c 	bl	8003e0c <uxListRemove>
				--uxCurrentNumberOfTasks;
 80049b4:	4a0b      	ldr	r2, [pc, #44]	@ (80049e4 <prvCheckTasksWaitingTermination+0x48>)
 80049b6:	6813      	ldr	r3, [r2, #0]
 80049b8:	3b01      	subs	r3, #1
 80049ba:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 80049bc:	4a07      	ldr	r2, [pc, #28]	@ (80049dc <prvCheckTasksWaitingTermination+0x40>)
 80049be:	6813      	ldr	r3, [r2, #0]
 80049c0:	3b01      	subs	r3, #1
 80049c2:	6013      	str	r3, [r2, #0]
			taskEXIT_CRITICAL();
 80049c4:	f000 ffd8 	bl	8005978 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 80049c8:	4620      	mov	r0, r4
 80049ca:	f7ff ffc7 	bl	800495c <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80049ce:	4b03      	ldr	r3, [pc, #12]	@ (80049dc <prvCheckTasksWaitingTermination+0x40>)
 80049d0:	681b      	ldr	r3, [r3, #0]
 80049d2:	2b00      	cmp	r3, #0
 80049d4:	d1e6      	bne.n	80049a4 <prvCheckTasksWaitingTermination+0x8>
}
 80049d6:	bd10      	pop	{r4, pc}
 80049d8:	4770      	bx	lr
 80049da:	bf00      	nop
 80049dc:	2000148c 	.word	0x2000148c
 80049e0:	20001490 	.word	0x20001490
 80049e4:	20001474 	.word	0x20001474

080049e8 <prvIdleTask>:
{
 80049e8:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 80049ea:	f7ff ffd7 	bl	800499c <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80049ee:	4b07      	ldr	r3, [pc, #28]	@ (8004a0c <prvIdleTask+0x24>)
 80049f0:	681b      	ldr	r3, [r3, #0]
 80049f2:	2b01      	cmp	r3, #1
 80049f4:	d9f9      	bls.n	80049ea <prvIdleTask+0x2>
				taskYIELD();
 80049f6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80049fa:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80049fe:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004a02:	f3bf 8f4f 	dsb	sy
 8004a06:	f3bf 8f6f 	isb	sy
 8004a0a:	e7ee      	b.n	80049ea <prvIdleTask+0x2>
 8004a0c:	200014e8 	.word	0x200014e8

08004a10 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8004a10:	b570      	push	{r4, r5, r6, lr}
 8004a12:	4604      	mov	r4, r0
 8004a14:	460d      	mov	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8004a16:	4b17      	ldr	r3, [pc, #92]	@ (8004a74 <prvAddCurrentTaskToDelayedList+0x64>)
 8004a18:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004a1a:	4b17      	ldr	r3, [pc, #92]	@ (8004a78 <prvAddCurrentTaskToDelayedList+0x68>)
 8004a1c:	6818      	ldr	r0, [r3, #0]
 8004a1e:	3004      	adds	r0, #4
 8004a20:	f7ff f9f4 	bl	8003e0c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8004a24:	f1b4 3fff 	cmp.w	r4, #4294967295
 8004a28:	d00d      	beq.n	8004a46 <prvAddCurrentTaskToDelayedList+0x36>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8004a2a:	4434      	add	r4, r6

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004a2c:	4b12      	ldr	r3, [pc, #72]	@ (8004a78 <prvAddCurrentTaskToDelayedList+0x68>)
 8004a2e:	681b      	ldr	r3, [r3, #0]
 8004a30:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8004a32:	42a6      	cmp	r6, r4
 8004a34:	d910      	bls.n	8004a58 <prvAddCurrentTaskToDelayedList+0x48>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a36:	4b11      	ldr	r3, [pc, #68]	@ (8004a7c <prvAddCurrentTaskToDelayedList+0x6c>)
 8004a38:	6818      	ldr	r0, [r3, #0]
 8004a3a:	4b0f      	ldr	r3, [pc, #60]	@ (8004a78 <prvAddCurrentTaskToDelayedList+0x68>)
 8004a3c:	6819      	ldr	r1, [r3, #0]
 8004a3e:	3104      	adds	r1, #4
 8004a40:	f7ff f9cb 	bl	8003dda <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8004a44:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8004a46:	2d00      	cmp	r5, #0
 8004a48:	d0ef      	beq.n	8004a2a <prvAddCurrentTaskToDelayedList+0x1a>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a4a:	4b0b      	ldr	r3, [pc, #44]	@ (8004a78 <prvAddCurrentTaskToDelayedList+0x68>)
 8004a4c:	6819      	ldr	r1, [r3, #0]
 8004a4e:	3104      	adds	r1, #4
 8004a50:	480b      	ldr	r0, [pc, #44]	@ (8004a80 <prvAddCurrentTaskToDelayedList+0x70>)
 8004a52:	f7ff f9b7 	bl	8003dc4 <vListInsertEnd>
 8004a56:	e7f5      	b.n	8004a44 <prvAddCurrentTaskToDelayedList+0x34>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004a58:	4b0a      	ldr	r3, [pc, #40]	@ (8004a84 <prvAddCurrentTaskToDelayedList+0x74>)
 8004a5a:	6818      	ldr	r0, [r3, #0]
 8004a5c:	4b06      	ldr	r3, [pc, #24]	@ (8004a78 <prvAddCurrentTaskToDelayedList+0x68>)
 8004a5e:	6819      	ldr	r1, [r3, #0]
 8004a60:	3104      	adds	r1, #4
 8004a62:	f7ff f9ba 	bl	8003dda <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8004a66:	4b08      	ldr	r3, [pc, #32]	@ (8004a88 <prvAddCurrentTaskToDelayedList+0x78>)
 8004a68:	681b      	ldr	r3, [r3, #0]
 8004a6a:	42a3      	cmp	r3, r4
 8004a6c:	d9ea      	bls.n	8004a44 <prvAddCurrentTaskToDelayedList+0x34>
					xNextTaskUnblockTime = xTimeToWake;
 8004a6e:	4b06      	ldr	r3, [pc, #24]	@ (8004a88 <prvAddCurrentTaskToDelayedList+0x78>)
 8004a70:	601c      	str	r4, [r3, #0]
}
 8004a72:	e7e7      	b.n	8004a44 <prvAddCurrentTaskToDelayedList+0x34>
 8004a74:	20001470 	.word	0x20001470
 8004a78:	20001948 	.word	0x20001948
 8004a7c:	200014b8 	.word	0x200014b8
 8004a80:	20001478 	.word	0x20001478
 8004a84:	200014bc 	.word	0x200014bc
 8004a88:	20001454 	.word	0x20001454

08004a8c <xTaskCreateStatic>:
	{
 8004a8c:	b530      	push	{r4, r5, lr}
 8004a8e:	b087      	sub	sp, #28
 8004a90:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
		configASSERT( puxStackBuffer != NULL );
 8004a92:	b17c      	cbz	r4, 8004ab4 <xTaskCreateStatic+0x28>
		configASSERT( pxTaskBuffer != NULL );
 8004a94:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8004a96:	b1b5      	cbz	r5, 8004ac6 <xTaskCreateStatic+0x3a>
			volatile size_t xSize = sizeof( StaticTask_t );
 8004a98:	25a8      	movs	r5, #168	@ 0xa8
 8004a9a:	9504      	str	r5, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8004a9c:	9d04      	ldr	r5, [sp, #16]
 8004a9e:	2da8      	cmp	r5, #168	@ 0xa8
 8004aa0:	d01a      	beq.n	8004ad8 <xTaskCreateStatic+0x4c>
 8004aa2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004aa6:	f383 8811 	msr	BASEPRI, r3
 8004aaa:	f3bf 8f6f 	isb	sy
 8004aae:	f3bf 8f4f 	dsb	sy
 8004ab2:	e7fe      	b.n	8004ab2 <xTaskCreateStatic+0x26>
 8004ab4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004ab8:	f383 8811 	msr	BASEPRI, r3
 8004abc:	f3bf 8f6f 	isb	sy
 8004ac0:	f3bf 8f4f 	dsb	sy
		configASSERT( puxStackBuffer != NULL );
 8004ac4:	e7fe      	b.n	8004ac4 <xTaskCreateStatic+0x38>
 8004ac6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004aca:	f383 8811 	msr	BASEPRI, r3
 8004ace:	f3bf 8f6f 	isb	sy
 8004ad2:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 8004ad6:	e7fe      	b.n	8004ad6 <xTaskCreateStatic+0x4a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8004ad8:	9d04      	ldr	r5, [sp, #16]
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8004ada:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8004adc:	632c      	str	r4, [r5, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8004ade:	2402      	movs	r4, #2
 8004ae0:	f885 40a5 	strb.w	r4, [r5, #165]	@ 0xa5
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8004ae4:	2400      	movs	r4, #0
 8004ae6:	9403      	str	r4, [sp, #12]
 8004ae8:	9502      	str	r5, [sp, #8]
 8004aea:	ac05      	add	r4, sp, #20
 8004aec:	9401      	str	r4, [sp, #4]
 8004aee:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8004af0:	9400      	str	r4, [sp, #0]
 8004af2:	f7ff fe47 	bl	8004784 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004af6:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8004af8:	f7ff feda 	bl	80048b0 <prvAddNewTaskToReadyList>
	}
 8004afc:	9805      	ldr	r0, [sp, #20]
 8004afe:	b007      	add	sp, #28
 8004b00:	bd30      	pop	{r4, r5, pc}

08004b02 <xTaskCreate>:
	{
 8004b02:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004b06:	b085      	sub	sp, #20
 8004b08:	4607      	mov	r7, r0
 8004b0a:	4688      	mov	r8, r1
 8004b0c:	4614      	mov	r4, r2
 8004b0e:	461e      	mov	r6, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8004b10:	0090      	lsls	r0, r2, #2
 8004b12:	f001 f8c7 	bl	8005ca4 <pvPortMalloc>
			if( pxStack != NULL )
 8004b16:	b308      	cbz	r0, 8004b5c <xTaskCreate+0x5a>
 8004b18:	4681      	mov	r9, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8004b1a:	20a8      	movs	r0, #168	@ 0xa8
 8004b1c:	f001 f8c2 	bl	8005ca4 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8004b20:	4605      	mov	r5, r0
 8004b22:	b1a8      	cbz	r0, 8004b50 <xTaskCreate+0x4e>
					pxNewTCB->pxStack = pxStack;
 8004b24:	f8c0 9030 	str.w	r9, [r0, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8004b28:	2300      	movs	r3, #0
 8004b2a:	f880 30a5 	strb.w	r3, [r0, #165]	@ 0xa5
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8004b2e:	9303      	str	r3, [sp, #12]
 8004b30:	9002      	str	r0, [sp, #8]
 8004b32:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8004b34:	9301      	str	r3, [sp, #4]
 8004b36:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8004b38:	9300      	str	r3, [sp, #0]
 8004b3a:	4633      	mov	r3, r6
 8004b3c:	4622      	mov	r2, r4
 8004b3e:	4641      	mov	r1, r8
 8004b40:	4638      	mov	r0, r7
 8004b42:	f7ff fe1f 	bl	8004784 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004b46:	4628      	mov	r0, r5
 8004b48:	f7ff feb2 	bl	80048b0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8004b4c:	2001      	movs	r0, #1
 8004b4e:	e007      	b.n	8004b60 <xTaskCreate+0x5e>
					vPortFree( pxStack );
 8004b50:	4648      	mov	r0, r9
 8004b52:	f001 f929 	bl	8005da8 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004b56:	f04f 30ff 	mov.w	r0, #4294967295
 8004b5a:	e001      	b.n	8004b60 <xTaskCreate+0x5e>
 8004b5c:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8004b60:	b005      	add	sp, #20
 8004b62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

08004b68 <vTaskStartScheduler>:
{
 8004b68:	b510      	push	{r4, lr}
 8004b6a:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 8004b6c:	2400      	movs	r4, #0
 8004b6e:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8004b70:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8004b72:	aa07      	add	r2, sp, #28
 8004b74:	a906      	add	r1, sp, #24
 8004b76:	a805      	add	r0, sp, #20
 8004b78:	f7fe ffd2 	bl	8003b20 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8004b7c:	9b05      	ldr	r3, [sp, #20]
 8004b7e:	9302      	str	r3, [sp, #8]
 8004b80:	9b06      	ldr	r3, [sp, #24]
 8004b82:	9301      	str	r3, [sp, #4]
 8004b84:	9400      	str	r4, [sp, #0]
 8004b86:	4623      	mov	r3, r4
 8004b88:	9a07      	ldr	r2, [sp, #28]
 8004b8a:	491a      	ldr	r1, [pc, #104]	@ (8004bf4 <vTaskStartScheduler+0x8c>)
 8004b8c:	481a      	ldr	r0, [pc, #104]	@ (8004bf8 <vTaskStartScheduler+0x90>)
 8004b8e:	f7ff ff7d 	bl	8004a8c <xTaskCreateStatic>
 8004b92:	4b1a      	ldr	r3, [pc, #104]	@ (8004bfc <vTaskStartScheduler+0x94>)
 8004b94:	6018      	str	r0, [r3, #0]
		if( xIdleTaskHandle != NULL )
 8004b96:	b1e8      	cbz	r0, 8004bd4 <vTaskStartScheduler+0x6c>
			xReturn = xTimerCreateTimerTask();
 8004b98:	f000 fca4 	bl	80054e4 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8004b9c:	2801      	cmp	r0, #1
 8004b9e:	d11a      	bne.n	8004bd6 <vTaskStartScheduler+0x6e>
 8004ba0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004ba4:	f383 8811 	msr	BASEPRI, r3
 8004ba8:	f3bf 8f6f 	isb	sy
 8004bac:	f3bf 8f4f 	dsb	sy
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8004bb0:	4b13      	ldr	r3, [pc, #76]	@ (8004c00 <vTaskStartScheduler+0x98>)
 8004bb2:	681b      	ldr	r3, [r3, #0]
 8004bb4:	3354      	adds	r3, #84	@ 0x54
 8004bb6:	4a13      	ldr	r2, [pc, #76]	@ (8004c04 <vTaskStartScheduler+0x9c>)
 8004bb8:	6013      	str	r3, [r2, #0]
		xNextTaskUnblockTime = portMAX_DELAY;
 8004bba:	4b13      	ldr	r3, [pc, #76]	@ (8004c08 <vTaskStartScheduler+0xa0>)
 8004bbc:	f04f 32ff 	mov.w	r2, #4294967295
 8004bc0:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8004bc2:	4b12      	ldr	r3, [pc, #72]	@ (8004c0c <vTaskStartScheduler+0xa4>)
 8004bc4:	2201      	movs	r2, #1
 8004bc6:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8004bc8:	4b11      	ldr	r3, [pc, #68]	@ (8004c10 <vTaskStartScheduler+0xa8>)
 8004bca:	2200      	movs	r2, #0
 8004bcc:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8004bce:	f000 ff4b 	bl	8005a68 <xPortStartScheduler>
		}
 8004bd2:	e003      	b.n	8004bdc <vTaskStartScheduler+0x74>
			xReturn = pdFAIL;
 8004bd4:	2000      	movs	r0, #0
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8004bd6:	f1b0 3fff 	cmp.w	r0, #4294967295
 8004bda:	d001      	beq.n	8004be0 <vTaskStartScheduler+0x78>
}
 8004bdc:	b008      	add	sp, #32
 8004bde:	bd10      	pop	{r4, pc}
 8004be0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004be4:	f383 8811 	msr	BASEPRI, r3
 8004be8:	f3bf 8f6f 	isb	sy
 8004bec:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8004bf0:	e7fe      	b.n	8004bf0 <vTaskStartScheduler+0x88>
 8004bf2:	bf00      	nop
 8004bf4:	08010198 	.word	0x08010198
 8004bf8:	080049e9 	.word	0x080049e9
 8004bfc:	20001450 	.word	0x20001450
 8004c00:	20001948 	.word	0x20001948
 8004c04:	20000030 	.word	0x20000030
 8004c08:	20001454 	.word	0x20001454
 8004c0c:	20001468 	.word	0x20001468
 8004c10:	20001470 	.word	0x20001470

08004c14 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8004c14:	4a02      	ldr	r2, [pc, #8]	@ (8004c20 <vTaskSuspendAll+0xc>)
 8004c16:	6813      	ldr	r3, [r2, #0]
 8004c18:	3301      	adds	r3, #1
 8004c1a:	6013      	str	r3, [r2, #0]
}
 8004c1c:	4770      	bx	lr
 8004c1e:	bf00      	nop
 8004c20:	2000144c 	.word	0x2000144c

08004c24 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8004c24:	4b01      	ldr	r3, [pc, #4]	@ (8004c2c <xTaskGetTickCount+0x8>)
 8004c26:	6818      	ldr	r0, [r3, #0]
}
 8004c28:	4770      	bx	lr
 8004c2a:	bf00      	nop
 8004c2c:	20001470 	.word	0x20001470

08004c30 <xTaskIncrementTick>:
{
 8004c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004c32:	4b3a      	ldr	r3, [pc, #232]	@ (8004d1c <xTaskIncrementTick+0xec>)
 8004c34:	681b      	ldr	r3, [r3, #0]
 8004c36:	2b00      	cmp	r3, #0
 8004c38:	d169      	bne.n	8004d0e <xTaskIncrementTick+0xde>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004c3a:	4b39      	ldr	r3, [pc, #228]	@ (8004d20 <xTaskIncrementTick+0xf0>)
 8004c3c:	681d      	ldr	r5, [r3, #0]
 8004c3e:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8004c40:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8004c42:	b9c5      	cbnz	r5, 8004c76 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8004c44:	4b37      	ldr	r3, [pc, #220]	@ (8004d24 <xTaskIncrementTick+0xf4>)
 8004c46:	681b      	ldr	r3, [r3, #0]
 8004c48:	681b      	ldr	r3, [r3, #0]
 8004c4a:	b143      	cbz	r3, 8004c5e <xTaskIncrementTick+0x2e>
 8004c4c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004c50:	f383 8811 	msr	BASEPRI, r3
 8004c54:	f3bf 8f6f 	isb	sy
 8004c58:	f3bf 8f4f 	dsb	sy
 8004c5c:	e7fe      	b.n	8004c5c <xTaskIncrementTick+0x2c>
 8004c5e:	4a31      	ldr	r2, [pc, #196]	@ (8004d24 <xTaskIncrementTick+0xf4>)
 8004c60:	6811      	ldr	r1, [r2, #0]
 8004c62:	4b31      	ldr	r3, [pc, #196]	@ (8004d28 <xTaskIncrementTick+0xf8>)
 8004c64:	6818      	ldr	r0, [r3, #0]
 8004c66:	6010      	str	r0, [r2, #0]
 8004c68:	6019      	str	r1, [r3, #0]
 8004c6a:	4a30      	ldr	r2, [pc, #192]	@ (8004d2c <xTaskIncrementTick+0xfc>)
 8004c6c:	6813      	ldr	r3, [r2, #0]
 8004c6e:	3301      	adds	r3, #1
 8004c70:	6013      	str	r3, [r2, #0]
 8004c72:	f7ff fd71 	bl	8004758 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004c76:	4b2e      	ldr	r3, [pc, #184]	@ (8004d30 <xTaskIncrementTick+0x100>)
 8004c78:	681b      	ldr	r3, [r3, #0]
 8004c7a:	42ab      	cmp	r3, r5
 8004c7c:	d93d      	bls.n	8004cfa <xTaskIncrementTick+0xca>
BaseType_t xSwitchRequired = pdFALSE;
 8004c7e:	2700      	movs	r7, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8004c80:	4b2c      	ldr	r3, [pc, #176]	@ (8004d34 <xTaskIncrementTick+0x104>)
 8004c82:	681b      	ldr	r3, [r3, #0]
 8004c84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004c86:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004c8a:	009a      	lsls	r2, r3, #2
 8004c8c:	4b2a      	ldr	r3, [pc, #168]	@ (8004d38 <xTaskIncrementTick+0x108>)
 8004c8e:	589b      	ldr	r3, [r3, r2]
 8004c90:	2b01      	cmp	r3, #1
 8004c92:	d900      	bls.n	8004c96 <xTaskIncrementTick+0x66>
				xSwitchRequired = pdTRUE;
 8004c94:	2701      	movs	r7, #1
			if( xYieldPending != pdFALSE )
 8004c96:	4b29      	ldr	r3, [pc, #164]	@ (8004d3c <xTaskIncrementTick+0x10c>)
 8004c98:	681b      	ldr	r3, [r3, #0]
 8004c9a:	2b00      	cmp	r3, #0
 8004c9c:	d03c      	beq.n	8004d18 <xTaskIncrementTick+0xe8>
				xSwitchRequired = pdTRUE;
 8004c9e:	2701      	movs	r7, #1
	return xSwitchRequired;
 8004ca0:	e03a      	b.n	8004d18 <xTaskIncrementTick+0xe8>
							xSwitchRequired = pdTRUE;
 8004ca2:	2701      	movs	r7, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004ca4:	4b1f      	ldr	r3, [pc, #124]	@ (8004d24 <xTaskIncrementTick+0xf4>)
 8004ca6:	681b      	ldr	r3, [r3, #0]
 8004ca8:	681b      	ldr	r3, [r3, #0]
 8004caa:	b343      	cbz	r3, 8004cfe <xTaskIncrementTick+0xce>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004cac:	4b1d      	ldr	r3, [pc, #116]	@ (8004d24 <xTaskIncrementTick+0xf4>)
 8004cae:	681b      	ldr	r3, [r3, #0]
 8004cb0:	68db      	ldr	r3, [r3, #12]
 8004cb2:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8004cb4:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
 8004cb6:	429d      	cmp	r5, r3
 8004cb8:	d326      	bcc.n	8004d08 <xTaskIncrementTick+0xd8>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004cba:	1d26      	adds	r6, r4, #4
 8004cbc:	4630      	mov	r0, r6
 8004cbe:	f7ff f8a5 	bl	8003e0c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004cc2:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8004cc4:	b11b      	cbz	r3, 8004cce <xTaskIncrementTick+0x9e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004cc6:	f104 0018 	add.w	r0, r4, #24
 8004cca:	f7ff f89f 	bl	8003e0c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004cce:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8004cd0:	4a1b      	ldr	r2, [pc, #108]	@ (8004d40 <xTaskIncrementTick+0x110>)
 8004cd2:	6812      	ldr	r2, [r2, #0]
 8004cd4:	4293      	cmp	r3, r2
 8004cd6:	d901      	bls.n	8004cdc <xTaskIncrementTick+0xac>
 8004cd8:	4a19      	ldr	r2, [pc, #100]	@ (8004d40 <xTaskIncrementTick+0x110>)
 8004cda:	6013      	str	r3, [r2, #0]
 8004cdc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004ce0:	009a      	lsls	r2, r3, #2
 8004ce2:	4631      	mov	r1, r6
 8004ce4:	4814      	ldr	r0, [pc, #80]	@ (8004d38 <xTaskIncrementTick+0x108>)
 8004ce6:	4410      	add	r0, r2
 8004ce8:	f7ff f86c 	bl	8003dc4 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004cec:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8004cee:	4b11      	ldr	r3, [pc, #68]	@ (8004d34 <xTaskIncrementTick+0x104>)
 8004cf0:	681b      	ldr	r3, [r3, #0]
 8004cf2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004cf4:	429a      	cmp	r2, r3
 8004cf6:	d2d4      	bcs.n	8004ca2 <xTaskIncrementTick+0x72>
 8004cf8:	e7d4      	b.n	8004ca4 <xTaskIncrementTick+0x74>
BaseType_t xSwitchRequired = pdFALSE;
 8004cfa:	2700      	movs	r7, #0
 8004cfc:	e7d2      	b.n	8004ca4 <xTaskIncrementTick+0x74>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cfe:	4b0c      	ldr	r3, [pc, #48]	@ (8004d30 <xTaskIncrementTick+0x100>)
 8004d00:	f04f 32ff 	mov.w	r2, #4294967295
 8004d04:	601a      	str	r2, [r3, #0]
					break;
 8004d06:	e7bb      	b.n	8004c80 <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 8004d08:	4a09      	ldr	r2, [pc, #36]	@ (8004d30 <xTaskIncrementTick+0x100>)
 8004d0a:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8004d0c:	e7b8      	b.n	8004c80 <xTaskIncrementTick+0x50>
		++xPendedTicks;
 8004d0e:	4a0d      	ldr	r2, [pc, #52]	@ (8004d44 <xTaskIncrementTick+0x114>)
 8004d10:	6813      	ldr	r3, [r2, #0]
 8004d12:	3301      	adds	r3, #1
 8004d14:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8004d16:	2700      	movs	r7, #0
}
 8004d18:	4638      	mov	r0, r7
 8004d1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004d1c:	2000144c 	.word	0x2000144c
 8004d20:	20001470 	.word	0x20001470
 8004d24:	200014bc 	.word	0x200014bc
 8004d28:	200014b8 	.word	0x200014b8
 8004d2c:	2000145c 	.word	0x2000145c
 8004d30:	20001454 	.word	0x20001454
 8004d34:	20001948 	.word	0x20001948
 8004d38:	200014e8 	.word	0x200014e8
 8004d3c:	20001460 	.word	0x20001460
 8004d40:	2000146c 	.word	0x2000146c
 8004d44:	20001464 	.word	0x20001464

08004d48 <xTaskResumeAll>:
{
 8004d48:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended );
 8004d4a:	4b35      	ldr	r3, [pc, #212]	@ (8004e20 <xTaskResumeAll+0xd8>)
 8004d4c:	681b      	ldr	r3, [r3, #0]
 8004d4e:	b943      	cbnz	r3, 8004d62 <xTaskResumeAll+0x1a>
 8004d50:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004d54:	f383 8811 	msr	BASEPRI, r3
 8004d58:	f3bf 8f6f 	isb	sy
 8004d5c:	f3bf 8f4f 	dsb	sy
 8004d60:	e7fe      	b.n	8004d60 <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
 8004d62:	f000 fde7 	bl	8005934 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8004d66:	4b2e      	ldr	r3, [pc, #184]	@ (8004e20 <xTaskResumeAll+0xd8>)
 8004d68:	681a      	ldr	r2, [r3, #0]
 8004d6a:	3a01      	subs	r2, #1
 8004d6c:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004d6e:	681b      	ldr	r3, [r3, #0]
 8004d70:	2b00      	cmp	r3, #0
 8004d72:	d14f      	bne.n	8004e14 <xTaskResumeAll+0xcc>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8004d74:	4b2b      	ldr	r3, [pc, #172]	@ (8004e24 <xTaskResumeAll+0xdc>)
 8004d76:	681b      	ldr	r3, [r3, #0]
 8004d78:	b90b      	cbnz	r3, 8004d7e <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8004d7a:	2400      	movs	r4, #0
 8004d7c:	e04b      	b.n	8004e16 <xTaskResumeAll+0xce>
TCB_t *pxTCB = NULL;
 8004d7e:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8004d80:	4b29      	ldr	r3, [pc, #164]	@ (8004e28 <xTaskResumeAll+0xe0>)
 8004d82:	681b      	ldr	r3, [r3, #0]
 8004d84:	b31b      	cbz	r3, 8004dce <xTaskResumeAll+0x86>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004d86:	4b28      	ldr	r3, [pc, #160]	@ (8004e28 <xTaskResumeAll+0xe0>)
 8004d88:	68db      	ldr	r3, [r3, #12]
 8004d8a:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004d8c:	f104 0018 	add.w	r0, r4, #24
 8004d90:	f7ff f83c 	bl	8003e0c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004d94:	1d25      	adds	r5, r4, #4
 8004d96:	4628      	mov	r0, r5
 8004d98:	f7ff f838 	bl	8003e0c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004d9c:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8004d9e:	4b23      	ldr	r3, [pc, #140]	@ (8004e2c <xTaskResumeAll+0xe4>)
 8004da0:	681b      	ldr	r3, [r3, #0]
 8004da2:	4298      	cmp	r0, r3
 8004da4:	d901      	bls.n	8004daa <xTaskResumeAll+0x62>
 8004da6:	4b21      	ldr	r3, [pc, #132]	@ (8004e2c <xTaskResumeAll+0xe4>)
 8004da8:	6018      	str	r0, [r3, #0]
 8004daa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004dae:	4629      	mov	r1, r5
 8004db0:	4b1f      	ldr	r3, [pc, #124]	@ (8004e30 <xTaskResumeAll+0xe8>)
 8004db2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8004db6:	f7ff f805 	bl	8003dc4 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004dba:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8004dbc:	4b1d      	ldr	r3, [pc, #116]	@ (8004e34 <xTaskResumeAll+0xec>)
 8004dbe:	681b      	ldr	r3, [r3, #0]
 8004dc0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004dc2:	429a      	cmp	r2, r3
 8004dc4:	d3dc      	bcc.n	8004d80 <xTaskResumeAll+0x38>
						xYieldPending = pdTRUE;
 8004dc6:	4b1c      	ldr	r3, [pc, #112]	@ (8004e38 <xTaskResumeAll+0xf0>)
 8004dc8:	2201      	movs	r2, #1
 8004dca:	601a      	str	r2, [r3, #0]
 8004dcc:	e7d8      	b.n	8004d80 <xTaskResumeAll+0x38>
				if( pxTCB != NULL )
 8004dce:	b10c      	cbz	r4, 8004dd4 <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
 8004dd0:	f7ff fcc2 	bl	8004758 <prvResetNextTaskUnblockTime>
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8004dd4:	4b19      	ldr	r3, [pc, #100]	@ (8004e3c <xTaskResumeAll+0xf4>)
 8004dd6:	681c      	ldr	r4, [r3, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
 8004dd8:	b984      	cbnz	r4, 8004dfc <xTaskResumeAll+0xb4>
				if( xYieldPending != pdFALSE )
 8004dda:	4b17      	ldr	r3, [pc, #92]	@ (8004e38 <xTaskResumeAll+0xf0>)
 8004ddc:	681c      	ldr	r4, [r3, #0]
 8004dde:	b1d4      	cbz	r4, 8004e16 <xTaskResumeAll+0xce>
					taskYIELD_IF_USING_PREEMPTION();
 8004de0:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8004de4:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8004de8:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004dec:	f3bf 8f4f 	dsb	sy
 8004df0:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8004df4:	2401      	movs	r4, #1
 8004df6:	e00e      	b.n	8004e16 <xTaskResumeAll+0xce>
						} while( xPendedCounts > ( TickType_t ) 0U );
 8004df8:	3c01      	subs	r4, #1
 8004dfa:	d007      	beq.n	8004e0c <xTaskResumeAll+0xc4>
							if( xTaskIncrementTick() != pdFALSE )
 8004dfc:	f7ff ff18 	bl	8004c30 <xTaskIncrementTick>
 8004e00:	2800      	cmp	r0, #0
 8004e02:	d0f9      	beq.n	8004df8 <xTaskResumeAll+0xb0>
								xYieldPending = pdTRUE;
 8004e04:	4b0c      	ldr	r3, [pc, #48]	@ (8004e38 <xTaskResumeAll+0xf0>)
 8004e06:	2201      	movs	r2, #1
 8004e08:	601a      	str	r2, [r3, #0]
 8004e0a:	e7f5      	b.n	8004df8 <xTaskResumeAll+0xb0>
						xPendedTicks = 0;
 8004e0c:	4b0b      	ldr	r3, [pc, #44]	@ (8004e3c <xTaskResumeAll+0xf4>)
 8004e0e:	2200      	movs	r2, #0
 8004e10:	601a      	str	r2, [r3, #0]
 8004e12:	e7e2      	b.n	8004dda <xTaskResumeAll+0x92>
BaseType_t xAlreadyYielded = pdFALSE;
 8004e14:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8004e16:	f000 fdaf 	bl	8005978 <vPortExitCritical>
}
 8004e1a:	4620      	mov	r0, r4
 8004e1c:	bd38      	pop	{r3, r4, r5, pc}
 8004e1e:	bf00      	nop
 8004e20:	2000144c 	.word	0x2000144c
 8004e24:	20001474 	.word	0x20001474
 8004e28:	200014a4 	.word	0x200014a4
 8004e2c:	2000146c 	.word	0x2000146c
 8004e30:	200014e8 	.word	0x200014e8
 8004e34:	20001948 	.word	0x20001948
 8004e38:	20001460 	.word	0x20001460
 8004e3c:	20001464 	.word	0x20001464

08004e40 <vTaskDelay>:
	{
 8004e40:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8004e42:	b1a8      	cbz	r0, 8004e70 <vTaskDelay+0x30>
 8004e44:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 8004e46:	4b10      	ldr	r3, [pc, #64]	@ (8004e88 <vTaskDelay+0x48>)
 8004e48:	681b      	ldr	r3, [r3, #0]
 8004e4a:	b143      	cbz	r3, 8004e5e <vTaskDelay+0x1e>
 8004e4c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004e50:	f383 8811 	msr	BASEPRI, r3
 8004e54:	f3bf 8f6f 	isb	sy
 8004e58:	f3bf 8f4f 	dsb	sy
 8004e5c:	e7fe      	b.n	8004e5c <vTaskDelay+0x1c>
			vTaskSuspendAll();
 8004e5e:	f7ff fed9 	bl	8004c14 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8004e62:	2100      	movs	r1, #0
 8004e64:	4620      	mov	r0, r4
 8004e66:	f7ff fdd3 	bl	8004a10 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8004e6a:	f7ff ff6d 	bl	8004d48 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8004e6e:	b948      	cbnz	r0, 8004e84 <vTaskDelay+0x44>
			portYIELD_WITHIN_API();
 8004e70:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8004e74:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8004e78:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8004e7c:	f3bf 8f4f 	dsb	sy
 8004e80:	f3bf 8f6f 	isb	sy
	}
 8004e84:	bd10      	pop	{r4, pc}
 8004e86:	bf00      	nop
 8004e88:	2000144c 	.word	0x2000144c

08004e8c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004e8c:	4b22      	ldr	r3, [pc, #136]	@ (8004f18 <vTaskSwitchContext+0x8c>)
 8004e8e:	681b      	ldr	r3, [r3, #0]
 8004e90:	b11b      	cbz	r3, 8004e9a <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8004e92:	4b22      	ldr	r3, [pc, #136]	@ (8004f1c <vTaskSwitchContext+0x90>)
 8004e94:	2201      	movs	r2, #1
 8004e96:	601a      	str	r2, [r3, #0]
 8004e98:	4770      	bx	lr
		xYieldPending = pdFALSE;
 8004e9a:	4b20      	ldr	r3, [pc, #128]	@ (8004f1c <vTaskSwitchContext+0x90>)
 8004e9c:	2200      	movs	r2, #0
 8004e9e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004ea0:	4b1f      	ldr	r3, [pc, #124]	@ (8004f20 <vTaskSwitchContext+0x94>)
 8004ea2:	681b      	ldr	r3, [r3, #0]
 8004ea4:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8004ea8:	008a      	lsls	r2, r1, #2
 8004eaa:	491e      	ldr	r1, [pc, #120]	@ (8004f24 <vTaskSwitchContext+0x98>)
 8004eac:	588a      	ldr	r2, [r1, r2]
 8004eae:	b95a      	cbnz	r2, 8004ec8 <vTaskSwitchContext+0x3c>
 8004eb0:	b10b      	cbz	r3, 8004eb6 <vTaskSwitchContext+0x2a>
 8004eb2:	3b01      	subs	r3, #1
 8004eb4:	e7f6      	b.n	8004ea4 <vTaskSwitchContext+0x18>
 8004eb6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004eba:	f383 8811 	msr	BASEPRI, r3
 8004ebe:	f3bf 8f6f 	isb	sy
 8004ec2:	f3bf 8f4f 	dsb	sy
 8004ec6:	e7fe      	b.n	8004ec6 <vTaskSwitchContext+0x3a>
 8004ec8:	4608      	mov	r0, r1
 8004eca:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8004ece:	008a      	lsls	r2, r1, #2
 8004ed0:	4402      	add	r2, r0
 8004ed2:	6851      	ldr	r1, [r2, #4]
 8004ed4:	6849      	ldr	r1, [r1, #4]
 8004ed6:	6051      	str	r1, [r2, #4]
 8004ed8:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 8004edc:	ea4f 028c 	mov.w	r2, ip, lsl #2
 8004ee0:	3208      	adds	r2, #8
 8004ee2:	4402      	add	r2, r0
 8004ee4:	4291      	cmp	r1, r2
 8004ee6:	d00f      	beq.n	8004f08 <vTaskSwitchContext+0x7c>
 8004ee8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8004eec:	0091      	lsls	r1, r2, #2
 8004eee:	4a0d      	ldr	r2, [pc, #52]	@ (8004f24 <vTaskSwitchContext+0x98>)
 8004ef0:	440a      	add	r2, r1
 8004ef2:	6852      	ldr	r2, [r2, #4]
 8004ef4:	68d1      	ldr	r1, [r2, #12]
 8004ef6:	4a0c      	ldr	r2, [pc, #48]	@ (8004f28 <vTaskSwitchContext+0x9c>)
 8004ef8:	6011      	str	r1, [r2, #0]
 8004efa:	4909      	ldr	r1, [pc, #36]	@ (8004f20 <vTaskSwitchContext+0x94>)
 8004efc:	600b      	str	r3, [r1, #0]
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8004efe:	6813      	ldr	r3, [r2, #0]
 8004f00:	3354      	adds	r3, #84	@ 0x54
 8004f02:	4a0a      	ldr	r2, [pc, #40]	@ (8004f2c <vTaskSwitchContext+0xa0>)
 8004f04:	6013      	str	r3, [r2, #0]
}
 8004f06:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004f08:	6848      	ldr	r0, [r1, #4]
 8004f0a:	4662      	mov	r2, ip
 8004f0c:	0091      	lsls	r1, r2, #2
 8004f0e:	4a05      	ldr	r2, [pc, #20]	@ (8004f24 <vTaskSwitchContext+0x98>)
 8004f10:	440a      	add	r2, r1
 8004f12:	6050      	str	r0, [r2, #4]
 8004f14:	e7e8      	b.n	8004ee8 <vTaskSwitchContext+0x5c>
 8004f16:	bf00      	nop
 8004f18:	2000144c 	.word	0x2000144c
 8004f1c:	20001460 	.word	0x20001460
 8004f20:	2000146c 	.word	0x2000146c
 8004f24:	200014e8 	.word	0x200014e8
 8004f28:	20001948 	.word	0x20001948
 8004f2c:	20000030 	.word	0x20000030

08004f30 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 8004f30:	b158      	cbz	r0, 8004f4a <vTaskPlaceOnEventList+0x1a>
{
 8004f32:	b510      	push	{r4, lr}
 8004f34:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004f36:	4a09      	ldr	r2, [pc, #36]	@ (8004f5c <vTaskPlaceOnEventList+0x2c>)
 8004f38:	6811      	ldr	r1, [r2, #0]
 8004f3a:	3118      	adds	r1, #24
 8004f3c:	f7fe ff4d 	bl	8003dda <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004f40:	2101      	movs	r1, #1
 8004f42:	4620      	mov	r0, r4
 8004f44:	f7ff fd64 	bl	8004a10 <prvAddCurrentTaskToDelayedList>
}
 8004f48:	bd10      	pop	{r4, pc}
 8004f4a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004f4e:	f383 8811 	msr	BASEPRI, r3
 8004f52:	f3bf 8f6f 	isb	sy
 8004f56:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 8004f5a:	e7fe      	b.n	8004f5a <vTaskPlaceOnEventList+0x2a>
 8004f5c:	20001948 	.word	0x20001948

08004f60 <vTaskPlaceOnUnorderedEventList>:
	configASSERT( pxEventList );
 8004f60:	b170      	cbz	r0, 8004f80 <vTaskPlaceOnUnorderedEventList+0x20>
{
 8004f62:	b510      	push	{r4, lr}
 8004f64:	4614      	mov	r4, r2
 8004f66:	4602      	mov	r2, r0
	configASSERT( uxSchedulerSuspended != 0 );
 8004f68:	4b11      	ldr	r3, [pc, #68]	@ (8004fb0 <vTaskPlaceOnUnorderedEventList+0x50>)
 8004f6a:	681b      	ldr	r3, [r3, #0]
 8004f6c:	b98b      	cbnz	r3, 8004f92 <vTaskPlaceOnUnorderedEventList+0x32>
 8004f6e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004f72:	f383 8811 	msr	BASEPRI, r3
 8004f76:	f3bf 8f6f 	isb	sy
 8004f7a:	f3bf 8f4f 	dsb	sy
 8004f7e:	e7fe      	b.n	8004f7e <vTaskPlaceOnUnorderedEventList+0x1e>
 8004f80:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004f84:	f383 8811 	msr	BASEPRI, r3
 8004f88:	f3bf 8f6f 	isb	sy
 8004f8c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 8004f90:	e7fe      	b.n	8004f90 <vTaskPlaceOnUnorderedEventList+0x30>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8004f92:	4b08      	ldr	r3, [pc, #32]	@ (8004fb4 <vTaskPlaceOnUnorderedEventList+0x54>)
 8004f94:	6818      	ldr	r0, [r3, #0]
 8004f96:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
 8004f9a:	6181      	str	r1, [r0, #24]
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004f9c:	6819      	ldr	r1, [r3, #0]
 8004f9e:	3118      	adds	r1, #24
 8004fa0:	4610      	mov	r0, r2
 8004fa2:	f7fe ff0f 	bl	8003dc4 <vListInsertEnd>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004fa6:	2101      	movs	r1, #1
 8004fa8:	4620      	mov	r0, r4
 8004faa:	f7ff fd31 	bl	8004a10 <prvAddCurrentTaskToDelayedList>
}
 8004fae:	bd10      	pop	{r4, pc}
 8004fb0:	2000144c 	.word	0x2000144c
 8004fb4:	20001948 	.word	0x20001948

08004fb8 <vTaskPlaceOnEventListRestricted>:
	{
 8004fb8:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 8004fba:	b170      	cbz	r0, 8004fda <vTaskPlaceOnEventListRestricted+0x22>
 8004fbc:	460d      	mov	r5, r1
 8004fbe:	4614      	mov	r4, r2
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004fc0:	4a0a      	ldr	r2, [pc, #40]	@ (8004fec <vTaskPlaceOnEventListRestricted+0x34>)
 8004fc2:	6811      	ldr	r1, [r2, #0]
 8004fc4:	3118      	adds	r1, #24
 8004fc6:	f7fe fefd 	bl	8003dc4 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 8004fca:	b10c      	cbz	r4, 8004fd0 <vTaskPlaceOnEventListRestricted+0x18>
			xTicksToWait = portMAX_DELAY;
 8004fcc:	f04f 35ff 	mov.w	r5, #4294967295
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8004fd0:	4621      	mov	r1, r4
 8004fd2:	4628      	mov	r0, r5
 8004fd4:	f7ff fd1c 	bl	8004a10 <prvAddCurrentTaskToDelayedList>
	}
 8004fd8:	bd38      	pop	{r3, r4, r5, pc}
 8004fda:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004fde:	f383 8811 	msr	BASEPRI, r3
 8004fe2:	f3bf 8f6f 	isb	sy
 8004fe6:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 8004fea:	e7fe      	b.n	8004fea <vTaskPlaceOnEventListRestricted+0x32>
 8004fec:	20001948 	.word	0x20001948

08004ff0 <xTaskRemoveFromEventList>:
{
 8004ff0:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004ff2:	68c3      	ldr	r3, [r0, #12]
 8004ff4:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8004ff6:	b324      	cbz	r4, 8005042 <xTaskRemoveFromEventList+0x52>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8004ff8:	f104 0518 	add.w	r5, r4, #24
 8004ffc:	4628      	mov	r0, r5
 8004ffe:	f7fe ff05 	bl	8003e0c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005002:	4b18      	ldr	r3, [pc, #96]	@ (8005064 <xTaskRemoveFromEventList+0x74>)
 8005004:	681b      	ldr	r3, [r3, #0]
 8005006:	bb2b      	cbnz	r3, 8005054 <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8005008:	1d25      	adds	r5, r4, #4
 800500a:	4628      	mov	r0, r5
 800500c:	f7fe fefe 	bl	8003e0c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8005010:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8005012:	4b15      	ldr	r3, [pc, #84]	@ (8005068 <xTaskRemoveFromEventList+0x78>)
 8005014:	681b      	ldr	r3, [r3, #0]
 8005016:	4298      	cmp	r0, r3
 8005018:	d901      	bls.n	800501e <xTaskRemoveFromEventList+0x2e>
 800501a:	4b13      	ldr	r3, [pc, #76]	@ (8005068 <xTaskRemoveFromEventList+0x78>)
 800501c:	6018      	str	r0, [r3, #0]
 800501e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8005022:	4629      	mov	r1, r5
 8005024:	4b11      	ldr	r3, [pc, #68]	@ (800506c <xTaskRemoveFromEventList+0x7c>)
 8005026:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800502a:	f7fe fecb 	bl	8003dc4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800502e:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8005030:	4b0f      	ldr	r3, [pc, #60]	@ (8005070 <xTaskRemoveFromEventList+0x80>)
 8005032:	681b      	ldr	r3, [r3, #0]
 8005034:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005036:	429a      	cmp	r2, r3
 8005038:	d911      	bls.n	800505e <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
 800503a:	2001      	movs	r0, #1
 800503c:	4b0d      	ldr	r3, [pc, #52]	@ (8005074 <xTaskRemoveFromEventList+0x84>)
 800503e:	6018      	str	r0, [r3, #0]
}
 8005040:	bd38      	pop	{r3, r4, r5, pc}
 8005042:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005046:	f383 8811 	msr	BASEPRI, r3
 800504a:	f3bf 8f6f 	isb	sy
 800504e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 8005052:	e7fe      	b.n	8005052 <xTaskRemoveFromEventList+0x62>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8005054:	4629      	mov	r1, r5
 8005056:	4808      	ldr	r0, [pc, #32]	@ (8005078 <xTaskRemoveFromEventList+0x88>)
 8005058:	f7fe feb4 	bl	8003dc4 <vListInsertEnd>
 800505c:	e7e7      	b.n	800502e <xTaskRemoveFromEventList+0x3e>
		xReturn = pdFALSE;
 800505e:	2000      	movs	r0, #0
	return xReturn;
 8005060:	e7ee      	b.n	8005040 <xTaskRemoveFromEventList+0x50>
 8005062:	bf00      	nop
 8005064:	2000144c 	.word	0x2000144c
 8005068:	2000146c 	.word	0x2000146c
 800506c:	200014e8 	.word	0x200014e8
 8005070:	20001948 	.word	0x20001948
 8005074:	20001460 	.word	0x20001460
 8005078:	200014a4 	.word	0x200014a4

0800507c <vTaskRemoveFromUnorderedEventList>:
{
 800507c:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended != pdFALSE );
 800507e:	4b1c      	ldr	r3, [pc, #112]	@ (80050f0 <vTaskRemoveFromUnorderedEventList+0x74>)
 8005080:	681b      	ldr	r3, [r3, #0]
 8005082:	b943      	cbnz	r3, 8005096 <vTaskRemoveFromUnorderedEventList+0x1a>
 8005084:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005088:	f383 8811 	msr	BASEPRI, r3
 800508c:	f3bf 8f6f 	isb	sy
 8005090:	f3bf 8f4f 	dsb	sy
 8005094:	e7fe      	b.n	8005094 <vTaskRemoveFromUnorderedEventList+0x18>
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8005096:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
 800509a:	6001      	str	r1, [r0, #0]
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800509c:	68c4      	ldr	r4, [r0, #12]
	configASSERT( pxUnblockedTCB );
 800509e:	b1f4      	cbz	r4, 80050de <vTaskRemoveFromUnorderedEventList+0x62>
	( void ) uxListRemove( pxEventListItem );
 80050a0:	f7fe feb4 	bl	8003e0c <uxListRemove>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 80050a4:	1d25      	adds	r5, r4, #4
 80050a6:	4628      	mov	r0, r5
 80050a8:	f7fe feb0 	bl	8003e0c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 80050ac:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 80050ae:	4b11      	ldr	r3, [pc, #68]	@ (80050f4 <vTaskRemoveFromUnorderedEventList+0x78>)
 80050b0:	681b      	ldr	r3, [r3, #0]
 80050b2:	4298      	cmp	r0, r3
 80050b4:	d901      	bls.n	80050ba <vTaskRemoveFromUnorderedEventList+0x3e>
 80050b6:	4b0f      	ldr	r3, [pc, #60]	@ (80050f4 <vTaskRemoveFromUnorderedEventList+0x78>)
 80050b8:	6018      	str	r0, [r3, #0]
 80050ba:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80050be:	4629      	mov	r1, r5
 80050c0:	4b0d      	ldr	r3, [pc, #52]	@ (80050f8 <vTaskRemoveFromUnorderedEventList+0x7c>)
 80050c2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80050c6:	f7fe fe7d 	bl	8003dc4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80050ca:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 80050cc:	4b0b      	ldr	r3, [pc, #44]	@ (80050fc <vTaskRemoveFromUnorderedEventList+0x80>)
 80050ce:	681b      	ldr	r3, [r3, #0]
 80050d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80050d2:	429a      	cmp	r2, r3
 80050d4:	d902      	bls.n	80050dc <vTaskRemoveFromUnorderedEventList+0x60>
		xYieldPending = pdTRUE;
 80050d6:	4b0a      	ldr	r3, [pc, #40]	@ (8005100 <vTaskRemoveFromUnorderedEventList+0x84>)
 80050d8:	2201      	movs	r2, #1
 80050da:	601a      	str	r2, [r3, #0]
}
 80050dc:	bd38      	pop	{r3, r4, r5, pc}
 80050de:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80050e2:	f383 8811 	msr	BASEPRI, r3
 80050e6:	f3bf 8f6f 	isb	sy
 80050ea:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 80050ee:	e7fe      	b.n	80050ee <vTaskRemoveFromUnorderedEventList+0x72>
 80050f0:	2000144c 	.word	0x2000144c
 80050f4:	2000146c 	.word	0x2000146c
 80050f8:	200014e8 	.word	0x200014e8
 80050fc:	20001948 	.word	0x20001948
 8005100:	20001460 	.word	0x20001460

08005104 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 8005104:	b160      	cbz	r0, 8005120 <vTaskSetTimeOutState+0x1c>
{
 8005106:	b510      	push	{r4, lr}
 8005108:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800510a:	f000 fc13 	bl	8005934 <vPortEnterCritical>
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 800510e:	4b09      	ldr	r3, [pc, #36]	@ (8005134 <vTaskSetTimeOutState+0x30>)
 8005110:	681b      	ldr	r3, [r3, #0]
 8005112:	6023      	str	r3, [r4, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
 8005114:	4b08      	ldr	r3, [pc, #32]	@ (8005138 <vTaskSetTimeOutState+0x34>)
 8005116:	681b      	ldr	r3, [r3, #0]
 8005118:	6063      	str	r3, [r4, #4]
	taskEXIT_CRITICAL();
 800511a:	f000 fc2d 	bl	8005978 <vPortExitCritical>
}
 800511e:	bd10      	pop	{r4, pc}
 8005120:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005124:	f383 8811 	msr	BASEPRI, r3
 8005128:	f3bf 8f6f 	isb	sy
 800512c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 8005130:	e7fe      	b.n	8005130 <vTaskSetTimeOutState+0x2c>
 8005132:	bf00      	nop
 8005134:	2000145c 	.word	0x2000145c
 8005138:	20001470 	.word	0x20001470

0800513c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800513c:	4b03      	ldr	r3, [pc, #12]	@ (800514c <vTaskInternalSetTimeOutState+0x10>)
 800513e:	681b      	ldr	r3, [r3, #0]
 8005140:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8005142:	4b03      	ldr	r3, [pc, #12]	@ (8005150 <vTaskInternalSetTimeOutState+0x14>)
 8005144:	681b      	ldr	r3, [r3, #0]
 8005146:	6043      	str	r3, [r0, #4]
}
 8005148:	4770      	bx	lr
 800514a:	bf00      	nop
 800514c:	2000145c 	.word	0x2000145c
 8005150:	20001470 	.word	0x20001470

08005154 <xTaskCheckForTimeOut>:
{
 8005154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 8005156:	b1c8      	cbz	r0, 800518c <xTaskCheckForTimeOut+0x38>
 8005158:	460c      	mov	r4, r1
 800515a:	4605      	mov	r5, r0
	configASSERT( pxTicksToWait );
 800515c:	b1f9      	cbz	r1, 800519e <xTaskCheckForTimeOut+0x4a>
	taskENTER_CRITICAL();
 800515e:	f000 fbe9 	bl	8005934 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8005162:	4b1b      	ldr	r3, [pc, #108]	@ (80051d0 <xTaskCheckForTimeOut+0x7c>)
 8005164:	6819      	ldr	r1, [r3, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8005166:	686b      	ldr	r3, [r5, #4]
 8005168:	1ac8      	subs	r0, r1, r3
			if( *pxTicksToWait == portMAX_DELAY )
 800516a:	6822      	ldr	r2, [r4, #0]
 800516c:	f1b2 3fff 	cmp.w	r2, #4294967295
 8005170:	d026      	beq.n	80051c0 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005172:	4e18      	ldr	r6, [pc, #96]	@ (80051d4 <xTaskCheckForTimeOut+0x80>)
 8005174:	6836      	ldr	r6, [r6, #0]
 8005176:	682f      	ldr	r7, [r5, #0]
 8005178:	42b7      	cmp	r7, r6
 800517a:	d001      	beq.n	8005180 <xTaskCheckForTimeOut+0x2c>
 800517c:	428b      	cmp	r3, r1
 800517e:	d924      	bls.n	80051ca <xTaskCheckForTimeOut+0x76>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005180:	4282      	cmp	r2, r0
 8005182:	d815      	bhi.n	80051b0 <xTaskCheckForTimeOut+0x5c>
			*pxTicksToWait = 0;
 8005184:	2300      	movs	r3, #0
 8005186:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 8005188:	2401      	movs	r4, #1
 800518a:	e01a      	b.n	80051c2 <xTaskCheckForTimeOut+0x6e>
 800518c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005190:	f383 8811 	msr	BASEPRI, r3
 8005194:	f3bf 8f6f 	isb	sy
 8005198:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 800519c:	e7fe      	b.n	800519c <xTaskCheckForTimeOut+0x48>
 800519e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80051a2:	f383 8811 	msr	BASEPRI, r3
 80051a6:	f3bf 8f6f 	isb	sy
 80051aa:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 80051ae:	e7fe      	b.n	80051ae <xTaskCheckForTimeOut+0x5a>
			*pxTicksToWait -= xElapsedTime;
 80051b0:	1a5b      	subs	r3, r3, r1
 80051b2:	4413      	add	r3, r2
 80051b4:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 80051b6:	4628      	mov	r0, r5
 80051b8:	f7ff ffc0 	bl	800513c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 80051bc:	2400      	movs	r4, #0
 80051be:	e000      	b.n	80051c2 <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
 80051c0:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80051c2:	f000 fbd9 	bl	8005978 <vPortExitCritical>
}
 80051c6:	4620      	mov	r0, r4
 80051c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 80051ca:	2401      	movs	r4, #1
 80051cc:	e7f9      	b.n	80051c2 <xTaskCheckForTimeOut+0x6e>
 80051ce:	bf00      	nop
 80051d0:	20001470 	.word	0x20001470
 80051d4:	2000145c 	.word	0x2000145c

080051d8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 80051d8:	4b01      	ldr	r3, [pc, #4]	@ (80051e0 <vTaskMissedYield+0x8>)
 80051da:	2201      	movs	r2, #1
 80051dc:	601a      	str	r2, [r3, #0]
}
 80051de:	4770      	bx	lr
 80051e0:	20001460 	.word	0x20001460

080051e4 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 80051e4:	4b01      	ldr	r3, [pc, #4]	@ (80051ec <xTaskGetCurrentTaskHandle+0x8>)
 80051e6:	6818      	ldr	r0, [r3, #0]
	}
 80051e8:	4770      	bx	lr
 80051ea:	bf00      	nop
 80051ec:	20001948 	.word	0x20001948

080051f0 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 80051f0:	4b05      	ldr	r3, [pc, #20]	@ (8005208 <xTaskGetSchedulerState+0x18>)
 80051f2:	681b      	ldr	r3, [r3, #0]
 80051f4:	b133      	cbz	r3, 8005204 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80051f6:	4b05      	ldr	r3, [pc, #20]	@ (800520c <xTaskGetSchedulerState+0x1c>)
 80051f8:	681b      	ldr	r3, [r3, #0]
 80051fa:	b10b      	cbz	r3, 8005200 <xTaskGetSchedulerState+0x10>
				xReturn = taskSCHEDULER_SUSPENDED;
 80051fc:	2000      	movs	r0, #0
	}
 80051fe:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 8005200:	2002      	movs	r0, #2
 8005202:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8005204:	2001      	movs	r0, #1
 8005206:	4770      	bx	lr
 8005208:	20001468 	.word	0x20001468
 800520c:	2000144c 	.word	0x2000144c

08005210 <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 8005210:	2800      	cmp	r0, #0
 8005212:	d03e      	beq.n	8005292 <xTaskPriorityInherit+0x82>
	{
 8005214:	b538      	push	{r3, r4, r5, lr}
 8005216:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8005218:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 800521a:	4a20      	ldr	r2, [pc, #128]	@ (800529c <xTaskPriorityInherit+0x8c>)
 800521c:	6812      	ldr	r2, [r2, #0]
 800521e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8005220:	4293      	cmp	r3, r2
 8005222:	d22e      	bcs.n	8005282 <xTaskPriorityInherit+0x72>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005224:	6982      	ldr	r2, [r0, #24]
 8005226:	2a00      	cmp	r2, #0
 8005228:	db05      	blt.n	8005236 <xTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800522a:	4a1c      	ldr	r2, [pc, #112]	@ (800529c <xTaskPriorityInherit+0x8c>)
 800522c:	6812      	ldr	r2, [r2, #0]
 800522e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8005230:	f1c2 0238 	rsb	r2, r2, #56	@ 0x38
 8005234:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8005236:	6961      	ldr	r1, [r4, #20]
 8005238:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800523c:	4a18      	ldr	r2, [pc, #96]	@ (80052a0 <xTaskPriorityInherit+0x90>)
 800523e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8005242:	4299      	cmp	r1, r3
 8005244:	d005      	beq.n	8005252 <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005246:	4b15      	ldr	r3, [pc, #84]	@ (800529c <xTaskPriorityInherit+0x8c>)
 8005248:	681b      	ldr	r3, [r3, #0]
 800524a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800524c:	62e3      	str	r3, [r4, #44]	@ 0x2c
				xReturn = pdTRUE;
 800524e:	2001      	movs	r0, #1
	}
 8005250:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005252:	1d25      	adds	r5, r4, #4
 8005254:	4628      	mov	r0, r5
 8005256:	f7fe fdd9 	bl	8003e0c <uxListRemove>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800525a:	4b10      	ldr	r3, [pc, #64]	@ (800529c <xTaskPriorityInherit+0x8c>)
 800525c:	681b      	ldr	r3, [r3, #0]
 800525e:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 8005260:	62e0      	str	r0, [r4, #44]	@ 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8005262:	4b10      	ldr	r3, [pc, #64]	@ (80052a4 <xTaskPriorityInherit+0x94>)
 8005264:	681b      	ldr	r3, [r3, #0]
 8005266:	4298      	cmp	r0, r3
 8005268:	d901      	bls.n	800526e <xTaskPriorityInherit+0x5e>
 800526a:	4b0e      	ldr	r3, [pc, #56]	@ (80052a4 <xTaskPriorityInherit+0x94>)
 800526c:	6018      	str	r0, [r3, #0]
 800526e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8005272:	4629      	mov	r1, r5
 8005274:	4b0a      	ldr	r3, [pc, #40]	@ (80052a0 <xTaskPriorityInherit+0x90>)
 8005276:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800527a:	f7fe fda3 	bl	8003dc4 <vListInsertEnd>
				xReturn = pdTRUE;
 800527e:	2001      	movs	r0, #1
 8005280:	e7e6      	b.n	8005250 <xTaskPriorityInherit+0x40>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8005282:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
 8005284:	4b05      	ldr	r3, [pc, #20]	@ (800529c <xTaskPriorityInherit+0x8c>)
 8005286:	681b      	ldr	r3, [r3, #0]
 8005288:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800528a:	429a      	cmp	r2, r3
 800528c:	d303      	bcc.n	8005296 <xTaskPriorityInherit+0x86>
	BaseType_t xReturn = pdFALSE;
 800528e:	2000      	movs	r0, #0
 8005290:	e7de      	b.n	8005250 <xTaskPriorityInherit+0x40>
 8005292:	2000      	movs	r0, #0
	}
 8005294:	4770      	bx	lr
					xReturn = pdTRUE;
 8005296:	2001      	movs	r0, #1
		return xReturn;
 8005298:	e7da      	b.n	8005250 <xTaskPriorityInherit+0x40>
 800529a:	bf00      	nop
 800529c:	20001948 	.word	0x20001948
 80052a0:	200014e8 	.word	0x200014e8
 80052a4:	2000146c 	.word	0x2000146c

080052a8 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 80052a8:	2800      	cmp	r0, #0
 80052aa:	d03b      	beq.n	8005324 <xTaskPriorityDisinherit+0x7c>
	{
 80052ac:	b538      	push	{r3, r4, r5, lr}
 80052ae:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 80052b0:	4b1e      	ldr	r3, [pc, #120]	@ (800532c <xTaskPriorityDisinherit+0x84>)
 80052b2:	681b      	ldr	r3, [r3, #0]
 80052b4:	4283      	cmp	r3, r0
 80052b6:	d008      	beq.n	80052ca <xTaskPriorityDisinherit+0x22>
 80052b8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80052bc:	f383 8811 	msr	BASEPRI, r3
 80052c0:	f3bf 8f6f 	isb	sy
 80052c4:	f3bf 8f4f 	dsb	sy
 80052c8:	e7fe      	b.n	80052c8 <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 80052ca:	6d03      	ldr	r3, [r0, #80]	@ 0x50
 80052cc:	b943      	cbnz	r3, 80052e0 <xTaskPriorityDisinherit+0x38>
 80052ce:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80052d2:	f383 8811 	msr	BASEPRI, r3
 80052d6:	f3bf 8f6f 	isb	sy
 80052da:	f3bf 8f4f 	dsb	sy
 80052de:	e7fe      	b.n	80052de <xTaskPriorityDisinherit+0x36>
			( pxTCB->uxMutexesHeld )--;
 80052e0:	3b01      	subs	r3, #1
 80052e2:	6503      	str	r3, [r0, #80]	@ 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80052e4:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 80052e6:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
 80052e8:	4291      	cmp	r1, r2
 80052ea:	d01d      	beq.n	8005328 <xTaskPriorityDisinherit+0x80>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80052ec:	b10b      	cbz	r3, 80052f2 <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 80052ee:	2000      	movs	r0, #0
	}
 80052f0:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80052f2:	1d05      	adds	r5, r0, #4
 80052f4:	4628      	mov	r0, r5
 80052f6:	f7fe fd89 	bl	8003e0c <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80052fa:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
 80052fc:	62e0      	str	r0, [r4, #44]	@ 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80052fe:	f1c0 0338 	rsb	r3, r0, #56	@ 0x38
 8005302:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8005304:	4b0a      	ldr	r3, [pc, #40]	@ (8005330 <xTaskPriorityDisinherit+0x88>)
 8005306:	681b      	ldr	r3, [r3, #0]
 8005308:	4298      	cmp	r0, r3
 800530a:	d901      	bls.n	8005310 <xTaskPriorityDisinherit+0x68>
 800530c:	4b08      	ldr	r3, [pc, #32]	@ (8005330 <xTaskPriorityDisinherit+0x88>)
 800530e:	6018      	str	r0, [r3, #0]
 8005310:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8005314:	4629      	mov	r1, r5
 8005316:	4b07      	ldr	r3, [pc, #28]	@ (8005334 <xTaskPriorityDisinherit+0x8c>)
 8005318:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800531c:	f7fe fd52 	bl	8003dc4 <vListInsertEnd>
					xReturn = pdTRUE;
 8005320:	2001      	movs	r0, #1
 8005322:	e7e5      	b.n	80052f0 <xTaskPriorityDisinherit+0x48>
	BaseType_t xReturn = pdFALSE;
 8005324:	2000      	movs	r0, #0
	}
 8005326:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
 8005328:	2000      	movs	r0, #0
 800532a:	e7e1      	b.n	80052f0 <xTaskPriorityDisinherit+0x48>
 800532c:	20001948 	.word	0x20001948
 8005330:	2000146c 	.word	0x2000146c
 8005334:	200014e8 	.word	0x200014e8

08005338 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 8005338:	2800      	cmp	r0, #0
 800533a:	d046      	beq.n	80053ca <vTaskPriorityDisinheritAfterTimeout+0x92>
	{
 800533c:	b538      	push	{r3, r4, r5, lr}
 800533e:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 8005340:	6d03      	ldr	r3, [r0, #80]	@ 0x50
 8005342:	b943      	cbnz	r3, 8005356 <vTaskPriorityDisinheritAfterTimeout+0x1e>
 8005344:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005348:	f383 8811 	msr	BASEPRI, r3
 800534c:	f3bf 8f6f 	isb	sy
 8005350:	f3bf 8f4f 	dsb	sy
 8005354:	e7fe      	b.n	8005354 <vTaskPriorityDisinheritAfterTimeout+0x1c>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8005356:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
 8005358:	428a      	cmp	r2, r1
 800535a:	d200      	bcs.n	800535e <vTaskPriorityDisinheritAfterTimeout+0x26>
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 800535c:	460a      	mov	r2, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
 800535e:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8005360:	4291      	cmp	r1, r2
 8005362:	d001      	beq.n	8005368 <vTaskPriorityDisinheritAfterTimeout+0x30>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8005364:	2b01      	cmp	r3, #1
 8005366:	d000      	beq.n	800536a <vTaskPriorityDisinheritAfterTimeout+0x32>
	}
 8005368:	bd38      	pop	{r3, r4, r5, pc}
					configASSERT( pxTCB != pxCurrentTCB );
 800536a:	4b18      	ldr	r3, [pc, #96]	@ (80053cc <vTaskPriorityDisinheritAfterTimeout+0x94>)
 800536c:	681b      	ldr	r3, [r3, #0]
 800536e:	42a3      	cmp	r3, r4
 8005370:	d022      	beq.n	80053b8 <vTaskPriorityDisinheritAfterTimeout+0x80>
					pxTCB->uxPriority = uxPriorityToUse;
 8005372:	62e2      	str	r2, [r4, #44]	@ 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005374:	69a3      	ldr	r3, [r4, #24]
 8005376:	2b00      	cmp	r3, #0
 8005378:	db02      	blt.n	8005380 <vTaskPriorityDisinheritAfterTimeout+0x48>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800537a:	f1c2 0238 	rsb	r2, r2, #56	@ 0x38
 800537e:	61a2      	str	r2, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005380:	6962      	ldr	r2, [r4, #20]
 8005382:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8005386:	4b12      	ldr	r3, [pc, #72]	@ (80053d0 <vTaskPriorityDisinheritAfterTimeout+0x98>)
 8005388:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800538c:	429a      	cmp	r2, r3
 800538e:	d1eb      	bne.n	8005368 <vTaskPriorityDisinheritAfterTimeout+0x30>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005390:	1d25      	adds	r5, r4, #4
 8005392:	4628      	mov	r0, r5
 8005394:	f7fe fd3a 	bl	8003e0c <uxListRemove>
						prvAddTaskToReadyList( pxTCB );
 8005398:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 800539a:	4b0e      	ldr	r3, [pc, #56]	@ (80053d4 <vTaskPriorityDisinheritAfterTimeout+0x9c>)
 800539c:	681b      	ldr	r3, [r3, #0]
 800539e:	4298      	cmp	r0, r3
 80053a0:	d901      	bls.n	80053a6 <vTaskPriorityDisinheritAfterTimeout+0x6e>
 80053a2:	4b0c      	ldr	r3, [pc, #48]	@ (80053d4 <vTaskPriorityDisinheritAfterTimeout+0x9c>)
 80053a4:	6018      	str	r0, [r3, #0]
 80053a6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80053aa:	4629      	mov	r1, r5
 80053ac:	4b08      	ldr	r3, [pc, #32]	@ (80053d0 <vTaskPriorityDisinheritAfterTimeout+0x98>)
 80053ae:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80053b2:	f7fe fd07 	bl	8003dc4 <vListInsertEnd>
	}
 80053b6:	e7d7      	b.n	8005368 <vTaskPriorityDisinheritAfterTimeout+0x30>
 80053b8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80053bc:	f383 8811 	msr	BASEPRI, r3
 80053c0:	f3bf 8f6f 	isb	sy
 80053c4:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 80053c8:	e7fe      	b.n	80053c8 <vTaskPriorityDisinheritAfterTimeout+0x90>
 80053ca:	4770      	bx	lr
 80053cc:	20001948 	.word	0x20001948
 80053d0:	200014e8 	.word	0x200014e8
 80053d4:	2000146c 	.word	0x2000146c

080053d8 <uxTaskResetEventItemValue>:
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 80053d8:	4a04      	ldr	r2, [pc, #16]	@ (80053ec <uxTaskResetEventItemValue+0x14>)
 80053da:	6813      	ldr	r3, [r2, #0]
 80053dc:	6998      	ldr	r0, [r3, #24]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80053de:	6813      	ldr	r3, [r2, #0]
 80053e0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80053e2:	6812      	ldr	r2, [r2, #0]
 80053e4:	f1c3 0338 	rsb	r3, r3, #56	@ 0x38
 80053e8:	6193      	str	r3, [r2, #24]
}
 80053ea:	4770      	bx	lr
 80053ec:	20001948 	.word	0x20001948

080053f0 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 80053f0:	4b05      	ldr	r3, [pc, #20]	@ (8005408 <pvTaskIncrementMutexHeldCount+0x18>)
 80053f2:	681b      	ldr	r3, [r3, #0]
 80053f4:	b123      	cbz	r3, 8005400 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 80053f6:	4b04      	ldr	r3, [pc, #16]	@ (8005408 <pvTaskIncrementMutexHeldCount+0x18>)
 80053f8:	681a      	ldr	r2, [r3, #0]
 80053fa:	6d13      	ldr	r3, [r2, #80]	@ 0x50
 80053fc:	3301      	adds	r3, #1
 80053fe:	6513      	str	r3, [r2, #80]	@ 0x50
		return pxCurrentTCB;
 8005400:	4b01      	ldr	r3, [pc, #4]	@ (8005408 <pvTaskIncrementMutexHeldCount+0x18>)
 8005402:	6818      	ldr	r0, [r3, #0]
	}
 8005404:	4770      	bx	lr
 8005406:	bf00      	nop
 8005408:	20001948 	.word	0x20001948

0800540c <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800540c:	4b06      	ldr	r3, [pc, #24]	@ (8005428 <prvGetNextExpireTime+0x1c>)
 800540e:	681a      	ldr	r2, [r3, #0]
 8005410:	6813      	ldr	r3, [r2, #0]
 8005412:	b92b      	cbnz	r3, 8005420 <prvGetNextExpireTime+0x14>
 8005414:	2301      	movs	r3, #1
 8005416:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
 8005418:	b923      	cbnz	r3, 8005424 <prvGetNextExpireTime+0x18>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800541a:	68d3      	ldr	r3, [r2, #12]
 800541c:	6818      	ldr	r0, [r3, #0]
 800541e:	4770      	bx	lr
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8005420:	2300      	movs	r3, #0
 8005422:	e7f8      	b.n	8005416 <prvGetNextExpireTime+0xa>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8005424:	2000      	movs	r0, #0
	}

	return xNextExpireTime;
}
 8005426:	4770      	bx	lr
 8005428:	20001a4c 	.word	0x20001a4c

0800542c <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 800542c:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800542e:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8005430:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
 8005432:	4291      	cmp	r1, r2
 8005434:	d80c      	bhi.n	8005450 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005436:	1ad2      	subs	r2, r2, r3
 8005438:	6983      	ldr	r3, [r0, #24]
 800543a:	429a      	cmp	r2, r3
 800543c:	d301      	bcc.n	8005442 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 800543e:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 8005440:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8005442:	1d01      	adds	r1, r0, #4
 8005444:	4b09      	ldr	r3, [pc, #36]	@ (800546c <prvInsertTimerInActiveList+0x40>)
 8005446:	6818      	ldr	r0, [r3, #0]
 8005448:	f7fe fcc7 	bl	8003dda <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 800544c:	2000      	movs	r0, #0
 800544e:	e7f7      	b.n	8005440 <prvInsertTimerInActiveList+0x14>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8005450:	429a      	cmp	r2, r3
 8005452:	d201      	bcs.n	8005458 <prvInsertTimerInActiveList+0x2c>
 8005454:	4299      	cmp	r1, r3
 8005456:	d206      	bcs.n	8005466 <prvInsertTimerInActiveList+0x3a>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8005458:	1d01      	adds	r1, r0, #4
 800545a:	4b05      	ldr	r3, [pc, #20]	@ (8005470 <prvInsertTimerInActiveList+0x44>)
 800545c:	6818      	ldr	r0, [r3, #0]
 800545e:	f7fe fcbc 	bl	8003dda <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8005462:	2000      	movs	r0, #0
 8005464:	e7ec      	b.n	8005440 <prvInsertTimerInActiveList+0x14>
			xProcessTimerNow = pdTRUE;
 8005466:	2001      	movs	r0, #1
	return xProcessTimerNow;
 8005468:	e7ea      	b.n	8005440 <prvInsertTimerInActiveList+0x14>
 800546a:	bf00      	nop
 800546c:	20001a48 	.word	0x20001a48
 8005470:	20001a4c 	.word	0x20001a4c

08005474 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8005474:	b530      	push	{r4, r5, lr}
 8005476:	b083      	sub	sp, #12
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8005478:	f000 fa5c 	bl	8005934 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 800547c:	4b11      	ldr	r3, [pc, #68]	@ (80054c4 <prvCheckForValidListAndQueue+0x50>)
 800547e:	681b      	ldr	r3, [r3, #0]
 8005480:	b11b      	cbz	r3, 800548a <prvCheckForValidListAndQueue+0x16>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8005482:	f000 fa79 	bl	8005978 <vPortExitCritical>
}
 8005486:	b003      	add	sp, #12
 8005488:	bd30      	pop	{r4, r5, pc}
			vListInitialise( &xActiveTimerList1 );
 800548a:	4d0f      	ldr	r5, [pc, #60]	@ (80054c8 <prvCheckForValidListAndQueue+0x54>)
 800548c:	4628      	mov	r0, r5
 800548e:	f7fe fc8b 	bl	8003da8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8005492:	4c0e      	ldr	r4, [pc, #56]	@ (80054cc <prvCheckForValidListAndQueue+0x58>)
 8005494:	4620      	mov	r0, r4
 8005496:	f7fe fc87 	bl	8003da8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800549a:	4b0d      	ldr	r3, [pc, #52]	@ (80054d0 <prvCheckForValidListAndQueue+0x5c>)
 800549c:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 800549e:	4b0d      	ldr	r3, [pc, #52]	@ (80054d4 <prvCheckForValidListAndQueue+0x60>)
 80054a0:	601c      	str	r4, [r3, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80054a2:	2300      	movs	r3, #0
 80054a4:	9300      	str	r3, [sp, #0]
 80054a6:	4b0c      	ldr	r3, [pc, #48]	@ (80054d8 <prvCheckForValidListAndQueue+0x64>)
 80054a8:	4a0c      	ldr	r2, [pc, #48]	@ (80054dc <prvCheckForValidListAndQueue+0x68>)
 80054aa:	2110      	movs	r1, #16
 80054ac:	200a      	movs	r0, #10
 80054ae:	f7fe fdbb 	bl	8004028 <xQueueGenericCreateStatic>
 80054b2:	4b04      	ldr	r3, [pc, #16]	@ (80054c4 <prvCheckForValidListAndQueue+0x50>)
 80054b4:	6018      	str	r0, [r3, #0]
				if( xTimerQueue != NULL )
 80054b6:	2800      	cmp	r0, #0
 80054b8:	d0e3      	beq.n	8005482 <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80054ba:	4909      	ldr	r1, [pc, #36]	@ (80054e0 <prvCheckForValidListAndQueue+0x6c>)
 80054bc:	f7ff f8e2 	bl	8004684 <vQueueAddToRegistry>
 80054c0:	e7df      	b.n	8005482 <prvCheckForValidListAndQueue+0xe>
 80054c2:	bf00      	nop
 80054c4:	20001a44 	.word	0x20001a44
 80054c8:	20001a64 	.word	0x20001a64
 80054cc:	20001a50 	.word	0x20001a50
 80054d0:	20001a4c 	.word	0x20001a4c
 80054d4:	20001a48 	.word	0x20001a48
 80054d8:	2000194c 	.word	0x2000194c
 80054dc:	2000199c 	.word	0x2000199c
 80054e0:	080101a0 	.word	0x080101a0

080054e4 <xTimerCreateTimerTask>:
{
 80054e4:	b510      	push	{r4, lr}
 80054e6:	b088      	sub	sp, #32
	prvCheckForValidListAndQueue();
 80054e8:	f7ff ffc4 	bl	8005474 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 80054ec:	4b12      	ldr	r3, [pc, #72]	@ (8005538 <xTimerCreateTimerTask+0x54>)
 80054ee:	681b      	ldr	r3, [r3, #0]
 80054f0:	b1cb      	cbz	r3, 8005526 <xTimerCreateTimerTask+0x42>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 80054f2:	2400      	movs	r4, #0
 80054f4:	9405      	str	r4, [sp, #20]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 80054f6:	9406      	str	r4, [sp, #24]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 80054f8:	aa07      	add	r2, sp, #28
 80054fa:	a906      	add	r1, sp, #24
 80054fc:	a805      	add	r0, sp, #20
 80054fe:	f7fe fb1b 	bl	8003b38 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 8005502:	9b05      	ldr	r3, [sp, #20]
 8005504:	9302      	str	r3, [sp, #8]
 8005506:	9b06      	ldr	r3, [sp, #24]
 8005508:	9301      	str	r3, [sp, #4]
 800550a:	2302      	movs	r3, #2
 800550c:	9300      	str	r3, [sp, #0]
 800550e:	4623      	mov	r3, r4
 8005510:	9a07      	ldr	r2, [sp, #28]
 8005512:	490a      	ldr	r1, [pc, #40]	@ (800553c <xTimerCreateTimerTask+0x58>)
 8005514:	480a      	ldr	r0, [pc, #40]	@ (8005540 <xTimerCreateTimerTask+0x5c>)
 8005516:	f7ff fab9 	bl	8004a8c <xTaskCreateStatic>
 800551a:	4b0a      	ldr	r3, [pc, #40]	@ (8005544 <xTimerCreateTimerTask+0x60>)
 800551c:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
 800551e:	b110      	cbz	r0, 8005526 <xTimerCreateTimerTask+0x42>
}
 8005520:	2001      	movs	r0, #1
 8005522:	b008      	add	sp, #32
 8005524:	bd10      	pop	{r4, pc}
 8005526:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800552a:	f383 8811 	msr	BASEPRI, r3
 800552e:	f3bf 8f6f 	isb	sy
 8005532:	f3bf 8f4f 	dsb	sy
	configASSERT( xReturn );
 8005536:	e7fe      	b.n	8005536 <xTimerCreateTimerTask+0x52>
 8005538:	20001a44 	.word	0x20001a44
 800553c:	080101a8 	.word	0x080101a8
 8005540:	08005849 	.word	0x08005849
 8005544:	20001a40 	.word	0x20001a40

08005548 <xTimerGenericCommand>:
	configASSERT( xTimer );
 8005548:	b1b8      	cbz	r0, 800557a <xTimerGenericCommand+0x32>
 800554a:	469c      	mov	ip, r3
 800554c:	4603      	mov	r3, r0
	if( xTimerQueue != NULL )
 800554e:	4818      	ldr	r0, [pc, #96]	@ (80055b0 <xTimerGenericCommand+0x68>)
 8005550:	6800      	ldr	r0, [r0, #0]
 8005552:	b358      	cbz	r0, 80055ac <xTimerGenericCommand+0x64>
{
 8005554:	b500      	push	{lr}
 8005556:	b085      	sub	sp, #20
		xMessage.xMessageID = xCommandID;
 8005558:	9100      	str	r1, [sp, #0]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800555a:	9201      	str	r2, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800555c:	9302      	str	r3, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 800555e:	2905      	cmp	r1, #5
 8005560:	dc1c      	bgt.n	800559c <xTimerGenericCommand+0x54>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8005562:	f7ff fe45 	bl	80051f0 <xTaskGetSchedulerState>
 8005566:	2802      	cmp	r0, #2
 8005568:	d010      	beq.n	800558c <xTimerGenericCommand+0x44>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800556a:	2300      	movs	r3, #0
 800556c:	461a      	mov	r2, r3
 800556e:	4669      	mov	r1, sp
 8005570:	480f      	ldr	r0, [pc, #60]	@ (80055b0 <xTimerGenericCommand+0x68>)
 8005572:	6800      	ldr	r0, [r0, #0]
 8005574:	f7fe fdc5 	bl	8004102 <xQueueGenericSend>
 8005578:	e015      	b.n	80055a6 <xTimerGenericCommand+0x5e>
 800557a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800557e:	f383 8811 	msr	BASEPRI, r3
 8005582:	f3bf 8f6f 	isb	sy
 8005586:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 800558a:	e7fe      	b.n	800558a <xTimerGenericCommand+0x42>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800558c:	2300      	movs	r3, #0
 800558e:	9a06      	ldr	r2, [sp, #24]
 8005590:	4669      	mov	r1, sp
 8005592:	4807      	ldr	r0, [pc, #28]	@ (80055b0 <xTimerGenericCommand+0x68>)
 8005594:	6800      	ldr	r0, [r0, #0]
 8005596:	f7fe fdb4 	bl	8004102 <xQueueGenericSend>
 800559a:	e004      	b.n	80055a6 <xTimerGenericCommand+0x5e>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800559c:	2300      	movs	r3, #0
 800559e:	4662      	mov	r2, ip
 80055a0:	4669      	mov	r1, sp
 80055a2:	f7fe fe72 	bl	800428a <xQueueGenericSendFromISR>
}
 80055a6:	b005      	add	sp, #20
 80055a8:	f85d fb04 	ldr.w	pc, [sp], #4
BaseType_t xReturn = pdFAIL;
 80055ac:	2000      	movs	r0, #0
}
 80055ae:	4770      	bx	lr
 80055b0:	20001a44 	.word	0x20001a44

080055b4 <prvSwitchTimerLists>:
{
 80055b4:	b570      	push	{r4, r5, r6, lr}
 80055b6:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80055b8:	4b1b      	ldr	r3, [pc, #108]	@ (8005628 <prvSwitchTimerLists+0x74>)
 80055ba:	681b      	ldr	r3, [r3, #0]
 80055bc:	681a      	ldr	r2, [r3, #0]
 80055be:	b362      	cbz	r2, 800561a <prvSwitchTimerLists+0x66>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80055c0:	68db      	ldr	r3, [r3, #12]
 80055c2:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80055c4:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80055c6:	1d25      	adds	r5, r4, #4
 80055c8:	4628      	mov	r0, r5
 80055ca:	f7fe fc1f 	bl	8003e0c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80055ce:	6a23      	ldr	r3, [r4, #32]
 80055d0:	4620      	mov	r0, r4
 80055d2:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80055d4:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 80055d8:	f013 0f04 	tst.w	r3, #4
 80055dc:	d0ec      	beq.n	80055b8 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80055de:	69a3      	ldr	r3, [r4, #24]
 80055e0:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 80055e2:	429e      	cmp	r6, r3
 80055e4:	d207      	bcs.n	80055f6 <prvSwitchTimerLists+0x42>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80055e6:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80055e8:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80055ea:	4629      	mov	r1, r5
 80055ec:	4b0e      	ldr	r3, [pc, #56]	@ (8005628 <prvSwitchTimerLists+0x74>)
 80055ee:	6818      	ldr	r0, [r3, #0]
 80055f0:	f7fe fbf3 	bl	8003dda <vListInsert>
 80055f4:	e7e0      	b.n	80055b8 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80055f6:	2100      	movs	r1, #0
 80055f8:	9100      	str	r1, [sp, #0]
 80055fa:	460b      	mov	r3, r1
 80055fc:	4632      	mov	r2, r6
 80055fe:	4620      	mov	r0, r4
 8005600:	f7ff ffa2 	bl	8005548 <xTimerGenericCommand>
				configASSERT( xResult );
 8005604:	2800      	cmp	r0, #0
 8005606:	d1d7      	bne.n	80055b8 <prvSwitchTimerLists+0x4>
 8005608:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800560c:	f383 8811 	msr	BASEPRI, r3
 8005610:	f3bf 8f6f 	isb	sy
 8005614:	f3bf 8f4f 	dsb	sy
 8005618:	e7fe      	b.n	8005618 <prvSwitchTimerLists+0x64>
	pxCurrentTimerList = pxOverflowTimerList;
 800561a:	4a04      	ldr	r2, [pc, #16]	@ (800562c <prvSwitchTimerLists+0x78>)
 800561c:	6810      	ldr	r0, [r2, #0]
 800561e:	4902      	ldr	r1, [pc, #8]	@ (8005628 <prvSwitchTimerLists+0x74>)
 8005620:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
 8005622:	6013      	str	r3, [r2, #0]
}
 8005624:	b002      	add	sp, #8
 8005626:	bd70      	pop	{r4, r5, r6, pc}
 8005628:	20001a4c 	.word	0x20001a4c
 800562c:	20001a48 	.word	0x20001a48

08005630 <prvSampleTimeNow>:
{
 8005630:	b538      	push	{r3, r4, r5, lr}
 8005632:	4605      	mov	r5, r0
	xTimeNow = xTaskGetTickCount();
 8005634:	f7ff faf6 	bl	8004c24 <xTaskGetTickCount>
 8005638:	4604      	mov	r4, r0
	if( xTimeNow < xLastTime )
 800563a:	4b07      	ldr	r3, [pc, #28]	@ (8005658 <prvSampleTimeNow+0x28>)
 800563c:	681b      	ldr	r3, [r3, #0]
 800563e:	4283      	cmp	r3, r0
 8005640:	d805      	bhi.n	800564e <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
 8005642:	2300      	movs	r3, #0
 8005644:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
 8005646:	4b04      	ldr	r3, [pc, #16]	@ (8005658 <prvSampleTimeNow+0x28>)
 8005648:	601c      	str	r4, [r3, #0]
}
 800564a:	4620      	mov	r0, r4
 800564c:	bd38      	pop	{r3, r4, r5, pc}
		prvSwitchTimerLists();
 800564e:	f7ff ffb1 	bl	80055b4 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8005652:	2301      	movs	r3, #1
 8005654:	602b      	str	r3, [r5, #0]
 8005656:	e7f6      	b.n	8005646 <prvSampleTimeNow+0x16>
 8005658:	20001a3c 	.word	0x20001a3c

0800565c <prvProcessExpiredTimer>:
{
 800565c:	b570      	push	{r4, r5, r6, lr}
 800565e:	b082      	sub	sp, #8
 8005660:	4606      	mov	r6, r0
 8005662:	460d      	mov	r5, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8005664:	4917      	ldr	r1, [pc, #92]	@ (80056c4 <prvProcessExpiredTimer+0x68>)
 8005666:	6809      	ldr	r1, [r1, #0]
 8005668:	68c9      	ldr	r1, [r1, #12]
 800566a:	68cc      	ldr	r4, [r1, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800566c:	1d20      	adds	r0, r4, #4
 800566e:	f7fe fbcd 	bl	8003e0c <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8005672:	f894 c028 	ldrb.w	ip, [r4, #40]	@ 0x28
 8005676:	f01c 0f04 	tst.w	ip, #4
 800567a:	d108      	bne.n	800568e <prvProcessExpiredTimer+0x32>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800567c:	f02c 0c01 	bic.w	ip, ip, #1
 8005680:	f884 c028 	strb.w	ip, [r4, #40]	@ 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8005684:	6a23      	ldr	r3, [r4, #32]
 8005686:	4620      	mov	r0, r4
 8005688:	4798      	blx	r3
}
 800568a:	b002      	add	sp, #8
 800568c:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800568e:	69a1      	ldr	r1, [r4, #24]
 8005690:	4633      	mov	r3, r6
 8005692:	462a      	mov	r2, r5
 8005694:	4431      	add	r1, r6
 8005696:	4620      	mov	r0, r4
 8005698:	f7ff fec8 	bl	800542c <prvInsertTimerInActiveList>
 800569c:	2800      	cmp	r0, #0
 800569e:	d0f1      	beq.n	8005684 <prvProcessExpiredTimer+0x28>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80056a0:	2100      	movs	r1, #0
 80056a2:	9100      	str	r1, [sp, #0]
 80056a4:	460b      	mov	r3, r1
 80056a6:	4632      	mov	r2, r6
 80056a8:	4620      	mov	r0, r4
 80056aa:	f7ff ff4d 	bl	8005548 <xTimerGenericCommand>
			configASSERT( xResult );
 80056ae:	2800      	cmp	r0, #0
 80056b0:	d1e8      	bne.n	8005684 <prvProcessExpiredTimer+0x28>
 80056b2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80056b6:	f383 8811 	msr	BASEPRI, r3
 80056ba:	f3bf 8f6f 	isb	sy
 80056be:	f3bf 8f4f 	dsb	sy
 80056c2:	e7fe      	b.n	80056c2 <prvProcessExpiredTimer+0x66>
 80056c4:	20001a4c 	.word	0x20001a4c

080056c8 <prvProcessTimerOrBlockTask>:
{
 80056c8:	b570      	push	{r4, r5, r6, lr}
 80056ca:	b082      	sub	sp, #8
 80056cc:	4606      	mov	r6, r0
 80056ce:	460c      	mov	r4, r1
	vTaskSuspendAll();
 80056d0:	f7ff faa0 	bl	8004c14 <vTaskSuspendAll>
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80056d4:	a801      	add	r0, sp, #4
 80056d6:	f7ff ffab 	bl	8005630 <prvSampleTimeNow>
		if( xTimerListsWereSwitched == pdFALSE )
 80056da:	9b01      	ldr	r3, [sp, #4]
 80056dc:	bb33      	cbnz	r3, 800572c <prvProcessTimerOrBlockTask+0x64>
 80056de:	4605      	mov	r5, r0
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80056e0:	b9e4      	cbnz	r4, 800571c <prvProcessTimerOrBlockTask+0x54>
 80056e2:	42b0      	cmp	r0, r6
 80056e4:	d213      	bcs.n	800570e <prvProcessTimerOrBlockTask+0x46>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 80056e6:	4622      	mov	r2, r4
 80056e8:	1b71      	subs	r1, r6, r5
 80056ea:	4b12      	ldr	r3, [pc, #72]	@ (8005734 <prvProcessTimerOrBlockTask+0x6c>)
 80056ec:	6818      	ldr	r0, [r3, #0]
 80056ee:	f7ff f809 	bl	8004704 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 80056f2:	f7ff fb29 	bl	8004d48 <xTaskResumeAll>
 80056f6:	b9d8      	cbnz	r0, 8005730 <prvProcessTimerOrBlockTask+0x68>
					portYIELD_WITHIN_API();
 80056f8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80056fc:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8005700:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8005704:	f3bf 8f4f 	dsb	sy
 8005708:	f3bf 8f6f 	isb	sy
 800570c:	e010      	b.n	8005730 <prvProcessTimerOrBlockTask+0x68>
				( void ) xTaskResumeAll();
 800570e:	f7ff fb1b 	bl	8004d48 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 8005712:	4629      	mov	r1, r5
 8005714:	4630      	mov	r0, r6
 8005716:	f7ff ffa1 	bl	800565c <prvProcessExpiredTimer>
 800571a:	e009      	b.n	8005730 <prvProcessTimerOrBlockTask+0x68>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800571c:	4a06      	ldr	r2, [pc, #24]	@ (8005738 <prvProcessTimerOrBlockTask+0x70>)
 800571e:	6812      	ldr	r2, [r2, #0]
 8005720:	6812      	ldr	r2, [r2, #0]
 8005722:	b90a      	cbnz	r2, 8005728 <prvProcessTimerOrBlockTask+0x60>
 8005724:	2401      	movs	r4, #1
 8005726:	e7de      	b.n	80056e6 <prvProcessTimerOrBlockTask+0x1e>
 8005728:	461c      	mov	r4, r3
 800572a:	e7dc      	b.n	80056e6 <prvProcessTimerOrBlockTask+0x1e>
			( void ) xTaskResumeAll();
 800572c:	f7ff fb0c 	bl	8004d48 <xTaskResumeAll>
}
 8005730:	b002      	add	sp, #8
 8005732:	bd70      	pop	{r4, r5, r6, pc}
 8005734:	20001a44 	.word	0x20001a44
 8005738:	20001a48 	.word	0x20001a48

0800573c <prvProcessReceivedCommands>:
{
 800573c:	b510      	push	{r4, lr}
 800573e:	b088      	sub	sp, #32
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8005740:	e002      	b.n	8005748 <prvProcessReceivedCommands+0xc>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8005742:	9b04      	ldr	r3, [sp, #16]
 8005744:	2b00      	cmp	r3, #0
 8005746:	da0f      	bge.n	8005768 <prvProcessReceivedCommands+0x2c>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8005748:	2200      	movs	r2, #0
 800574a:	a904      	add	r1, sp, #16
 800574c:	4b3d      	ldr	r3, [pc, #244]	@ (8005844 <prvProcessReceivedCommands+0x108>)
 800574e:	6818      	ldr	r0, [r3, #0]
 8005750:	f7fe fe02 	bl	8004358 <xQueueReceive>
 8005754:	2800      	cmp	r0, #0
 8005756:	d073      	beq.n	8005840 <prvProcessReceivedCommands+0x104>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8005758:	9b04      	ldr	r3, [sp, #16]
 800575a:	2b00      	cmp	r3, #0
 800575c:	daf1      	bge.n	8005742 <prvProcessReceivedCommands+0x6>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 800575e:	9907      	ldr	r1, [sp, #28]
 8005760:	9806      	ldr	r0, [sp, #24]
 8005762:	9b05      	ldr	r3, [sp, #20]
 8005764:	4798      	blx	r3
 8005766:	e7ec      	b.n	8005742 <prvProcessReceivedCommands+0x6>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8005768:	9c06      	ldr	r4, [sp, #24]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 800576a:	6963      	ldr	r3, [r4, #20]
 800576c:	b113      	cbz	r3, 8005774 <prvProcessReceivedCommands+0x38>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800576e:	1d20      	adds	r0, r4, #4
 8005770:	f7fe fb4c 	bl	8003e0c <uxListRemove>
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8005774:	a803      	add	r0, sp, #12
 8005776:	f7ff ff5b 	bl	8005630 <prvSampleTimeNow>
			switch( xMessage.xMessageID )
 800577a:	9b04      	ldr	r3, [sp, #16]
 800577c:	2b09      	cmp	r3, #9
 800577e:	d8e3      	bhi.n	8005748 <prvProcessReceivedCommands+0xc>
 8005780:	e8df f003 	tbb	[pc, r3]
 8005784:	30050505 	.word	0x30050505
 8005788:	05055037 	.word	0x05055037
 800578c:	3730      	.short	0x3730
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800578e:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 8005792:	f043 0301 	orr.w	r3, r3, #1
 8005796:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800579a:	9b05      	ldr	r3, [sp, #20]
 800579c:	69a1      	ldr	r1, [r4, #24]
 800579e:	4602      	mov	r2, r0
 80057a0:	4419      	add	r1, r3
 80057a2:	4620      	mov	r0, r4
 80057a4:	f7ff fe42 	bl	800542c <prvInsertTimerInActiveList>
 80057a8:	2800      	cmp	r0, #0
 80057aa:	d0cd      	beq.n	8005748 <prvProcessReceivedCommands+0xc>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80057ac:	6a23      	ldr	r3, [r4, #32]
 80057ae:	4620      	mov	r0, r4
 80057b0:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80057b2:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 80057b6:	f013 0f04 	tst.w	r3, #4
 80057ba:	d0c5      	beq.n	8005748 <prvProcessReceivedCommands+0xc>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 80057bc:	69a2      	ldr	r2, [r4, #24]
 80057be:	2100      	movs	r1, #0
 80057c0:	9100      	str	r1, [sp, #0]
 80057c2:	460b      	mov	r3, r1
 80057c4:	9805      	ldr	r0, [sp, #20]
 80057c6:	4402      	add	r2, r0
 80057c8:	4620      	mov	r0, r4
 80057ca:	f7ff febd 	bl	8005548 <xTimerGenericCommand>
							configASSERT( xResult );
 80057ce:	2800      	cmp	r0, #0
 80057d0:	d1ba      	bne.n	8005748 <prvProcessReceivedCommands+0xc>
 80057d2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80057d6:	f383 8811 	msr	BASEPRI, r3
 80057da:	f3bf 8f6f 	isb	sy
 80057de:	f3bf 8f4f 	dsb	sy
 80057e2:	e7fe      	b.n	80057e2 <prvProcessReceivedCommands+0xa6>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80057e4:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 80057e8:	f023 0301 	bic.w	r3, r3, #1
 80057ec:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
					break;
 80057f0:	e7aa      	b.n	8005748 <prvProcessReceivedCommands+0xc>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80057f2:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 80057f6:	f043 0301 	orr.w	r3, r3, #1
 80057fa:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80057fe:	9905      	ldr	r1, [sp, #20]
 8005800:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8005802:	b131      	cbz	r1, 8005812 <prvProcessReceivedCommands+0xd6>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8005804:	4603      	mov	r3, r0
 8005806:	4602      	mov	r2, r0
 8005808:	4401      	add	r1, r0
 800580a:	4620      	mov	r0, r4
 800580c:	f7ff fe0e 	bl	800542c <prvInsertTimerInActiveList>
					break;
 8005810:	e79a      	b.n	8005748 <prvProcessReceivedCommands+0xc>
 8005812:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005816:	f383 8811 	msr	BASEPRI, r3
 800581a:	f3bf 8f6f 	isb	sy
 800581e:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8005822:	e7fe      	b.n	8005822 <prvProcessReceivedCommands+0xe6>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8005824:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 8005828:	f013 0f02 	tst.w	r3, #2
 800582c:	d004      	beq.n	8005838 <prvProcessReceivedCommands+0xfc>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800582e:	f023 0301 	bic.w	r3, r3, #1
 8005832:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
 8005836:	e787      	b.n	8005748 <prvProcessReceivedCommands+0xc>
							vPortFree( pxTimer );
 8005838:	4620      	mov	r0, r4
 800583a:	f000 fab5 	bl	8005da8 <vPortFree>
 800583e:	e783      	b.n	8005748 <prvProcessReceivedCommands+0xc>
}
 8005840:	b008      	add	sp, #32
 8005842:	bd10      	pop	{r4, pc}
 8005844:	20001a44 	.word	0x20001a44

08005848 <prvTimerTask>:
{
 8005848:	b500      	push	{lr}
 800584a:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800584c:	a801      	add	r0, sp, #4
 800584e:	f7ff fddd 	bl	800540c <prvGetNextExpireTime>
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 8005852:	9901      	ldr	r1, [sp, #4]
 8005854:	f7ff ff38 	bl	80056c8 <prvProcessTimerOrBlockTask>
		prvProcessReceivedCommands();
 8005858:	f7ff ff70 	bl	800573c <prvProcessReceivedCommands>
	for( ;; )
 800585c:	e7f6      	b.n	800584c <prvTimerTask+0x4>
	...

08005860 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8005860:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8005862:	2300      	movs	r3, #0
 8005864:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8005866:	4b0d      	ldr	r3, [pc, #52]	@ (800589c <prvTaskExitError+0x3c>)
 8005868:	681b      	ldr	r3, [r3, #0]
 800586a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800586e:	d008      	beq.n	8005882 <prvTaskExitError+0x22>
 8005870:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005874:	f383 8811 	msr	BASEPRI, r3
 8005878:	f3bf 8f6f 	isb	sy
 800587c:	f3bf 8f4f 	dsb	sy
 8005880:	e7fe      	b.n	8005880 <prvTaskExitError+0x20>
 8005882:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005886:	f383 8811 	msr	BASEPRI, r3
 800588a:	f3bf 8f6f 	isb	sy
 800588e:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8005892:	9b01      	ldr	r3, [sp, #4]
 8005894:	2b00      	cmp	r3, #0
 8005896:	d0fc      	beq.n	8005892 <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8005898:	b002      	add	sp, #8
 800589a:	4770      	bx	lr
 800589c:	20000014 	.word	0x20000014

080058a0 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 80058a0:	4808      	ldr	r0, [pc, #32]	@ (80058c4 <prvPortStartFirstTask+0x24>)
 80058a2:	6800      	ldr	r0, [r0, #0]
 80058a4:	6800      	ldr	r0, [r0, #0]
 80058a6:	f380 8808 	msr	MSP, r0
 80058aa:	f04f 0000 	mov.w	r0, #0
 80058ae:	f380 8814 	msr	CONTROL, r0
 80058b2:	b662      	cpsie	i
 80058b4:	b661      	cpsie	f
 80058b6:	f3bf 8f4f 	dsb	sy
 80058ba:	f3bf 8f6f 	isb	sy
 80058be:	df00      	svc	0
 80058c0:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 80058c2:	0000      	.short	0x0000
 80058c4:	e000ed08 	.word	0xe000ed08

080058c8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80058c8:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 80058d8 <vPortEnableVFP+0x10>
 80058cc:	6801      	ldr	r1, [r0, #0]
 80058ce:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80058d2:	6001      	str	r1, [r0, #0]
 80058d4:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 80058d6:	0000      	.short	0x0000
 80058d8:	e000ed88 	.word	0xe000ed88

080058dc <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80058dc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 80058e0:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80058e4:	f021 0101 	bic.w	r1, r1, #1
 80058e8:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80058ec:	4b05      	ldr	r3, [pc, #20]	@ (8005904 <pxPortInitialiseStack+0x28>)
 80058ee:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80058f2:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80058f6:	f06f 0302 	mvn.w	r3, #2
 80058fa:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80058fe:	3844      	subs	r0, #68	@ 0x44
 8005900:	4770      	bx	lr
 8005902:	bf00      	nop
 8005904:	08005861 	.word	0x08005861
	...

08005910 <SVC_Handler>:
	__asm volatile (
 8005910:	4b07      	ldr	r3, [pc, #28]	@ (8005930 <pxCurrentTCBConst2>)
 8005912:	6819      	ldr	r1, [r3, #0]
 8005914:	6808      	ldr	r0, [r1, #0]
 8005916:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800591a:	f380 8809 	msr	PSP, r0
 800591e:	f3bf 8f6f 	isb	sy
 8005922:	f04f 0000 	mov.w	r0, #0
 8005926:	f380 8811 	msr	BASEPRI, r0
 800592a:	4770      	bx	lr
 800592c:	f3af 8000 	nop.w

08005930 <pxCurrentTCBConst2>:
 8005930:	20001948 	.word	0x20001948

08005934 <vPortEnterCritical>:
 8005934:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005938:	f383 8811 	msr	BASEPRI, r3
 800593c:	f3bf 8f6f 	isb	sy
 8005940:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8005944:	4a0b      	ldr	r2, [pc, #44]	@ (8005974 <vPortEnterCritical+0x40>)
 8005946:	6813      	ldr	r3, [r2, #0]
 8005948:	3301      	adds	r3, #1
 800594a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800594c:	2b01      	cmp	r3, #1
 800594e:	d000      	beq.n	8005952 <vPortEnterCritical+0x1e>
}
 8005950:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8005952:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8005956:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
 800595a:	f013 0fff 	tst.w	r3, #255	@ 0xff
 800595e:	d0f7      	beq.n	8005950 <vPortEnterCritical+0x1c>
 8005960:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005964:	f383 8811 	msr	BASEPRI, r3
 8005968:	f3bf 8f6f 	isb	sy
 800596c:	f3bf 8f4f 	dsb	sy
 8005970:	e7fe      	b.n	8005970 <vPortEnterCritical+0x3c>
 8005972:	bf00      	nop
 8005974:	20000014 	.word	0x20000014

08005978 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8005978:	4b09      	ldr	r3, [pc, #36]	@ (80059a0 <vPortExitCritical+0x28>)
 800597a:	681b      	ldr	r3, [r3, #0]
 800597c:	b943      	cbnz	r3, 8005990 <vPortExitCritical+0x18>
 800597e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005982:	f383 8811 	msr	BASEPRI, r3
 8005986:	f3bf 8f6f 	isb	sy
 800598a:	f3bf 8f4f 	dsb	sy
 800598e:	e7fe      	b.n	800598e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8005990:	3b01      	subs	r3, #1
 8005992:	4a03      	ldr	r2, [pc, #12]	@ (80059a0 <vPortExitCritical+0x28>)
 8005994:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8005996:	b90b      	cbnz	r3, 800599c <vPortExitCritical+0x24>
	__asm volatile
 8005998:	f383 8811 	msr	BASEPRI, r3
}
 800599c:	4770      	bx	lr
 800599e:	bf00      	nop
 80059a0:	20000014 	.word	0x20000014
	...

080059b0 <PendSV_Handler>:
	__asm volatile
 80059b0:	f3ef 8009 	mrs	r0, PSP
 80059b4:	f3bf 8f6f 	isb	sy
 80059b8:	4b15      	ldr	r3, [pc, #84]	@ (8005a10 <pxCurrentTCBConst>)
 80059ba:	681a      	ldr	r2, [r3, #0]
 80059bc:	f01e 0f10 	tst.w	lr, #16
 80059c0:	bf08      	it	eq
 80059c2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80059c6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80059ca:	6010      	str	r0, [r2, #0]
 80059cc:	e92d 0009 	stmdb	sp!, {r0, r3}
 80059d0:	f04f 0050 	mov.w	r0, #80	@ 0x50
 80059d4:	f380 8811 	msr	BASEPRI, r0
 80059d8:	f3bf 8f4f 	dsb	sy
 80059dc:	f3bf 8f6f 	isb	sy
 80059e0:	f7ff fa54 	bl	8004e8c <vTaskSwitchContext>
 80059e4:	f04f 0000 	mov.w	r0, #0
 80059e8:	f380 8811 	msr	BASEPRI, r0
 80059ec:	bc09      	pop	{r0, r3}
 80059ee:	6819      	ldr	r1, [r3, #0]
 80059f0:	6808      	ldr	r0, [r1, #0]
 80059f2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80059f6:	f01e 0f10 	tst.w	lr, #16
 80059fa:	bf08      	it	eq
 80059fc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8005a00:	f380 8809 	msr	PSP, r0
 8005a04:	f3bf 8f6f 	isb	sy
 8005a08:	4770      	bx	lr
 8005a0a:	bf00      	nop
 8005a0c:	f3af 8000 	nop.w

08005a10 <pxCurrentTCBConst>:
 8005a10:	20001948 	.word	0x20001948

08005a14 <xPortSysTickHandler>:
{
 8005a14:	b508      	push	{r3, lr}
	__asm volatile
 8005a16:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005a1a:	f383 8811 	msr	BASEPRI, r3
 8005a1e:	f3bf 8f6f 	isb	sy
 8005a22:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8005a26:	f7ff f903 	bl	8004c30 <xTaskIncrementTick>
 8005a2a:	b128      	cbz	r0, 8005a38 <xPortSysTickHandler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005a2c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8005a30:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8005a34:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 8005a38:	2300      	movs	r3, #0
 8005a3a:	f383 8811 	msr	BASEPRI, r3
}
 8005a3e:	bd08      	pop	{r3, pc}

08005a40 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8005a40:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 8005a44:	2300      	movs	r3, #0
 8005a46:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8005a48:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8005a4a:	4b05      	ldr	r3, [pc, #20]	@ (8005a60 <vPortSetupTimerInterrupt+0x20>)
 8005a4c:	681b      	ldr	r3, [r3, #0]
 8005a4e:	4905      	ldr	r1, [pc, #20]	@ (8005a64 <vPortSetupTimerInterrupt+0x24>)
 8005a50:	fba1 1303 	umull	r1, r3, r1, r3
 8005a54:	099b      	lsrs	r3, r3, #6
 8005a56:	3b01      	subs	r3, #1
 8005a58:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8005a5a:	2307      	movs	r3, #7
 8005a5c:	6113      	str	r3, [r2, #16]
}
 8005a5e:	4770      	bx	lr
 8005a60:	20000000 	.word	0x20000000
 8005a64:	10624dd3 	.word	0x10624dd3

08005a68 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8005a68:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8005a6c:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
 8005a70:	4b3d      	ldr	r3, [pc, #244]	@ (8005b68 <xPortStartScheduler+0x100>)
 8005a72:	429a      	cmp	r2, r3
 8005a74:	d01c      	beq.n	8005ab0 <xPortStartScheduler+0x48>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8005a76:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8005a7a:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
 8005a7e:	4b3b      	ldr	r3, [pc, #236]	@ (8005b6c <xPortStartScheduler+0x104>)
 8005a80:	429a      	cmp	r2, r3
 8005a82:	d01e      	beq.n	8005ac2 <xPortStartScheduler+0x5a>
{
 8005a84:	b530      	push	{r4, r5, lr}
 8005a86:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005a88:	4b39      	ldr	r3, [pc, #228]	@ (8005b70 <xPortStartScheduler+0x108>)
 8005a8a:	781a      	ldrb	r2, [r3, #0]
 8005a8c:	b2d2      	uxtb	r2, r2
 8005a8e:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8005a90:	22ff      	movs	r2, #255	@ 0xff
 8005a92:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8005a94:	781b      	ldrb	r3, [r3, #0]
 8005a96:	b2db      	uxtb	r3, r3
 8005a98:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005a9c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005aa0:	f003 0350 	and.w	r3, r3, #80	@ 0x50
 8005aa4:	4a33      	ldr	r2, [pc, #204]	@ (8005b74 <xPortStartScheduler+0x10c>)
 8005aa6:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005aa8:	4b33      	ldr	r3, [pc, #204]	@ (8005b78 <xPortStartScheduler+0x110>)
 8005aaa:	2207      	movs	r2, #7
 8005aac:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005aae:	e01b      	b.n	8005ae8 <xPortStartScheduler+0x80>
	__asm volatile
 8005ab0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005ab4:	f383 8811 	msr	BASEPRI, r3
 8005ab8:	f3bf 8f6f 	isb	sy
 8005abc:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8005ac0:	e7fe      	b.n	8005ac0 <xPortStartScheduler+0x58>
 8005ac2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005ac6:	f383 8811 	msr	BASEPRI, r3
 8005aca:	f3bf 8f6f 	isb	sy
 8005ace:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8005ad2:	e7fe      	b.n	8005ad2 <xPortStartScheduler+0x6a>
			ulMaxPRIGROUPValue--;
 8005ad4:	4a28      	ldr	r2, [pc, #160]	@ (8005b78 <xPortStartScheduler+0x110>)
 8005ad6:	6813      	ldr	r3, [r2, #0]
 8005ad8:	3b01      	subs	r3, #1
 8005ada:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8005adc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005ae0:	005b      	lsls	r3, r3, #1
 8005ae2:	b2db      	uxtb	r3, r3
 8005ae4:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005ae8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005aec:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8005af0:	d1f0      	bne.n	8005ad4 <xPortStartScheduler+0x6c>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8005af2:	4b21      	ldr	r3, [pc, #132]	@ (8005b78 <xPortStartScheduler+0x110>)
 8005af4:	681b      	ldr	r3, [r3, #0]
 8005af6:	2b03      	cmp	r3, #3
 8005af8:	d008      	beq.n	8005b0c <xPortStartScheduler+0xa4>
 8005afa:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005afe:	f383 8811 	msr	BASEPRI, r3
 8005b02:	f3bf 8f6f 	isb	sy
 8005b06:	f3bf 8f4f 	dsb	sy
 8005b0a:	e7fe      	b.n	8005b0a <xPortStartScheduler+0xa2>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8005b0c:	021b      	lsls	r3, r3, #8
 8005b0e:	4a1a      	ldr	r2, [pc, #104]	@ (8005b78 <xPortStartScheduler+0x110>)
 8005b10:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8005b12:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8005b16:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8005b18:	9b01      	ldr	r3, [sp, #4]
 8005b1a:	b2db      	uxtb	r3, r3
 8005b1c:	4a14      	ldr	r2, [pc, #80]	@ (8005b70 <xPortStartScheduler+0x108>)
 8005b1e:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005b20:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
 8005b24:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8005b28:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8005b2c:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8005b30:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 8005b34:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 8005b38:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	vPortSetupTimerInterrupt();
 8005b3c:	f7ff ff80 	bl	8005a40 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8005b40:	2500      	movs	r5, #0
 8005b42:	4b0e      	ldr	r3, [pc, #56]	@ (8005b7c <xPortStartScheduler+0x114>)
 8005b44:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
 8005b46:	f7ff febf 	bl	80058c8 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8005b4a:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	@ 0xf34
 8005b4e:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 8005b52:	f8c4 3f34 	str.w	r3, [r4, #3892]	@ 0xf34
	prvPortStartFirstTask();
 8005b56:	f7ff fea3 	bl	80058a0 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8005b5a:	f7ff f997 	bl	8004e8c <vTaskSwitchContext>
	prvTaskExitError();
 8005b5e:	f7ff fe7f 	bl	8005860 <prvTaskExitError>
}
 8005b62:	4628      	mov	r0, r5
 8005b64:	b003      	add	sp, #12
 8005b66:	bd30      	pop	{r4, r5, pc}
 8005b68:	410fc271 	.word	0x410fc271
 8005b6c:	410fc270 	.word	0x410fc270
 8005b70:	e000e400 	.word	0xe000e400
 8005b74:	20001a7c 	.word	0x20001a7c
 8005b78:	20001a78 	.word	0x20001a78
 8005b7c:	20000014 	.word	0x20000014

08005b80 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8005b80:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8005b84:	2b0f      	cmp	r3, #15
 8005b86:	d90f      	bls.n	8005ba8 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8005b88:	4a11      	ldr	r2, [pc, #68]	@ (8005bd0 <vPortValidateInterruptPriority+0x50>)
 8005b8a:	5c9b      	ldrb	r3, [r3, r2]
 8005b8c:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8005b8e:	4a11      	ldr	r2, [pc, #68]	@ (8005bd4 <vPortValidateInterruptPriority+0x54>)
 8005b90:	7812      	ldrb	r2, [r2, #0]
 8005b92:	429a      	cmp	r2, r3
 8005b94:	d908      	bls.n	8005ba8 <vPortValidateInterruptPriority+0x28>
 8005b96:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005b9a:	f383 8811 	msr	BASEPRI, r3
 8005b9e:	f3bf 8f6f 	isb	sy
 8005ba2:	f3bf 8f4f 	dsb	sy
 8005ba6:	e7fe      	b.n	8005ba6 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8005ba8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8005bac:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
 8005bb0:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8005bb4:	4a08      	ldr	r2, [pc, #32]	@ (8005bd8 <vPortValidateInterruptPriority+0x58>)
 8005bb6:	6812      	ldr	r2, [r2, #0]
 8005bb8:	4293      	cmp	r3, r2
 8005bba:	d908      	bls.n	8005bce <vPortValidateInterruptPriority+0x4e>
 8005bbc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005bc0:	f383 8811 	msr	BASEPRI, r3
 8005bc4:	f3bf 8f6f 	isb	sy
 8005bc8:	f3bf 8f4f 	dsb	sy
 8005bcc:	e7fe      	b.n	8005bcc <vPortValidateInterruptPriority+0x4c>
	}
 8005bce:	4770      	bx	lr
 8005bd0:	e000e3f0 	.word	0xe000e3f0
 8005bd4:	20001a7c 	.word	0x20001a7c
 8005bd8:	20001a78 	.word	0x20001a78

08005bdc <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8005bdc:	4a12      	ldr	r2, [pc, #72]	@ (8005c28 <prvHeapInit+0x4c>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005bde:	f012 0f07 	tst.w	r2, #7
 8005be2:	d01e      	beq.n	8005c22 <prvHeapInit+0x46>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8005be4:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005be6:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8005bea:	f5c1 3380 	rsb	r3, r1, #65536	@ 0x10000
 8005bee:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005bf0:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005bf2:	480e      	ldr	r0, [pc, #56]	@ (8005c2c <prvHeapInit+0x50>)
 8005bf4:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8005bf6:	2100      	movs	r1, #0
 8005bf8:	6041      	str	r1, [r0, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8005bfa:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8005bfc:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005bfe:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 8005c02:	480b      	ldr	r0, [pc, #44]	@ (8005c30 <prvHeapInit+0x54>)
 8005c04:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
 8005c06:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8005c08:	6019      	str	r1, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005c0a:	1a99      	subs	r1, r3, r2
 8005c0c:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005c0e:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005c10:	4b08      	ldr	r3, [pc, #32]	@ (8005c34 <prvHeapInit+0x58>)
 8005c12:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005c14:	4b08      	ldr	r3, [pc, #32]	@ (8005c38 <prvHeapInit+0x5c>)
 8005c16:	6019      	str	r1, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005c18:	4b08      	ldr	r3, [pc, #32]	@ (8005c3c <prvHeapInit+0x60>)
 8005c1a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 8005c1e:	601a      	str	r2, [r3, #0]
}
 8005c20:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8005c22:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8005c26:	e7e4      	b.n	8005bf2 <prvHeapInit+0x16>
 8005c28:	20001aa0 	.word	0x20001aa0
 8005c2c:	20001a98 	.word	0x20001a98
 8005c30:	20001a94 	.word	0x20001a94
 8005c34:	20001a8c 	.word	0x20001a8c
 8005c38:	20001a90 	.word	0x20001a90
 8005c3c:	20001a80 	.word	0x20001a80

08005c40 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8005c40:	4b16      	ldr	r3, [pc, #88]	@ (8005c9c <prvInsertBlockIntoFreeList+0x5c>)
 8005c42:	461a      	mov	r2, r3
 8005c44:	681b      	ldr	r3, [r3, #0]
 8005c46:	4283      	cmp	r3, r0
 8005c48:	d3fb      	bcc.n	8005c42 <prvInsertBlockIntoFreeList+0x2>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8005c4a:	6851      	ldr	r1, [r2, #4]
 8005c4c:	eb02 0c01 	add.w	ip, r2, r1
 8005c50:	4584      	cmp	ip, r0
 8005c52:	d009      	beq.n	8005c68 <prvInsertBlockIntoFreeList+0x28>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8005c54:	6841      	ldr	r1, [r0, #4]
 8005c56:	eb00 0c01 	add.w	ip, r0, r1
 8005c5a:	4563      	cmp	r3, ip
 8005c5c:	d009      	beq.n	8005c72 <prvInsertBlockIntoFreeList+0x32>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8005c5e:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8005c60:	4290      	cmp	r0, r2
 8005c62:	d019      	beq.n	8005c98 <prvInsertBlockIntoFreeList+0x58>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8005c64:	6010      	str	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
 8005c66:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8005c68:	6840      	ldr	r0, [r0, #4]
 8005c6a:	4401      	add	r1, r0
 8005c6c:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
 8005c6e:	4610      	mov	r0, r2
 8005c70:	e7f0      	b.n	8005c54 <prvInsertBlockIntoFreeList+0x14>
{
 8005c72:	b410      	push	{r4}
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8005c74:	4c0a      	ldr	r4, [pc, #40]	@ (8005ca0 <prvInsertBlockIntoFreeList+0x60>)
 8005c76:	6824      	ldr	r4, [r4, #0]
 8005c78:	42a3      	cmp	r3, r4
 8005c7a:	d00b      	beq.n	8005c94 <prvInsertBlockIntoFreeList+0x54>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005c7c:	685b      	ldr	r3, [r3, #4]
 8005c7e:	4419      	add	r1, r3
 8005c80:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8005c82:	6813      	ldr	r3, [r2, #0]
 8005c84:	681b      	ldr	r3, [r3, #0]
 8005c86:	6003      	str	r3, [r0, #0]
	if( pxIterator != pxBlockToInsert )
 8005c88:	4290      	cmp	r0, r2
 8005c8a:	d000      	beq.n	8005c8e <prvInsertBlockIntoFreeList+0x4e>
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8005c8c:	6010      	str	r0, [r2, #0]
	}
}
 8005c8e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005c92:	4770      	bx	lr
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8005c94:	6004      	str	r4, [r0, #0]
 8005c96:	e7f7      	b.n	8005c88 <prvInsertBlockIntoFreeList+0x48>
 8005c98:	4770      	bx	lr
 8005c9a:	bf00      	nop
 8005c9c:	20001a98 	.word	0x20001a98
 8005ca0:	20001a94 	.word	0x20001a94

08005ca4 <pvPortMalloc>:
{
 8005ca4:	b538      	push	{r3, r4, r5, lr}
 8005ca6:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8005ca8:	f7fe ffb4 	bl	8004c14 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8005cac:	4b38      	ldr	r3, [pc, #224]	@ (8005d90 <pvPortMalloc+0xec>)
 8005cae:	681b      	ldr	r3, [r3, #0]
 8005cb0:	b1b3      	cbz	r3, 8005ce0 <pvPortMalloc+0x3c>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8005cb2:	4b38      	ldr	r3, [pc, #224]	@ (8005d94 <pvPortMalloc+0xf0>)
 8005cb4:	681b      	ldr	r3, [r3, #0]
 8005cb6:	421c      	tst	r4, r3
 8005cb8:	d150      	bne.n	8005d5c <pvPortMalloc+0xb8>
			if( xWantedSize > 0 )
 8005cba:	2c00      	cmp	r4, #0
 8005cbc:	d050      	beq.n	8005d60 <pvPortMalloc+0xbc>
				xWantedSize += xHeapStructSize;
 8005cbe:	f104 0208 	add.w	r2, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8005cc2:	f014 0f07 	tst.w	r4, #7
 8005cc6:	d002      	beq.n	8005cce <pvPortMalloc+0x2a>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005cc8:	f022 0207 	bic.w	r2, r2, #7
 8005ccc:	3208      	adds	r2, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8005cce:	2a00      	cmp	r2, #0
 8005cd0:	d055      	beq.n	8005d7e <pvPortMalloc+0xda>
 8005cd2:	4b31      	ldr	r3, [pc, #196]	@ (8005d98 <pvPortMalloc+0xf4>)
 8005cd4:	681b      	ldr	r3, [r3, #0]
 8005cd6:	4293      	cmp	r3, r2
 8005cd8:	d353      	bcc.n	8005d82 <pvPortMalloc+0xde>
				pxBlock = xStart.pxNextFreeBlock;
 8005cda:	4930      	ldr	r1, [pc, #192]	@ (8005d9c <pvPortMalloc+0xf8>)
 8005cdc:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005cde:	e004      	b.n	8005cea <pvPortMalloc+0x46>
			prvHeapInit();
 8005ce0:	f7ff ff7c 	bl	8005bdc <prvHeapInit>
 8005ce4:	e7e5      	b.n	8005cb2 <pvPortMalloc+0xe>
					pxPreviousBlock = pxBlock;
 8005ce6:	4621      	mov	r1, r4
					pxBlock = pxBlock->pxNextFreeBlock;
 8005ce8:	461c      	mov	r4, r3
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005cea:	6863      	ldr	r3, [r4, #4]
 8005cec:	4293      	cmp	r3, r2
 8005cee:	d202      	bcs.n	8005cf6 <pvPortMalloc+0x52>
 8005cf0:	6823      	ldr	r3, [r4, #0]
 8005cf2:	2b00      	cmp	r3, #0
 8005cf4:	d1f7      	bne.n	8005ce6 <pvPortMalloc+0x42>
				if( pxBlock != pxEnd )
 8005cf6:	4b26      	ldr	r3, [pc, #152]	@ (8005d90 <pvPortMalloc+0xec>)
 8005cf8:	681b      	ldr	r3, [r3, #0]
 8005cfa:	42a3      	cmp	r3, r4
 8005cfc:	d043      	beq.n	8005d86 <pvPortMalloc+0xe2>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8005cfe:	680d      	ldr	r5, [r1, #0]
 8005d00:	3508      	adds	r5, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8005d02:	6823      	ldr	r3, [r4, #0]
 8005d04:	600b      	str	r3, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8005d06:	6863      	ldr	r3, [r4, #4]
 8005d08:	1a9b      	subs	r3, r3, r2
 8005d0a:	2b10      	cmp	r3, #16
 8005d0c:	d910      	bls.n	8005d30 <pvPortMalloc+0x8c>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8005d0e:	18a0      	adds	r0, r4, r2
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8005d10:	f010 0f07 	tst.w	r0, #7
 8005d14:	d008      	beq.n	8005d28 <pvPortMalloc+0x84>
 8005d16:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005d1a:	f383 8811 	msr	BASEPRI, r3
 8005d1e:	f3bf 8f6f 	isb	sy
 8005d22:	f3bf 8f4f 	dsb	sy
 8005d26:	e7fe      	b.n	8005d26 <pvPortMalloc+0x82>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8005d28:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8005d2a:	6062      	str	r2, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8005d2c:	f7ff ff88 	bl	8005c40 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005d30:	6862      	ldr	r2, [r4, #4]
 8005d32:	4919      	ldr	r1, [pc, #100]	@ (8005d98 <pvPortMalloc+0xf4>)
 8005d34:	680b      	ldr	r3, [r1, #0]
 8005d36:	1a9b      	subs	r3, r3, r2
 8005d38:	600b      	str	r3, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005d3a:	4919      	ldr	r1, [pc, #100]	@ (8005da0 <pvPortMalloc+0xfc>)
 8005d3c:	6809      	ldr	r1, [r1, #0]
 8005d3e:	428b      	cmp	r3, r1
 8005d40:	d201      	bcs.n	8005d46 <pvPortMalloc+0xa2>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8005d42:	4917      	ldr	r1, [pc, #92]	@ (8005da0 <pvPortMalloc+0xfc>)
 8005d44:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8005d46:	4b13      	ldr	r3, [pc, #76]	@ (8005d94 <pvPortMalloc+0xf0>)
 8005d48:	681b      	ldr	r3, [r3, #0]
 8005d4a:	4313      	orrs	r3, r2
 8005d4c:	6063      	str	r3, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8005d4e:	2300      	movs	r3, #0
 8005d50:	6023      	str	r3, [r4, #0]
					xNumberOfSuccessfulAllocations++;
 8005d52:	4a14      	ldr	r2, [pc, #80]	@ (8005da4 <pvPortMalloc+0x100>)
 8005d54:	6813      	ldr	r3, [r2, #0]
 8005d56:	3301      	adds	r3, #1
 8005d58:	6013      	str	r3, [r2, #0]
 8005d5a:	e002      	b.n	8005d62 <pvPortMalloc+0xbe>
void *pvReturn = NULL;
 8005d5c:	2500      	movs	r5, #0
 8005d5e:	e000      	b.n	8005d62 <pvPortMalloc+0xbe>
 8005d60:	2500      	movs	r5, #0
	( void ) xTaskResumeAll();
 8005d62:	f7fe fff1 	bl	8004d48 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8005d66:	f015 0f07 	tst.w	r5, #7
 8005d6a:	d00e      	beq.n	8005d8a <pvPortMalloc+0xe6>
 8005d6c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005d70:	f383 8811 	msr	BASEPRI, r3
 8005d74:	f3bf 8f6f 	isb	sy
 8005d78:	f3bf 8f4f 	dsb	sy
 8005d7c:	e7fe      	b.n	8005d7c <pvPortMalloc+0xd8>
void *pvReturn = NULL;
 8005d7e:	2500      	movs	r5, #0
 8005d80:	e7ef      	b.n	8005d62 <pvPortMalloc+0xbe>
 8005d82:	2500      	movs	r5, #0
 8005d84:	e7ed      	b.n	8005d62 <pvPortMalloc+0xbe>
 8005d86:	2500      	movs	r5, #0
 8005d88:	e7eb      	b.n	8005d62 <pvPortMalloc+0xbe>
}
 8005d8a:	4628      	mov	r0, r5
 8005d8c:	bd38      	pop	{r3, r4, r5, pc}
 8005d8e:	bf00      	nop
 8005d90:	20001a94 	.word	0x20001a94
 8005d94:	20001a80 	.word	0x20001a80
 8005d98:	20001a90 	.word	0x20001a90
 8005d9c:	20001a98 	.word	0x20001a98
 8005da0:	20001a8c 	.word	0x20001a8c
 8005da4:	20001a88 	.word	0x20001a88

08005da8 <vPortFree>:
	if( pv != NULL )
 8005da8:	2800      	cmp	r0, #0
 8005daa:	d034      	beq.n	8005e16 <vPortFree+0x6e>
{
 8005dac:	b538      	push	{r3, r4, r5, lr}
 8005dae:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 8005db0:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005db4:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8005db8:	4a17      	ldr	r2, [pc, #92]	@ (8005e18 <vPortFree+0x70>)
 8005dba:	6812      	ldr	r2, [r2, #0]
 8005dbc:	4213      	tst	r3, r2
 8005dbe:	d108      	bne.n	8005dd2 <vPortFree+0x2a>
 8005dc0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005dc4:	f383 8811 	msr	BASEPRI, r3
 8005dc8:	f3bf 8f6f 	isb	sy
 8005dcc:	f3bf 8f4f 	dsb	sy
 8005dd0:	e7fe      	b.n	8005dd0 <vPortFree+0x28>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8005dd2:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8005dd6:	b141      	cbz	r1, 8005dea <vPortFree+0x42>
 8005dd8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8005ddc:	f383 8811 	msr	BASEPRI, r3
 8005de0:	f3bf 8f6f 	isb	sy
 8005de4:	f3bf 8f4f 	dsb	sy
 8005de8:	e7fe      	b.n	8005de8 <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8005dea:	ea23 0302 	bic.w	r3, r3, r2
 8005dee:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8005df2:	f7fe ff0f 	bl	8004c14 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8005df6:	f854 1c04 	ldr.w	r1, [r4, #-4]
 8005dfa:	4a08      	ldr	r2, [pc, #32]	@ (8005e1c <vPortFree+0x74>)
 8005dfc:	6813      	ldr	r3, [r2, #0]
 8005dfe:	440b      	add	r3, r1
 8005e00:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005e02:	4628      	mov	r0, r5
 8005e04:	f7ff ff1c 	bl	8005c40 <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
 8005e08:	4a05      	ldr	r2, [pc, #20]	@ (8005e20 <vPortFree+0x78>)
 8005e0a:	6813      	ldr	r3, [r2, #0]
 8005e0c:	3301      	adds	r3, #1
 8005e0e:	6013      	str	r3, [r2, #0]
				( void ) xTaskResumeAll();
 8005e10:	f7fe ff9a 	bl	8004d48 <xTaskResumeAll>
}
 8005e14:	bd38      	pop	{r3, r4, r5, pc}
 8005e16:	4770      	bx	lr
 8005e18:	20001a80 	.word	0x20001a80
 8005e1c:	20001a90 	.word	0x20001a90
 8005e20:	20001a84 	.word	0x20001a84

08005e24 <prvFindCacheEntry>:
 */
static BaseType_t prvFindCacheEntry( const MACAddress_t * pxMACAddress,
                                     const uint32_t ulIPAddress,
                                     struct xNetworkEndPoint * pxEndPoint,
                                     CacheLocation_t * pxLocation )
{
 8005e24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005e28:	4605      	mov	r5, r0
 8005e2a:	460f      	mov	r7, r1
 8005e2c:	4691      	mov	r9, r2
 8005e2e:	461e      	mov	r6, r3
    #endif

    /* Start with the maximum possible number. */
    ucMinAgeFound--;

    pxLocation->xIpEntry = -1;
 8005e30:	f04f 33ff 	mov.w	r3, #4294967295
 8005e34:	6033      	str	r3, [r6, #0]
    pxLocation->xMacEntry = -1;
 8005e36:	6073      	str	r3, [r6, #4]
    pxLocation->xUseEntry = 0;
 8005e38:	2400      	movs	r4, #0
 8005e3a:	60b4      	str	r4, [r6, #8]
    ucMinAgeFound--;
 8005e3c:	f04f 08ff 	mov.w	r8, #255	@ 0xff

    /* For each entry in the ARP cache table. */
    for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005e40:	e010      	b.n	8005e64 <prvFindCacheEntry+0x40>
    {
        BaseType_t xMatchingMAC = pdFALSE;

        if( pxMACAddress != NULL )
        {
            if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 8005e42:	481c      	ldr	r0, [pc, #112]	@ (8005eb4 <prvFindCacheEntry+0x90>)
 8005e44:	eb00 1004 	add.w	r0, r0, r4, lsl #4
 8005e48:	2206      	movs	r2, #6
 8005e4a:	4629      	mov	r1, r5
 8005e4c:	3004      	adds	r0, #4
 8005e4e:	f008 ff07 	bl	800ec60 <memcmp>
 8005e52:	b108      	cbz	r0, 8005e58 <prvFindCacheEntry+0x34>
        BaseType_t xMatchingMAC = pdFALSE;
 8005e54:	2000      	movs	r0, #0
 8005e56:	e00a      	b.n	8005e6e <prvFindCacheEntry+0x4a>
            {
                xMatchingMAC = pdTRUE;
 8005e58:	2001      	movs	r0, #1
 8005e5a:	e008      	b.n	8005e6e <prvFindCacheEntry+0x4a>

        /* Does this line in the cache table hold an entry for the IP
         * address being queried? */
        if( xARPCache[ x ].ulIPAddress == ulIPAddress )
        {
            if( pxMACAddress == NULL )
 8005e5c:	b18d      	cbz	r5, 8005e82 <prvFindCacheEntry+0x5e>
                pxLocation->xIpEntry = x;
                break;
            }

            /* See if the MAC-address also matches. */
            if( xMatchingMAC != pdFALSE )
 8005e5e:	b998      	cbnz	r0, 8005e88 <prvFindCacheEntry+0x64>
            /* Found an entry containing ulIPAddress, but the MAC address
             * doesn't match.  Might be an entry with ucValid=pdFALSE, waiting
             * for an ARP reply.  Still want to see if there is match with the
             * given MAC address.ucBytes.  If found, either of the two entries
             * must be cleared. */
            pxLocation->xIpEntry = x;
 8005e60:	6034      	str	r4, [r6, #0]
    for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005e62:	3401      	adds	r4, #1
 8005e64:	2c05      	cmp	r4, #5
 8005e66:	dc22      	bgt.n	8005eae <prvFindCacheEntry+0x8a>
        if( pxMACAddress != NULL )
 8005e68:	2d00      	cmp	r5, #0
 8005e6a:	d1ea      	bne.n	8005e42 <prvFindCacheEntry+0x1e>
        BaseType_t xMatchingMAC = pdFALSE;
 8005e6c:	2000      	movs	r0, #0
        if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 8005e6e:	ea4f 1c04 	mov.w	ip, r4, lsl #4
 8005e72:	4b10      	ldr	r3, [pc, #64]	@ (8005eb4 <prvFindCacheEntry+0x90>)
 8005e74:	f853 300c 	ldr.w	r3, [r3, ip]
 8005e78:	42bb      	cmp	r3, r7
 8005e7a:	d0ef      	beq.n	8005e5c <prvFindCacheEntry+0x38>
        }
        else if( xMatchingMAC != pdFALSE )
 8005e7c:	b170      	cbz	r0, 8005e9c <prvFindCacheEntry+0x78>
                    pxLocation->xMacEntry = x;
                }
            }
            #else /* if ( ipconfigARP_STORES_REMOTE_ADDRESSES != 0 ) */
            {
                pxLocation->xMacEntry = x;
 8005e7e:	6074      	str	r4, [r6, #4]
 8005e80:	e7ef      	b.n	8005e62 <prvFindCacheEntry+0x3e>
                pxLocation->xIpEntry = x;
 8005e82:	6034      	str	r4, [r6, #0]
    BaseType_t xReturn = pdFALSE;
 8005e84:	2000      	movs	r0, #0
                break;
 8005e86:	e013      	b.n	8005eb0 <prvFindCacheEntry+0x8c>
                xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 8005e88:	4b0a      	ldr	r3, [pc, #40]	@ (8005eb4 <prvFindCacheEntry+0x90>)
 8005e8a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 8005e8e:	2296      	movs	r2, #150	@ 0x96
 8005e90:	729a      	strb	r2, [r3, #10]
                xARPCache[ x ].ucValid = ( uint8_t ) pdTRUE;
 8005e92:	2201      	movs	r2, #1
 8005e94:	72da      	strb	r2, [r3, #11]
                xARPCache[ x ].pxEndPoint = pxEndPoint;
 8005e96:	f8c3 900c 	str.w	r9, [r3, #12]
                break;
 8005e9a:	e009      	b.n	8005eb0 <prvFindCacheEntry+0x8c>
            #endif /* if ( ipconfigARP_STORES_REMOTE_ADDRESSES != 0 ) */
        }

        /* _HT_
         * Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
        else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8005e9c:	4b05      	ldr	r3, [pc, #20]	@ (8005eb4 <prvFindCacheEntry+0x90>)
 8005e9e:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 8005ea2:	7a9b      	ldrb	r3, [r3, #10]
 8005ea4:	4543      	cmp	r3, r8
 8005ea6:	d2dc      	bcs.n	8005e62 <prvFindCacheEntry+0x3e>
            /* As the table is traversed, remember the table row that
             * contains the oldest entry (the lowest age count, as ages are
             * decremented to zero) so the row can be re-used if this function
             * needs to add an entry that does not already exist. */
            ucMinAgeFound = xARPCache[ x ].ucAge;
            pxLocation->xUseEntry = x;
 8005ea8:	60b4      	str	r4, [r6, #8]
            ucMinAgeFound = xARPCache[ x ].ucAge;
 8005eaa:	4698      	mov	r8, r3
 8005eac:	e7d9      	b.n	8005e62 <prvFindCacheEntry+0x3e>
    BaseType_t xReturn = pdFALSE;
 8005eae:	2000      	movs	r0, #0
            /* Nothing happens to this cache entry for now. */
        }
    } /* for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ ) */

    return xReturn;
}
 8005eb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005eb4:	20011ab0 	.word	0x20011ab0

08005eb8 <prvCacheLookup>:
    {
        BaseType_t x;
        eARPLookupResult_t eReturn = eARPCacheMiss;

        /* Loop through each entry in the ARP cache. */
        for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005eb8:	2300      	movs	r3, #0
 8005eba:	2b05      	cmp	r3, #5
 8005ebc:	dc20      	bgt.n	8005f00 <prvCacheLookup+0x48>
    {
 8005ebe:	b410      	push	{r4}
        {
            /* Does this row in the ARP cache table hold an entry for the IP address
             * being queried? */
            if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 8005ec0:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 8005ec4:	4c0f      	ldr	r4, [pc, #60]	@ (8005f04 <prvCacheLookup+0x4c>)
 8005ec6:	f854 400c 	ldr.w	r4, [r4, ip]
 8005eca:	4284      	cmp	r4, r0
 8005ecc:	d006      	beq.n	8005edc <prvCacheLookup+0x24>
        for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005ece:	3301      	adds	r3, #1
 8005ed0:	2b05      	cmp	r3, #5
 8005ed2:	ddf5      	ble.n	8005ec0 <prvCacheLookup+0x8>
        eARPLookupResult_t eReturn = eARPCacheMiss;
 8005ed4:	2000      	movs	r0, #0
                break;
            }
        }

        return eReturn;
    }
 8005ed6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005eda:	4770      	bx	lr
                if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8005edc:	4809      	ldr	r0, [pc, #36]	@ (8005f04 <prvCacheLookup+0x4c>)
 8005ede:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 8005ee2:	7ac0      	ldrb	r0, [r0, #11]
 8005ee4:	b908      	cbnz	r0, 8005eea <prvCacheLookup+0x32>
                    eReturn = eCantSendPacket;
 8005ee6:	2002      	movs	r0, #2
 8005ee8:	e7f5      	b.n	8005ed6 <prvCacheLookup+0x1e>
                    ( void ) memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 8005eea:	4806      	ldr	r0, [pc, #24]	@ (8005f04 <prvCacheLookup+0x4c>)
 8005eec:	eb00 1303 	add.w	r3, r0, r3, lsl #4
 8005ef0:	6858      	ldr	r0, [r3, #4]
 8005ef2:	6008      	str	r0, [r1, #0]
 8005ef4:	8918      	ldrh	r0, [r3, #8]
 8005ef6:	8088      	strh	r0, [r1, #4]
                    *( ppxEndPoint ) = xARPCache[ x ].pxEndPoint;
 8005ef8:	68db      	ldr	r3, [r3, #12]
 8005efa:	6013      	str	r3, [r2, #0]
                    eReturn = eARPCacheHit;
 8005efc:	2001      	movs	r0, #1
 8005efe:	e7ea      	b.n	8005ed6 <prvCacheLookup+0x1e>
        eARPLookupResult_t eReturn = eARPCacheMiss;
 8005f00:	2000      	movs	r0, #0
    }
 8005f02:	4770      	bx	lr
 8005f04:	20011ab0 	.word	0x20011ab0

08005f08 <eARPGetCacheEntryGateWay>:
    {
 8005f08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005f0a:	4604      	mov	r4, r0
 8005f0c:	460f      	mov	r7, r1
 8005f0e:	4615      	mov	r5, r2
        pxEndPoint = FreeRTOS_FindEndPointOnNetMask( ulAddressToLookup, 4 );
 8005f10:	2104      	movs	r1, #4
 8005f12:	6800      	ldr	r0, [r0, #0]
 8005f14:	f003 fe22 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
        if( pxEndPoint == NULL )
 8005f18:	b120      	cbz	r0, 8005f24 <eARPGetCacheEntryGateWay+0x1c>
            ulAddressToLookup = *pulIPAddress;
 8005f1a:	6826      	ldr	r6, [r4, #0]
            *ppxEndPoint = pxEndPoint;
 8005f1c:	6028      	str	r0, [r5, #0]
            if( ulAddressToLookup == 0U )
 8005f1e:	b946      	cbnz	r6, 8005f32 <eARPGetCacheEntryGateWay+0x2a>
                eReturn = eCantSendPacket;
 8005f20:	2002      	movs	r0, #2
    }
 8005f22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                *( ppxEndPoint ) = FreeRTOS_FindGateWay( ( BaseType_t ) ipTYPE_IPv4 );
 8005f24:	2040      	movs	r0, #64	@ 0x40
 8005f26:	f003 fe49 	bl	8009bbc <FreeRTOS_FindGateWay>
 8005f2a:	6028      	str	r0, [r5, #0]
                if( *( ppxEndPoint ) != NULL )
 8005f2c:	b140      	cbz	r0, 8005f40 <eARPGetCacheEntryGateWay+0x38>
                    ulAddressToLookup = ( *ppxEndPoint )->ipv4_settings.ulGatewayAddress;
 8005f2e:	6886      	ldr	r6, [r0, #8]
 8005f30:	e7f5      	b.n	8005f1e <eARPGetCacheEntryGateWay+0x16>
                eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress, ppxEndPoint );
 8005f32:	462a      	mov	r2, r5
 8005f34:	4639      	mov	r1, r7
 8005f36:	4630      	mov	r0, r6
 8005f38:	f7ff ffbe 	bl	8005eb8 <prvCacheLookup>
                *pulIPAddress = ulAddressToLookup;
 8005f3c:	6026      	str	r6, [r4, #0]
 8005f3e:	e7f0      	b.n	8005f22 <eARPGetCacheEntryGateWay+0x1a>
                eReturn = eCantSendPacket;
 8005f40:	2002      	movs	r0, #2
 8005f42:	e7ee      	b.n	8005f22 <eARPGetCacheEntryGateWay+0x1a>

08005f44 <xIsIPInARPCache>:
    for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005f44:	2300      	movs	r3, #0
 8005f46:	2b05      	cmp	r3, #5
 8005f48:	dc0c      	bgt.n	8005f64 <xIsIPInARPCache+0x20>
        if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 8005f4a:	011a      	lsls	r2, r3, #4
 8005f4c:	4907      	ldr	r1, [pc, #28]	@ (8005f6c <xIsIPInARPCache+0x28>)
 8005f4e:	588a      	ldr	r2, [r1, r2]
 8005f50:	4282      	cmp	r2, r0
 8005f52:	d001      	beq.n	8005f58 <xIsIPInARPCache+0x14>
    for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005f54:	3301      	adds	r3, #1
 8005f56:	e7f6      	b.n	8005f46 <xIsIPInARPCache+0x2>
            if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8005f58:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 8005f5c:	7adb      	ldrb	r3, [r3, #11]
 8005f5e:	b11b      	cbz	r3, 8005f68 <xIsIPInARPCache+0x24>
            xReturn = pdTRUE;
 8005f60:	2001      	movs	r0, #1
 8005f62:	4770      	bx	lr
    BaseType_t x, xReturn = pdFALSE;
 8005f64:	2000      	movs	r0, #0
 8005f66:	4770      	bx	lr
                xReturn = pdFALSE;
 8005f68:	2000      	movs	r0, #0
}
 8005f6a:	4770      	bx	lr
 8005f6c:	20011ab0 	.word	0x20011ab0

08005f70 <vARPRefreshCacheEntryAge>:
    if( pxMACAddress != NULL )
 8005f70:	b120      	cbz	r0, 8005f7c <vARPRefreshCacheEntryAge+0xc>
{
 8005f72:	b570      	push	{r4, r5, r6, lr}
 8005f74:	460d      	mov	r5, r1
 8005f76:	4606      	mov	r6, r0
        for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8005f78:	2400      	movs	r4, #0
 8005f7a:	e001      	b.n	8005f80 <vARPRefreshCacheEntryAge+0x10>
 8005f7c:	4770      	bx	lr
 8005f7e:	3401      	adds	r4, #1
 8005f80:	2c05      	cmp	r4, #5
 8005f82:	dc12      	bgt.n	8005faa <vARPRefreshCacheEntryAge+0x3a>
            if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 8005f84:	0123      	lsls	r3, r4, #4
 8005f86:	4a09      	ldr	r2, [pc, #36]	@ (8005fac <vARPRefreshCacheEntryAge+0x3c>)
 8005f88:	58d3      	ldr	r3, [r2, r3]
 8005f8a:	42ab      	cmp	r3, r5
 8005f8c:	d1f7      	bne.n	8005f7e <vARPRefreshCacheEntryAge+0xe>
                if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 8005f8e:	eb02 1004 	add.w	r0, r2, r4, lsl #4
 8005f92:	2206      	movs	r2, #6
 8005f94:	4631      	mov	r1, r6
 8005f96:	3004      	adds	r0, #4
 8005f98:	f008 fe62 	bl	800ec60 <memcmp>
 8005f9c:	2800      	cmp	r0, #0
 8005f9e:	d1ee      	bne.n	8005f7e <vARPRefreshCacheEntryAge+0xe>
                    xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 8005fa0:	4b02      	ldr	r3, [pc, #8]	@ (8005fac <vARPRefreshCacheEntryAge+0x3c>)
 8005fa2:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 8005fa6:	2296      	movs	r2, #150	@ 0x96
 8005fa8:	729a      	strb	r2, [r3, #10]
}
 8005faa:	bd70      	pop	{r4, r5, r6, pc}
 8005fac:	20011ab0 	.word	0x20011ab0

08005fb0 <vARPRefreshCacheEntry>:
{
 8005fb0:	b570      	push	{r4, r5, r6, lr}
 8005fb2:	b084      	sub	sp, #16
 8005fb4:	4605      	mov	r5, r0
 8005fb6:	460c      	mov	r4, r1
 8005fb8:	4616      	mov	r6, r2
        BaseType_t xAddressIsLocal = ( FreeRTOS_FindEndPointOnNetMask( ulIPAddress, 2 ) != NULL ) ? 1 : 0; /* ARP remote address. */
 8005fba:	2102      	movs	r1, #2
 8005fbc:	4620      	mov	r0, r4
 8005fbe:	f003 fdcd 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
        if( xAddressIsLocal != 0 )
 8005fc2:	b1e8      	cbz	r0, 8006000 <vARPRefreshCacheEntry+0x50>
        xReady = prvFindCacheEntry( pxMACAddress, ulIPAddress, pxEndPoint, &( xLocation ) );
 8005fc4:	ab01      	add	r3, sp, #4
 8005fc6:	4632      	mov	r2, r6
 8005fc8:	4621      	mov	r1, r4
 8005fca:	4628      	mov	r0, r5
 8005fcc:	f7ff ff2a 	bl	8005e24 <prvFindCacheEntry>
        if( xReady == pdFALSE )
 8005fd0:	b9b0      	cbnz	r0, 8006000 <vARPRefreshCacheEntry+0x50>
            if( xLocation.xMacEntry >= 0 )
 8005fd2:	9b02      	ldr	r3, [sp, #8]
 8005fd4:	2b00      	cmp	r3, #0
 8005fd6:	db1f      	blt.n	8006018 <vARPRefreshCacheEntry+0x68>
                xLocation.xUseEntry = xLocation.xMacEntry;
 8005fd8:	9303      	str	r3, [sp, #12]
                if( xLocation.xIpEntry >= 0 )
 8005fda:	9b01      	ldr	r3, [sp, #4]
 8005fdc:	2b00      	cmp	r3, #0
 8005fde:	da11      	bge.n	8006004 <vARPRefreshCacheEntry+0x54>
            xARPCache[ xLocation.xUseEntry ].ulIPAddress = ulIPAddress;
 8005fe0:	9a03      	ldr	r2, [sp, #12]
 8005fe2:	0113      	lsls	r3, r2, #4
 8005fe4:	4914      	ldr	r1, [pc, #80]	@ (8006038 <vARPRefreshCacheEntry+0x88>)
 8005fe6:	50cc      	str	r4, [r1, r3]
            if( pxMACAddress != NULL )
 8005fe8:	b1dd      	cbz	r5, 8006022 <vARPRefreshCacheEntry+0x72>
                ( void ) memcpy( xARPCache[ xLocation.xUseEntry ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) );
 8005fea:	eb01 1302 	add.w	r3, r1, r2, lsl #4
 8005fee:	682a      	ldr	r2, [r5, #0]
 8005ff0:	605a      	str	r2, [r3, #4]
 8005ff2:	88aa      	ldrh	r2, [r5, #4]
 8005ff4:	811a      	strh	r2, [r3, #8]
                xARPCache[ xLocation.xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 8005ff6:	2296      	movs	r2, #150	@ 0x96
 8005ff8:	729a      	strb	r2, [r3, #10]
                xARPCache[ xLocation.xUseEntry ].ucValid = ( uint8_t ) pdTRUE;
 8005ffa:	2201      	movs	r2, #1
 8005ffc:	72da      	strb	r2, [r3, #11]
                xARPCache[ xLocation.xUseEntry ].pxEndPoint = pxEndPoint;
 8005ffe:	60de      	str	r6, [r3, #12]
}
 8006000:	b004      	add	sp, #16
 8006002:	bd70      	pop	{r4, r5, r6, pc}
                    ( void ) memset( &( xARPCache[ xLocation.xIpEntry ] ), 0, sizeof( ARPCacheRow_t ) );
 8006004:	0118      	lsls	r0, r3, #4
 8006006:	490c      	ldr	r1, [pc, #48]	@ (8006038 <vARPRefreshCacheEntry+0x88>)
 8006008:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 800600c:	2200      	movs	r2, #0
 800600e:	500a      	str	r2, [r1, r0]
 8006010:	605a      	str	r2, [r3, #4]
 8006012:	609a      	str	r2, [r3, #8]
 8006014:	60da      	str	r2, [r3, #12]
 8006016:	e7e3      	b.n	8005fe0 <vARPRefreshCacheEntry+0x30>
            else if( xLocation.xIpEntry >= 0 )
 8006018:	9b01      	ldr	r3, [sp, #4]
 800601a:	2b00      	cmp	r3, #0
 800601c:	dbe0      	blt.n	8005fe0 <vARPRefreshCacheEntry+0x30>
                xLocation.xUseEntry = xLocation.xIpEntry;
 800601e:	9303      	str	r3, [sp, #12]
 8006020:	e7de      	b.n	8005fe0 <vARPRefreshCacheEntry+0x30>
            else if( xLocation.xIpEntry < 0 )
 8006022:	9b01      	ldr	r3, [sp, #4]
 8006024:	2b00      	cmp	r3, #0
 8006026:	daeb      	bge.n	8006000 <vARPRefreshCacheEntry+0x50>
                xARPCache[ xLocation.xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
 8006028:	4b03      	ldr	r3, [pc, #12]	@ (8006038 <vARPRefreshCacheEntry+0x88>)
 800602a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 800602e:	2205      	movs	r2, #5
 8006030:	729a      	strb	r2, [r3, #10]
                xARPCache[ xLocation.xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
 8006032:	2200      	movs	r2, #0
 8006034:	72da      	strb	r2, [r3, #11]
}
 8006036:	e7e3      	b.n	8006000 <vARPRefreshCacheEntry+0x50>
 8006038:	20011ab0 	.word	0x20011ab0

0800603c <vARPProcessPacketRequest>:
    {
 800603c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800603e:	4604      	mov	r4, r0
 8006040:	460d      	mov	r5, r1
 8006042:	4616      	mov	r6, r2
        vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress, pxTargetEndPoint );
 8006044:	f100 0716 	add.w	r7, r0, #22
 8006048:	460a      	mov	r2, r1
 800604a:	4631      	mov	r1, r6
 800604c:	4638      	mov	r0, r7
 800604e:	f7ff ffaf 	bl	8005fb0 <vARPRefreshCacheEntry>
        pxARPHeader->usOperation = ( uint16_t ) ipARP_REPLY;
 8006052:	2300      	movs	r3, #0
 8006054:	7523      	strb	r3, [r4, #20]
 8006056:	2302      	movs	r3, #2
 8006058:	7563      	strb	r3, [r4, #21]
        ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( MACAddress_t ) );
 800605a:	f8d4 3016 	ldr.w	r3, [r4, #22]
 800605e:	6223      	str	r3, [r4, #32]
 8006060:	8b63      	ldrh	r3, [r4, #26]
 8006062:	84a3      	strh	r3, [r4, #36]	@ 0x24
        pxARPHeader->ulTargetProtocolAddress = ulSenderProtocolAddress;
 8006064:	f8c4 6026 	str.w	r6, [r4, #38]	@ 0x26
        ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( MACAddress_t ) );
 8006068:	f8d5 30e8 	ldr.w	r3, [r5, #232]	@ 0xe8
 800606c:	f8c4 3016 	str.w	r3, [r4, #22]
 8006070:	f8b5 30ec 	ldrh.w	r3, [r5, #236]	@ 0xec
 8006074:	8363      	strh	r3, [r4, #26]
        ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxARPHeader->ucSenderProtocolAddress ) );
 8006076:	682b      	ldr	r3, [r5, #0]
 8006078:	61e3      	str	r3, [r4, #28]
    }
 800607a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800607c <vARPProcessPacketReply>:
    {
 800607c:	b570      	push	{r4, r5, r6, lr}
 800607e:	b082      	sub	sp, #8
 8006080:	4604      	mov	r4, r0
 8006082:	460d      	mov	r5, r1
 8006084:	4616      	mov	r6, r2
        uint32_t ulTargetProtocolAddress = pxARPHeader->ulTargetProtocolAddress;
 8006086:	f8d0 3026 	ldr.w	r3, [r0, #38]	@ 0x26
        if( ( ulTargetProtocolAddress == pxTargetEndPoint->ipv4_settings.ulIPAddress ) ||
 800608a:	680a      	ldr	r2, [r1, #0]
 800608c:	429a      	cmp	r2, r3
 800608e:	d00d      	beq.n	80060ac <vARPProcessPacketReply+0x30>
            ( xIsIPInARPCache( ulSenderProtocolAddress ) == pdTRUE ) )
 8006090:	4630      	mov	r0, r6
 8006092:	f7ff ff57 	bl	8005f44 <xIsIPInARPCache>
        if( ( ulTargetProtocolAddress == pxTargetEndPoint->ipv4_settings.ulIPAddress ) ||
 8006096:	2801      	cmp	r0, #1
 8006098:	d008      	beq.n	80060ac <vARPProcessPacketReply+0x30>
        if( ( pxARPWaitingNetworkBuffer != NULL ) &&
 800609a:	4b16      	ldr	r3, [pc, #88]	@ (80060f4 <vARPProcessPacketReply+0x78>)
 800609c:	6818      	ldr	r0, [r3, #0]
 800609e:	b118      	cbz	r0, 80060a8 <vARPProcessPacketReply+0x2c>
            ( uxIPHeaderSizePacket( pxARPWaitingNetworkBuffer ) == ipSIZE_OF_IPv4_HEADER ) )
 80060a0:	f001 fa1a 	bl	80074d8 <uxIPHeaderSizePacket>
        if( ( pxARPWaitingNetworkBuffer != NULL ) &&
 80060a4:	2814      	cmp	r0, #20
 80060a6:	d008      	beq.n	80060ba <vARPProcessPacketReply+0x3e>
    }
 80060a8:	b002      	add	sp, #8
 80060aa:	bd70      	pop	{r4, r5, r6, pc}
            vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress, pxTargetEndPoint );
 80060ac:	462a      	mov	r2, r5
 80060ae:	4631      	mov	r1, r6
 80060b0:	f104 0016 	add.w	r0, r4, #22
 80060b4:	f7ff ff7c 	bl	8005fb0 <vARPRefreshCacheEntry>
 80060b8:	e7ef      	b.n	800609a <vARPProcessPacketReply+0x1e>
            const IPPacket_t * pxARPWaitingIPPacket = ( ( IPPacket_t * ) pxARPWaitingNetworkBuffer->pucEthernetBuffer );
 80060ba:	4b0e      	ldr	r3, [pc, #56]	@ (80060f4 <vARPProcessPacketReply+0x78>)
 80060bc:	681b      	ldr	r3, [r3, #0]
 80060be:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
            if( ulSenderProtocolAddress == pxARPWaitingIPHeader->ulSourceIPAddress )
 80060c0:	f8d2 201a 	ldr.w	r2, [r2, #26]
 80060c4:	42b2      	cmp	r2, r6
 80060c6:	d1ef      	bne.n	80060a8 <vARPProcessPacketReply+0x2c>
                xEventMessage.eEventType = eNetworkRxEvent;
 80060c8:	2201      	movs	r2, #1
 80060ca:	f88d 2000 	strb.w	r2, [sp]
                xEventMessage.pvData = ( void * ) pxARPWaitingNetworkBuffer;
 80060ce:	9301      	str	r3, [sp, #4]
                if( xSendEventStructToIPTask( &xEventMessage, xDontBlock ) != pdPASS )
 80060d0:	2100      	movs	r1, #0
 80060d2:	4668      	mov	r0, sp
 80060d4:	f001 f906 	bl	80072e4 <xSendEventStructToIPTask>
 80060d8:	2801      	cmp	r0, #1
 80060da:	d105      	bne.n	80060e8 <vARPProcessPacketReply+0x6c>
                pxARPWaitingNetworkBuffer = NULL;
 80060dc:	2000      	movs	r0, #0
 80060de:	4b05      	ldr	r3, [pc, #20]	@ (80060f4 <vARPProcessPacketReply+0x78>)
 80060e0:	6018      	str	r0, [r3, #0]
                vIPSetARPResolutionTimerEnableState( pdFALSE );
 80060e2:	f001 fca7 	bl	8007a34 <vIPSetARPResolutionTimerEnableState>
    }
 80060e6:	e7df      	b.n	80060a8 <vARPProcessPacketReply+0x2c>
                    vReleaseNetworkBufferAndDescriptor( pxARPWaitingNetworkBuffer );
 80060e8:	4b02      	ldr	r3, [pc, #8]	@ (80060f4 <vARPProcessPacketReply+0x78>)
 80060ea:	6818      	ldr	r0, [r3, #0]
 80060ec:	f008 fad8 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 80060f0:	e7f4      	b.n	80060dc <vARPProcessPacketReply+0x60>
 80060f2:	bf00      	nop
 80060f4:	200133b4 	.word	0x200133b4

080060f8 <eARPGetCacheEntry>:
    {
 80060f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        configASSERT( pxMACAddress != NULL );
 80060fa:	b1b9      	cbz	r1, 800612c <eARPGetCacheEntry+0x34>
 80060fc:	4604      	mov	r4, r0
 80060fe:	4615      	mov	r5, r2
 8006100:	460e      	mov	r6, r1
        configASSERT( pulIPAddress != NULL );
 8006102:	b1e0      	cbz	r0, 800613e <eARPGetCacheEntry+0x46>
        configASSERT( ppxEndPoint != NULL );
 8006104:	b322      	cbz	r2, 8006150 <eARPGetCacheEntry+0x58>
        *( ppxEndPoint ) = NULL;
 8006106:	2100      	movs	r1, #0
 8006108:	6011      	str	r1, [r2, #0]
        ulAddressToLookup = *pulIPAddress;
 800610a:	6807      	ldr	r7, [r0, #0]
        pxEndPoint = FreeRTOS_FindEndPointOnIP_IPv4( ulAddressToLookup, 0 );
 800610c:	4638      	mov	r0, r7
 800610e:	f003 fcad 	bl	8009a6c <FreeRTOS_FindEndPointOnIP_IPv4>
        if( xIsIPv4Multicast( ulAddressToLookup ) != 0 )
 8006112:	4638      	mov	r0, r7
 8006114:	f002 f8c7 	bl	80082a6 <xIsIPv4Multicast>
 8006118:	bb18      	cbnz	r0, 8006162 <eARPGetCacheEntry+0x6a>
        else if( ( FreeRTOS_htonl( ulAddressToLookup ) & 0xffU ) == 0xffU ) /* Is this a broadcast address like x.x.x.255 ? */
 800611a:	0e3b      	lsrs	r3, r7, #24
 800611c:	2bff      	cmp	r3, #255	@ 0xff
 800611e:	d038      	beq.n	8006192 <eARPGetCacheEntry+0x9a>
            eReturn = eARPGetCacheEntryGateWay( pulIPAddress, pxMACAddress, ppxEndPoint );
 8006120:	462a      	mov	r2, r5
 8006122:	4631      	mov	r1, r6
 8006124:	4620      	mov	r0, r4
 8006126:	f7ff feef 	bl	8005f08 <eARPGetCacheEntryGateWay>
    }
 800612a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800612c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006130:	f383 8811 	msr	BASEPRI, r3
 8006134:	f3bf 8f6f 	isb	sy
 8006138:	f3bf 8f4f 	dsb	sy
        configASSERT( pxMACAddress != NULL );
 800613c:	e7fe      	b.n	800613c <eARPGetCacheEntry+0x44>
 800613e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006142:	f383 8811 	msr	BASEPRI, r3
 8006146:	f3bf 8f6f 	isb	sy
 800614a:	f3bf 8f4f 	dsb	sy
        configASSERT( pulIPAddress != NULL );
 800614e:	e7fe      	b.n	800614e <eARPGetCacheEntry+0x56>
 8006150:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006154:	f383 8811 	msr	BASEPRI, r3
 8006158:	f3bf 8f6f 	isb	sy
 800615c:	f3bf 8f4f 	dsb	sy
        configASSERT( ppxEndPoint != NULL );
 8006160:	e7fe      	b.n	8006160 <eARPGetCacheEntry+0x68>
            vSetMultiCastIPv4MacAddress( ulAddressToLookup, pxMACAddress );
 8006162:	4631      	mov	r1, r6
 8006164:	4638      	mov	r0, r7
 8006166:	f002 f9a5 	bl	80084b4 <vSetMultiCastIPv4MacAddress>
            pxEndPoint = FreeRTOS_FirstEndPoint( NULL );
 800616a:	2000      	movs	r0, #0
 800616c:	f003 fc5c 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8006170:	4601      	mov	r1, r0
                 pxEndPoint != NULL;
 8006172:	b161      	cbz	r1, 800618e <eARPGetCacheEntry+0x96>
                if( pxEndPoint->bits.bIPv6 == 0U ) /*NULL End Point is checked in the for loop, no need for an extra check */
 8006174:	f891 30f0 	ldrb.w	r3, [r1, #240]	@ 0xf0
 8006178:	f013 0f08 	tst.w	r3, #8
 800617c:	d004      	beq.n	8006188 <eARPGetCacheEntry+0x90>
                 pxEndPoint = FreeRTOS_NextEndPoint( NULL, pxEndPoint ) )
 800617e:	2000      	movs	r0, #0
 8006180:	f003 fc62 	bl	8009a48 <FreeRTOS_NextEndPoint>
 8006184:	4601      	mov	r1, r0
 8006186:	e7f4      	b.n	8006172 <eARPGetCacheEntry+0x7a>
                    *( ppxEndPoint ) = pxEndPoint;
 8006188:	6029      	str	r1, [r5, #0]
                    eReturn = eARPCacheHit;
 800618a:	2001      	movs	r0, #1
                    break;
 800618c:	e7cd      	b.n	800612a <eARPGetCacheEntry+0x32>
            eReturn = eCantSendPacket;
 800618e:	2002      	movs	r0, #2
 8006190:	e7cb      	b.n	800612a <eARPGetCacheEntry+0x32>
            ( void ) memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
 8006192:	4b07      	ldr	r3, [pc, #28]	@ (80061b0 <eARPGetCacheEntry+0xb8>)
 8006194:	681a      	ldr	r2, [r3, #0]
 8006196:	6032      	str	r2, [r6, #0]
 8006198:	889b      	ldrh	r3, [r3, #4]
 800619a:	80b3      	strh	r3, [r6, #4]
            pxEndPoint = FreeRTOS_FindEndPointOnNetMask( ulAddressToLookup, 4 );
 800619c:	2104      	movs	r1, #4
 800619e:	4638      	mov	r0, r7
 80061a0:	f003 fcdc 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
            if( pxEndPoint != NULL )
 80061a4:	b110      	cbz	r0, 80061ac <eARPGetCacheEntry+0xb4>
                *( ppxEndPoint ) = pxEndPoint;
 80061a6:	6028      	str	r0, [r5, #0]
            eReturn = eARPCacheHit;
 80061a8:	2001      	movs	r0, #1
 80061aa:	e7be      	b.n	800612a <eARPGetCacheEntry+0x32>
 80061ac:	2001      	movs	r0, #1
 80061ae:	e7bc      	b.n	800612a <eARPGetCacheEntry+0x32>
 80061b0:	080102c4 	.word	0x080102c4

080061b4 <vARPSendGratuitous>:
/**
 * @brief Send a Gratuitous ARP packet to allow this node to announce the IP-MAC
 *        mapping to the entire network.
 */
    void vARPSendGratuitous( void )
    {
 80061b4:	b508      	push	{r3, lr}
        /* Setting xLastGratuitousARPTime to 0 will force a gratuitous ARP the next
         * time vARPAgeCache() is called. */
        xLastGratuitousARPTime = ( TickType_t ) 0;
 80061b6:	4b03      	ldr	r3, [pc, #12]	@ (80061c4 <vARPSendGratuitous+0x10>)
 80061b8:	2200      	movs	r2, #0
 80061ba:	601a      	str	r2, [r3, #0]

        /* Let the IP-task call vARPAgeCache(). */
        ( void ) xSendEventToIPTask( eARPTimerEvent );
 80061bc:	2003      	movs	r0, #3
 80061be:	f001 f8fb 	bl	80073b8 <xSendEventToIPTask>
    }
 80061c2:	bd08      	pop	{r3, pc}
 80061c4:	20011aac 	.word	0x20011aac

080061c8 <vARPGenerateRequestPacket>:
        void * pvCopyDest;

        /* Buffer allocation ensures that buffers always have space
         * for an ARP packet. See buffer allocation implementations 1
         * and 2 under portable/BufferManagement. */
        configASSERT( pxNetworkBuffer != NULL );
 80061c8:	b168      	cbz	r0, 80061e6 <vARPGenerateRequestPacket+0x1e>
    {
 80061ca:	b5f0      	push	{r4, r5, r6, r7, lr}
 80061cc:	4604      	mov	r4, r0
        configASSERT( pxNetworkBuffer->xDataLength >= sizeof( ARPPacket_t ) );
 80061ce:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80061d0:	2b29      	cmp	r3, #41	@ 0x29
 80061d2:	d811      	bhi.n	80061f8 <vARPGenerateRequestPacket+0x30>
 80061d4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80061d8:	f383 8811 	msr	BASEPRI, r3
 80061dc:	f3bf 8f6f 	isb	sy
 80061e0:	f3bf 8f4f 	dsb	sy
 80061e4:	e7fe      	b.n	80061e4 <vARPGenerateRequestPacket+0x1c>
 80061e6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80061ea:	f383 8811 	msr	BASEPRI, r3
 80061ee:	f3bf 8f6f 	isb	sy
 80061f2:	f3bf 8f4f 	dsb	sy
        configASSERT( pxNetworkBuffer != NULL );
 80061f6:	e7fe      	b.n	80061f6 <vARPGenerateRequestPacket+0x2e>
        configASSERT( pxNetworkBuffer->pxEndPoint != NULL );
 80061f8:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 80061fa:	b3ab      	cbz	r3, 8006268 <vARPGenerateRequestPacket+0xa0>

        /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxARPPacket = ( ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80061fc:	6a46      	ldr	r6, [r0, #36]	@ 0x24
         * compliant with MISRA Rule 21.15.  These should be
         * optimized away.
         */
        pvCopySource = xDefaultPartARPPacketHeader;
        pvCopyDest = pxARPPacket;
        ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( xDefaultPartARPPacketHeader ) );
 80061fe:	4d1f      	ldr	r5, [pc, #124]	@ (800627c <vARPGenerateRequestPacket+0xb4>)
 8006200:	46b4      	mov	ip, r6
 8006202:	f105 0720 	add.w	r7, r5, #32
 8006206:	46ae      	mov	lr, r5
 8006208:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800620c:	f8cc 0000 	str.w	r0, [ip]
 8006210:	f8cc 1004 	str.w	r1, [ip, #4]
 8006214:	f8cc 2008 	str.w	r2, [ip, #8]
 8006218:	f8cc 300c 	str.w	r3, [ip, #12]
 800621c:	4675      	mov	r5, lr
 800621e:	f10c 0c10 	add.w	ip, ip, #16
 8006222:	45be      	cmp	lr, r7
 8006224:	d1ef      	bne.n	8006206 <vARPGenerateRequestPacket+0x3e>
 8006226:	f8de 0000 	ldr.w	r0, [lr]
 800622a:	f8cc 0000 	str.w	r0, [ip]
 800622e:	f8be 3004 	ldrh.w	r3, [lr, #4]
 8006232:	f8ac 3004 	strh.w	r3, [ip, #4]

        pvCopySource = pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes;
 8006236:	6b23      	ldr	r3, [r4, #48]	@ 0x30
        pvCopyDest = pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes;
        ( void ) memcpy( pvCopyDest, pvCopySource, ipMAC_ADDRESS_LENGTH_BYTES );
 8006238:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 800623c:	f8c6 2006 	str.w	r2, [r6, #6]
 8006240:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 8006244:	8173      	strh	r3, [r6, #10]

        pvCopySource = pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes;
 8006246:	6b23      	ldr	r3, [r4, #48]	@ 0x30
        pvCopyDest = pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes;
        ( void ) memcpy( pvCopyDest, pvCopySource, ipMAC_ADDRESS_LENGTH_BYTES );
 8006248:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 800624c:	f8c6 2016 	str.w	r2, [r6, #22]
 8006250:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 8006254:	8373      	strh	r3, [r6, #26]

        pvCopySource = &( pxNetworkBuffer->pxEndPoint->ipv4_settings.ulIPAddress );
 8006256:	6b23      	ldr	r3, [r4, #48]	@ 0x30
        pvCopyDest = pxARPPacket->xARPHeader.ucSenderProtocolAddress;
        ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxARPPacket->xARPHeader.ucSenderProtocolAddress ) );
 8006258:	681b      	ldr	r3, [r3, #0]
 800625a:	61f3      	str	r3, [r6, #28]
        pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->xIPAddress.ulIP_IPv4;
 800625c:	6963      	ldr	r3, [r4, #20]
 800625e:	f8c6 3026 	str.w	r3, [r6, #38]	@ 0x26

        pxNetworkBuffer->xDataLength = sizeof( ARPPacket_t );
 8006262:	232a      	movs	r3, #42	@ 0x2a
 8006264:	62a3      	str	r3, [r4, #40]	@ 0x28

        iptraceCREATING_ARP_REQUEST( pxNetworkBuffer->xIPAddress.ulIP_IPv4 );
    }
 8006266:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006268:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800626c:	f383 8811 	msr	BASEPRI, r3
 8006270:	f3bf 8f6f 	isb	sy
 8006274:	f3bf 8f4f 	dsb	sy
        configASSERT( pxNetworkBuffer->pxEndPoint != NULL );
 8006278:	e7fe      	b.n	8006278 <vARPGenerateRequestPacket+0xb0>
 800627a:	bf00      	nop
 800627c:	0800ff04 	.word	0x0800ff04

08006280 <FreeRTOS_OutputARPRequest_Multi>:
        if( ( pxEndPoint->bits.bIPv6 == pdFALSE_UNSIGNED ) &&
 8006280:	f890 30f0 	ldrb.w	r3, [r0, #240]	@ 0xf0
 8006284:	f013 0f08 	tst.w	r3, #8
 8006288:	d130      	bne.n	80062ec <FreeRTOS_OutputARPRequest_Multi+0x6c>
    {
 800628a:	b570      	push	{r4, r5, r6, lr}
 800628c:	b082      	sub	sp, #8
 800628e:	4604      	mov	r4, r0
 8006290:	460d      	mov	r5, r1
            ( pxEndPoint->ipv4_settings.ulIPAddress != 0U ) )
 8006292:	6803      	ldr	r3, [r0, #0]
        if( ( pxEndPoint->bits.bIPv6 == pdFALSE_UNSIGNED ) &&
 8006294:	b90b      	cbnz	r3, 800629a <FreeRTOS_OutputARPRequest_Multi+0x1a>
    }
 8006296:	b002      	add	sp, #8
 8006298:	bd70      	pop	{r4, r5, r6, pc}
            pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( ARPPacket_t ), ( TickType_t ) 0U );
 800629a:	2100      	movs	r1, #0
 800629c:	202a      	movs	r0, #42	@ 0x2a
 800629e:	f008 fa25 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
            if( pxNetworkBuffer != NULL )
 80062a2:	4606      	mov	r6, r0
 80062a4:	2800      	cmp	r0, #0
 80062a6:	d0f6      	beq.n	8006296 <FreeRTOS_OutputARPRequest_Multi+0x16>
                pxNetworkBuffer->xIPAddress.ulIP_IPv4 = ulIPAddress;
 80062a8:	6145      	str	r5, [r0, #20]
                pxNetworkBuffer->pxEndPoint = pxEndPoint;
 80062aa:	6304      	str	r4, [r0, #48]	@ 0x30
                pxNetworkBuffer->pxInterface = pxEndPoint->pxNetworkInterface;
 80062ac:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
 80062b0:	62c3      	str	r3, [r0, #44]	@ 0x2c
                vARPGenerateRequestPacket( pxNetworkBuffer );
 80062b2:	f7ff ff89 	bl	80061c8 <vARPGenerateRequestPacket>
                if( xIsCallingFromIPTask() != pdFALSE )
 80062b6:	f001 fd86 	bl	8007dc6 <xIsCallingFromIPTask>
 80062ba:	b140      	cbz	r0, 80062ce <FreeRTOS_OutputARPRequest_Multi+0x4e>
                    if( pxEndPoint->pxNetworkInterface != NULL )
 80062bc:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
 80062c0:	2800      	cmp	r0, #0
 80062c2:	d0e8      	beq.n	8006296 <FreeRTOS_OutputARPRequest_Multi+0x16>
                        ( void ) pxEndPoint->pxNetworkInterface->pfOutput( pxEndPoint->pxNetworkInterface, pxNetworkBuffer, pdTRUE );
 80062c4:	68c3      	ldr	r3, [r0, #12]
 80062c6:	2201      	movs	r2, #1
 80062c8:	4631      	mov	r1, r6
 80062ca:	4798      	blx	r3
 80062cc:	e7e3      	b.n	8006296 <FreeRTOS_OutputARPRequest_Multi+0x16>
                    xSendEvent.eEventType = eNetworkTxEvent;
 80062ce:	2302      	movs	r3, #2
 80062d0:	f88d 3000 	strb.w	r3, [sp]
                    xSendEvent.pvData = pxNetworkBuffer;
 80062d4:	9601      	str	r6, [sp, #4]
                    if( xSendEventStructToIPTask( &xSendEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 80062d6:	f04f 31ff 	mov.w	r1, #4294967295
 80062da:	4668      	mov	r0, sp
 80062dc:	f001 f802 	bl	80072e4 <xSendEventStructToIPTask>
 80062e0:	2800      	cmp	r0, #0
 80062e2:	d1d8      	bne.n	8006296 <FreeRTOS_OutputARPRequest_Multi+0x16>
                        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80062e4:	4630      	mov	r0, r6
 80062e6:	f008 f9db 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
    }
 80062ea:	e7d4      	b.n	8006296 <FreeRTOS_OutputARPRequest_Multi+0x16>
 80062ec:	4770      	bx	lr
	...

080062f0 <eARPProcessPacket>:
    {
 80062f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80062f4:	b086      	sub	sp, #24
        ARPPacket_t * pxARPFrame = ( ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80062f6:	6a44      	ldr	r4, [r0, #36]	@ 0x24
        NetworkEndPoint_t * pxTargetEndPoint = pxNetworkBuffer->pxEndPoint;
 80062f8:	6b06      	ldr	r6, [r0, #48]	@ 0x30
        if( ( pxARPHeader->usHardwareType == ipARP_HARDWARE_TYPE_ETHERNET ) &&
 80062fa:	89e3      	ldrh	r3, [r4, #14]
 80062fc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8006300:	d004      	beq.n	800630c <eARPProcessPacket+0x1c>
        eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8006302:	2500      	movs	r5, #0
    }
 8006304:	4628      	mov	r0, r5
 8006306:	b006      	add	sp, #24
 8006308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ( pxARPHeader->usProtocolType == ipARP_PROTOCOL_TYPE ) &&
 800630c:	8a23      	ldrh	r3, [r4, #16]
        if( ( pxARPHeader->usHardwareType == ipARP_HARDWARE_TYPE_ETHERNET ) &&
 800630e:	2b08      	cmp	r3, #8
 8006310:	d001      	beq.n	8006316 <eARPProcessPacket+0x26>
        eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8006312:	2500      	movs	r5, #0
 8006314:	e7f6      	b.n	8006304 <eARPProcessPacket+0x14>
            ( pxARPHeader->ucHardwareAddressLength == ipMAC_ADDRESS_LENGTH_BYTES ) &&
 8006316:	7ca3      	ldrb	r3, [r4, #18]
            ( pxARPHeader->usProtocolType == ipARP_PROTOCOL_TYPE ) &&
 8006318:	2b06      	cmp	r3, #6
 800631a:	d001      	beq.n	8006320 <eARPProcessPacket+0x30>
        eFrameProcessingResult_t eReturn = eReleaseBuffer;
 800631c:	2500      	movs	r5, #0
 800631e:	e7f1      	b.n	8006304 <eARPProcessPacket+0x14>
            ( pxARPHeader->ucProtocolAddressLength == ipIP_ADDRESS_LENGTH_BYTES ) )
 8006320:	7ce3      	ldrb	r3, [r4, #19]
            ( pxARPHeader->ucHardwareAddressLength == ipMAC_ADDRESS_LENGTH_BYTES ) &&
 8006322:	2b04      	cmp	r3, #4
 8006324:	d001      	beq.n	800632a <eARPProcessPacket+0x3a>
        eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8006326:	2500      	movs	r5, #0
 8006328:	e7ec      	b.n	8006304 <eARPProcessPacket+0x14>
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( ulSenderProtocolAddress ) );
 800632a:	69e3      	ldr	r3, [r4, #28]
 800632c:	9305      	str	r3, [sp, #20]
            ulTargetProtocolAddress = pxARPHeader->ulTargetProtocolAddress;
 800632e:	f8d4 8026 	ldr.w	r8, [r4, #38]	@ 0x26
            if( uxARPClashCounter != 0U )
 8006332:	4b52      	ldr	r3, [pc, #328]	@ (800647c <eARPProcessPacket+0x18c>)
 8006334:	681b      	ldr	r3, [r3, #0]
 8006336:	bb6b      	cbnz	r3, 8006394 <eARPProcessPacket+0xa4>
            if( ( pxARPHeader->xSenderHardwareAddress.ucBytes[ 0 ] & 0x01U ) == 0x01U )
 8006338:	7da5      	ldrb	r5, [r4, #22]
 800633a:	f015 0501 	ands.w	r5, r5, #1
 800633e:	f040 8098 	bne.w	8006472 <eARPProcessPacket+0x182>
            else if( ( ipFIRST_LOOPBACK_IPv4 <= ( FreeRTOS_ntohl( ulSenderProtocolAddress ) ) ) &&
 8006342:	9f05      	ldr	r7, [sp, #20]
 8006344:	023b      	lsls	r3, r7, #8
 8006346:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800634a:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 800634e:	0a3a      	lsrs	r2, r7, #8
 8006350:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 8006354:	4313      	orrs	r3, r2
 8006356:	ea43 6317 	orr.w	r3, r3, r7, lsr #24
 800635a:	f103 4301 	add.w	r3, r3, #2164260864	@ 0x81000000
 800635e:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8006362:	d3cf      	bcc.n	8006304 <eARPProcessPacket+0x14>
            else if( ( pxTargetEndPoint != NULL ) && ( ulSenderProtocolAddress == pxTargetEndPoint->ipv4_settings.ulIPAddress ) )
 8006364:	b116      	cbz	r6, 800636c <eARPProcessPacket+0x7c>
 8006366:	6831      	ldr	r1, [r6, #0]
 8006368:	428f      	cmp	r7, r1
 800636a:	d01d      	beq.n	80063a8 <eARPProcessPacket+0xb8>
                    if( ( pxARPHeader->usOperation == ( uint16_t ) ipARP_REQUEST ) &&
 800636c:	8aa2      	ldrh	r2, [r4, #20]
                if( ( pxTargetEndPoint != NULL ) && ( pxTargetEndPoint->bits.bEndPointUp != pdFALSE_UNSIGNED ) )
 800636e:	2e00      	cmp	r6, #0
 8006370:	d0c8      	beq.n	8006304 <eARPProcessPacket+0x14>
 8006372:	f896 30f0 	ldrb.w	r3, [r6, #240]	@ 0xf0
 8006376:	f013 0320 	ands.w	r3, r3, #32
 800637a:	d07c      	beq.n	8006476 <eARPProcessPacket+0x186>
                    switch( pxARPHeader->usOperation )
 800637c:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
 8006380:	d028      	beq.n	80063d4 <eARPProcessPacket+0xe4>
 8006382:	f5b2 7f00 	cmp.w	r2, #512	@ 0x200
 8006386:	d1bd      	bne.n	8006304 <eARPProcessPacket+0x14>
                            vARPProcessPacketReply( pxARPFrame, pxTargetEndPoint, ulSenderProtocolAddress );
 8006388:	463a      	mov	r2, r7
 800638a:	4631      	mov	r1, r6
 800638c:	4620      	mov	r0, r4
 800638e:	f7ff fe75 	bl	800607c <vARPProcessPacketReply>
                            break;
 8006392:	e7b7      	b.n	8006304 <eARPProcessPacket+0x14>
                if( xTaskCheckForTimeOut( &xARPClashTimeOut, &uxARPClashTimeoutPeriod ) == pdTRUE )
 8006394:	493a      	ldr	r1, [pc, #232]	@ (8006480 <eARPProcessPacket+0x190>)
 8006396:	483b      	ldr	r0, [pc, #236]	@ (8006484 <eARPProcessPacket+0x194>)
 8006398:	f7fe fedc 	bl	8005154 <xTaskCheckForTimeOut>
 800639c:	2801      	cmp	r0, #1
 800639e:	d1cb      	bne.n	8006338 <eARPProcessPacket+0x48>
                    uxARPClashCounter = 0;
 80063a0:	4b36      	ldr	r3, [pc, #216]	@ (800647c <eARPProcessPacket+0x18c>)
 80063a2:	2200      	movs	r2, #0
 80063a4:	601a      	str	r2, [r3, #0]
 80063a6:	e7c7      	b.n	8006338 <eARPProcessPacket+0x48>
                if( uxARPClashCounter < arpIP_CLASH_MAX_RETRIES )
 80063a8:	4b34      	ldr	r3, [pc, #208]	@ (800647c <eARPProcessPacket+0x18c>)
 80063aa:	681b      	ldr	r3, [r3, #0]
 80063ac:	2b00      	cmp	r3, #0
 80063ae:	d1a9      	bne.n	8006304 <eARPProcessPacket+0x14>
                    uxARPClashCounter++;
 80063b0:	3301      	adds	r3, #1
 80063b2:	4a32      	ldr	r2, [pc, #200]	@ (800647c <eARPProcessPacket+0x18c>)
 80063b4:	6013      	str	r3, [r2, #0]
                    FreeRTOS_OutputARPRequest_Multi( pxTargetEndPoint, pxTargetEndPoint->ipv4_settings.ulIPAddress );
 80063b6:	4630      	mov	r0, r6
 80063b8:	f7ff ff62 	bl	8006280 <FreeRTOS_OutputARPRequest_Multi>
                    xLastGratuitousARPTime = xTaskGetTickCount();
 80063bc:	f7fe fc32 	bl	8004c24 <xTaskGetTickCount>
 80063c0:	4b31      	ldr	r3, [pc, #196]	@ (8006488 <eARPProcessPacket+0x198>)
 80063c2:	6018      	str	r0, [r3, #0]
                    vTaskSetTimeOutState( &xARPClashTimeOut );
 80063c4:	482f      	ldr	r0, [pc, #188]	@ (8006484 <eARPProcessPacket+0x194>)
 80063c6:	f7fe fe9d 	bl	8005104 <vTaskSetTimeOutState>
                    uxARPClashTimeoutPeriod = pdMS_TO_TICKS( arpIP_CLASH_RESET_TIMEOUT_MS );
 80063ca:	4b2d      	ldr	r3, [pc, #180]	@ (8006480 <eARPProcessPacket+0x190>)
 80063cc:	f242 7210 	movw	r2, #10000	@ 0x2710
 80063d0:	601a      	str	r2, [r3, #0]
 80063d2:	e797      	b.n	8006304 <eARPProcessPacket+0x14>
                            if( ulTargetProtocolAddress == pxTargetEndPoint->ipv4_settings.ulIPAddress )
 80063d4:	6833      	ldr	r3, [r6, #0]
 80063d6:	4543      	cmp	r3, r8
 80063d8:	d03a      	beq.n	8006450 <eARPProcessPacket+0x160>
                            else if( ( ulSenderProtocolAddress == ulTargetProtocolAddress ) &&
 80063da:	4547      	cmp	r7, r8
 80063dc:	d192      	bne.n	8006304 <eARPProcessPacket+0x14>
                                     ( ( ulSenderProtocolAddress & pxTargetEndPoint->ipv4_settings.ulNetMask ) == ( pxTargetEndPoint->ipv4_settings.ulNetMask & pxTargetEndPoint->ipv4_settings.ulIPAddress ) ) )
 80063de:	6872      	ldr	r2, [r6, #4]
 80063e0:	407b      	eors	r3, r7
                            else if( ( ulSenderProtocolAddress == ulTargetProtocolAddress ) &&
 80063e2:	4213      	tst	r3, r2
 80063e4:	d18e      	bne.n	8006304 <eARPProcessPacket+0x14>
                                const MACAddress_t xGARPTargetAddress = { { 0, 0, 0, 0, 0, 0 } };
 80063e6:	4b29      	ldr	r3, [pc, #164]	@ (800648c <eARPProcessPacket+0x19c>)
 80063e8:	e893 0003 	ldmia.w	r3, {r0, r1}
 80063ec:	9001      	str	r0, [sp, #4]
 80063ee:	f8ad 1008 	strh.w	r1, [sp, #8]
                                if( ( ( memcmp( pxARPHeader->xTargetHardwareAddress.ucBytes, xBroadcastMACAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES ) == 0 ) ||
 80063f2:	f104 0720 	add.w	r7, r4, #32
 80063f6:	2206      	movs	r2, #6
 80063f8:	4925      	ldr	r1, [pc, #148]	@ (8006490 <eARPProcessPacket+0x1a0>)
 80063fa:	4638      	mov	r0, r7
 80063fc:	f008 fc30 	bl	800ec60 <memcmp>
 8006400:	b138      	cbz	r0, 8006412 <eARPProcessPacket+0x122>
                                      ( ( memcmp( pxARPHeader->xTargetHardwareAddress.ucBytes, xGARPTargetAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES ) == 0 ) ) ) &&
 8006402:	2206      	movs	r2, #6
 8006404:	a901      	add	r1, sp, #4
 8006406:	4638      	mov	r0, r7
 8006408:	f008 fc2a 	bl	800ec60 <memcmp>
                                if( ( ( memcmp( pxARPHeader->xTargetHardwareAddress.ucBytes, xBroadcastMACAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES ) == 0 ) ||
 800640c:	2800      	cmp	r0, #0
 800640e:	f47f af79 	bne.w	8006304 <eARPProcessPacket+0x14>
                                    ( memcmp( pxTargetEndPoint->xMACAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES ) != 0 ) )
 8006412:	2206      	movs	r2, #6
 8006414:	f104 0116 	add.w	r1, r4, #22
 8006418:	f106 00e8 	add.w	r0, r6, #232	@ 0xe8
 800641c:	f008 fc20 	bl	800ec60 <memcmp>
                                      ( ( memcmp( pxARPHeader->xTargetHardwareAddress.ucBytes, xGARPTargetAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES ) == 0 ) ) ) &&
 8006420:	2800      	cmp	r0, #0
 8006422:	f43f af6f 	beq.w	8006304 <eARPProcessPacket+0x14>
                                    pxCachedEndPoint = NULL;
 8006426:	2300      	movs	r3, #0
 8006428:	9300      	str	r3, [sp, #0]
                                    if( eARPGetCacheEntry( &( ulSenderProtocolAddress ), &( xHardwareAddress ), &( pxCachedEndPoint ) ) == eARPCacheHit )
 800642a:	466a      	mov	r2, sp
 800642c:	a903      	add	r1, sp, #12
 800642e:	a805      	add	r0, sp, #20
 8006430:	f7ff fe62 	bl	80060f8 <eARPGetCacheEntry>
 8006434:	2801      	cmp	r0, #1
 8006436:	f47f af65 	bne.w	8006304 <eARPProcessPacket+0x14>
                                        if( pxCachedEndPoint == pxTargetEndPoint )
 800643a:	9b00      	ldr	r3, [sp, #0]
 800643c:	42b3      	cmp	r3, r6
 800643e:	f47f af61 	bne.w	8006304 <eARPProcessPacket+0x14>
                                            vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), ulSenderProtocolAddress, pxTargetEndPoint );
 8006442:	4632      	mov	r2, r6
 8006444:	9905      	ldr	r1, [sp, #20]
 8006446:	f104 0016 	add.w	r0, r4, #22
 800644a:	f7ff fdb1 	bl	8005fb0 <vARPRefreshCacheEntry>
 800644e:	e759      	b.n	8006304 <eARPProcessPacket+0x14>
                                if( memcmp( pxTargetEndPoint->xMACAddress.ucBytes,
 8006450:	2206      	movs	r2, #6
 8006452:	f104 0116 	add.w	r1, r4, #22
 8006456:	f106 00e8 	add.w	r0, r6, #232	@ 0xe8
 800645a:	f008 fc01 	bl	800ec60 <memcmp>
 800645e:	2800      	cmp	r0, #0
 8006460:	f43f af50 	beq.w	8006304 <eARPProcessPacket+0x14>
                                    vARPProcessPacketRequest( pxARPFrame, pxTargetEndPoint, ulSenderProtocolAddress );
 8006464:	463a      	mov	r2, r7
 8006466:	4631      	mov	r1, r6
 8006468:	4620      	mov	r0, r4
 800646a:	f7ff fde7 	bl	800603c <vARPProcessPacketRequest>
                                    eReturn = eReturnEthernetFrame;
 800646e:	2502      	movs	r5, #2
 8006470:	e748      	b.n	8006304 <eARPProcessPacket+0x14>
        eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8006472:	2500      	movs	r5, #0
 8006474:	e746      	b.n	8006304 <eARPProcessPacket+0x14>
 8006476:	461d      	mov	r5, r3
 8006478:	e744      	b.n	8006304 <eARPProcessPacket+0x14>
 800647a:	bf00      	nop
 800647c:	20011aa8 	.word	0x20011aa8
 8006480:	20000018 	.word	0x20000018
 8006484:	20011aa0 	.word	0x20011aa0
 8006488:	20011aac 	.word	0x20011aac
 800648c:	0800ff2c 	.word	0x0800ff2c
 8006490:	080102c4 	.word	0x080102c4

08006494 <xCheckRequiresARPResolution>:
{
 8006494:	b530      	push	{r4, r5, lr}
 8006496:	b099      	sub	sp, #100	@ 0x64
 8006498:	4604      	mov	r4, r0
    switch( uxIPHeaderSizePacket( pxNetworkBuffer ) )
 800649a:	f001 f81d 	bl	80074d8 <uxIPHeaderSizePacket>
 800649e:	2814      	cmp	r0, #20
 80064a0:	d004      	beq.n	80064ac <xCheckRequiresARPResolution+0x18>
 80064a2:	2828      	cmp	r0, #40	@ 0x28
 80064a4:	d017      	beq.n	80064d6 <xCheckRequiresARPResolution+0x42>
 80064a6:	2000      	movs	r0, #0
}
 80064a8:	b019      	add	sp, #100	@ 0x64
 80064aa:	bd30      	pop	{r4, r5, pc}
                   const IPPacket_t * pxIPPacket = ( ( const IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80064ac:	6a63      	ldr	r3, [r4, #36]	@ 0x24
                   const IPV4Parameters_t * pxIPv4Settings = &( pxNetworkBuffer->pxEndPoint->ipv4_settings );
 80064ae:	6b24      	ldr	r4, [r4, #48]	@ 0x30
                   if( ( pxIPHeader->ulSourceIPAddress & pxIPv4Settings->ulNetMask ) == ( pxIPv4Settings->ulIPAddress & pxIPv4Settings->ulNetMask ) )
 80064b0:	f8d3 501a 	ldr.w	r5, [r3, #26]
 80064b4:	6823      	ldr	r3, [r4, #0]
 80064b6:	6862      	ldr	r2, [r4, #4]
 80064b8:	406b      	eors	r3, r5
 80064ba:	4213      	tst	r3, r2
 80064bc:	d139      	bne.n	8006532 <xCheckRequiresARPResolution+0x9e>
                       if( xIsIPInARPCache( pxIPHeader->ulSourceIPAddress ) == pdFALSE )
 80064be:	4628      	mov	r0, r5
 80064c0:	f7ff fd40 	bl	8005f44 <xIsIPInARPCache>
 80064c4:	b108      	cbz	r0, 80064ca <xCheckRequiresARPResolution+0x36>
    BaseType_t xNeedsARPResolution = pdFALSE;
 80064c6:	2000      	movs	r0, #0
 80064c8:	e7ee      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
                           FreeRTOS_OutputARPRequest_Multi( pxNetworkBuffer->pxEndPoint, pxIPHeader->ulSourceIPAddress );
 80064ca:	4629      	mov	r1, r5
 80064cc:	4620      	mov	r0, r4
 80064ce:	f7ff fed7 	bl	8006280 <FreeRTOS_OutputARPRequest_Multi>
                           xNeedsARPResolution = pdTRUE;
 80064d2:	2001      	movs	r0, #1
 80064d4:	e7e8      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
                   IPPacket_IPv6_t * pxIPPacket = ( ( IPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80064d6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
                   IPv6_Address_t * pxIPAddress = &( pxIPHeader->xSourceAddress );
 80064d8:	f103 0516 	add.w	r5, r3, #22
                   uint8_t ucNextHeader = pxIPHeader->ucNextHeader;
 80064dc:	7d1b      	ldrb	r3, [r3, #20]
                   if( ( ucNextHeader == ipPROTOCOL_TCP ) ||
 80064de:	2b06      	cmp	r3, #6
 80064e0:	d003      	beq.n	80064ea <xCheckRequiresARPResolution+0x56>
 80064e2:	2b11      	cmp	r3, #17
 80064e4:	d001      	beq.n	80064ea <xCheckRequiresARPResolution+0x56>
    BaseType_t xNeedsARPResolution = pdFALSE;
 80064e6:	2000      	movs	r0, #0
 80064e8:	e7de      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
                       IPv6_Type_t eType = xIPv6_GetIPType( ( const IPv6_Address_t * ) pxIPAddress );
 80064ea:	4628      	mov	r0, r5
 80064ec:	f003 fb8c 	bl	8009c08 <xIPv6_GetIPType>
                       if( eType == eIPv6_LinkLocal )
 80064f0:	2801      	cmp	r0, #1
 80064f2:	d001      	beq.n	80064f8 <xCheckRequiresARPResolution+0x64>
    BaseType_t xNeedsARPResolution = pdFALSE;
 80064f4:	2000      	movs	r0, #0
    return xNeedsARPResolution;
 80064f6:	e7d7      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
                           ( void ) memset( &( pcName ), 0, sizeof( pcName ) );
 80064f8:	2250      	movs	r2, #80	@ 0x50
 80064fa:	2100      	movs	r1, #0
 80064fc:	a804      	add	r0, sp, #16
 80064fe:	f008 fbd9 	bl	800ecb4 <memset>
                           eResult = eNDGetCacheEntry( pxIPAddress, &xMACAddress, &pxEndPoint );
 8006502:	aa01      	add	r2, sp, #4
 8006504:	a902      	add	r1, sp, #8
 8006506:	4628      	mov	r0, r5
 8006508:	f002 fc88 	bl	8008e1c <eNDGetCacheEntry>
                           if( eResult == eARPCacheMiss )
 800650c:	b108      	cbz	r0, 8006512 <xCheckRequiresARPResolution+0x7e>
    BaseType_t xNeedsARPResolution = pdFALSE;
 800650e:	2000      	movs	r0, #0
 8006510:	e7ca      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
                               pxTempBuffer = pxGetNetworkBufferWithDescriptor( BUFFER_FROM_WHERE_CALL( 199 ) uxNeededSize, 0U );
 8006512:	2100      	movs	r1, #0
 8006514:	2056      	movs	r0, #86	@ 0x56
 8006516:	f008 f8e9 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
                               if( pxTempBuffer != NULL )
 800651a:	b140      	cbz	r0, 800652e <xCheckRequiresARPResolution+0x9a>
                                   pxTempBuffer->pxEndPoint = pxNetworkBuffer->pxEndPoint;
 800651c:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800651e:	6302      	str	r2, [r0, #48]	@ 0x30
                                   pxTempBuffer->pxInterface = pxNetworkBuffer->pxInterface;
 8006520:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8006522:	62c2      	str	r2, [r0, #44]	@ 0x2c
                                   vNDSendNeighbourSolicitation( pxTempBuffer, pxIPAddress );
 8006524:	4629      	mov	r1, r5
 8006526:	f002 fd25 	bl	8008f74 <vNDSendNeighbourSolicitation>
                               xNeedsARPResolution = pdTRUE;
 800652a:	2001      	movs	r0, #1
 800652c:	e7bc      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
 800652e:	2001      	movs	r0, #1
 8006530:	e7ba      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>
    BaseType_t xNeedsARPResolution = pdFALSE;
 8006532:	2000      	movs	r0, #0
 8006534:	e7b8      	b.n	80064a8 <xCheckRequiresARPResolution+0x14>

08006536 <FreeRTOS_OutputARPRequest>:
    {
 8006536:	b510      	push	{r4, lr}
 8006538:	4604      	mov	r4, r0
        NetworkEndPoint_t * pxEndPoint = FreeRTOS_FindEndPointOnNetMask( ulIPAddress, 12 );
 800653a:	210c      	movs	r1, #12
 800653c:	f003 fb0e 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
        if( pxEndPoint != NULL )
 8006540:	b110      	cbz	r0, 8006548 <FreeRTOS_OutputARPRequest+0x12>
            FreeRTOS_OutputARPRequest_Multi( pxEndPoint, ulIPAddress );
 8006542:	4621      	mov	r1, r4
 8006544:	f7ff fe9c 	bl	8006280 <FreeRTOS_OutputARPRequest_Multi>
    }
 8006548:	bd10      	pop	{r4, pc}
	...

0800654c <vARPAgeCache>:
    {
 800654c:	b538      	push	{r3, r4, r5, lr}
        for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 800654e:	2400      	movs	r4, #0
 8006550:	e00e      	b.n	8006570 <vARPAgeCache+0x24>
                    FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 8006552:	0123      	lsls	r3, r4, #4
 8006554:	4a28      	ldr	r2, [pc, #160]	@ (80065f8 <vARPAgeCache+0xac>)
 8006556:	58d0      	ldr	r0, [r2, r3]
 8006558:	f7ff ffed 	bl	8006536 <FreeRTOS_OutputARPRequest>
                if( xARPCache[ x ].ucAge == 0U )
 800655c:	4b26      	ldr	r3, [pc, #152]	@ (80065f8 <vARPAgeCache+0xac>)
 800655e:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 8006562:	7a9b      	ldrb	r3, [r3, #10]
 8006564:	b91b      	cbnz	r3, 800656e <vARPAgeCache+0x22>
                    xARPCache[ x ].ulIPAddress = 0U;
 8006566:	0123      	lsls	r3, r4, #4
 8006568:	4a23      	ldr	r2, [pc, #140]	@ (80065f8 <vARPAgeCache+0xac>)
 800656a:	2100      	movs	r1, #0
 800656c:	50d1      	str	r1, [r2, r3]
        for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 800656e:	3401      	adds	r4, #1
 8006570:	2c05      	cmp	r4, #5
 8006572:	dc16      	bgt.n	80065a2 <vARPAgeCache+0x56>
            if( xARPCache[ x ].ucAge > 0U )
 8006574:	4b20      	ldr	r3, [pc, #128]	@ (80065f8 <vARPAgeCache+0xac>)
 8006576:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 800657a:	7a9b      	ldrb	r3, [r3, #10]
 800657c:	2b00      	cmp	r3, #0
 800657e:	d0f6      	beq.n	800656e <vARPAgeCache+0x22>
                ( xARPCache[ x ].ucAge )--;
 8006580:	3b01      	subs	r3, #1
 8006582:	b2db      	uxtb	r3, r3
 8006584:	4a1c      	ldr	r2, [pc, #112]	@ (80065f8 <vARPAgeCache+0xac>)
 8006586:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 800658a:	7293      	strb	r3, [r2, #10]
                if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 800658c:	7ad2      	ldrb	r2, [r2, #11]
 800658e:	2a00      	cmp	r2, #0
 8006590:	d0df      	beq.n	8006552 <vARPAgeCache+0x6>
                else if( xARPCache[ x ].ucAge <= ( uint8_t ) arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST )
 8006592:	2b03      	cmp	r3, #3
 8006594:	d8e2      	bhi.n	800655c <vARPAgeCache+0x10>
                    FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 8006596:	0123      	lsls	r3, r4, #4
 8006598:	4a17      	ldr	r2, [pc, #92]	@ (80065f8 <vARPAgeCache+0xac>)
 800659a:	58d0      	ldr	r0, [r2, r3]
 800659c:	f7ff ffcb 	bl	8006536 <FreeRTOS_OutputARPRequest>
 80065a0:	e7dc      	b.n	800655c <vARPAgeCache+0x10>
        xTimeNow = xTaskGetTickCount();
 80065a2:	f7fe fb3f 	bl	8004c24 <xTaskGetTickCount>
 80065a6:	4605      	mov	r5, r0
        if( ( xLastGratuitousARPTime == ( TickType_t ) 0 ) || ( ( xTimeNow - xLastGratuitousARPTime ) > ( TickType_t ) arpGRATUITOUS_ARP_PERIOD ) )
 80065a8:	4b14      	ldr	r3, [pc, #80]	@ (80065fc <vARPAgeCache+0xb0>)
 80065aa:	681b      	ldr	r3, [r3, #0]
 80065ac:	b123      	cbz	r3, 80065b8 <vARPAgeCache+0x6c>
 80065ae:	1ac3      	subs	r3, r0, r3
 80065b0:	f644 6220 	movw	r2, #20000	@ 0x4e20
 80065b4:	4293      	cmp	r3, r2
 80065b6:	d91d      	bls.n	80065f4 <vARPAgeCache+0xa8>
            NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 80065b8:	4b11      	ldr	r3, [pc, #68]	@ (8006600 <vARPAgeCache+0xb4>)
 80065ba:	681c      	ldr	r4, [r3, #0]
            while( pxEndPoint != NULL )
 80065bc:	e004      	b.n	80065c8 <vARPAgeCache+0x7c>
                                FreeRTOS_OutputARPRequest_Multi( pxEndPoint, pxEndPoint->ipv4_settings.ulIPAddress );
 80065be:	4620      	mov	r0, r4
 80065c0:	f7ff fe5e 	bl	8006280 <FreeRTOS_OutputARPRequest_Multi>
                pxEndPoint = pxEndPoint->pxNext;
 80065c4:	f8d4 415c 	ldr.w	r4, [r4, #348]	@ 0x15c
            while( pxEndPoint != NULL )
 80065c8:	b194      	cbz	r4, 80065f0 <vARPAgeCache+0xa4>
                if( ( pxEndPoint->bits.bEndPointUp != pdFALSE_UNSIGNED ) && ( pxEndPoint->ipv4_settings.ulIPAddress != 0U ) )
 80065ca:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 80065ce:	f013 0f20 	tst.w	r3, #32
 80065d2:	d0f7      	beq.n	80065c4 <vARPAgeCache+0x78>
 80065d4:	6821      	ldr	r1, [r4, #0]
 80065d6:	2900      	cmp	r1, #0
 80065d8:	d0f4      	beq.n	80065c4 <vARPAgeCache+0x78>
                    switch( pxEndPoint->bits.bIPv6 ) /* LCOV_EXCL_BR_LINE */
 80065da:	f3c3 02c0 	ubfx	r2, r3, #3, #1
 80065de:	f013 0f08 	tst.w	r3, #8
 80065e2:	d0ec      	beq.n	80065be <vARPAgeCache+0x72>
 80065e4:	2a00      	cmp	r2, #0
 80065e6:	d0ed      	beq.n	80065c4 <vARPAgeCache+0x78>
                                FreeRTOS_OutputAdvertiseIPv6( pxEndPoint );
 80065e8:	4620      	mov	r0, r4
 80065ea:	f002 fe3d 	bl	8009268 <FreeRTOS_OutputAdvertiseIPv6>
                                break;
 80065ee:	e7e9      	b.n	80065c4 <vARPAgeCache+0x78>
            xLastGratuitousARPTime = xTimeNow;
 80065f0:	4b02      	ldr	r3, [pc, #8]	@ (80065fc <vARPAgeCache+0xb0>)
 80065f2:	601d      	str	r5, [r3, #0]
    }
 80065f4:	bd38      	pop	{r3, r4, r5, pc}
 80065f6:	bf00      	nop
 80065f8:	20011ab0 	.word	0x20011ab0
 80065fc:	20011aac 	.word	0x20011aac
 8006600:	20013778 	.word	0x20013778

08006604 <FreeRTOS_ClearARP>:
 * @brief A call to this function will clear the ARP cache.
 * @param[in] pxEndPoint only clean entries with this end-point, or when NULL,
 *                        clear the entire ARP cache.
 */
void FreeRTOS_ClearARP( const struct xNetworkEndPoint * pxEndPoint )
{
 8006604:	b510      	push	{r4, lr}
    if( pxEndPoint != NULL )
 8006606:	b1b8      	cbz	r0, 8006638 <FreeRTOS_ClearARP+0x34>
 8006608:	4601      	mov	r1, r0
    {
        BaseType_t x;

        for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 800660a:	2300      	movs	r3, #0
 800660c:	e000      	b.n	8006610 <FreeRTOS_ClearARP+0xc>
 800660e:	3301      	adds	r3, #1
 8006610:	2b05      	cmp	r3, #5
 8006612:	dc16      	bgt.n	8006642 <FreeRTOS_ClearARP+0x3e>
        {
            if( xARPCache[ x ].pxEndPoint == pxEndPoint )
 8006614:	4a0b      	ldr	r2, [pc, #44]	@ (8006644 <FreeRTOS_ClearARP+0x40>)
 8006616:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 800661a:	68d2      	ldr	r2, [r2, #12]
 800661c:	428a      	cmp	r2, r1
 800661e:	d1f6      	bne.n	800660e <FreeRTOS_ClearARP+0xa>
            {
                ( void ) memset( &( xARPCache[ x ] ), 0, sizeof( ARPCacheRow_t ) );
 8006620:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 8006624:	4c07      	ldr	r4, [pc, #28]	@ (8006644 <FreeRTOS_ClearARP+0x40>)
 8006626:	eb04 1003 	add.w	r0, r4, r3, lsl #4
 800662a:	2200      	movs	r2, #0
 800662c:	f844 200c 	str.w	r2, [r4, ip]
 8006630:	6042      	str	r2, [r0, #4]
 8006632:	6082      	str	r2, [r0, #8]
 8006634:	60c2      	str	r2, [r0, #12]
 8006636:	e7ea      	b.n	800660e <FreeRTOS_ClearARP+0xa>
            }
        }
    }
    else
    {
        ( void ) memset( xARPCache, 0, sizeof( xARPCache ) );
 8006638:	2260      	movs	r2, #96	@ 0x60
 800663a:	2100      	movs	r1, #0
 800663c:	4801      	ldr	r0, [pc, #4]	@ (8006644 <FreeRTOS_ClearARP+0x40>)
 800663e:	f008 fb39 	bl	800ecb4 <memset>
    }
}
 8006642:	bd10      	pop	{r4, pc}
 8006644:	20011ab0 	.word	0x20011ab0

08006648 <vProcessHandleOption>:
                                      ProcessSet_t * pxSet,
                                      BaseType_t xExpectedMessageType )
    {
        /* Option-specific handling. */

        switch( pxSet->ucOptionCode )
 8006648:	780b      	ldrb	r3, [r1, #0]
 800664a:	2b33      	cmp	r3, #51	@ 0x33
 800664c:	d070      	beq.n	8006730 <vProcessHandleOption+0xe8>
    {
 800664e:	b530      	push	{r4, r5, lr}
        switch( pxSet->ucOptionCode )
 8006650:	d80b      	bhi.n	800666a <vProcessHandleOption+0x22>
 8006652:	2b03      	cmp	r3, #3
 8006654:	d030      	beq.n	80066b8 <vProcessHandleOption+0x70>
 8006656:	2b06      	cmp	r3, #6
 8006658:	d034      	beq.n	80066c4 <vProcessHandleOption+0x7c>
 800665a:	2b01      	cmp	r3, #1
 800665c:	d121      	bne.n	80066a2 <vProcessHandleOption+0x5a>

                break;

            case dhcpIPv4_SUBNET_MASK_OPTION_CODE:

                if( pxSet->uxLength == sizeof( uint32_t ) )
 800665e:	68cb      	ldr	r3, [r1, #12]
 8006660:	2b04      	cmp	r3, #4
 8006662:	d11e      	bne.n	80066a2 <vProcessHandleOption+0x5a>
                {
                    EP_IPv4_SETTINGS.ulNetMask = pxSet->ulParameter;
 8006664:	690b      	ldr	r3, [r1, #16]
 8006666:	6043      	str	r3, [r0, #4]
 8006668:	e01b      	b.n	80066a2 <vProcessHandleOption+0x5a>
        switch( pxSet->ucOptionCode )
 800666a:	2b35      	cmp	r3, #53	@ 0x35
 800666c:	d00f      	beq.n	800668e <vProcessHandleOption+0x46>
 800666e:	2b36      	cmp	r3, #54	@ 0x36
 8006670:	d117      	bne.n	80066a2 <vProcessHandleOption+0x5a>

                break;

            case dhcpIPv4_SERVER_IP_ADDRESS_OPTION_CODE:

                if( pxSet->uxLength == sizeof( uint32_t ) )
 8006672:	68cb      	ldr	r3, [r1, #12]
 8006674:	2b04      	cmp	r3, #4
 8006676:	d114      	bne.n	80066a2 <vProcessHandleOption+0x5a>
                {
                    if( xExpectedMessageType == ( BaseType_t ) dhcpMESSAGE_TYPE_OFFER )
 8006678:	2a02      	cmp	r2, #2
 800667a:	d052      	beq.n	8006722 <vProcessHandleOption+0xda>
                        EP_DHCPData.ulDHCPServerAddress = pxSet->ulParameter;
                    }
                    else
                    {
                        /* The ack must come from the expected server. */
                        if( EP_DHCPData.ulDHCPServerAddress == pxSet->ulParameter )
 800667c:	f8d0 2118 	ldr.w	r2, [r0, #280]	@ 0x118
 8006680:	690b      	ldr	r3, [r1, #16]
 8006682:	429a      	cmp	r2, r3
 8006684:	d10d      	bne.n	80066a2 <vProcessHandleOption+0x5a>
                        {
                            pxSet->ulProcessed++;
 8006686:	694b      	ldr	r3, [r1, #20]
 8006688:	3301      	adds	r3, #1
 800668a:	614b      	str	r3, [r1, #20]
 800668c:	e009      	b.n	80066a2 <vProcessHandleOption+0x5a>
                if( pxSet->pucByte[ pxSet->uxIndex ] == ( uint8_t ) xExpectedMessageType )
 800668e:	698c      	ldr	r4, [r1, #24]
 8006690:	684b      	ldr	r3, [r1, #4]
 8006692:	5ce3      	ldrb	r3, [r4, r3]
 8006694:	b2d4      	uxtb	r4, r2
 8006696:	42a3      	cmp	r3, r4
 8006698:	d004      	beq.n	80066a4 <vProcessHandleOption+0x5c>
                    if( pxSet->pucByte[ pxSet->uxIndex ] == ( uint8_t ) dhcpMESSAGE_TYPE_NACK )
 800669a:	2b06      	cmp	r3, #6
 800669c:	d006      	beq.n	80066ac <vProcessHandleOption+0x64>
                    pxSet->uxLength = 0;
 800669e:	2300      	movs	r3, #0
 80066a0:	60cb      	str	r3, [r1, #12]

                /* Not interested in this field. */

                break;
        }
    }
 80066a2:	bd30      	pop	{r4, r5, pc}
                    pxSet->ulProcessed++;
 80066a4:	694b      	ldr	r3, [r1, #20]
 80066a6:	3301      	adds	r3, #1
 80066a8:	614b      	str	r3, [r1, #20]
 80066aa:	e7fa      	b.n	80066a2 <vProcessHandleOption+0x5a>
                        if( xExpectedMessageType == ( BaseType_t ) dhcpMESSAGE_TYPE_ACK )
 80066ac:	2a05      	cmp	r2, #5
 80066ae:	d1f6      	bne.n	800669e <vProcessHandleOption+0x56>
                            EP_DHCPData.eDHCPState = eInitialWait;
 80066b0:	2300      	movs	r3, #0
 80066b2:	f880 312c 	strb.w	r3, [r0, #300]	@ 0x12c
 80066b6:	e7f2      	b.n	800669e <vProcessHandleOption+0x56>
                if( pxSet->uxLength >= sizeof( uint32_t ) )
 80066b8:	68cb      	ldr	r3, [r1, #12]
 80066ba:	2b03      	cmp	r3, #3
 80066bc:	d9f1      	bls.n	80066a2 <vProcessHandleOption+0x5a>
                    EP_IPv4_SETTINGS.ulGatewayAddress = pxSet->ulParameter;
 80066be:	690b      	ldr	r3, [r1, #16]
 80066c0:	6083      	str	r3, [r0, #8]
 80066c2:	e7ee      	b.n	80066a2 <vProcessHandleOption+0x5a>
                if( pxSet->uxLength >= sizeof( uint32_t ) )
 80066c4:	68cb      	ldr	r3, [r1, #12]
 80066c6:	2b03      	cmp	r3, #3
 80066c8:	d9eb      	bls.n	80066a2 <vProcessHandleOption+0x5a>
                    size_t uxDNSCount = pxSet->uxLength / sizeof( uint32_t );
 80066ca:	089d      	lsrs	r5, r3, #2
                    size_t uxByteIndex = pxSet->uxIndex;
 80066cc:	684c      	ldr	r4, [r1, #4]
                    if( uxDNSCount > ipconfigENDPOINT_DNS_ADDRESS_COUNT )
 80066ce:	2b0b      	cmp	r3, #11
 80066d0:	d900      	bls.n	80066d4 <vProcessHandleOption+0x8c>
                        uxDNSCount = ipconfigENDPOINT_DNS_ADDRESS_COUNT;
 80066d2:	2502      	movs	r5, #2
                    size_t uxTargetIndex = 0;
 80066d4:	f04f 0c00 	mov.w	ip, #0
                    for( uxSourceIndex = 0U; uxSourceIndex < uxDNSCount; uxSourceIndex++ )
 80066d8:	4662      	mov	r2, ip
 80066da:	e001      	b.n	80066e0 <vProcessHandleOption+0x98>
                        uxByteIndex += sizeof( uint32_t );
 80066dc:	3404      	adds	r4, #4
                    for( uxSourceIndex = 0U; uxSourceIndex < uxDNSCount; uxSourceIndex++ )
 80066de:	3201      	adds	r2, #1
 80066e0:	42aa      	cmp	r2, r5
 80066e2:	d218      	bcs.n	8006716 <vProcessHandleOption+0xce>
                        const void * pvCopySource = &( pxSet->pucByte[ uxByteIndex ] );
 80066e4:	698b      	ldr	r3, [r1, #24]
                        ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxSet->ulParameter ) );
 80066e6:	591b      	ldr	r3, [r3, r4]
 80066e8:	610b      	str	r3, [r1, #16]
                        if( ( pxSet->ulParameter != FREERTOS_INADDR_ANY ) && ( pxSet->ulParameter != ipBROADCAST_IP_ADDRESS ) )
 80066ea:	f103 3eff 	add.w	lr, r3, #4294967295
 80066ee:	f11e 0f03 	cmn.w	lr, #3
 80066f2:	d8f3      	bhi.n	80066dc <vProcessHandleOption+0x94>
                            EP_IPv4_SETTINGS.ulDNSServerAddresses[ uxTargetIndex ] = pxSet->ulParameter;
 80066f4:	f10c 0e02 	add.w	lr, ip, #2
 80066f8:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
 80066fc:	f8ce 3004 	str.w	r3, [lr, #4]
                            uxTargetIndex++;
 8006700:	f10c 0c01 	add.w	ip, ip, #1
 8006704:	e7ea      	b.n	80066dc <vProcessHandleOption+0x94>
                        EP_IPv4_SETTINGS.ulDNSServerAddresses[ uxTargetIndex ] = 0U;
 8006706:	f10c 0302 	add.w	r3, ip, #2
 800670a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800670e:	2200      	movs	r2, #0
 8006710:	605a      	str	r2, [r3, #4]
                        uxTargetIndex++;
 8006712:	f10c 0c01 	add.w	ip, ip, #1
                    while( uxTargetIndex < ipconfigENDPOINT_DNS_ADDRESS_COUNT )
 8006716:	f1bc 0f01 	cmp.w	ip, #1
 800671a:	d9f4      	bls.n	8006706 <vProcessHandleOption+0xbe>
                    EP_IPv4_SETTINGS.ucDNSIndex = 0U;
 800671c:	2300      	movs	r3, #0
 800671e:	7603      	strb	r3, [r0, #24]
 8006720:	e7bf      	b.n	80066a2 <vProcessHandleOption+0x5a>
                        pxSet->ulProcessed++;
 8006722:	694b      	ldr	r3, [r1, #20]
 8006724:	3301      	adds	r3, #1
 8006726:	614b      	str	r3, [r1, #20]
                        EP_DHCPData.ulDHCPServerAddress = pxSet->ulParameter;
 8006728:	690b      	ldr	r3, [r1, #16]
 800672a:	f8c0 3118 	str.w	r3, [r0, #280]	@ 0x118
 800672e:	e7b8      	b.n	80066a2 <vProcessHandleOption+0x5a>
                if( pxSet->uxLength == sizeof( EP_DHCPData.ulLeaseTime ) )
 8006730:	68cb      	ldr	r3, [r1, #12]
 8006732:	2b04      	cmp	r3, #4
 8006734:	d000      	beq.n	8006738 <vProcessHandleOption+0xf0>
 8006736:	4770      	bx	lr
                    EP_DHCPData.ulLeaseTime = FreeRTOS_ntohl( pxSet->ulParameter );
 8006738:	690a      	ldr	r2, [r1, #16]
 800673a:	0213      	lsls	r3, r2, #8
 800673c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8006740:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8006744:	0a11      	lsrs	r1, r2, #8
 8006746:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800674a:	430b      	orrs	r3, r1
 800674c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8006750:	f8c0 311c 	str.w	r3, [r0, #284]	@ 0x11c
                    EP_DHCPData.ulLeaseTime >>= 1U;
 8006754:	085b      	lsrs	r3, r3, #1
 8006756:	f8c0 311c 	str.w	r3, [r0, #284]	@ 0x11c
                    EP_DHCPData.ulLeaseTime = ( uint32_t ) configTICK_RATE_HZ * ( uint32_t ) EP_DHCPData.ulLeaseTime;
 800675a:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800675e:	fb02 f303 	mul.w	r3, r2, r3
 8006762:	f8c0 311c 	str.w	r3, [r0, #284]	@ 0x11c
    }
 8006766:	4770      	bx	lr

08006768 <prvIsValidDHCPResponse>:
 */
    static BaseType_t prvIsValidDHCPResponse( const DHCPMessage_IPv4_t * pxDHCPMessage )
    {
        BaseType_t xReturn = pdPASS;

        if( ( pxDHCPMessage->ulDHCPCookie != ( uint32_t ) dhcpCOOKIE ) ||
 8006768:	f8d0 20ec 	ldr.w	r2, [r0, #236]	@ 0xec
 800676c:	4b10      	ldr	r3, [pc, #64]	@ (80067b0 <prvIsValidDHCPResponse+0x48>)
 800676e:	429a      	cmp	r2, r3
 8006770:	d001      	beq.n	8006776 <prvIsValidDHCPResponse+0xe>
             * Unexpected opcode OR
             * Incorrect address type OR
             * Incorrect address length OR
             * The DHCP server is trying to assign a broadcast address to the device OR
             * The DHCP server is trying to assign a localhost address to the device. */
            xReturn = pdFAIL;
 8006772:	2000      	movs	r0, #0
 8006774:	4770      	bx	lr
            ( pxDHCPMessage->ucOpcode != ( uint8_t ) dhcpREPLY_OPCODE ) ||
 8006776:	7803      	ldrb	r3, [r0, #0]
        if( ( pxDHCPMessage->ulDHCPCookie != ( uint32_t ) dhcpCOOKIE ) ||
 8006778:	2b02      	cmp	r3, #2
 800677a:	d001      	beq.n	8006780 <prvIsValidDHCPResponse+0x18>
            xReturn = pdFAIL;
 800677c:	2000      	movs	r0, #0
 800677e:	4770      	bx	lr
            ( pxDHCPMessage->ucAddressType != ( uint8_t ) dhcpADDRESS_TYPE_ETHERNET ) ||
 8006780:	7843      	ldrb	r3, [r0, #1]
            ( pxDHCPMessage->ucOpcode != ( uint8_t ) dhcpREPLY_OPCODE ) ||
 8006782:	2b01      	cmp	r3, #1
 8006784:	d001      	beq.n	800678a <prvIsValidDHCPResponse+0x22>
            xReturn = pdFAIL;
 8006786:	2000      	movs	r0, #0
 8006788:	4770      	bx	lr
            ( pxDHCPMessage->ucAddressLength != ( uint8_t ) dhcpETHERNET_ADDRESS_LENGTH ) ||
 800678a:	7883      	ldrb	r3, [r0, #2]
            ( pxDHCPMessage->ucAddressType != ( uint8_t ) dhcpADDRESS_TYPE_ETHERNET ) ||
 800678c:	2b06      	cmp	r3, #6
 800678e:	d001      	beq.n	8006794 <prvIsValidDHCPResponse+0x2c>
            xReturn = pdFAIL;
 8006790:	2000      	movs	r0, #0
 8006792:	4770      	bx	lr
            ( ( FreeRTOS_ntohl( pxDHCPMessage->ulYourIPAddress_yiaddr ) & 0xFFU ) == 0xFFU ) ||
 8006794:	6903      	ldr	r3, [r0, #16]
 8006796:	0e1a      	lsrs	r2, r3, #24
            ( pxDHCPMessage->ucAddressLength != ( uint8_t ) dhcpETHERNET_ADDRESS_LENGTH ) ||
 8006798:	2aff      	cmp	r2, #255	@ 0xff
 800679a:	d005      	beq.n	80067a8 <prvIsValidDHCPResponse+0x40>
            ( ( ( pxDHCPMessage->ulYourIPAddress_yiaddr & 0x7FU ) ^ 0x7FU ) == 0x00U ) )
 800679c:	43db      	mvns	r3, r3
            ( ( FreeRTOS_ntohl( pxDHCPMessage->ulYourIPAddress_yiaddr ) & 0xFFU ) == 0xFFU ) ||
 800679e:	f013 0f7f 	tst.w	r3, #127	@ 0x7f
 80067a2:	d003      	beq.n	80067ac <prvIsValidDHCPResponse+0x44>
        BaseType_t xReturn = pdPASS;
 80067a4:	2001      	movs	r0, #1
 80067a6:	4770      	bx	lr
            xReturn = pdFAIL;
 80067a8:	2000      	movs	r0, #0
 80067aa:	4770      	bx	lr
 80067ac:	2000      	movs	r0, #0
        }

        return xReturn;
    }
 80067ae:	4770      	bx	lr
 80067b0:	63538263 	.word	0x63538263

080067b4 <xProcessCheckOption>:
    {
        BaseType_t xResult = -1;

        do
        {
            if( pxSet->ucOptionCode == ( uint8_t ) dhcpOPTION_END_BYTE )
 80067b4:	7803      	ldrb	r3, [r0, #0]
 80067b6:	2bff      	cmp	r3, #255	@ 0xff
 80067b8:	d020      	beq.n	80067fc <xProcessCheckOption+0x48>
                /* Ready, the last byte has been seen.
                 * Return -1 so that the parsing will stop. */
                break;
            }

            if( pxSet->ucOptionCode == ( uint8_t ) dhcpIPv4_ZERO_PAD_OPTION_CODE )
 80067ba:	b923      	cbnz	r3, 80067c6 <xProcessCheckOption+0x12>
            {
                /* The value zero is used as a pad byte,
                 * it is not followed by a length byte. */
                pxSet->uxIndex++;
 80067bc:	6843      	ldr	r3, [r0, #4]
 80067be:	3301      	adds	r3, #1
 80067c0:	6043      	str	r3, [r0, #4]
                /* Return zero to skip this option. */
                xResult = 0;
 80067c2:	2000      	movs	r0, #0
                break;
 80067c4:	4770      	bx	lr
            }

            /* Stop if the response is malformed. */
            if( ( pxSet->uxIndex + 1U ) >= pxSet->uxPayloadDataLength )
 80067c6:	6843      	ldr	r3, [r0, #4]
 80067c8:	1c59      	adds	r1, r3, #1
 80067ca:	6882      	ldr	r2, [r0, #8]
 80067cc:	4291      	cmp	r1, r2
 80067ce:	d218      	bcs.n	8006802 <xProcessCheckOption+0x4e>
    {
 80067d0:	b430      	push	{r4, r5}
                /* The length byte is missing, stop parsing. */
                break;
            }

            /* Fetch the length byte. */
            pxSet->uxLength = ( size_t ) pxSet->pucByte[ pxSet->uxIndex + 1U ];
 80067d2:	6985      	ldr	r5, [r0, #24]
 80067d4:	5c6c      	ldrb	r4, [r5, r1]
 80067d6:	60c4      	str	r4, [r0, #12]
            pxSet->uxIndex = pxSet->uxIndex + 2U;
 80067d8:	3302      	adds	r3, #2
 80067da:	6043      	str	r3, [r0, #4]

            if( !( ( ( pxSet->uxIndex + pxSet->uxLength ) - 1U ) < pxSet->uxPayloadDataLength ) )
 80067dc:	18e1      	adds	r1, r4, r3
 80067de:	3901      	subs	r1, #1
 80067e0:	428a      	cmp	r2, r1
 80067e2:	d911      	bls.n	8006808 <xProcessCheckOption+0x54>
                break;
            }

            /* In most cases, a 4-byte network-endian parameter follows,
             * just get it once here and use later. */
            if( pxSet->uxLength >= sizeof( pxSet->ulParameter ) )
 80067e4:	2c03      	cmp	r4, #3
 80067e6:	d906      	bls.n	80067f6 <xProcessCheckOption+0x42>
                 * compliant with MISRA Rule 21.15.  These should be
                 * optimized away.
                 */
                const void * pvCopySource = &( pxSet->pucByte[ pxSet->uxIndex ] );
                void * pvCopyDest = &( pxSet->ulParameter );
                ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxSet->ulParameter ) );
 80067e8:	58e9      	ldr	r1, [r5, r3]
 80067ea:	6101      	str	r1, [r0, #16]
            {
                pxSet->ulParameter = 0;
            }

            /* Confirm uxIndex is still a valid index after adjustments to uxIndex above */
            if( !( pxSet->uxIndex < pxSet->uxPayloadDataLength ) )
 80067ec:	429a      	cmp	r2, r3
 80067ee:	d80f      	bhi.n	8006810 <xProcessCheckOption+0x5c>
        BaseType_t xResult = -1;
 80067f0:	f04f 30ff 	mov.w	r0, #4294967295
 80067f4:	e00a      	b.n	800680c <xProcessCheckOption+0x58>
                pxSet->ulParameter = 0;
 80067f6:	2100      	movs	r1, #0
 80067f8:	6101      	str	r1, [r0, #16]
 80067fa:	e7f7      	b.n	80067ec <xProcessCheckOption+0x38>
        BaseType_t xResult = -1;
 80067fc:	f04f 30ff 	mov.w	r0, #4294967295
 8006800:	4770      	bx	lr
 8006802:	f04f 30ff 	mov.w	r0, #4294967295
            /* Try to please CBMC with a break statement here. */
            break;
        } while( ipFALSE_BOOL );

        return xResult;
    }
 8006806:	4770      	bx	lr
        BaseType_t xResult = -1;
 8006808:	f04f 30ff 	mov.w	r0, #4294967295
    }
 800680c:	bc30      	pop	{r4, r5}
 800680e:	4770      	bx	lr
            xResult = 1;
 8006810:	2001      	movs	r0, #1
        return xResult;
 8006812:	e7fb      	b.n	800680c <xProcessCheckOption+0x58>

08006814 <prvCreatePartDHCPMessage>:
    static uint8_t * prvCreatePartDHCPMessage( struct freertos_sockaddr * pxAddress,
                                               BaseType_t xOpcode,
                                               const uint8_t * const pucOptionsArray,
                                               size_t * pxOptionsArraySize,
                                               const NetworkEndPoint_t * pxEndPoint )
    {
 8006814:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006818:	4606      	mov	r6, r0
 800681a:	468a      	mov	sl, r1
 800681c:	4691      	mov	r9, r2
 800681e:	461f      	mov	r7, r3
 8006820:	9d08      	ldr	r5, [sp, #32]
        DHCPMessage_IPv4_t * pxDHCPMessage;
        size_t uxRequiredBufferSize = sizeof( DHCPMessage_IPv4_t ) + *pxOptionsArraySize;
 8006822:	6818      	ldr	r0, [r3, #0]
            uxRequiredBufferSize += ( 2U + uxNameLength );
        #endif /* if ( ipconfigDHCP_REGISTER_HOSTNAME == 1 ) */

        /* Obtain a network buffer with the required amount of storage.  It doesn't make much sense
         * to use a time-out here, because that would cause the IP-task to wait for itself. */
        pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( UDPPacket_t ) + uxRequiredBufferSize, 0U );
 8006824:	2100      	movs	r1, #0
 8006826:	f500 708d 	add.w	r0, r0, #282	@ 0x11a
 800682a:	f007 ff5f 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>

        if( pxNetworkBuffer != NULL )
 800682e:	4680      	mov	r8, r0
 8006830:	2800      	cmp	r0, #0
 8006832:	d057      	beq.n	80068e4 <prvCreatePartDHCPMessage+0xd0>
        {
            uint8_t * pucIPType;

            /* Leave space for the UDP header. */
            pucUDPPayloadBuffer = &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] );
 8006834:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 8006836:	f104 082a 	add.w	r8, r4, #42	@ 0x2a

            /* MISRA Ref 18.4.1 [Usage of +, -, += and -= operators on expression of pointer type]. */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-184. */
            /* coverity[misra_c_2012_rule_18_4_violation] */
            pucIPType = pucUDPPayloadBuffer - ipUDP_PAYLOAD_IP_TYPE_OFFSET;
            *pucIPType = ipTYPE_IPv4;
 800683a:	2340      	movs	r3, #64	@ 0x40
 800683c:	f804 3c06 	strb.w	r3, [r4, #-6]

            /* Most fields need to be zero. */
            ( void ) memset( pxDHCPMessage, 0x00, sizeof( DHCPMessage_IPv4_t ) );
 8006840:	22f0      	movs	r2, #240	@ 0xf0
 8006842:	2100      	movs	r1, #0
 8006844:	4640      	mov	r0, r8
 8006846:	f008 fa35 	bl	800ecb4 <memset>

            /* Create the message. */
            pxDHCPMessage->ucOpcode = ( uint8_t ) xOpcode;
 800684a:	f884 a02a 	strb.w	sl, [r4, #42]	@ 0x2a
            pxDHCPMessage->ucAddressType = ( uint8_t ) dhcpADDRESS_TYPE_ETHERNET;
 800684e:	2301      	movs	r3, #1
 8006850:	f884 302b 	strb.w	r3, [r4, #43]	@ 0x2b
            pxDHCPMessage->ucAddressLength = ( uint8_t ) dhcpETHERNET_ADDRESS_LENGTH;
 8006854:	2306      	movs	r3, #6
 8006856:	f884 302c 	strb.w	r3, [r4, #44]	@ 0x2c
            pxDHCPMessage->ulTransactionID = FreeRTOS_htonl( EP_DHCPData.ulTransactionId );
 800685a:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
 800685e:	ea4f 2c03 	mov.w	ip, r3, lsl #8
 8006862:	f40c 0c7f 	and.w	ip, ip, #16711680	@ 0xff0000
 8006866:	ea4c 6c03 	orr.w	ip, ip, r3, lsl #24
 800686a:	0a1a      	lsrs	r2, r3, #8
 800686c:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 8006870:	ea4c 0c02 	orr.w	ip, ip, r2
 8006874:	ea4c 6c13 	orr.w	ip, ip, r3, lsr #24
 8006878:	f8c4 c02e 	str.w	ip, [r4, #46]	@ 0x2e
            pxDHCPMessage->ulDHCPCookie = ( uint32_t ) dhcpCOOKIE;
 800687c:	2363      	movs	r3, #99	@ 0x63
 800687e:	f884 3116 	strb.w	r3, [r4, #278]	@ 0x116
 8006882:	f06f 027d 	mvn.w	r2, #125	@ 0x7d
 8006886:	f884 2117 	strb.w	r2, [r4, #279]	@ 0x117
 800688a:	2253      	movs	r2, #83	@ 0x53
 800688c:	f884 2118 	strb.w	r2, [r4, #280]	@ 0x118
 8006890:	f884 3119 	strb.w	r3, [r4, #281]	@ 0x119

            if( EP_DHCPData.xUseBroadcast != pdFALSE )
 8006894:	f8d5 3128 	ldr.w	r3, [r5, #296]	@ 0x128
 8006898:	b133      	cbz	r3, 80068a8 <prvCreatePartDHCPMessage+0x94>
            {
                pxDHCPMessage->usFlags = ( uint16_t ) dhcpBROADCAST;
 800689a:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 800689e:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
 80068a2:	2300      	movs	r3, #0
 80068a4:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
            else
            {
                pxDHCPMessage->usFlags = 0U;
            }

            ( void ) memcpy( &( pxDHCPMessage->ucClientHardwareAddress[ 0 ] ), pxEndPoint->xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 80068a8:	f8d5 30e8 	ldr.w	r3, [r5, #232]	@ 0xe8
 80068ac:	f8c4 3046 	str.w	r3, [r4, #70]	@ 0x46
 80068b0:	f8b5 30ec 	ldrh.w	r3, [r5, #236]	@ 0xec
 80068b4:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a

            /* Copy in the const part of the options options. */
            ( void ) memcpy( &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET ] ), pucOptionsArray, *pxOptionsArraySize );
 80068b8:	683a      	ldr	r2, [r7, #0]
 80068ba:	4649      	mov	r1, r9
 80068bc:	f504 708d 	add.w	r0, r4, #282	@ 0x11a
 80068c0:	f008 fad1 	bl	800ee66 <memcpy>
                *pxOptionsArraySize += ( size_t ) ( 2U + uxNameLength );
            }
            #endif /* if ( ipconfigDHCP_REGISTER_HOSTNAME == 1 ) */

            /* Map in the client identifier. */
            ( void ) memcpy( &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET + dhcpCLIENT_IDENTIFIER_OFFSET ] ),
 80068c4:	f8d5 30e8 	ldr.w	r3, [r5, #232]	@ 0xe8
 80068c8:	f8c4 3120 	str.w	r3, [r4, #288]	@ 0x120
 80068cc:	f8b5 30ec 	ldrh.w	r3, [r5, #236]	@ 0xec
 80068d0:	f8a4 3124 	strh.w	r3, [r4, #292]	@ 0x124
                             pxEndPoint->xMACAddress.ucBytes, sizeof( MACAddress_t ) );

            /* Set the addressing. */
            pxAddress->sin_address.ulIP_IPv4 = ipBROADCAST_IP_ADDRESS;
 80068d4:	f04f 33ff 	mov.w	r3, #4294967295
 80068d8:	60b3      	str	r3, [r6, #8]
            pxAddress->sin_port = ( uint16_t ) dhcpSERVER_PORT_IPv4;
 80068da:	f44f 4386 	mov.w	r3, #17152	@ 0x4300
 80068de:	8073      	strh	r3, [r6, #2]
            pxAddress->sin_family = FREERTOS_AF_INET4;
 80068e0:	2302      	movs	r3, #2
 80068e2:	7073      	strb	r3, [r6, #1]
        }

        return pucUDPPayloadBuffer;
    }
 80068e4:	4640      	mov	r0, r8
 80068e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

080068ec <prvSendDHCPDiscover>:
 * @param[in] pxEndPoint the end-point for which the discover message will be sent.
 *
 * @return: pdPASS if the DHCP discover message was sent successfully, pdFAIL otherwise.
 */
    static BaseType_t prvSendDHCPDiscover( NetworkEndPoint_t * pxEndPoint )
    {
 80068ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80068ee:	b08b      	sub	sp, #44	@ 0x2c
 80068f0:	4605      	mov	r5, r0
            dhcpIPv4_CLIENT_IDENTIFIER_OPTION_CODE,  7, 1,                                0,                            0, 0, 0, 0, 0,                    /* Client identifier. */
            dhcpIPv4_REQUEST_IP_ADDRESS_OPTION_CODE, 4, 0,                                0,                            0, 0,                             /* The IP address being requested. */
            dhcpIPv4_PARAMETER_REQUEST_OPTION_CODE,  3, dhcpIPv4_SUBNET_MASK_OPTION_CODE, dhcpIPv4_GATEWAY_OPTION_CODE, dhcpIPv4_DNS_SERVER_OPTIONS_CODE, /* Parameter request option. */
            dhcpOPTION_END_BYTE
        };
        size_t uxOptionsLength = sizeof( ucDHCPDiscoverOptions );
 80068f2:	2318      	movs	r3, #24
 80068f4:	9303      	str	r3, [sp, #12]

        ( void ) memset( &( xAddress ), 0, sizeof( xAddress ) );
 80068f6:	2300      	movs	r3, #0
 80068f8:	9304      	str	r3, [sp, #16]
 80068fa:	9305      	str	r3, [sp, #20]
 80068fc:	9306      	str	r3, [sp, #24]
 80068fe:	9307      	str	r3, [sp, #28]
 8006900:	9308      	str	r3, [sp, #32]
 8006902:	9309      	str	r3, [sp, #36]	@ 0x24
        pucUDPPayloadBuffer = prvCreatePartDHCPMessage( &xAddress,
 8006904:	9000      	str	r0, [sp, #0]
 8006906:	ab03      	add	r3, sp, #12
 8006908:	4a23      	ldr	r2, [pc, #140]	@ (8006998 <prvSendDHCPDiscover+0xac>)
 800690a:	2101      	movs	r1, #1
 800690c:	a804      	add	r0, sp, #16
 800690e:	f7ff ff81 	bl	8006814 <prvCreatePartDHCPMessage>
 8006912:	4606      	mov	r6, r0
                                                        pxEndPoint );

        /* MISRA Ref 11.4.1 [Socket error and integer to pointer conversion] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-114 */
        /* coverity[misra_c_2012_rule_11_4_violation] */
        if( ( xSocketValid( EP_DHCPData.xDHCPSocket ) == pdTRUE ) && ( pucUDPPayloadBuffer != NULL ) )
 8006914:	f8d5 0130 	ldr.w	r0, [r5, #304]	@ 0x130
 8006918:	f004 f912 	bl	800ab40 <xSocketValid>
 800691c:	2801      	cmp	r0, #1
 800691e:	d003      	beq.n	8006928 <prvSendDHCPDiscover+0x3c>
        BaseType_t xResult = pdFAIL;
 8006920:	2400      	movs	r4, #0
                xResult = pdTRUE;
            }
        }

        return xResult;
    }
 8006922:	4620      	mov	r0, r4
 8006924:	b00b      	add	sp, #44	@ 0x2c
 8006926:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006928:	4604      	mov	r4, r0
        if( ( xSocketValid( EP_DHCPData.xDHCPSocket ) == pdTRUE ) && ( pucUDPPayloadBuffer != NULL ) )
 800692a:	b396      	cbz	r6, 8006992 <prvSendDHCPDiscover+0xa6>
            if( pxEndPoint->xDHCPData.ulPreferredIPAddress != 0U )
 800692c:	f8d5 3114 	ldr.w	r3, [r5, #276]	@ 0x114
 8006930:	b1c3      	cbz	r3, 8006964 <prvSendDHCPDiscover+0x78>
                ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( EP_DHCPData.ulPreferredIPAddress ) );
 8006932:	f8c6 30fe 	str.w	r3, [r6, #254]	@ 0xfe
            EP_DHCPData.xDHCPSocket->pxEndPoint = pxEndPoint;
 8006936:	f8d5 3130 	ldr.w	r3, [r5, #304]	@ 0x130
 800693a:	64dd      	str	r5, [r3, #76]	@ 0x4c
            if( FreeRTOS_sendto( EP_DHCPData.xDHCPSocket,
 800693c:	2318      	movs	r3, #24
 800693e:	9301      	str	r3, [sp, #4]
 8006940:	ab04      	add	r3, sp, #16
 8006942:	9300      	str	r3, [sp, #0]
 8006944:	2301      	movs	r3, #1
 8006946:	9a03      	ldr	r2, [sp, #12]
 8006948:	32f0      	adds	r2, #240	@ 0xf0
 800694a:	4631      	mov	r1, r6
 800694c:	f8d5 0130 	ldr.w	r0, [r5, #304]	@ 0x130
 8006950:	f004 fb43 	bl	800afda <FreeRTOS_sendto>
 8006954:	4605      	mov	r5, r0
 8006956:	2800      	cmp	r0, #0
 8006958:	d1e3      	bne.n	8006922 <prvSendDHCPDiscover+0x36>
                FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayloadBuffer );
 800695a:	4630      	mov	r0, r6
 800695c:	f000 fcac 	bl	80072b8 <FreeRTOS_ReleaseUDPPayloadBuffer>
        BaseType_t xResult = pdFAIL;
 8006960:	462c      	mov	r4, r5
 8006962:	e7de      	b.n	8006922 <prvSendDHCPDiscover+0x36>
                configASSERT( uxOptionsLength > ( dhcpOPTION_50_OFFSET + dhcpOPTION_50_SIZE ) ); /* LCOV_EXCL_BR_LINE */
 8006964:	9f03      	ldr	r7, [sp, #12]
 8006966:	2f12      	cmp	r7, #18
 8006968:	d808      	bhi.n	800697c <prvSendDHCPDiscover+0x90>
 800696a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800696e:	f383 8811 	msr	BASEPRI, r3
 8006972:	f3bf 8f6f 	isb	sy
 8006976:	f3bf 8f4f 	dsb	sy
 800697a:	e7fe      	b.n	800697a <prvSendDHCPDiscover+0x8e>
                ( void ) memmove( pvCopyDest, pvCopySource, uxCopyLength );
 800697c:	f1a7 0212 	sub.w	r2, r7, #18
 8006980:	f506 7181 	add.w	r1, r6, #258	@ 0x102
 8006984:	f106 00fc 	add.w	r0, r6, #252	@ 0xfc
 8006988:	f008 f97a 	bl	800ec80 <memmove>
                uxOptionsLength -= dhcpOPTION_50_SIZE;
 800698c:	3f06      	subs	r7, #6
 800698e:	9703      	str	r7, [sp, #12]
 8006990:	e7d1      	b.n	8006936 <prvSendDHCPDiscover+0x4a>
        BaseType_t xResult = pdFAIL;
 8006992:	2400      	movs	r4, #0
        return xResult;
 8006994:	e7c5      	b.n	8006922 <prvSendDHCPDiscover+0x36>
 8006996:	bf00      	nop
 8006998:	080102ac 	.word	0x080102ac

0800699c <xHandleWaitingFirstDiscover>:
            if( EP_DHCPData.xDHCPSocket == NULL )
 800699c:	f8d0 3130 	ldr.w	r3, [r0, #304]	@ 0x130
 80069a0:	b19b      	cbz	r3, 80069ca <xHandleWaitingFirstDiscover+0x2e>
    {
 80069a2:	b510      	push	{r4, lr}
 80069a4:	4604      	mov	r4, r0
                EP_IPv4_SETTINGS.ulIPAddress = 0U;
 80069a6:	2300      	movs	r3, #0
 80069a8:	6003      	str	r3, [r0, #0]
                EP_DHCPData.xDHCPTxTime = xTaskGetTickCount();
 80069aa:	f7fe f93b 	bl	8004c24 <xTaskGetTickCount>
 80069ae:	f8c4 0120 	str.w	r0, [r4, #288]	@ 0x120
                if( prvSendDHCPDiscover( pxEndPoint ) == pdPASS )
 80069b2:	4620      	mov	r0, r4
 80069b4:	f7ff ff9a 	bl	80068ec <prvSendDHCPDiscover>
 80069b8:	2801      	cmp	r0, #1
 80069ba:	d001      	beq.n	80069c0 <xHandleWaitingFirstDiscover+0x24>
        BaseType_t xGivingUp = pdFALSE;
 80069bc:	2000      	movs	r0, #0
    }
 80069be:	bd10      	pop	{r4, pc}
                    EP_DHCPData.eDHCPState = eWaitingOffer;
 80069c0:	2302      	movs	r3, #2
 80069c2:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
        BaseType_t xGivingUp = pdFALSE;
 80069c6:	2000      	movs	r0, #0
 80069c8:	e7f9      	b.n	80069be <xHandleWaitingFirstDiscover+0x22>
                xGivingUp = pdTRUE;
 80069ca:	2001      	movs	r0, #1
    }
 80069cc:	4770      	bx	lr
	...

080069d0 <prvSendDHCPRequest>:
    {
 80069d0:	b570      	push	{r4, r5, r6, lr}
 80069d2:	b08a      	sub	sp, #40	@ 0x28
 80069d4:	4604      	mov	r4, r0
        size_t uxOptionsLength = sizeof( ucDHCPRequestOptions );
 80069d6:	2319      	movs	r3, #25
 80069d8:	9303      	str	r3, [sp, #12]
        ( void ) memset( &( xAddress ), 0, sizeof( xAddress ) );
 80069da:	2300      	movs	r3, #0
 80069dc:	9304      	str	r3, [sp, #16]
 80069de:	9305      	str	r3, [sp, #20]
 80069e0:	9306      	str	r3, [sp, #24]
 80069e2:	9307      	str	r3, [sp, #28]
 80069e4:	9308      	str	r3, [sp, #32]
 80069e6:	9309      	str	r3, [sp, #36]	@ 0x24
        pucUDPPayloadBuffer = prvCreatePartDHCPMessage( &xAddress,
 80069e8:	9000      	str	r0, [sp, #0]
 80069ea:	ab03      	add	r3, sp, #12
 80069ec:	4a19      	ldr	r2, [pc, #100]	@ (8006a54 <prvSendDHCPRequest+0x84>)
 80069ee:	2101      	movs	r1, #1
 80069f0:	a804      	add	r0, sp, #16
 80069f2:	f7ff ff0f 	bl	8006814 <prvCreatePartDHCPMessage>
 80069f6:	4606      	mov	r6, r0
        if( ( xSocketValid( EP_DHCPData.xDHCPSocket ) == pdTRUE ) && ( pucUDPPayloadBuffer != NULL ) )
 80069f8:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
 80069fc:	f004 f8a0 	bl	800ab40 <xSocketValid>
 8006a00:	2801      	cmp	r0, #1
 8006a02:	d003      	beq.n	8006a0c <prvSendDHCPRequest+0x3c>
        BaseType_t xResult = pdFAIL;
 8006a04:	2500      	movs	r5, #0
    }
 8006a06:	4628      	mov	r0, r5
 8006a08:	b00a      	add	sp, #40	@ 0x28
 8006a0a:	bd70      	pop	{r4, r5, r6, pc}
 8006a0c:	4605      	mov	r5, r0
        if( ( xSocketValid( EP_DHCPData.xDHCPSocket ) == pdTRUE ) && ( pucUDPPayloadBuffer != NULL ) )
 8006a0e:	b1f6      	cbz	r6, 8006a4e <prvSendDHCPRequest+0x7e>
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( EP_DHCPData.ulOfferedIPAddress ) );
 8006a10:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
 8006a14:	f8c6 30fe 	str.w	r3, [r6, #254]	@ 0xfe
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( EP_DHCPData.ulDHCPServerAddress ) );
 8006a18:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
 8006a1c:	f8c6 3104 	str.w	r3, [r6, #260]	@ 0x104
            EP_DHCPData.xDHCPSocket->pxEndPoint = pxEndPoint;
 8006a20:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
 8006a24:	64dc      	str	r4, [r3, #76]	@ 0x4c
            if( FreeRTOS_sendto( EP_DHCPData.xDHCPSocket, pucUDPPayloadBuffer, sizeof( DHCPMessage_IPv4_t ) + uxOptionsLength, FREERTOS_ZERO_COPY, &xAddress, ( socklen_t ) sizeof( xAddress ) ) == 0 )
 8006a26:	2318      	movs	r3, #24
 8006a28:	9301      	str	r3, [sp, #4]
 8006a2a:	ab04      	add	r3, sp, #16
 8006a2c:	9300      	str	r3, [sp, #0]
 8006a2e:	2301      	movs	r3, #1
 8006a30:	9a03      	ldr	r2, [sp, #12]
 8006a32:	32f0      	adds	r2, #240	@ 0xf0
 8006a34:	4631      	mov	r1, r6
 8006a36:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
 8006a3a:	f004 face 	bl	800afda <FreeRTOS_sendto>
 8006a3e:	4604      	mov	r4, r0
 8006a40:	2800      	cmp	r0, #0
 8006a42:	d1e0      	bne.n	8006a06 <prvSendDHCPRequest+0x36>
                FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayloadBuffer );
 8006a44:	4630      	mov	r0, r6
 8006a46:	f000 fc37 	bl	80072b8 <FreeRTOS_ReleaseUDPPayloadBuffer>
        BaseType_t xResult = pdFAIL;
 8006a4a:	4625      	mov	r5, r4
 8006a4c:	e7db      	b.n	8006a06 <prvSendDHCPRequest+0x36>
 8006a4e:	2500      	movs	r5, #0
        return xResult;
 8006a50:	e7d9      	b.n	8006a06 <prvSendDHCPRequest+0x36>
 8006a52:	bf00      	nop
 8006a54:	08010290 	.word	0x08010290

08006a58 <prvProcessDHCPReplies>:
    {
 8006a58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006a5c:	b08a      	sub	sp, #40	@ 0x28
 8006a5e:	4605      	mov	r5, r0
 8006a60:	460e      	mov	r6, r1
        ( void ) memset( &( xSet ), 0, sizeof( xSet ) );
 8006a62:	2200      	movs	r2, #0
 8006a64:	9202      	str	r2, [sp, #8]
 8006a66:	9203      	str	r2, [sp, #12]
 8006a68:	9204      	str	r2, [sp, #16]
 8006a6a:	9205      	str	r2, [sp, #20]
 8006a6c:	9206      	str	r2, [sp, #24]
 8006a6e:	9207      	str	r2, [sp, #28]
 8006a70:	9208      	str	r2, [sp, #32]
        lBytes = FreeRTOS_recvfrom( EP_DHCPData.xDHCPSocket, &pucUDPPayload, 0U, FREERTOS_ZERO_COPY, NULL, NULL );
 8006a72:	9201      	str	r2, [sp, #4]
 8006a74:	9200      	str	r2, [sp, #0]
 8006a76:	2301      	movs	r3, #1
 8006a78:	a909      	add	r1, sp, #36	@ 0x24
 8006a7a:	f8d6 0130 	ldr.w	r0, [r6, #304]	@ 0x130
 8006a7e:	f004 f87c 	bl	800ab7a <FreeRTOS_recvfrom>
        if( lBytes > 0 )
 8006a82:	1e04      	subs	r4, r0, #0
 8006a84:	dd5c      	ble.n	8006b40 <prvProcessDHCPReplies+0xe8>
            pxDHCPMessage = ( ( DHCPMessage_IPv4_t * ) pucUDPPayload );
 8006a86:	f8dd 8024 	ldr.w	r8, [sp, #36]	@ 0x24
            if( lBytes < ( int32_t ) sizeof( DHCPMessage_IPv4_t ) )
 8006a8a:	2cef      	cmp	r4, #239	@ 0xef
 8006a8c:	dd50      	ble.n	8006b30 <prvProcessDHCPReplies+0xd8>
            else if( prvIsValidDHCPResponse( pxDHCPMessage ) == pdFAIL )
 8006a8e:	4640      	mov	r0, r8
 8006a90:	f7ff fe6a 	bl	8006768 <prvIsValidDHCPResponse>
 8006a94:	4607      	mov	r7, r0
 8006a96:	2800      	cmp	r0, #0
 8006a98:	d04b      	beq.n	8006b32 <prvProcessDHCPReplies+0xda>
            else if( ( pxDHCPMessage->ulTransactionID != FreeRTOS_htonl( EP_DHCPData.ulTransactionId ) ) )
 8006a9a:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8006a9e:	f8d6 210c 	ldr.w	r2, [r6, #268]	@ 0x10c
 8006aa2:	0213      	lsls	r3, r2, #8
 8006aa4:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8006aa8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8006aac:	0a11      	lsrs	r1, r2, #8
 8006aae:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 8006ab2:	430b      	orrs	r3, r1
 8006ab4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8006ab8:	4298      	cmp	r0, r3
 8006aba:	d001      	beq.n	8006ac0 <prvProcessDHCPReplies+0x68>
        BaseType_t xReturn = pdFALSE;
 8006abc:	2700      	movs	r7, #0
 8006abe:	e038      	b.n	8006b32 <prvProcessDHCPReplies+0xda>
                if( memcmp( pxDHCPMessage->ucClientHardwareAddress,
 8006ac0:	2206      	movs	r2, #6
 8006ac2:	f106 01e8 	add.w	r1, r6, #232	@ 0xe8
 8006ac6:	f108 001c 	add.w	r0, r8, #28
 8006aca:	f008 f8c9 	bl	800ec60 <memcmp>
 8006ace:	4607      	mov	r7, r0
 8006ad0:	2800      	cmp	r0, #0
 8006ad2:	d133      	bne.n	8006b3c <prvProcessDHCPReplies+0xe4>
                    xSet.ulProcessed = 0U;
 8006ad4:	2300      	movs	r3, #0
 8006ad6:	9307      	str	r3, [sp, #28]
                    xSet.pucByte = &( pucUDPPayload[ sizeof( DHCPMessage_IPv4_t ) ] );
 8006ad8:	f108 02f0 	add.w	r2, r8, #240	@ 0xf0
 8006adc:	9208      	str	r2, [sp, #32]
                    xSet.uxIndex = 0;
 8006ade:	9303      	str	r3, [sp, #12]
                    xSet.uxPayloadDataLength = ( ( size_t ) lBytes ) - sizeof( DHCPMessage_IPv4_t );
 8006ae0:	3cf0      	subs	r4, #240	@ 0xf0
 8006ae2:	9404      	str	r4, [sp, #16]
                    while( xSet.uxIndex < xSet.uxPayloadDataLength )
 8006ae4:	e000      	b.n	8006ae8 <prvProcessDHCPReplies+0x90>
                        if( xResult != 0 )
 8006ae6:	b994      	cbnz	r4, 8006b0e <prvProcessDHCPReplies+0xb6>
                    while( xSet.uxIndex < xSet.uxPayloadDataLength )
 8006ae8:	9b03      	ldr	r3, [sp, #12]
 8006aea:	9a04      	ldr	r2, [sp, #16]
 8006aec:	4293      	cmp	r3, r2
 8006aee:	d216      	bcs.n	8006b1e <prvProcessDHCPReplies+0xc6>
                        xSet.ucOptionCode = xSet.pucByte[ xSet.uxIndex ];
 8006af0:	9a08      	ldr	r2, [sp, #32]
 8006af2:	5cd3      	ldrb	r3, [r2, r3]
 8006af4:	f88d 3008 	strb.w	r3, [sp, #8]
                        xResult = xProcessCheckOption( &( xSet ) );
 8006af8:	a802      	add	r0, sp, #8
 8006afa:	f7ff fe5b 	bl	80067b4 <xProcessCheckOption>
                        if( xResult > 0 )
 8006afe:	1e04      	subs	r4, r0, #0
 8006b00:	ddf1      	ble.n	8006ae6 <prvProcessDHCPReplies+0x8e>
                            vProcessHandleOption( pxEndPoint, &( xSet ), xExpectedMessageType );
 8006b02:	462a      	mov	r2, r5
 8006b04:	a902      	add	r1, sp, #8
 8006b06:	4630      	mov	r0, r6
 8006b08:	f7ff fd9e 	bl	8006648 <vProcessHandleOption>
 8006b0c:	e7eb      	b.n	8006ae6 <prvProcessDHCPReplies+0x8e>
                            if( ( xSet.uxLength == 0U ) || ( xResult < 0 ) )
 8006b0e:	9b05      	ldr	r3, [sp, #20]
 8006b10:	b12b      	cbz	r3, 8006b1e <prvProcessDHCPReplies+0xc6>
 8006b12:	2c00      	cmp	r4, #0
 8006b14:	db03      	blt.n	8006b1e <prvProcessDHCPReplies+0xc6>
                            xSet.uxIndex += xSet.uxLength;
 8006b16:	9a03      	ldr	r2, [sp, #12]
 8006b18:	4413      	add	r3, r2
 8006b1a:	9303      	str	r3, [sp, #12]
 8006b1c:	e7e4      	b.n	8006ae8 <prvProcessDHCPReplies+0x90>
                    if( xSet.ulProcessed >= ulMandatoryOptions )
 8006b1e:	9b07      	ldr	r3, [sp, #28]
 8006b20:	2b01      	cmp	r3, #1
 8006b22:	d906      	bls.n	8006b32 <prvProcessDHCPReplies+0xda>
                        EP_DHCPData.ulOfferedIPAddress = pxDHCPMessage->ulYourIPAddress_yiaddr;
 8006b24:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8006b28:	f8c6 3110 	str.w	r3, [r6, #272]	@ 0x110
                        xReturn = pdPASS;
 8006b2c:	2701      	movs	r7, #1
 8006b2e:	e000      	b.n	8006b32 <prvProcessDHCPReplies+0xda>
        BaseType_t xReturn = pdFALSE;
 8006b30:	2700      	movs	r7, #0
            if( pucUDPPayload != NULL )
 8006b32:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8006b34:	b128      	cbz	r0, 8006b42 <prvProcessDHCPReplies+0xea>
                FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayload );
 8006b36:	f000 fbbf 	bl	80072b8 <FreeRTOS_ReleaseUDPPayloadBuffer>
 8006b3a:	e002      	b.n	8006b42 <prvProcessDHCPReplies+0xea>
        BaseType_t xReturn = pdFALSE;
 8006b3c:	2700      	movs	r7, #0
 8006b3e:	e7f8      	b.n	8006b32 <prvProcessDHCPReplies+0xda>
 8006b40:	2700      	movs	r7, #0
    }
 8006b42:	4638      	mov	r0, r7
 8006b44:	b00a      	add	sp, #40	@ 0x28
 8006b46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08006b4c <xHandleWaitingOffer>:
    {
 8006b4c:	b538      	push	{r3, r4, r5, lr}
 8006b4e:	4604      	mov	r4, r0
        if( xDoCheck != pdFALSE )
 8006b50:	b1f1      	cbz	r1, 8006b90 <xHandleWaitingOffer+0x44>
            if( prvProcessDHCPReplies( dhcpMESSAGE_TYPE_OFFER, pxEndPoint ) == pdPASS )
 8006b52:	4601      	mov	r1, r0
 8006b54:	2002      	movs	r0, #2
 8006b56:	f7ff ff7f 	bl	8006a58 <prvProcessDHCPReplies>
 8006b5a:	2801      	cmp	r0, #1
 8006b5c:	d001      	beq.n	8006b62 <xHandleWaitingOffer+0x16>
        BaseType_t xGivingUp = pdFALSE;
 8006b5e:	2000      	movs	r0, #0
    }
 8006b60:	bd38      	pop	{r3, r4, r5, pc}
                    if( prvSendDHCPRequest( pxEndPoint ) == pdPASS )
 8006b62:	4620      	mov	r0, r4
 8006b64:	f7ff ff34 	bl	80069d0 <prvSendDHCPRequest>
 8006b68:	2801      	cmp	r0, #1
 8006b6a:	d004      	beq.n	8006b76 <xHandleWaitingOffer+0x2a>
                        EP_DHCPData.eDHCPState = eSendDHCPRequest;
 8006b6c:	2304      	movs	r3, #4
 8006b6e:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
        BaseType_t xGivingUp = pdFALSE;
 8006b72:	2000      	movs	r0, #0
 8006b74:	e7f4      	b.n	8006b60 <xHandleWaitingOffer+0x14>
                        EP_DHCPData.xDHCPTxTime = xTaskGetTickCount();
 8006b76:	f7fe f855 	bl	8004c24 <xTaskGetTickCount>
 8006b7a:	f8c4 0120 	str.w	r0, [r4, #288]	@ 0x120
                        EP_DHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8006b7e:	f241 3388 	movw	r3, #5000	@ 0x1388
 8006b82:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
                        EP_DHCPData.eDHCPState = eWaitingAcknowledge;
 8006b86:	2303      	movs	r3, #3
 8006b88:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
        BaseType_t xGivingUp = pdFALSE;
 8006b8c:	2000      	movs	r0, #0
 8006b8e:	e7e7      	b.n	8006b60 <xHandleWaitingOffer+0x14>
 8006b90:	460d      	mov	r5, r1
        else if( ( xTaskGetTickCount() - EP_DHCPData.xDHCPTxTime ) > EP_DHCPData.xDHCPTxPeriod )
 8006b92:	f7fe f847 	bl	8004c24 <xTaskGetTickCount>
 8006b96:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
 8006b9a:	1ac0      	subs	r0, r0, r3
 8006b9c:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
 8006ba0:	4298      	cmp	r0, r3
 8006ba2:	d925      	bls.n	8006bf0 <xHandleWaitingOffer+0xa4>
            EP_DHCPData.xDHCPTxPeriod <<= 1;
 8006ba4:	005b      	lsls	r3, r3, #1
 8006ba6:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
            if( EP_DHCPData.xDHCPTxPeriod <= ( ( TickType_t ) ipconfigMAXIMUM_DISCOVER_TX_PERIOD ) )
 8006baa:	4a13      	ldr	r2, [pc, #76]	@ (8006bf8 <xHandleWaitingOffer+0xac>)
 8006bac:	4293      	cmp	r3, r2
 8006bae:	d901      	bls.n	8006bb4 <xHandleWaitingOffer+0x68>
                    xGivingUp = pdTRUE;
 8006bb0:	2001      	movs	r0, #1
 8006bb2:	e7d5      	b.n	8006b60 <xHandleWaitingOffer+0x14>
                if( xApplicationGetRandomNumber( &( EP_DHCPData.ulTransactionId ) ) != pdFALSE )
 8006bb4:	f504 7086 	add.w	r0, r4, #268	@ 0x10c
 8006bb8:	f7fa fca0 	bl	80014fc <xApplicationGetRandomNumber>
 8006bbc:	2800      	cmp	r0, #0
 8006bbe:	d0cf      	beq.n	8006b60 <xHandleWaitingOffer+0x14>
                    EP_DHCPData.xDHCPTxTime = xTaskGetTickCount();
 8006bc0:	f7fe f830 	bl	8004c24 <xTaskGetTickCount>
 8006bc4:	f8c4 0120 	str.w	r0, [r4, #288]	@ 0x120
                    if( EP_DHCPData.xUseBroadcast != pdFALSE )
 8006bc8:	f8d4 3128 	ldr.w	r3, [r4, #296]	@ 0x128
 8006bcc:	b163      	cbz	r3, 8006be8 <xHandleWaitingOffer+0x9c>
                        EP_DHCPData.xUseBroadcast = pdFALSE;
 8006bce:	2300      	movs	r3, #0
 8006bd0:	f8c4 3128 	str.w	r3, [r4, #296]	@ 0x128
                    if( prvSendDHCPDiscover( pxEndPoint ) == pdPASS )
 8006bd4:	4620      	mov	r0, r4
 8006bd6:	f7ff fe89 	bl	80068ec <prvSendDHCPDiscover>
 8006bda:	2801      	cmp	r0, #1
 8006bdc:	d00a      	beq.n	8006bf4 <xHandleWaitingOffer+0xa8>
                        EP_DHCPData.eDHCPState = eInitialWait;
 8006bde:	2300      	movs	r3, #0
 8006be0:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
        BaseType_t xGivingUp = pdFALSE;
 8006be4:	4628      	mov	r0, r5
 8006be6:	e7bb      	b.n	8006b60 <xHandleWaitingOffer+0x14>
                        EP_DHCPData.xUseBroadcast = pdTRUE;
 8006be8:	2301      	movs	r3, #1
 8006bea:	f8c4 3128 	str.w	r3, [r4, #296]	@ 0x128
 8006bee:	e7f1      	b.n	8006bd4 <xHandleWaitingOffer+0x88>
        BaseType_t xGivingUp = pdFALSE;
 8006bf0:	4628      	mov	r0, r5
 8006bf2:	e7b5      	b.n	8006b60 <xHandleWaitingOffer+0x14>
 8006bf4:	4628      	mov	r0, r5
        return xGivingUp;
 8006bf6:	e7b3      	b.n	8006b60 <xHandleWaitingOffer+0x14>
 8006bf8:	0001d4c0 	.word	0x0001d4c0

08006bfc <prvCloseDHCPSocket>:
        if( ( EP_DHCPData.xDHCPSocket == NULL ) || ( EP_DHCPData.xDHCPSocket != xDHCPv4Socket ) )
 8006bfc:	f8d0 3130 	ldr.w	r3, [r0, #304]	@ 0x130
 8006c00:	b1c3      	cbz	r3, 8006c34 <prvCloseDHCPSocket+0x38>
    {
 8006c02:	b510      	push	{r4, lr}
 8006c04:	4604      	mov	r4, r0
        if( ( EP_DHCPData.xDHCPSocket == NULL ) || ( EP_DHCPData.xDHCPSocket != xDHCPv4Socket ) )
 8006c06:	4a0c      	ldr	r2, [pc, #48]	@ (8006c38 <prvCloseDHCPSocket+0x3c>)
 8006c08:	6810      	ldr	r0, [r2, #0]
 8006c0a:	4283      	cmp	r3, r0
 8006c0c:	d000      	beq.n	8006c10 <prvCloseDHCPSocket+0x14>
    }
 8006c0e:	bd10      	pop	{r4, pc}
        else if( xDHCPSocketUserCount > 0 )
 8006c10:	4b0a      	ldr	r3, [pc, #40]	@ (8006c3c <prvCloseDHCPSocket+0x40>)
 8006c12:	681b      	ldr	r3, [r3, #0]
 8006c14:	2b00      	cmp	r3, #0
 8006c16:	ddfa      	ble.n	8006c0e <prvCloseDHCPSocket+0x12>
            xDHCPSocketUserCount--;
 8006c18:	3b01      	subs	r3, #1
 8006c1a:	4a08      	ldr	r2, [pc, #32]	@ (8006c3c <prvCloseDHCPSocket+0x40>)
 8006c1c:	6013      	str	r3, [r2, #0]
            if( xDHCPSocketUserCount == 0 )
 8006c1e:	b11b      	cbz	r3, 8006c28 <prvCloseDHCPSocket+0x2c>
            EP_DHCPData.xDHCPSocket = NULL;
 8006c20:	2300      	movs	r3, #0
 8006c22:	f8c4 3130 	str.w	r3, [r4, #304]	@ 0x130
    }
 8006c26:	e7f2      	b.n	8006c0e <prvCloseDHCPSocket+0x12>
                ( void ) vSocketClose( xDHCPv4Socket );
 8006c28:	f003 fce1 	bl	800a5ee <vSocketClose>
                xDHCPv4Socket = NULL;
 8006c2c:	4b02      	ldr	r3, [pc, #8]	@ (8006c38 <prvCloseDHCPSocket+0x3c>)
 8006c2e:	2200      	movs	r2, #0
 8006c30:	601a      	str	r2, [r3, #0]
 8006c32:	e7f5      	b.n	8006c20 <prvCloseDHCPSocket+0x24>
 8006c34:	4770      	bx	lr
 8006c36:	bf00      	nop
 8006c38:	20011b14 	.word	0x20011b14
 8006c3c:	20011b10 	.word	0x20011b10

08006c40 <prvCreateDHCPSocket>:
    {
 8006c40:	b570      	push	{r4, r5, r6, lr}
 8006c42:	b08a      	sub	sp, #40	@ 0x28
 8006c44:	4604      	mov	r4, r0
        TickType_t xTimeoutTime = ( TickType_t ) 0;
 8006c46:	2300      	movs	r3, #0
 8006c48:	9303      	str	r3, [sp, #12]
        if( ( xDHCPv4Socket != NULL ) && ( EP_DHCPData.xDHCPSocket == xDHCPv4Socket ) )
 8006c4a:	4b30      	ldr	r3, [pc, #192]	@ (8006d0c <prvCreateDHCPSocket+0xcc>)
 8006c4c:	681b      	ldr	r3, [r3, #0]
 8006c4e:	b11b      	cbz	r3, 8006c58 <prvCreateDHCPSocket+0x18>
 8006c50:	f8d0 2130 	ldr.w	r2, [r0, #304]	@ 0x130
 8006c54:	4293      	cmp	r3, r2
 8006c56:	d006      	beq.n	8006c66 <prvCreateDHCPSocket+0x26>
        else if( xDHCPv4Socket == NULL ) /* Create the socket, if it has not already been created. */
 8006c58:	b13b      	cbz	r3, 8006c6a <prvCreateDHCPSocket+0x2a>
            xDHCPSocketUserCount++;
 8006c5a:	492d      	ldr	r1, [pc, #180]	@ (8006d10 <prvCreateDHCPSocket+0xd0>)
 8006c5c:	680a      	ldr	r2, [r1, #0]
 8006c5e:	3201      	adds	r2, #1
 8006c60:	600a      	str	r2, [r1, #0]
            EP_DHCPData.xDHCPSocket = xDHCPv4Socket;
 8006c62:	f8c4 3130 	str.w	r3, [r4, #304]	@ 0x130
    }
 8006c66:	b00a      	add	sp, #40	@ 0x28
 8006c68:	bd70      	pop	{r4, r5, r6, pc}
            xDHCPv4Socket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 8006c6a:	2211      	movs	r2, #17
 8006c6c:	2102      	movs	r1, #2
 8006c6e:	4608      	mov	r0, r1
 8006c70:	f003 fc54 	bl	800a51c <FreeRTOS_socket>
 8006c74:	4b25      	ldr	r3, [pc, #148]	@ (8006d0c <prvCreateDHCPSocket+0xcc>)
 8006c76:	6018      	str	r0, [r3, #0]
            configASSERT( xSocketValid( xDHCPv4Socket ) == pdTRUE );
 8006c78:	f003 ff62 	bl	800ab40 <xSocketValid>
 8006c7c:	2801      	cmp	r0, #1
 8006c7e:	d008      	beq.n	8006c92 <prvCreateDHCPSocket+0x52>
 8006c80:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006c84:	f383 8811 	msr	BASEPRI, r3
 8006c88:	f3bf 8f6f 	isb	sy
 8006c8c:	f3bf 8f4f 	dsb	sy
 8006c90:	e7fe      	b.n	8006c90 <prvCreateDHCPSocket+0x50>
            if( xSocketValid( xDHCPv4Socket ) == pdTRUE )
 8006c92:	4b1e      	ldr	r3, [pc, #120]	@ (8006d0c <prvCreateDHCPSocket+0xcc>)
 8006c94:	6818      	ldr	r0, [r3, #0]
 8006c96:	f003 ff53 	bl	800ab40 <xSocketValid>
 8006c9a:	2801      	cmp	r0, #1
 8006c9c:	d005      	beq.n	8006caa <prvCreateDHCPSocket+0x6a>
                xDHCPv4Socket = NULL;
 8006c9e:	2300      	movs	r3, #0
 8006ca0:	4a1a      	ldr	r2, [pc, #104]	@ (8006d0c <prvCreateDHCPSocket+0xcc>)
 8006ca2:	6013      	str	r3, [r2, #0]
                EP_DHCPData.xDHCPSocket = NULL;
 8006ca4:	f8c4 3130 	str.w	r3, [r4, #304]	@ 0x130
 8006ca8:	e7dd      	b.n	8006c66 <prvCreateDHCPSocket+0x26>
                ( void ) FreeRTOS_setsockopt( xDHCPv4Socket, 0, FREERTOS_SO_RCVTIMEO, &( xTimeoutTime ), sizeof( TickType_t ) );
 8006caa:	4d18      	ldr	r5, [pc, #96]	@ (8006d0c <prvCreateDHCPSocket+0xcc>)
 8006cac:	2604      	movs	r6, #4
 8006cae:	9600      	str	r6, [sp, #0]
 8006cb0:	ab03      	add	r3, sp, #12
 8006cb2:	2200      	movs	r2, #0
 8006cb4:	4611      	mov	r1, r2
 8006cb6:	6828      	ldr	r0, [r5, #0]
 8006cb8:	f004 fad1 	bl	800b25e <FreeRTOS_setsockopt>
                ( void ) FreeRTOS_setsockopt( xDHCPv4Socket, 0, FREERTOS_SO_SNDTIMEO, &( xTimeoutTime ), sizeof( TickType_t ) );
 8006cbc:	9600      	str	r6, [sp, #0]
 8006cbe:	ab03      	add	r3, sp, #12
 8006cc0:	2201      	movs	r2, #1
 8006cc2:	2100      	movs	r1, #0
 8006cc4:	6828      	ldr	r0, [r5, #0]
 8006cc6:	f004 faca 	bl	800b25e <FreeRTOS_setsockopt>
                ( void ) memset( &xAddress, 0, sizeof( xAddress ) );
 8006cca:	2300      	movs	r3, #0
 8006ccc:	9304      	str	r3, [sp, #16]
 8006cce:	9305      	str	r3, [sp, #20]
 8006cd0:	9306      	str	r3, [sp, #24]
 8006cd2:	9307      	str	r3, [sp, #28]
 8006cd4:	9308      	str	r3, [sp, #32]
 8006cd6:	9309      	str	r3, [sp, #36]	@ 0x24
                xAddress.sin_family = FREERTOS_AF_INET4;
 8006cd8:	2202      	movs	r2, #2
 8006cda:	f88d 2011 	strb.w	r2, [sp, #17]
                xAddress.sin_len = ( uint8_t ) sizeof( xAddress );
 8006cde:	2218      	movs	r2, #24
 8006ce0:	f88d 2010 	strb.w	r2, [sp, #16]
                xAddress.sin_port = ( uint16_t ) dhcpCLIENT_PORT_IPv4;
 8006ce4:	f44f 4188 	mov.w	r1, #17408	@ 0x4400
 8006ce8:	f8ad 1012 	strh.w	r1, [sp, #18]
                xReturn = vSocketBind( xDHCPv4Socket, &xAddress, sizeof( xAddress ), pdFALSE );
 8006cec:	a904      	add	r1, sp, #16
 8006cee:	6828      	ldr	r0, [r5, #0]
 8006cf0:	f004 fa5a 	bl	800b1a8 <vSocketBind>
                xDHCPSocketUserCount = 1;
 8006cf4:	4b06      	ldr	r3, [pc, #24]	@ (8006d10 <prvCreateDHCPSocket+0xd0>)
 8006cf6:	2201      	movs	r2, #1
 8006cf8:	601a      	str	r2, [r3, #0]
                EP_DHCPData.xDHCPSocket = xDHCPv4Socket;
 8006cfa:	682b      	ldr	r3, [r5, #0]
 8006cfc:	f8c4 3130 	str.w	r3, [r4, #304]	@ 0x130
                if( xReturn != 0 )
 8006d00:	2800      	cmp	r0, #0
 8006d02:	d0b0      	beq.n	8006c66 <prvCreateDHCPSocket+0x26>
                    prvCloseDHCPSocket( pxEndPoint );
 8006d04:	4620      	mov	r0, r4
 8006d06:	f7ff ff79 	bl	8006bfc <prvCloseDHCPSocket>
 8006d0a:	e7ac      	b.n	8006c66 <prvCreateDHCPSocket+0x26>
 8006d0c:	20011b14 	.word	0x20011b14
 8006d10:	20011b10 	.word	0x20011b10

08006d14 <prvInitialiseDHCP>:
    {
 8006d14:	b510      	push	{r4, lr}
 8006d16:	4604      	mov	r4, r0
        if( xApplicationGetRandomNumber( &( EP_DHCPData.ulTransactionId ) ) != pdFALSE )
 8006d18:	f500 7086 	add.w	r0, r0, #268	@ 0x10c
 8006d1c:	f7fa fbee 	bl	80014fc <xApplicationGetRandomNumber>
 8006d20:	b900      	cbnz	r0, 8006d24 <prvInitialiseDHCP+0x10>
    }
 8006d22:	bd10      	pop	{r4, pc}
            EP_DHCPData.xUseBroadcast = 0;
 8006d24:	2300      	movs	r3, #0
 8006d26:	f8c4 3128 	str.w	r3, [r4, #296]	@ 0x128
            EP_DHCPData.ulOfferedIPAddress = 0U;
 8006d2a:	f8c4 3110 	str.w	r3, [r4, #272]	@ 0x110
            EP_DHCPData.ulDHCPServerAddress = 0U;
 8006d2e:	f8c4 3118 	str.w	r3, [r4, #280]	@ 0x118
            EP_DHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8006d32:	f241 3388 	movw	r3, #5000	@ 0x1388
 8006d36:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
            prvCreateDHCPSocket( pxEndPoint );
 8006d3a:	4620      	mov	r0, r4
 8006d3c:	f7ff ff80 	bl	8006c40 <prvCreateDHCPSocket>
            vDHCP_RATimerReload( pxEndPoint, dhcpINITIAL_TIMER_PERIOD );
 8006d40:	21fa      	movs	r1, #250	@ 0xfa
 8006d42:	4620      	mov	r0, r4
 8006d44:	f000 fe44 	bl	80079d0 <vDHCP_RATimerReload>
    }
 8006d48:	e7eb      	b.n	8006d22 <prvInitialiseDHCP+0xe>

08006d4a <prvHandleWaitingeLeasedAddress>:
    {
 8006d4a:	b510      	push	{r4, lr}
 8006d4c:	b082      	sub	sp, #8
 8006d4e:	4604      	mov	r4, r0
        if( FreeRTOS_IsEndPointUp( pxEndPoint ) != 0 )
 8006d50:	f000 fbb2 	bl	80074b8 <FreeRTOS_IsEndPointUp>
 8006d54:	b338      	cbz	r0, 8006da6 <prvHandleWaitingeLeasedAddress+0x5c>
            prvCreateDHCPSocket( pxEndPoint );
 8006d56:	4620      	mov	r0, r4
 8006d58:	f7ff ff72 	bl	8006c40 <prvCreateDHCPSocket>
            if( EP_DHCPData.xDHCPSocket != NULL )
 8006d5c:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
 8006d60:	b333      	cbz	r3, 8006db0 <prvHandleWaitingeLeasedAddress+0x66>
                uint32_t ulID = 0U;
 8006d62:	2300      	movs	r3, #0
 8006d64:	9301      	str	r3, [sp, #4]
                if( xApplicationGetRandomNumber( &( ulID ) ) != pdFALSE )
 8006d66:	a801      	add	r0, sp, #4
 8006d68:	f7fa fbc8 	bl	80014fc <xApplicationGetRandomNumber>
 8006d6c:	b110      	cbz	r0, 8006d74 <prvHandleWaitingeLeasedAddress+0x2a>
                    EP_DHCPData.ulTransactionId = ulID;
 8006d6e:	9b01      	ldr	r3, [sp, #4]
 8006d70:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
                EP_DHCPData.xDHCPTxTime = xTaskGetTickCount();
 8006d74:	f7fd ff56 	bl	8004c24 <xTaskGetTickCount>
 8006d78:	f8c4 0120 	str.w	r0, [r4, #288]	@ 0x120
                EP_DHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8006d7c:	f241 3388 	movw	r3, #5000	@ 0x1388
 8006d80:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
                if( prvSendDHCPRequest( pxEndPoint ) == pdPASS )
 8006d84:	4620      	mov	r0, r4
 8006d86:	f7ff fe23 	bl	80069d0 <prvSendDHCPRequest>
 8006d8a:	2801      	cmp	r0, #1
 8006d8c:	d007      	beq.n	8006d9e <prvHandleWaitingeLeasedAddress+0x54>
                    EP_DHCPData.eDHCPState = eSendDHCPRequest;
 8006d8e:	2304      	movs	r3, #4
 8006d90:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
                vDHCP_RATimerReload( pxEndPoint, dhcpINITIAL_TIMER_PERIOD );
 8006d94:	21fa      	movs	r1, #250	@ 0xfa
 8006d96:	4620      	mov	r0, r4
 8006d98:	f000 fe1a 	bl	80079d0 <vDHCP_RATimerReload>
 8006d9c:	e008      	b.n	8006db0 <prvHandleWaitingeLeasedAddress+0x66>
                    EP_DHCPData.eDHCPState = eWaitingAcknowledge;
 8006d9e:	2303      	movs	r3, #3
 8006da0:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
 8006da4:	e7f6      	b.n	8006d94 <prvHandleWaitingeLeasedAddress+0x4a>
            vDHCP_RATimerReload( ( struct xNetworkEndPoint * ) pxEndPoint, pdMS_TO_TICKS( 5000U ) );
 8006da6:	f241 3188 	movw	r1, #5000	@ 0x1388
 8006daa:	4620      	mov	r0, r4
 8006dac:	f000 fe10 	bl	80079d0 <vDHCP_RATimerReload>
    }
 8006db0:	b002      	add	sp, #8
 8006db2:	bd10      	pop	{r4, pc}

08006db4 <vHandleWaitingAcknowledge>:
    {
 8006db4:	b510      	push	{r4, lr}
 8006db6:	4604      	mov	r4, r0
        if( xDoCheck == pdFALSE )
 8006db8:	b9f9      	cbnz	r1, 8006dfa <vHandleWaitingAcknowledge+0x46>
            if( ( xTaskGetTickCount() - EP_DHCPData.xDHCPTxTime ) > EP_DHCPData.xDHCPTxPeriod )
 8006dba:	f7fd ff33 	bl	8004c24 <xTaskGetTickCount>
 8006dbe:	f8d4 3120 	ldr.w	r3, [r4, #288]	@ 0x120
 8006dc2:	1ac0      	subs	r0, r0, r3
 8006dc4:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
 8006dc8:	4298      	cmp	r0, r3
 8006dca:	d91c      	bls.n	8006e06 <vHandleWaitingAcknowledge+0x52>
                EP_DHCPData.xDHCPTxPeriod <<= 1;
 8006dcc:	005b      	lsls	r3, r3, #1
 8006dce:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
                if( EP_DHCPData.xDHCPTxPeriod <= ( TickType_t ) ipconfigMAXIMUM_DISCOVER_TX_PERIOD )
 8006dd2:	4a21      	ldr	r2, [pc, #132]	@ (8006e58 <vHandleWaitingAcknowledge+0xa4>)
 8006dd4:	4293      	cmp	r3, r2
 8006dd6:	d903      	bls.n	8006de0 <vHandleWaitingAcknowledge+0x2c>
                    EP_DHCPData.eDHCPState = eInitialWait;
 8006dd8:	2300      	movs	r3, #0
 8006dda:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
 8006dde:	e012      	b.n	8006e06 <vHandleWaitingAcknowledge+0x52>
                    EP_DHCPData.xDHCPTxTime = xTaskGetTickCount();
 8006de0:	f7fd ff20 	bl	8004c24 <xTaskGetTickCount>
 8006de4:	f8c4 0120 	str.w	r0, [r4, #288]	@ 0x120
                    if( prvSendDHCPRequest( pxEndPoint ) == pdPASS )
 8006de8:	4620      	mov	r0, r4
 8006dea:	f7ff fdf1 	bl	80069d0 <prvSendDHCPRequest>
 8006dee:	2801      	cmp	r0, #1
 8006df0:	d009      	beq.n	8006e06 <vHandleWaitingAcknowledge+0x52>
                        EP_DHCPData.eDHCPState = eSendDHCPRequest;
 8006df2:	2304      	movs	r3, #4
 8006df4:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
 8006df8:	e005      	b.n	8006e06 <vHandleWaitingAcknowledge+0x52>
        else if( prvProcessDHCPReplies( dhcpMESSAGE_TYPE_ACK, pxEndPoint ) == pdPASS )
 8006dfa:	4601      	mov	r1, r0
 8006dfc:	2005      	movs	r0, #5
 8006dfe:	f7ff fe2b 	bl	8006a58 <prvProcessDHCPReplies>
 8006e02:	2801      	cmp	r0, #1
 8006e04:	d000      	beq.n	8006e08 <vHandleWaitingAcknowledge+0x54>
    }
 8006e06:	bd10      	pop	{r4, pc}
            EP_IPv4_SETTINGS.ulIPAddress = EP_DHCPData.ulOfferedIPAddress;
 8006e08:	f8d4 3110 	ldr.w	r3, [r4, #272]	@ 0x110
 8006e0c:	6023      	str	r3, [r4, #0]
            EP_IPv4_SETTINGS.ulBroadcastAddress = EP_DHCPData.ulOfferedIPAddress | ~( EP_IPv4_SETTINGS.ulNetMask );
 8006e0e:	6862      	ldr	r2, [r4, #4]
 8006e10:	ea63 0302 	orn	r3, r3, r2
 8006e14:	6163      	str	r3, [r4, #20]
            EP_DHCPData.eDHCPState = eLeasedAddress;
 8006e16:	2305      	movs	r3, #5
 8006e18:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
            vIPNetworkUpCalls( pxEndPoint );
 8006e1c:	4620      	mov	r0, r4
 8006e1e:	f000 f9dd 	bl	80071dc <vIPNetworkUpCalls>
            prvCloseDHCPSocket( pxEndPoint );
 8006e22:	4620      	mov	r0, r4
 8006e24:	f7ff feea 	bl	8006bfc <prvCloseDHCPSocket>
            if( EP_DHCPData.ulLeaseTime == 0U )
 8006e28:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
 8006e2c:	b953      	cbnz	r3, 8006e44 <vHandleWaitingAcknowledge+0x90>
                EP_DHCPData.ulLeaseTime = dhcpDEFAULT_LEASE_TIME;
 8006e2e:	4b0b      	ldr	r3, [pc, #44]	@ (8006e5c <vHandleWaitingAcknowledge+0xa8>)
 8006e30:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
            vARPSendGratuitous();
 8006e34:	f7ff f9be 	bl	80061b4 <vARPSendGratuitous>
            vDHCP_RATimerReload( ( struct xNetworkEndPoint * ) pxEndPoint, EP_DHCPData.ulLeaseTime );
 8006e38:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
 8006e3c:	4620      	mov	r0, r4
 8006e3e:	f000 fdc7 	bl	80079d0 <vDHCP_RATimerReload>
    }
 8006e42:	e7e0      	b.n	8006e06 <vHandleWaitingAcknowledge+0x52>
            else if( EP_DHCPData.ulLeaseTime < dhcpMINIMUM_LEASE_TIME )
 8006e44:	f64e 225f 	movw	r2, #59999	@ 0xea5f
 8006e48:	4293      	cmp	r3, r2
 8006e4a:	d8f3      	bhi.n	8006e34 <vHandleWaitingAcknowledge+0x80>
                EP_DHCPData.ulLeaseTime = dhcpMINIMUM_LEASE_TIME;
 8006e4c:	f64e 2360 	movw	r3, #60000	@ 0xea60
 8006e50:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
 8006e54:	e7ee      	b.n	8006e34 <vHandleWaitingAcknowledge+0x80>
 8006e56:	bf00      	nop
 8006e58:	0001d4c0 	.word	0x0001d4c0
 8006e5c:	0a4cb800 	.word	0x0a4cb800

08006e60 <vDHCPProcessEndPoint>:
        configASSERT( pxEndPoint != NULL );
 8006e60:	b1d2      	cbz	r2, 8006e98 <vDHCPProcessEndPoint+0x38>
    {
 8006e62:	b510      	push	{r4, lr}
 8006e64:	4614      	mov	r4, r2
        if( xReset != pdFALSE )
 8006e66:	b110      	cbz	r0, 8006e6e <vDHCPProcessEndPoint+0xe>
            EP_DHCPData.eDHCPState = eInitialWait;
 8006e68:	2300      	movs	r3, #0
 8006e6a:	f882 312c 	strb.w	r3, [r2, #300]	@ 0x12c
        if( ( EP_DHCPData.eDHCPState != EP_DHCPData.eExpectedState ) && ( xReset == pdFALSE ) )
 8006e6e:	f894 312c 	ldrb.w	r3, [r4, #300]	@ 0x12c
 8006e72:	f894 212d 	ldrb.w	r2, [r4, #301]	@ 0x12d
 8006e76:	4293      	cmp	r3, r2
 8006e78:	d000      	beq.n	8006e7c <vDHCPProcessEndPoint+0x1c>
 8006e7a:	b330      	cbz	r0, 8006eca <vDHCPProcessEndPoint+0x6a>
                if( eLastState != EP_DHCPData.eDHCPState )
 8006e7c:	4a34      	ldr	r2, [pc, #208]	@ (8006f50 <vDHCPProcessEndPoint+0xf0>)
 8006e7e:	7812      	ldrb	r2, [r2, #0]
 8006e80:	4293      	cmp	r3, r2
 8006e82:	d001      	beq.n	8006e88 <vDHCPProcessEndPoint+0x28>
                    eLastState = EP_DHCPData.eDHCPState;
 8006e84:	4a32      	ldr	r2, [pc, #200]	@ (8006f50 <vDHCPProcessEndPoint+0xf0>)
 8006e86:	7013      	strb	r3, [r2, #0]
            switch( EP_DHCPData.eDHCPState )
 8006e88:	2b06      	cmp	r3, #6
 8006e8a:	d84b      	bhi.n	8006f24 <vDHCPProcessEndPoint+0xc4>
 8006e8c:	e8df f003 	tbb	[pc, r3]
 8006e90:	3a361e0d 	.word	0x3a361e0d
 8006e94:	3f22      	.short	0x3f22
 8006e96:	44          	.byte	0x44
 8006e97:	00          	.byte	0x00
 8006e98:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006e9c:	f383 8811 	msr	BASEPRI, r3
 8006ea0:	f3bf 8f6f 	isb	sy
 8006ea4:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEndPoint != NULL );
 8006ea8:	e7fe      	b.n	8006ea8 <vDHCPProcessEndPoint+0x48>
                    prvInitialiseDHCP( pxEndPoint );
 8006eaa:	4620      	mov	r0, r4
 8006eac:	f7ff ff32 	bl	8006d14 <prvInitialiseDHCP>
                    EP_DHCPData.eDHCPState = eWaitingSendFirstDiscover;
 8006eb0:	2301      	movs	r3, #1
 8006eb2:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
        BaseType_t xGivingUp = pdFALSE;
 8006eb6:	2000      	movs	r0, #0
                if( eLastState != EP_DHCPData.eDHCPState )
 8006eb8:	f894 312c 	ldrb.w	r3, [r4, #300]	@ 0x12c
 8006ebc:	4a25      	ldr	r2, [pc, #148]	@ (8006f54 <vDHCPProcessEndPoint+0xf4>)
 8006ebe:	7812      	ldrb	r2, [r2, #0]
 8006ec0:	4293      	cmp	r3, r2
 8006ec2:	d001      	beq.n	8006ec8 <vDHCPProcessEndPoint+0x68>
                    eLastState = EP_DHCPData.eDHCPState;
 8006ec4:	4a23      	ldr	r2, [pc, #140]	@ (8006f54 <vDHCPProcessEndPoint+0xf4>)
 8006ec6:	7013      	strb	r3, [r2, #0]
            if( xGivingUp != pdFALSE )
 8006ec8:	bb70      	cbnz	r0, 8006f28 <vDHCPProcessEndPoint+0xc8>
    }
 8006eca:	bd10      	pop	{r4, pc}
                    xGivingUp = xHandleWaitingFirstDiscover( pxEndPoint );
 8006ecc:	4620      	mov	r0, r4
 8006ece:	f7ff fd65 	bl	800699c <xHandleWaitingFirstDiscover>
                    break;
 8006ed2:	e7f1      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                    if( prvSendDHCPRequest( pxEndPoint ) == pdPASS )
 8006ed4:	4620      	mov	r0, r4
 8006ed6:	f7ff fd7b 	bl	80069d0 <prvSendDHCPRequest>
 8006eda:	2801      	cmp	r0, #1
 8006edc:	d001      	beq.n	8006ee2 <vDHCPProcessEndPoint+0x82>
        BaseType_t xGivingUp = pdFALSE;
 8006ede:	2000      	movs	r0, #0
 8006ee0:	e7ea      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                        EP_DHCPData.xDHCPTxTime = xTaskGetTickCount();
 8006ee2:	f7fd fe9f 	bl	8004c24 <xTaskGetTickCount>
 8006ee6:	f8c4 0120 	str.w	r0, [r4, #288]	@ 0x120
                        EP_DHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8006eea:	f241 3388 	movw	r3, #5000	@ 0x1388
 8006eee:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
                        EP_DHCPData.eDHCPState = eWaitingAcknowledge;
 8006ef2:	2303      	movs	r3, #3
 8006ef4:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
        BaseType_t xGivingUp = pdFALSE;
 8006ef8:	2000      	movs	r0, #0
 8006efa:	e7dd      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                    xGivingUp = xHandleWaitingOffer( pxEndPoint, xDoCheck );
 8006efc:	4620      	mov	r0, r4
 8006efe:	f7ff fe25 	bl	8006b4c <xHandleWaitingOffer>
                    break;
 8006f02:	e7d9      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                    vHandleWaitingAcknowledge( pxEndPoint, xDoCheck );
 8006f04:	4620      	mov	r0, r4
 8006f06:	f7ff ff55 	bl	8006db4 <vHandleWaitingAcknowledge>
        BaseType_t xGivingUp = pdFALSE;
 8006f0a:	2000      	movs	r0, #0
                    break;
 8006f0c:	e7d4      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                    prvHandleWaitingeLeasedAddress( pxEndPoint );
 8006f0e:	4620      	mov	r0, r4
 8006f10:	f7ff ff1b 	bl	8006d4a <prvHandleWaitingeLeasedAddress>
        BaseType_t xGivingUp = pdFALSE;
 8006f14:	2000      	movs	r0, #0
                    break;
 8006f16:	e7cf      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                    vIPSetDHCP_RATimerEnableState( pxEndPoint, pdFALSE );
 8006f18:	2100      	movs	r1, #0
 8006f1a:	4620      	mov	r0, r4
 8006f1c:	f000 fd9a 	bl	8007a54 <vIPSetDHCP_RATimerEnableState>
        BaseType_t xGivingUp = pdFALSE;
 8006f20:	2000      	movs	r0, #0
                    break;
 8006f22:	e7c9      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
            switch( EP_DHCPData.eDHCPState )
 8006f24:	2000      	movs	r0, #0
 8006f26:	e7c7      	b.n	8006eb8 <vDHCPProcessEndPoint+0x58>
                taskENTER_CRITICAL();
 8006f28:	f7fe fd04 	bl	8005934 <vPortEnterCritical>
                    EP_IPv4_SETTINGS.ulIPAddress = pxEndPoint->ipv4_defaults.ulIPAddress;
 8006f2c:	69e3      	ldr	r3, [r4, #28]
 8006f2e:	6023      	str	r3, [r4, #0]
                taskEXIT_CRITICAL();
 8006f30:	f7fe fd22 	bl	8005978 <vPortExitCritical>
                EP_DHCPData.eDHCPState = eNotUsingLeasedAddress;
 8006f34:	2306      	movs	r3, #6
 8006f36:	f884 312c 	strb.w	r3, [r4, #300]	@ 0x12c
                vIPSetDHCP_RATimerEnableState( pxEndPoint, pdFALSE );
 8006f3a:	2100      	movs	r1, #0
 8006f3c:	4620      	mov	r0, r4
 8006f3e:	f000 fd89 	bl	8007a54 <vIPSetDHCP_RATimerEnableState>
                vIPNetworkUpCalls( pxEndPoint );
 8006f42:	4620      	mov	r0, r4
 8006f44:	f000 f94a 	bl	80071dc <vIPNetworkUpCalls>
                prvCloseDHCPSocket( pxEndPoint );
 8006f48:	4620      	mov	r0, r4
 8006f4a:	f7ff fe57 	bl	8006bfc <prvCloseDHCPSocket>
    }
 8006f4e:	e7bc      	b.n	8006eca <vDHCPProcessEndPoint+0x6a>
 8006f50:	2000001d 	.word	0x2000001d
 8006f54:	2000001c 	.word	0x2000001c

08006f58 <xIsDHCPSocket>:
        if( xDHCPv4Socket == xSocket )
 8006f58:	4b03      	ldr	r3, [pc, #12]	@ (8006f68 <xIsDHCPSocket+0x10>)
 8006f5a:	681b      	ldr	r3, [r3, #0]
 8006f5c:	4283      	cmp	r3, r0
 8006f5e:	d001      	beq.n	8006f64 <xIsDHCPSocket+0xc>
            xReturn = pdFALSE;
 8006f60:	2000      	movs	r0, #0
    }
 8006f62:	4770      	bx	lr
            xReturn = pdTRUE;
 8006f64:	2001      	movs	r0, #1
 8006f66:	4770      	bx	lr
 8006f68:	20011b14 	.word	0x20011b14

08006f6c <vDHCPProcess>:
        configASSERT( pxEndPoint != NULL );
 8006f6c:	b189      	cbz	r1, 8006f92 <vDHCPProcess+0x26>
    {
 8006f6e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006f70:	b085      	sub	sp, #20
 8006f72:	4606      	mov	r6, r0
 8006f74:	460c      	mov	r4, r1
        configASSERT( pxEndPoint->bits.bIPv6 == 0 );
 8006f76:	f891 30f0 	ldrb.w	r3, [r1, #240]	@ 0xf0
 8006f7a:	f013 0f08 	tst.w	r3, #8
 8006f7e:	d011      	beq.n	8006fa4 <vDHCPProcess+0x38>
 8006f80:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006f84:	f383 8811 	msr	BASEPRI, r3
 8006f88:	f3bf 8f6f 	isb	sy
 8006f8c:	f3bf 8f4f 	dsb	sy
 8006f90:	e7fe      	b.n	8006f90 <vDHCPProcess+0x24>
 8006f92:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8006f96:	f383 8811 	msr	BASEPRI, r3
 8006f9a:	f3bf 8f6f 	isb	sy
 8006f9e:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEndPoint != NULL );
 8006fa2:	e7fe      	b.n	8006fa2 <vDHCPProcess+0x36>
        if( xReset != pdFALSE )
 8006fa4:	b110      	cbz	r0, 8006fac <vDHCPProcess+0x40>
            EP_DHCPData.eDHCPState = eInitialWait;
 8006fa6:	2300      	movs	r3, #0
 8006fa8:	f881 312c 	strb.w	r3, [r1, #300]	@ 0x12c
        if( ( EP_DHCPData.eDHCPState != EP_DHCPData.eExpectedState ) && ( xReset == pdFALSE ) )
 8006fac:	f894 212c 	ldrb.w	r2, [r4, #300]	@ 0x12c
 8006fb0:	f894 312d 	ldrb.w	r3, [r4, #301]	@ 0x12d
 8006fb4:	429a      	cmp	r2, r3
 8006fb6:	d001      	beq.n	8006fbc <vDHCPProcess+0x50>
 8006fb8:	2e00      	cmp	r6, #0
 8006fba:	d054      	beq.n	8007066 <vDHCPProcess+0xfa>
        else if( EP_DHCPData.xDHCPSocket != NULL ) /* If there is a socket, check for incoming messages first. */
 8006fbc:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
 8006fc0:	2b00      	cmp	r3, #0
 8006fc2:	d050      	beq.n	8007066 <vDHCPProcess+0xfa>
            uint8_t * pucUDPPayload = NULL;
 8006fc4:	2300      	movs	r3, #0
 8006fc6:	9303      	str	r3, [sp, #12]
        BaseType_t xDoProcess = pdTRUE;
 8006fc8:	2701      	movs	r7, #1
            while( EP_DHCPData.xDHCPSocket != NULL )
 8006fca:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
 8006fce:	2800      	cmp	r0, #0
 8006fd0:	d048      	beq.n	8007064 <vDHCPProcess+0xf8>
                lBytes = FreeRTOS_recvfrom( EP_DHCPData.xDHCPSocket, &( pucUDPPayload ), 0, xRecvFlags, NULL, NULL );
 8006fd2:	2200      	movs	r2, #0
 8006fd4:	9201      	str	r2, [sp, #4]
 8006fd6:	9200      	str	r2, [sp, #0]
 8006fd8:	2305      	movs	r3, #5
 8006fda:	a903      	add	r1, sp, #12
 8006fdc:	f003 fdcd 	bl	800ab7a <FreeRTOS_recvfrom>
                if( lBytes < ( ( int32_t ) sizeof( DHCPMessage_IPv4_t ) ) )
 8006fe0:	28ef      	cmp	r0, #239	@ 0xef
 8006fe2:	dd3f      	ble.n	8007064 <vDHCPProcess+0xf8>
                pxDHCPMessage = ( ( const DHCPMessage_IPv4_t * ) pucUDPPayload );
 8006fe4:	9903      	ldr	r1, [sp, #12]
                if( ( pxDHCPMessage->ulDHCPCookie == dhcpCOOKIE ) && ( pxDHCPMessage->ucOpcode == dhcpREPLY_OPCODE ) )
 8006fe6:	f8d1 20ec 	ldr.w	r2, [r1, #236]	@ 0xec
 8006fea:	4b22      	ldr	r3, [pc, #136]	@ (8007074 <vDHCPProcess+0x108>)
 8006fec:	429a      	cmp	r2, r3
 8006fee:	d102      	bne.n	8006ff6 <vDHCPProcess+0x8a>
 8006ff0:	780b      	ldrb	r3, [r1, #0]
 8006ff2:	2b02      	cmp	r3, #2
 8006ff4:	d010      	beq.n	8007018 <vDHCPProcess+0xac>
                    lBytes = FreeRTOS_recvfrom( EP_DHCPData.xDHCPSocket, &( pucUDPPayload ), 0, FREERTOS_ZERO_COPY, NULL, NULL );
 8006ff6:	2200      	movs	r2, #0
 8006ff8:	9201      	str	r2, [sp, #4]
 8006ffa:	9200      	str	r2, [sp, #0]
 8006ffc:	2301      	movs	r3, #1
 8006ffe:	a903      	add	r1, sp, #12
 8007000:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
 8007004:	f003 fdb9 	bl	800ab7a <FreeRTOS_recvfrom>
                    if( ( lBytes > 0 ) && ( pucUDPPayload != NULL ) )
 8007008:	2800      	cmp	r0, #0
 800700a:	ddde      	ble.n	8006fca <vDHCPProcess+0x5e>
 800700c:	9803      	ldr	r0, [sp, #12]
 800700e:	2800      	cmp	r0, #0
 8007010:	d0db      	beq.n	8006fca <vDHCPProcess+0x5e>
                        FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayload );
 8007012:	f000 f951 	bl	80072b8 <FreeRTOS_ReleaseUDPPayloadBuffer>
 8007016:	e7d8      	b.n	8006fca <vDHCPProcess+0x5e>
                    pxIterator = pxNetworkEndPoints;
 8007018:	4b17      	ldr	r3, [pc, #92]	@ (8007078 <vDHCPProcess+0x10c>)
 800701a:	681d      	ldr	r5, [r3, #0]
                    while( pxIterator != NULL )
 800701c:	b19d      	cbz	r5, 8007046 <vDHCPProcess+0xda>
                        if( pxDHCPMessage->ulTransactionID == FreeRTOS_htonl( pxIterator->xDHCPData.ulTransactionId ) )
 800701e:	f8d1 c004 	ldr.w	ip, [r1, #4]
 8007022:	f8d5 210c 	ldr.w	r2, [r5, #268]	@ 0x10c
 8007026:	0213      	lsls	r3, r2, #8
 8007028:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800702c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8007030:	0a10      	lsrs	r0, r2, #8
 8007032:	f400 407f 	and.w	r0, r0, #65280	@ 0xff00
 8007036:	4303      	orrs	r3, r0
 8007038:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800703c:	459c      	cmp	ip, r3
 800703e:	d002      	beq.n	8007046 <vDHCPProcess+0xda>
                        pxIterator = pxIterator->pxNext;
 8007040:	f8d5 515c 	ldr.w	r5, [r5, #348]	@ 0x15c
 8007044:	e7ea      	b.n	800701c <vDHCPProcess+0xb0>
                if( ( pxIterator != NULL ) && ( pxIterator->xDHCPData.eDHCPState == eLeasedAddress ) )
 8007046:	2d00      	cmp	r5, #0
 8007048:	d0d5      	beq.n	8006ff6 <vDHCPProcess+0x8a>
 800704a:	f895 312c 	ldrb.w	r3, [r5, #300]	@ 0x12c
 800704e:	2b05      	cmp	r3, #5
 8007050:	d0d1      	beq.n	8006ff6 <vDHCPProcess+0x8a>
                    vDHCPProcessEndPoint( pdFALSE, pdTRUE, pxIterator );
 8007052:	462a      	mov	r2, r5
 8007054:	2101      	movs	r1, #1
 8007056:	2000      	movs	r0, #0
 8007058:	f7ff ff02 	bl	8006e60 <vDHCPProcessEndPoint>
                    if( pxEndPoint == pxIterator )
 800705c:	42a5      	cmp	r5, r4
 800705e:	d1b4      	bne.n	8006fca <vDHCPProcess+0x5e>
                        xDoProcess = pdFALSE;
 8007060:	2700      	movs	r7, #0
 8007062:	e7b2      	b.n	8006fca <vDHCPProcess+0x5e>
        if( xDoProcess != pdFALSE )
 8007064:	b127      	cbz	r7, 8007070 <vDHCPProcess+0x104>
            vDHCPProcessEndPoint( xReset, pdFALSE, pxEndPoint );
 8007066:	4622      	mov	r2, r4
 8007068:	2100      	movs	r1, #0
 800706a:	4630      	mov	r0, r6
 800706c:	f7ff fef8 	bl	8006e60 <vDHCPProcessEndPoint>
    }
 8007070:	b005      	add	sp, #20
 8007072:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007074:	63538263 	.word	0x63538263
 8007078:	20013778 	.word	0x20013778

0800707c <vDHCPStop>:
    {
 800707c:	b510      	push	{r4, lr}
 800707e:	4604      	mov	r4, r0
        vIPSetDHCP_RATimerEnableState( pxEndPoint, pdFALSE );
 8007080:	2100      	movs	r1, #0
 8007082:	f000 fce7 	bl	8007a54 <vIPSetDHCP_RATimerEnableState>
        prvCloseDHCPSocket( pxEndPoint );
 8007086:	4620      	mov	r0, r4
 8007088:	f7ff fdb8 	bl	8006bfc <prvCloseDHCPSocket>
    }
 800708c:	bd10      	pop	{r4, pc}
	...

08007090 <FreeRTOS_dnsclear>:
/**
 * @brief perform a dns clear in the local cache
 * @post the global structure \a xDNSCache is modified
 */
    void FreeRTOS_dnsclear( void )
    {
 8007090:	b508      	push	{r3, lr}
        ( void ) memset( xDNSCache, 0x0, sizeof( xDNSCache ) );
 8007092:	f44f 72c2 	mov.w	r2, #388	@ 0x184
 8007096:	2100      	movs	r1, #0
 8007098:	4803      	ldr	r0, [pc, #12]	@ (80070a8 <FreeRTOS_dnsclear+0x18>)
 800709a:	f007 fe0b 	bl	800ecb4 <memset>
        uxFreeEntry = 0U;
 800709e:	4b03      	ldr	r3, [pc, #12]	@ (80070ac <FreeRTOS_dnsclear+0x1c>)
 80070a0:	2200      	movs	r2, #0
 80070a2:	601a      	str	r2, [r3, #0]
    }
 80070a4:	bd08      	pop	{r3, pc}
 80070a6:	bf00      	nop
 80070a8:	20011b1c 	.word	0x20011b1c
 80070ac:	20011b18 	.word	0x20011b18

080070b0 <prvProcessICMPEchoRequest>:
 * @param pxNetworkBuffer Pointer to the network buffer containing the ICMP packet.
 * @returns Function returns eReturnEthernetFrame.
 */
    static eFrameProcessingResult_t prvProcessICMPEchoRequest( ICMPPacket_t * const pxICMPPacket,
                                                               const NetworkBufferDescriptor_t * const pxNetworkBuffer )
    {
 80070b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80070b2:	4604      	mov	r4, r0
 80070b4:	460e      	mov	r6, r1

        /* The checksum can be checked here - but a ping reply should be
         * returned even if the checksum is incorrect so the other end can
         * tell that the ping was received - even if the ping reply contains
         * invalid data. */
        pxICMPHeader->ucTypeOfMessage = ( uint8_t ) ipICMP_ECHO_REPLY;
 80070b6:	2500      	movs	r5, #0
 80070b8:	f880 5022 	strb.w	r5, [r0, #34]	@ 0x22
        ulIPAddress = pxIPHeader->ulDestinationIPAddress;
 80070bc:	f8d0 301e 	ldr.w	r3, [r0, #30]
        pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 80070c0:	f8d0 201a 	ldr.w	r2, [r0, #26]
 80070c4:	f8c0 201e 	str.w	r2, [r0, #30]
        pxIPHeader->ulSourceIPAddress = ulIPAddress;
 80070c8:	f8c0 301a 	str.w	r3, [r0, #26]
        /* Update the TTL field. */
        pxIPHeader->ucTimeToLive = ipconfigICMP_TIME_TO_LIVE;
 80070cc:	2340      	movs	r3, #64	@ 0x40
 80070ce:	7583      	strb	r3, [r0, #22]
         * The header was never memset to zero, so set both the fragment offset and fragmentation flags in one go.
         */
        #if ( ipconfigFORCE_IP_DONT_FRAGMENT != 0 )
            pxIPHeader->usFragmentOffset = ipFRAGMENT_FLAGS_DONT_FRAGMENT;
        #else
            pxIPHeader->usFragmentOffset = 0U;
 80070d0:	7505      	strb	r5, [r0, #20]
 80070d2:	7545      	strb	r5, [r0, #21]
        #endif

        #if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
        {
            /* calculate the IP header checksum, in case the driver won't do that. */
            pxIPHeader->usHeaderChecksum = 0x00U;
 80070d4:	7605      	strb	r5, [r0, #24]
 80070d6:	7645      	strb	r5, [r0, #25]
            pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), uxIPHeaderSizePacket( pxNetworkBuffer ) );
 80070d8:	f100 070e 	add.w	r7, r0, #14
 80070dc:	4608      	mov	r0, r1
 80070de:	f000 f9fb 	bl	80074d8 <uxIPHeaderSizePacket>
 80070e2:	4602      	mov	r2, r0
 80070e4:	4639      	mov	r1, r7
 80070e6:	4628      	mov	r0, r5
 80070e8:	f000 ff4a 	bl	8007f80 <usGenerateChecksum>
 80070ec:	8320      	strh	r0, [r4, #24]
            pxIPHeader->usHeaderChecksum = ( uint16_t ) ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 80070ee:	f3c0 230f 	ubfx	r3, r0, #8, #16
 80070f2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80070f6:	b29b      	uxth	r3, r3
 80070f8:	43db      	mvns	r3, r3
 80070fa:	8323      	strh	r3, [r4, #24]

            /* calculate the ICMP checksum for an outgoing packet. */
            ( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxICMPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
 80070fc:	2201      	movs	r2, #1
 80070fe:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8007100:	4620      	mov	r0, r4
 8007102:	f001 f81f 	bl	8008144 <usGenerateProtocolChecksum>
            pxICMPHeader->usChecksum = 0U;
        }
        #endif /* if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 ) */

        return eReturnEthernetFrame;
    }
 8007106:	2002      	movs	r0, #2
 8007108:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800710a <ProcessICMPPacket>:
    {
 800710a:	b508      	push	{r3, lr}
        configASSERT( pxNetworkBuffer->xDataLength >= sizeof( ICMPPacket_t ) );
 800710c:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800710e:	2b29      	cmp	r3, #41	@ 0x29
 8007110:	d808      	bhi.n	8007124 <ProcessICMPPacket+0x1a>
 8007112:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007116:	f383 8811 	msr	BASEPRI, r3
 800711a:	f3bf 8f6f 	isb	sy
 800711e:	f3bf 8f4f 	dsb	sy
 8007122:	e7fe      	b.n	8007122 <ProcessICMPPacket+0x18>
            ICMPPacket_t * pxICMPPacket = ( ( ICMPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 8007124:	6a43      	ldr	r3, [r0, #36]	@ 0x24
            switch( pxICMPPacket->xICMPHeader.ucTypeOfMessage )
 8007126:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
 800712a:	2a08      	cmp	r2, #8
 800712c:	d001      	beq.n	8007132 <ProcessICMPPacket+0x28>
        eFrameProcessingResult_t eReturn = eReleaseBuffer;
 800712e:	2000      	movs	r0, #0
    }
 8007130:	bd08      	pop	{r3, pc}
                        eReturn = prvProcessICMPEchoRequest( pxICMPPacket, pxNetworkBuffer );
 8007132:	4601      	mov	r1, r0
 8007134:	4618      	mov	r0, r3
 8007136:	f7ff ffbb 	bl	80070b0 <prvProcessICMPEchoRequest>
                    break;
 800713a:	e7f9      	b.n	8007130 <ProcessICMPPacket+0x26>

0800713c <prvForwardTxPacket>:
 * @param[in] pxNetworkBuffer The message buffer.
 * @param[in] xReleaseAfterSend When true, the network interface will own the buffer and is responsible for it's release.
 */
static void prvForwardTxPacket( NetworkBufferDescriptor_t * pxNetworkBuffer,
                                BaseType_t xReleaseAfterSend )
{
 800713c:	4603      	mov	r3, r0
    iptraceNETWORK_INTERFACE_OUTPUT( pxNetworkBuffer->xDataLength, pxNetworkBuffer->pucEthernetBuffer );

    if( pxNetworkBuffer->pxInterface != NULL )
 800713e:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 8007140:	b128      	cbz	r0, 800714e <prvForwardTxPacket+0x12>
{
 8007142:	b510      	push	{r4, lr}
 8007144:	460a      	mov	r2, r1
    {
        ( void ) pxNetworkBuffer->pxInterface->pfOutput( pxNetworkBuffer->pxInterface, pxNetworkBuffer, xReleaseAfterSend );
 8007146:	68c4      	ldr	r4, [r0, #12]
 8007148:	4619      	mov	r1, r3
 800714a:	47a0      	blx	r4
    }
}
 800714c:	bd10      	pop	{r4, pc}
 800714e:	4770      	bx	lr

08007150 <prvCallDHCP_RA_Handler>:
{
 8007150:	b538      	push	{r3, r4, r5, lr}
 8007152:	4604      	mov	r4, r0
        if( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED )
 8007154:	f890 30f0 	ldrb.w	r3, [r0, #240]	@ 0xf0
 8007158:	f013 0f08 	tst.w	r3, #8
 800715c:	d106      	bne.n	800716c <prvCallDHCP_RA_Handler+0x1c>
    BaseType_t xIsIPv6 = pdFALSE;
 800715e:	2500      	movs	r5, #0
        if( ( pxEndPoint->bits.bWantDHCP != pdFALSE_UNSIGNED ) && ( xIsIPv6 == pdFALSE ) )
 8007160:	f013 0f02 	tst.w	r3, #2
 8007164:	d000      	beq.n	8007168 <prvCallDHCP_RA_Handler+0x18>
 8007166:	b11d      	cbz	r5, 8007170 <prvCallDHCP_RA_Handler+0x20>
        if( ( xIsIPv6 == pdTRUE ) && ( pxEndPoint->bits.bWantRA != pdFALSE_UNSIGNED ) )
 8007168:	b93d      	cbnz	r5, 800717a <prvCallDHCP_RA_Handler+0x2a>
}
 800716a:	bd38      	pop	{r3, r4, r5, pc}
            xIsIPv6 = pdTRUE;
 800716c:	2501      	movs	r5, #1
 800716e:	e7f7      	b.n	8007160 <prvCallDHCP_RA_Handler+0x10>
            vDHCPProcess( pdFALSE, pxEndPoint );
 8007170:	4621      	mov	r1, r4
 8007172:	2000      	movs	r0, #0
 8007174:	f7ff fefa 	bl	8006f6c <vDHCPProcess>
 8007178:	e7f6      	b.n	8007168 <prvCallDHCP_RA_Handler+0x18>
        if( ( xIsIPv6 == pdTRUE ) && ( pxEndPoint->bits.bWantRA != pdFALSE_UNSIGNED ) )
 800717a:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 800717e:	f013 0f04 	tst.w	r3, #4
 8007182:	d0f2      	beq.n	800716a <prvCallDHCP_RA_Handler+0x1a>
            vRAProcess( pdFALSE, pxEndPoint );
 8007184:	4621      	mov	r1, r4
 8007186:	2000      	movs	r0, #0
 8007188:	f002 fb13 	bl	80097b2 <vRAProcess>
}
 800718c:	e7ed      	b.n	800716a <prvCallDHCP_RA_Handler+0x1a>
	...

08007190 <prvIPTask_CheckPendingEvents>:
    if( xNetworkDownEventPending != pdFALSE )
 8007190:	4b0e      	ldr	r3, [pc, #56]	@ (80071cc <prvIPTask_CheckPendingEvents+0x3c>)
 8007192:	681b      	ldr	r3, [r3, #0]
 8007194:	b903      	cbnz	r3, 8007198 <prvIPTask_CheckPendingEvents+0x8>
 8007196:	4770      	bx	lr
{
 8007198:	b510      	push	{r4, lr}
        xNetworkDownEventPending = pdFALSE;
 800719a:	4b0c      	ldr	r3, [pc, #48]	@ (80071cc <prvIPTask_CheckPendingEvents+0x3c>)
 800719c:	2200      	movs	r2, #0
 800719e:	601a      	str	r2, [r3, #0]
        for( pxInterface = FreeRTOS_FirstNetworkInterface();
 80071a0:	f002 fc38 	bl	8009a14 <FreeRTOS_FirstNetworkInterface>
 80071a4:	4604      	mov	r4, r0
 80071a6:	e003      	b.n	80071b0 <prvIPTask_CheckPendingEvents+0x20>
             pxInterface = FreeRTOS_NextNetworkInterface( pxInterface ) )
 80071a8:	4620      	mov	r0, r4
 80071aa:	f002 fc39 	bl	8009a20 <FreeRTOS_NextNetworkInterface>
 80071ae:	4604      	mov	r4, r0
             pxInterface != NULL;
 80071b0:	b15c      	cbz	r4, 80071ca <prvIPTask_CheckPendingEvents+0x3a>
            if( pxInterface->bits.bCallDownEvent != pdFALSE_UNSIGNED )
 80071b2:	7f23      	ldrb	r3, [r4, #28]
 80071b4:	f013 0f02 	tst.w	r3, #2
 80071b8:	d0f6      	beq.n	80071a8 <prvIPTask_CheckPendingEvents+0x18>
                prvProcessNetworkDownEvent( pxInterface );
 80071ba:	4620      	mov	r0, r4
 80071bc:	f000 fe0f 	bl	8007dde <prvProcessNetworkDownEvent>
                pxInterface->bits.bCallDownEvent = pdFALSE_UNSIGNED;
 80071c0:	7f23      	ldrb	r3, [r4, #28]
 80071c2:	f023 0302 	bic.w	r3, r3, #2
 80071c6:	7723      	strb	r3, [r4, #28]
 80071c8:	e7ee      	b.n	80071a8 <prvIPTask_CheckPendingEvents+0x18>
}
 80071ca:	bd10      	pop	{r4, pc}
 80071cc:	200133a8 	.word	0x200133a8

080071d0 <FreeRTOS_GetIPTaskHandle>:
}
 80071d0:	4b01      	ldr	r3, [pc, #4]	@ (80071d8 <FreeRTOS_GetIPTaskHandle+0x8>)
 80071d2:	6818      	ldr	r0, [r3, #0]
 80071d4:	4770      	bx	lr
 80071d6:	bf00      	nop
 80071d8:	200133a4 	.word	0x200133a4

080071dc <vIPNetworkUpCalls>:
{
 80071dc:	b510      	push	{r4, lr}
 80071de:	4604      	mov	r4, r0
    if( pxEndPoint->bits.bIPv6 == pdTRUE_UNSIGNED )
 80071e0:	f890 30f0 	ldrb.w	r3, [r0, #240]	@ 0xf0
 80071e4:	f013 0f08 	tst.w	r3, #8
 80071e8:	d10e      	bne.n	8007208 <vIPNetworkUpCalls+0x2c>
    pxEndPoint->bits.bEndPointUp = pdTRUE_UNSIGNED;
 80071ea:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 80071ee:	f043 0320 	orr.w	r3, r3, #32
 80071f2:	f884 30f0 	strb.w	r3, [r4, #240]	@ 0xf0
            vApplicationIPNetworkEventHook_Multi( eNetworkUp, pxEndPoint );
 80071f6:	4621      	mov	r1, r4
 80071f8:	2000      	movs	r0, #0
 80071fa:	f7fa f96f 	bl	80014dc <vApplicationIPNetworkEventHook_Multi>
    vARPTimerReload( pdMS_TO_TICKS( ipARP_TIMER_PERIOD_MS ) );
 80071fe:	f242 7010 	movw	r0, #10000	@ 0x2710
 8007202:	f000 fbdd 	bl	80079c0 <vARPTimerReload>
}
 8007206:	bd10      	pop	{r4, pc}
            vManageSolicitedNodeAddress( pxEndPoint, pdTRUE );
 8007208:	2101      	movs	r1, #1
 800720a:	f001 fd0c 	bl	8008c26 <vManageSolicitedNodeAddress>
 800720e:	e7ec      	b.n	80071ea <vIPNetworkUpCalls+0xe>

08007210 <FreeRTOS_IPInit_Multi>:
 * @brief Initialise the FreeRTOS-Plus-TCP network stack and initialise the IP-task.
 *        Before calling this function, at least 1 interface and 1 end-point must
 *        have been set-up.
 */
BaseType_t FreeRTOS_IPInit_Multi( void )
{
 8007210:	b530      	push	{r4, r5, lr}
 8007212:	b085      	sub	sp, #20
    BaseType_t xReturn = pdFALSE;

    /* There must be at least one interface and one end-point. */
    configASSERT( FreeRTOS_FirstNetworkInterface() != NULL );
 8007214:	f002 fbfe 	bl	8009a14 <FreeRTOS_FirstNetworkInterface>
 8007218:	b1d8      	cbz	r0, 8007252 <FreeRTOS_IPInit_Multi+0x42>

    /* Check that the configuration values are correct and that the IP-task has not
     * already been initialized. */
    vPreCheckConfigs();
 800721a:	f000 fe89 	bl	8007f30 <vPreCheckConfigs>
    /* Attempt to create the queue used to communicate with the IP task. */
    #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    {
        static StaticQueue_t xNetworkEventStaticQueue;
        static uint8_t ucNetworkEventQueueStorageArea[ ipconfigEVENT_QUEUE_LENGTH * sizeof( IPStackEvent_t ) ];
        xNetworkEventQueue = xQueueCreateStatic( ipconfigEVENT_QUEUE_LENGTH,
 800721e:	2300      	movs	r3, #0
 8007220:	9300      	str	r3, [sp, #0]
 8007222:	4b1c      	ldr	r3, [pc, #112]	@ (8007294 <FreeRTOS_IPInit_Multi+0x84>)
 8007224:	4a1c      	ldr	r2, [pc, #112]	@ (8007298 <FreeRTOS_IPInit_Multi+0x88>)
 8007226:	2108      	movs	r1, #8
 8007228:	2041      	movs	r0, #65	@ 0x41
 800722a:	f7fc fefd 	bl	8004028 <xQueueGenericCreateStatic>
 800722e:	4b1b      	ldr	r3, [pc, #108]	@ (800729c <FreeRTOS_IPInit_Multi+0x8c>)
 8007230:	6018      	str	r0, [r3, #0]
        xNetworkEventQueue = xQueueCreate( ipconfigEVENT_QUEUE_LENGTH, sizeof( IPStackEvent_t ) );
        configASSERT( xNetworkEventQueue != NULL );
    }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    if( xNetworkEventQueue != NULL )
 8007232:	b358      	cbz	r0, 800728c <FreeRTOS_IPInit_Multi+0x7c>
        #if ( configQUEUE_REGISTRY_SIZE > 0 )
        {
            /* A queue registry is normally used to assist a kernel aware
             * debugger.  If one is in use then it will be helpful for the debugger
             * to show information about the network event queue. */
            vQueueAddToRegistry( xNetworkEventQueue, "NetEvnt" );
 8007234:	491a      	ldr	r1, [pc, #104]	@ (80072a0 <FreeRTOS_IPInit_Multi+0x90>)
 8007236:	f7fd fa25 	bl	8004684 <vQueueAddToRegistry>
        }
        #endif /* configQUEUE_REGISTRY_SIZE */

        if( xNetworkBuffersInitialise() == pdPASS )
 800723a:	f007 f9e3 	bl	800e604 <xNetworkBuffersInitialise>
 800723e:	4604      	mov	r4, r0
 8007240:	2801      	cmp	r0, #1
 8007242:	d00f      	beq.n	8007264 <FreeRTOS_IPInit_Multi+0x54>
        else
        {
            FreeRTOS_debug_printf( ( "FreeRTOS_IPInit_Multi: xNetworkBuffersInitialise() failed\n" ) );

            /* Clean up. */
            vQueueDelete( xNetworkEventQueue );
 8007244:	4d15      	ldr	r5, [pc, #84]	@ (800729c <FreeRTOS_IPInit_Multi+0x8c>)
 8007246:	6828      	ldr	r0, [r5, #0]
 8007248:	f7fd fa46 	bl	80046d8 <vQueueDelete>
            xNetworkEventQueue = NULL;
 800724c:	2400      	movs	r4, #0
 800724e:	602c      	str	r4, [r5, #0]
 8007250:	e01d      	b.n	800728e <FreeRTOS_IPInit_Multi+0x7e>
 8007252:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007256:	f383 8811 	msr	BASEPRI, r3
 800725a:	f3bf 8f6f 	isb	sy
 800725e:	f3bf 8f4f 	dsb	sy
    configASSERT( FreeRTOS_FirstNetworkInterface() != NULL );
 8007262:	e7fe      	b.n	8007262 <FreeRTOS_IPInit_Multi+0x52>
            vNetworkSocketsInit();
 8007264:	f003 f94e 	bl	800a504 <vNetworkSocketsInit>
                xIPTaskHandle = xTaskCreateStatic( prvIPTask,
 8007268:	4b0e      	ldr	r3, [pc, #56]	@ (80072a4 <FreeRTOS_IPInit_Multi+0x94>)
 800726a:	9302      	str	r3, [sp, #8]
 800726c:	4b0e      	ldr	r3, [pc, #56]	@ (80072a8 <FreeRTOS_IPInit_Multi+0x98>)
 800726e:	9301      	str	r3, [sp, #4]
 8007270:	2336      	movs	r3, #54	@ 0x36
 8007272:	9300      	str	r3, [sp, #0]
 8007274:	2300      	movs	r3, #0
 8007276:	f44f 62a0 	mov.w	r2, #1280	@ 0x500
 800727a:	490c      	ldr	r1, [pc, #48]	@ (80072ac <FreeRTOS_IPInit_Multi+0x9c>)
 800727c:	480c      	ldr	r0, [pc, #48]	@ (80072b0 <FreeRTOS_IPInit_Multi+0xa0>)
 800727e:	f7fd fc05 	bl	8004a8c <xTaskCreateStatic>
 8007282:	4b0c      	ldr	r3, [pc, #48]	@ (80072b4 <FreeRTOS_IPInit_Multi+0xa4>)
 8007284:	6018      	str	r0, [r3, #0]
                if( xIPTaskHandle != NULL )
 8007286:	b910      	cbnz	r0, 800728e <FreeRTOS_IPInit_Multi+0x7e>
    BaseType_t xReturn = pdFALSE;
 8007288:	2400      	movs	r4, #0
 800728a:	e000      	b.n	800728e <FreeRTOS_IPInit_Multi+0x7e>
 800728c:	2400      	movs	r4, #0
    {
        FreeRTOS_debug_printf( ( "FreeRTOS_IPInit_Multi: Network event queue could not be created\n" ) );
    }

    return xReturn;
}
 800728e:	4620      	mov	r0, r4
 8007290:	b005      	add	sp, #20
 8007292:	bd30      	pop	{r4, r5, pc}
 8007294:	20013148 	.word	0x20013148
 8007298:	20013198 	.word	0x20013198
 800729c:	200133b0 	.word	0x200133b0
 80072a0:	080101b0 	.word	0x080101b0
 80072a4:	20011ca0 	.word	0x20011ca0
 80072a8:	20011d48 	.word	0x20011d48
 80072ac:	080101b8 	.word	0x080101b8
 80072b0:	0800789d 	.word	0x0800789d
 80072b4:	200133a4 	.word	0x200133a4

080072b8 <FreeRTOS_ReleaseUDPPayloadBuffer>:
 * @brief Release the UDP payload buffer.
 *
 * @param[in] pvBuffer Pointer to the UDP buffer that is to be released.
 */
void FreeRTOS_ReleaseUDPPayloadBuffer( void const * pvBuffer )
{
 80072b8:	b508      	push	{r3, lr}
    NetworkBufferDescriptor_t * pxBuffer;

    pxBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pvBuffer );
 80072ba:	f000 fd61 	bl	8007d80 <pxUDPPayloadBuffer_to_NetworkBuffer>
    configASSERT( pxBuffer != NULL );
 80072be:	b110      	cbz	r0, 80072c6 <FreeRTOS_ReleaseUDPPayloadBuffer+0xe>
    vReleaseNetworkBufferAndDescriptor( pxBuffer );
 80072c0:	f007 f9ee 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
}
 80072c4:	bd08      	pop	{r3, pc}
 80072c6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80072ca:	f383 8811 	msr	BASEPRI, r3
 80072ce:	f3bf 8f6f 	isb	sy
 80072d2:	f3bf 8f4f 	dsb	sy
    configASSERT( pxBuffer != NULL );
 80072d6:	e7fe      	b.n	80072d6 <FreeRTOS_ReleaseUDPPayloadBuffer+0x1e>

080072d8 <xIPIsNetworkTaskReady>:
 * @return pdTRUE if IP task is ready, else pdFALSE.
 */
BaseType_t xIPIsNetworkTaskReady( void )
{
    return xIPTaskInitialised;
}
 80072d8:	4b01      	ldr	r3, [pc, #4]	@ (80072e0 <xIPIsNetworkTaskReady+0x8>)
 80072da:	6818      	ldr	r0, [r3, #0]
 80072dc:	4770      	bx	lr
 80072de:	bf00      	nop
 80072e0:	200133a0 	.word	0x200133a0

080072e4 <xSendEventStructToIPTask>:
{
 80072e4:	b538      	push	{r3, r4, r5, lr}
 80072e6:	4604      	mov	r4, r0
 80072e8:	460d      	mov	r5, r1
    if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
 80072ea:	f7ff fff5 	bl	80072d8 <xIPIsNetworkTaskReady>
 80072ee:	b910      	cbnz	r0, 80072f6 <xSendEventStructToIPTask+0x12>
 80072f0:	f994 3000 	ldrsb.w	r3, [r4]
 80072f4:	b973      	cbnz	r3, 8007314 <xSendEventStructToIPTask+0x30>
            if( pxEvent->eEventType == eTCPTimerEvent )
 80072f6:	f994 3000 	ldrsb.w	r3, [r4]
 80072fa:	2b06      	cmp	r3, #6
 80072fc:	d00b      	beq.n	8007316 <xSendEventStructToIPTask+0x32>
            if( ( xIsCallingFromIPTask() == pdTRUE ) && ( uxUseTimeout > ( TickType_t ) 0U ) )
 80072fe:	f000 fd62 	bl	8007dc6 <xIsCallingFromIPTask>
 8007302:	2801      	cmp	r0, #1
 8007304:	d012      	beq.n	800732c <xSendEventStructToIPTask+0x48>
            xReturn = xQueueSendToBack( xNetworkEventQueue, pxEvent, uxUseTimeout );
 8007306:	2300      	movs	r3, #0
 8007308:	462a      	mov	r2, r5
 800730a:	4621      	mov	r1, r4
 800730c:	4809      	ldr	r0, [pc, #36]	@ (8007334 <xSendEventStructToIPTask+0x50>)
 800730e:	6800      	ldr	r0, [r0, #0]
 8007310:	f7fc fef7 	bl	8004102 <xQueueGenericSend>
}
 8007314:	bd38      	pop	{r3, r4, r5, pc}
                vIPSetTCPTimerExpiredState( pdTRUE );
 8007316:	2001      	movs	r0, #1
 8007318:	f000 fb68 	bl	80079ec <vIPSetTCPTimerExpiredState>
                if( uxQueueMessagesWaiting( xNetworkEventQueue ) != 0U )
 800731c:	4b05      	ldr	r3, [pc, #20]	@ (8007334 <xSendEventStructToIPTask+0x50>)
 800731e:	6818      	ldr	r0, [r3, #0]
 8007320:	f7fd f99c 	bl	800465c <uxQueueMessagesWaiting>
 8007324:	2800      	cmp	r0, #0
 8007326:	d0ea      	beq.n	80072fe <xSendEventStructToIPTask+0x1a>
            xReturn = pdPASS;
 8007328:	2001      	movs	r0, #1
    return xReturn;
 800732a:	e7f3      	b.n	8007314 <xSendEventStructToIPTask+0x30>
            if( ( xIsCallingFromIPTask() == pdTRUE ) && ( uxUseTimeout > ( TickType_t ) 0U ) )
 800732c:	2d00      	cmp	r5, #0
 800732e:	d0ea      	beq.n	8007306 <xSendEventStructToIPTask+0x22>
                uxUseTimeout = ( TickType_t ) 0;
 8007330:	2500      	movs	r5, #0
 8007332:	e7e8      	b.n	8007306 <xSendEventStructToIPTask+0x22>
 8007334:	200133b0 	.word	0x200133b0

08007338 <FreeRTOS_NetworkDown>:
{
 8007338:	b510      	push	{r4, lr}
 800733a:	b082      	sub	sp, #8
 800733c:	4604      	mov	r4, r0
    pxNetworkInterface->bits.bInterfaceUp = pdFALSE_UNSIGNED;
 800733e:	7f03      	ldrb	r3, [r0, #28]
 8007340:	f023 0301 	bic.w	r3, r3, #1
 8007344:	7703      	strb	r3, [r0, #28]
    xNetworkDownEvent.eEventType = eNetworkDownEvent;
 8007346:	2100      	movs	r1, #0
 8007348:	f88d 1000 	strb.w	r1, [sp]
    xNetworkDownEvent.pvData = pxNetworkInterface;
 800734c:	9001      	str	r0, [sp, #4]
    if( xSendEventStructToIPTask( &xNetworkDownEvent, xDontBlock ) != pdPASS )
 800734e:	4668      	mov	r0, sp
 8007350:	f7ff ffc8 	bl	80072e4 <xSendEventStructToIPTask>
 8007354:	2801      	cmp	r0, #1
 8007356:	d008      	beq.n	800736a <FreeRTOS_NetworkDown+0x32>
        pxNetworkInterface->bits.bCallDownEvent = pdTRUE;
 8007358:	7f23      	ldrb	r3, [r4, #28]
 800735a:	f043 0302 	orr.w	r3, r3, #2
 800735e:	7723      	strb	r3, [r4, #28]
        xNetworkDownEventPending = pdTRUE;
 8007360:	4b04      	ldr	r3, [pc, #16]	@ (8007374 <FreeRTOS_NetworkDown+0x3c>)
 8007362:	2201      	movs	r2, #1
 8007364:	601a      	str	r2, [r3, #0]
}
 8007366:	b002      	add	sp, #8
 8007368:	bd10      	pop	{r4, pc}
        pxNetworkInterface->bits.bCallDownEvent = pdFALSE;
 800736a:	7f23      	ldrb	r3, [r4, #28]
 800736c:	f023 0302 	bic.w	r3, r3, #2
 8007370:	7723      	strb	r3, [r4, #28]
}
 8007372:	e7f8      	b.n	8007366 <FreeRTOS_NetworkDown+0x2e>
 8007374:	200133a8 	.word	0x200133a8

08007378 <prvIPTask_Initialise>:
{
 8007378:	b510      	push	{r4, lr}
    vNetworkTimerReload( pdMS_TO_TICKS( ipINITIALISATION_RETRY_DELAY ) );
 800737a:	f640 30b8 	movw	r0, #3000	@ 0xbb8
 800737e:	f000 fb2d 	bl	80079dc <vNetworkTimerReload>
    for( pxInterface = pxNetworkInterfaces; pxInterface != NULL; pxInterface = pxInterface->pxNext )
 8007382:	4b0b      	ldr	r3, [pc, #44]	@ (80073b0 <prvIPTask_Initialise+0x38>)
 8007384:	681c      	ldr	r4, [r3, #0]
 8007386:	e003      	b.n	8007390 <prvIPTask_Initialise+0x18>
        FreeRTOS_NetworkDown( pxInterface );
 8007388:	4620      	mov	r0, r4
 800738a:	f7ff ffd5 	bl	8007338 <FreeRTOS_NetworkDown>
    for( pxInterface = pxNetworkInterfaces; pxInterface != NULL; pxInterface = pxInterface->pxNext )
 800738e:	6a64      	ldr	r4, [r4, #36]	@ 0x24
 8007390:	2c00      	cmp	r4, #0
 8007392:	d1f9      	bne.n	8007388 <prvIPTask_Initialise+0x10>
        vTCPTimerReload( pdMS_TO_TICKS( ipTCP_TIMER_PERIOD_MS ) );
 8007394:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8007398:	f000 fb0a 	bl	80079b0 <vTCPTimerReload>
    vIPSetARPResolutionTimerEnableState( pdFALSE );
 800739c:	2000      	movs	r0, #0
 800739e:	f000 fb49 	bl	8007a34 <vIPSetARPResolutionTimerEnableState>
        FreeRTOS_dnsclear();
 80073a2:	f7ff fe75 	bl	8007090 <FreeRTOS_dnsclear>
    xIPTaskInitialised = pdTRUE;
 80073a6:	4b03      	ldr	r3, [pc, #12]	@ (80073b4 <prvIPTask_Initialise+0x3c>)
 80073a8:	2201      	movs	r2, #1
 80073aa:	601a      	str	r2, [r3, #0]
}
 80073ac:	bd10      	pop	{r4, pc}
 80073ae:	bf00      	nop
 80073b0:	20013774 	.word	0x20013774
 80073b4:	200133a0 	.word	0x200133a0

080073b8 <xSendEventToIPTask>:
{
 80073b8:	b500      	push	{lr}
 80073ba:	b083      	sub	sp, #12
    xEventMessage.eEventType = eEvent;
 80073bc:	f88d 0000 	strb.w	r0, [sp]
    xEventMessage.pvData = ( void * ) NULL;
 80073c0:	2100      	movs	r1, #0
 80073c2:	9101      	str	r1, [sp, #4]
    return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
 80073c4:	4668      	mov	r0, sp
 80073c6:	f7ff ff8d 	bl	80072e4 <xSendEventStructToIPTask>
}
 80073ca:	b003      	add	sp, #12
 80073cc:	f85d fb04 	ldr.w	pc, [sp], #4

080073d0 <vReturnEthernetFrame>:
{
 80073d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80073d2:	b087      	sub	sp, #28
 80073d4:	4604      	mov	r4, r0
 80073d6:	460e      	mov	r6, r1
        IPPacket_t * pxIPPacket = ( ( IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80073d8:	6a45      	ldr	r5, [r0, #36]	@ 0x24
            uint32_t ulDestinationIPAddress = 0U;
 80073da:	2300      	movs	r3, #0
 80073dc:	9301      	str	r3, [sp, #4]
        if( pxNetworkBuffer->pxEndPoint == NULL )
 80073de:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 80073e0:	b313      	cbz	r3, 8007428 <vReturnEthernetFrame+0x58>
        if( pxNetworkBuffer->pxEndPoint != NULL )
 80073e2:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80073e4:	2b00      	cmp	r3, #0
 80073e6:	d03d      	beq.n	8007464 <vReturnEthernetFrame+0x94>
            NetworkInterface_t * pxInterface = pxNetworkBuffer->pxEndPoint->pxNetworkInterface; /*_RB_ Why not use the pxNetworkBuffer->pxNetworkInterface directly? */
 80073e8:	f8d3 7158 	ldr.w	r7, [r3, #344]	@ 0x158
            switch( pxIPPacket->xEthernetHeader.usFrameType )
 80073ec:	89ab      	ldrh	r3, [r5, #12]
 80073ee:	2b08      	cmp	r3, #8
 80073f0:	d024      	beq.n	800743c <vReturnEthernetFrame+0x6c>
                    pvCopySource = &( pxIPPacket->xEthernetHeader.xSourceAddress );
 80073f2:	1dab      	adds	r3, r5, #6
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxIPPacket->xEthernetHeader.xDestinationAddress ) );
 80073f4:	681a      	ldr	r2, [r3, #0]
 80073f6:	602a      	str	r2, [r5, #0]
 80073f8:	889b      	ldrh	r3, [r3, #4]
 80073fa:	80ab      	strh	r3, [r5, #4]
            pvCopySource = pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes;
 80073fc:	6b23      	ldr	r3, [r4, #48]	@ 0x30
            ( void ) memcpy( pvCopyDest, pvCopySource, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 80073fe:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 8007402:	f8c5 2006 	str.w	r2, [r5, #6]
 8007406:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 800740a:	816b      	strh	r3, [r5, #10]
            if( xIsCallingFromIPTask() == pdTRUE )
 800740c:	f000 fcdb 	bl	8007dc6 <xIsCallingFromIPTask>
 8007410:	2801      	cmp	r0, #1
 8007412:	d022      	beq.n	800745a <vReturnEthernetFrame+0x8a>
            else if( xReleaseAfterSend != pdFALSE )
 8007414:	bb46      	cbnz	r6, 8007468 <vReturnEthernetFrame+0x98>
 8007416:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800741a:	f383 8811 	msr	BASEPRI, r3
 800741e:	f3bf 8f6f 	isb	sy
 8007422:	f3bf 8f4f 	dsb	sy
                configASSERT( pdFALSE );
 8007426:	e7fe      	b.n	8007426 <vReturnEthernetFrame+0x56>
            switch( ( ( ( EthernetHeader_t * ) pxNetworkBuffer->pucEthernetBuffer ) )->usFrameType )
 8007428:	89ab      	ldrh	r3, [r5, #12]
 800742a:	2b08      	cmp	r3, #8
 800742c:	d1d9      	bne.n	80073e2 <vReturnEthernetFrame+0x12>
                        pxNetworkBuffer->pxEndPoint = FreeRTOS_FindEndPointOnNetMask( pxIPPacket->xIPHeader.ulDestinationIPAddress, 7 );
 800742e:	2107      	movs	r1, #7
 8007430:	f8d5 001e 	ldr.w	r0, [r5, #30]
 8007434:	f002 fb92 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
 8007438:	6320      	str	r0, [r4, #48]	@ 0x30
                        break;
 800743a:	e7d2      	b.n	80073e2 <vReturnEthernetFrame+0x12>
                        ulDestinationIPAddress = pxIPPacket->xIPHeader.ulDestinationIPAddress;
 800743c:	f8d5 301e 	ldr.w	r3, [r5, #30]
 8007440:	9301      	str	r3, [sp, #4]
                        eResult = eARPGetCacheEntry( &ulDestinationIPAddress, &xMACAddress, &( pxNetworkBuffer->pxEndPoint ) );
 8007442:	f104 0230 	add.w	r2, r4, #48	@ 0x30
 8007446:	a902      	add	r1, sp, #8
 8007448:	a801      	add	r0, sp, #4
 800744a:	f7fe fe55 	bl	80060f8 <eARPGetCacheEntry>
                        if( eResult == eARPCacheHit )
 800744e:	2801      	cmp	r0, #1
 8007450:	d001      	beq.n	8007456 <vReturnEthernetFrame+0x86>
                            pvCopySource = &( pxIPPacket->xEthernetHeader.xSourceAddress );
 8007452:	1dab      	adds	r3, r5, #6
 8007454:	e7ce      	b.n	80073f4 <vReturnEthernetFrame+0x24>
                            pvCopySource = &xMACAddress;
 8007456:	ab02      	add	r3, sp, #8
 8007458:	e7cc      	b.n	80073f4 <vReturnEthernetFrame+0x24>
                ( void ) pxInterface->pfOutput( pxInterface, pxNetworkBuffer, xReleaseAfterSend );
 800745a:	68fb      	ldr	r3, [r7, #12]
 800745c:	4632      	mov	r2, r6
 800745e:	4621      	mov	r1, r4
 8007460:	4638      	mov	r0, r7
 8007462:	4798      	blx	r3
}
 8007464:	b007      	add	sp, #28
 8007466:	bdf0      	pop	{r4, r5, r6, r7, pc}
                xSendEvent.eEventType = eNetworkTxEvent;
 8007468:	2302      	movs	r3, #2
 800746a:	f88d 3010 	strb.w	r3, [sp, #16]
                xSendEvent.pvData = pxNetworkBuffer;
 800746e:	9405      	str	r4, [sp, #20]
                if( xSendEventStructToIPTask( &xSendEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 8007470:	f04f 31ff 	mov.w	r1, #4294967295
 8007474:	a804      	add	r0, sp, #16
 8007476:	f7ff ff35 	bl	80072e4 <xSendEventStructToIPTask>
 800747a:	2800      	cmp	r0, #0
 800747c:	d1f2      	bne.n	8007464 <vReturnEthernetFrame+0x94>
                    vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800747e:	4620      	mov	r0, r4
 8007480:	f007 f90e 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 8007484:	e7ee      	b.n	8007464 <vReturnEthernetFrame+0x94>
	...

08007488 <FreeRTOS_AllEndPointsUp>:
 * @return pdTRUE if all end-points are up, otherwise pdFALSE;
 */
BaseType_t FreeRTOS_AllEndPointsUp( const struct xNetworkInterface * pxInterface )
{
    BaseType_t xResult = pdTRUE;
    const NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8007488:	4b0a      	ldr	r3, [pc, #40]	@ (80074b4 <FreeRTOS_AllEndPointsUp+0x2c>)
 800748a:	681b      	ldr	r3, [r3, #0]

    while( pxEndPoint != NULL )
 800748c:	e006      	b.n	800749c <FreeRTOS_AllEndPointsUp+0x14>
    {
        if( ( pxInterface == NULL ) ||
            ( pxEndPoint->pxNetworkInterface == pxInterface ) )

        {
            if( pxEndPoint->bits.bEndPointUp == pdFALSE_UNSIGNED )
 800748e:	f893 20f0 	ldrb.w	r2, [r3, #240]	@ 0xf0
 8007492:	f012 0f20 	tst.w	r2, #32
 8007496:	d00b      	beq.n	80074b0 <FreeRTOS_AllEndPointsUp+0x28>
                xResult = pdFALSE;
                break;
            }
        }

        pxEndPoint = pxEndPoint->pxNext;
 8007498:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
    while( pxEndPoint != NULL )
 800749c:	b133      	cbz	r3, 80074ac <FreeRTOS_AllEndPointsUp+0x24>
        if( ( pxInterface == NULL ) ||
 800749e:	2800      	cmp	r0, #0
 80074a0:	d0f5      	beq.n	800748e <FreeRTOS_AllEndPointsUp+0x6>
            ( pxEndPoint->pxNetworkInterface == pxInterface ) )
 80074a2:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
        if( ( pxInterface == NULL ) ||
 80074a6:	4282      	cmp	r2, r0
 80074a8:	d1f6      	bne.n	8007498 <FreeRTOS_AllEndPointsUp+0x10>
 80074aa:	e7f0      	b.n	800748e <FreeRTOS_AllEndPointsUp+0x6>
    BaseType_t xResult = pdTRUE;
 80074ac:	2001      	movs	r0, #1
 80074ae:	4770      	bx	lr
                xResult = pdFALSE;
 80074b0:	2000      	movs	r0, #0
    }

    return xResult;
}
 80074b2:	4770      	bx	lr
 80074b4:	20013778 	.word	0x20013778

080074b8 <FreeRTOS_IsEndPointUp>:
{
 80074b8:	b508      	push	{r3, lr}
    if( pxEndPoint != NULL )
 80074ba:	b120      	cbz	r0, 80074c6 <FreeRTOS_IsEndPointUp+0xe>
        xReturn = ( BaseType_t ) pxEndPoint->bits.bEndPointUp;
 80074bc:	f890 00f0 	ldrb.w	r0, [r0, #240]	@ 0xf0
 80074c0:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
 80074c4:	bd08      	pop	{r3, pc}
        xReturn = FreeRTOS_AllEndPointsUp( NULL );
 80074c6:	2000      	movs	r0, #0
 80074c8:	f7ff ffde 	bl	8007488 <FreeRTOS_AllEndPointsUp>
    return xReturn;
 80074cc:	e7fa      	b.n	80074c4 <FreeRTOS_IsEndPointUp+0xc>

080074ce <FreeRTOS_IsNetworkUp>:
{
 80074ce:	b508      	push	{r3, lr}
    return FreeRTOS_IsEndPointUp( NULL );
 80074d0:	2000      	movs	r0, #0
 80074d2:	f7ff fff1 	bl	80074b8 <FreeRTOS_IsEndPointUp>
}
 80074d6:	bd08      	pop	{r3, pc}

080074d8 <uxIPHeaderSizePacket>:
    size_t uxResult;
    /* Map the buffer onto Ethernet Header struct for easy access to fields. */
    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    const EthernetHeader_t * pxHeader = ( ( const EthernetHeader_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80074d8:	6a43      	ldr	r3, [r0, #36]	@ 0x24

    if( pxHeader->usFrameType == ( uint16_t ) ipIPv6_FRAME_TYPE )
 80074da:	899a      	ldrh	r2, [r3, #12]
 80074dc:	f64d 5386 	movw	r3, #56710	@ 0xdd86
 80074e0:	429a      	cmp	r2, r3
 80074e2:	d001      	beq.n	80074e8 <uxIPHeaderSizePacket+0x10>
    {
        uxResult = ipSIZE_OF_IPv6_HEADER;
    }
    else
    {
        uxResult = ipSIZE_OF_IPv4_HEADER;
 80074e4:	2014      	movs	r0, #20
    }

    return uxResult;
}
 80074e6:	4770      	bx	lr
        uxResult = ipSIZE_OF_IPv6_HEADER;
 80074e8:	2028      	movs	r0, #40	@ 0x28
 80074ea:	4770      	bx	lr

080074ec <prvProcessUDPPacket>:
{
 80074ec:	b570      	push	{r4, r5, r6, lr}
 80074ee:	b082      	sub	sp, #8
 80074f0:	4604      	mov	r4, r0
    BaseType_t xIsWaitingARPResolution = pdFALSE;
 80074f2:	2300      	movs	r3, #0
 80074f4:	9301      	str	r3, [sp, #4]
    const UDPPacket_t * pxUDPPacket = ( ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80074f6:	6a45      	ldr	r5, [r0, #36]	@ 0x24
    const UDPHeader_t * pxUDPHeader = &( pxUDPPacket->xUDPHeader );
 80074f8:	f105 0622 	add.w	r6, r5, #34	@ 0x22
    size_t uxMinSize = ipSIZE_OF_ETH_HEADER + ( size_t ) uxIPHeaderSizePacket( pxNetworkBuffer ) + ipSIZE_OF_UDP_HEADER;
 80074fc:	f7ff ffec 	bl	80074d8 <uxIPHeaderSizePacket>
 8007500:	f100 0c16 	add.w	ip, r0, #22
        if( pxUDPPacket->xEthernetHeader.usFrameType == ipIPv6_FRAME_TYPE )
 8007504:	89aa      	ldrh	r2, [r5, #12]
 8007506:	f64d 5386 	movw	r3, #56710	@ 0xdd86
 800750a:	429a      	cmp	r2, r3
 800750c:	d023      	beq.n	8007556 <prvProcessUDPPacket+0x6a>
    usLength = FreeRTOS_ntohs( pxUDPHeader->usLength );
 800750e:	88b1      	ldrh	r1, [r6, #4]
 8007510:	020b      	lsls	r3, r1, #8
 8007512:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
 8007516:	b29b      	uxth	r3, r3
        if( ( pxUDPPacket->xEthernetHeader.usFrameType == ipIPv4_FRAME_TYPE ) &&
 8007518:	2a08      	cmp	r2, #8
 800751a:	d01f      	beq.n	800755c <prvProcessUDPPacket+0x70>
    if( ( pxNetworkBuffer->xDataLength >= uxMinSize ) &&
 800751c:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 800751e:	4562      	cmp	r2, ip
 8007520:	d326      	bcc.n	8007570 <prvProcessUDPPacket+0x84>
 8007522:	2b07      	cmp	r3, #7
 8007524:	d927      	bls.n	8007576 <prvProcessUDPPacket+0x8a>
        uxPayloadSize_1 = pxNetworkBuffer->xDataLength - uxMinSize;
 8007526:	eba2 020c 	sub.w	r2, r2, ip
        uxPayloadSize_2 = uxLength - ipSIZE_OF_UDP_HEADER;
 800752a:	3b08      	subs	r3, #8
        if( uxPayloadSize_1 > uxPayloadSize_2 )
 800752c:	429a      	cmp	r2, r3
 800752e:	d901      	bls.n	8007534 <prvProcessUDPPacket+0x48>
            pxNetworkBuffer->xDataLength = uxPayloadSize_2 + uxMinSize;
 8007530:	4463      	add	r3, ip
 8007532:	62a3      	str	r3, [r4, #40]	@ 0x28
        pxNetworkBuffer->usPort = pxUDPHeader->usSourcePort;
 8007534:	8833      	ldrh	r3, [r6, #0]
 8007536:	86a3      	strh	r3, [r4, #52]	@ 0x34
        pxNetworkBuffer->xIPAddress.ulIP_IPv4 = pxUDPPacket->xIPHeader.ulSourceIPAddress;
 8007538:	f8d5 301a 	ldr.w	r3, [r5, #26]
 800753c:	6163      	str	r3, [r4, #20]
        if( xProcessReceivedUDPPacket( pxNetworkBuffer,
 800753e:	aa01      	add	r2, sp, #4
 8007540:	8871      	ldrh	r1, [r6, #2]
 8007542:	4620      	mov	r0, r4
 8007544:	f006 fdfb 	bl	800e13e <xProcessReceivedUDPPacket>
 8007548:	2801      	cmp	r0, #1
 800754a:	d016      	beq.n	800757a <prvProcessUDPPacket+0x8e>
            if( xIsWaitingARPResolution == pdTRUE )
 800754c:	9b01      	ldr	r3, [sp, #4]
 800754e:	2b01      	cmp	r3, #1
 8007550:	d015      	beq.n	800757e <prvProcessUDPPacket+0x92>
    eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8007552:	2000      	movs	r0, #0
 8007554:	e00d      	b.n	8007572 <prvProcessUDPPacket+0x86>
            pxUDPHeader = &( pxProtocolHeaders->xUDPHeader );
 8007556:	f105 0636 	add.w	r6, r5, #54	@ 0x36
 800755a:	e7d8      	b.n	800750e <prvProcessUDPPacket+0x22>
            ( usLength > ( FreeRTOS_ntohs( pxUDPPacket->xIPHeader.usLength ) - uxIPHeaderSizePacket( pxNetworkBuffer ) ) ) )
 800755c:	8a29      	ldrh	r1, [r5, #16]
 800755e:	020a      	lsls	r2, r1, #8
 8007560:	ea42 2211 	orr.w	r2, r2, r1, lsr #8
 8007564:	b292      	uxth	r2, r2
 8007566:	1a12      	subs	r2, r2, r0
        if( ( pxUDPPacket->xEthernetHeader.usFrameType == ipIPv4_FRAME_TYPE ) &&
 8007568:	429a      	cmp	r2, r3
 800756a:	d2d7      	bcs.n	800751c <prvProcessUDPPacket+0x30>
            eReturn = eReleaseBuffer;
 800756c:	2000      	movs	r0, #0
 800756e:	e000      	b.n	8007572 <prvProcessUDPPacket+0x86>
    eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8007570:	2000      	movs	r0, #0
}
 8007572:	b002      	add	sp, #8
 8007574:	bd70      	pop	{r4, r5, r6, pc}
    eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8007576:	2000      	movs	r0, #0
 8007578:	e7fb      	b.n	8007572 <prvProcessUDPPacket+0x86>
            eReturn = eFrameConsumed;
 800757a:	2003      	movs	r0, #3
 800757c:	e7f9      	b.n	8007572 <prvProcessUDPPacket+0x86>
                eReturn = eWaitingARPResolution;
 800757e:	2004      	movs	r0, #4
 8007580:	e7f7      	b.n	8007572 <prvProcessUDPPacket+0x86>

08007582 <prvProcessIPPacket>:
{
 8007582:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007586:	4604      	mov	r4, r0
 8007588:	460d      	mov	r5, r1
    switch( pxIPPacket->xEthernetHeader.usFrameType )
 800758a:	8983      	ldrh	r3, [r0, #12]
 800758c:	2b08      	cmp	r3, #8
 800758e:	d039      	beq.n	8007604 <prvProcessIPPacket+0x82>
 8007590:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 8007594:	4293      	cmp	r3, r2
 8007596:	f040 8093 	bne.w	80076c0 <prvProcessIPPacket+0x13e>
                if( pxNetworkBuffer->xDataLength < sizeof( IPPacket_IPv6_t ) )
 800759a:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
 800759c:	2b35      	cmp	r3, #53	@ 0x35
 800759e:	d801      	bhi.n	80075a4 <prvProcessIPPacket+0x22>
                    eReturn = eReleaseBuffer;
 80075a0:	2600      	movs	r6, #0
 80075a2:	e08e      	b.n	80076c2 <prvProcessIPPacket+0x140>
                    pxIPHeader_IPv6 = ( ( const IPHeader_IPv6_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 80075a4:	6a4f      	ldr	r7, [r1, #36]	@ 0x24
 80075a6:	f107 090e 	add.w	r9, r7, #14
                    ucProtocol = pxIPHeader_IPv6->ucNextHeader;
 80075aa:	f897 8014 	ldrb.w	r8, [r7, #20]
                    eReturn = prvAllowIPPacketIPv6( ( ( const IPHeader_IPv6_t * ) &( pxIPPacket->xIPHeader ) ), pxNetworkBuffer, uxHeaderLength );
 80075ae:	2228      	movs	r2, #40	@ 0x28
 80075b0:	300e      	adds	r0, #14
 80075b2:	f001 f893 	bl	80086dc <prvAllowIPPacketIPv6>
 80075b6:	4606      	mov	r6, r0
                    pxNetworkBuffer->pucEthernetBuffer[ 0 - ( BaseType_t ) ipIP_TYPE_OFFSET ] = pxIPHeader_IPv6->ucVersionTrafficClass;
 80075b8:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 80075ba:	7bba      	ldrb	r2, [r7, #14]
 80075bc:	f803 2c06 	strb.w	r2, [r3, #-6]
                    uxHeaderLength = ipSIZE_OF_IPv6_HEADER;
 80075c0:	2728      	movs	r7, #40	@ 0x28
    if( eReturn == eProcessBuffer )
 80075c2:	2e01      	cmp	r6, #1
 80075c4:	d17d      	bne.n	80076c2 <prvProcessIPPacket+0x140>
        switch( pxIPPacket->xEthernetHeader.usFrameType ) /* LCOV_EXCL_BR_LINE */
 80075c6:	89a3      	ldrh	r3, [r4, #12]
 80075c8:	2b08      	cmp	r3, #8
 80075ca:	d034      	beq.n	8007636 <prvProcessIPPacket+0xb4>
 80075cc:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 80075d0:	4293      	cmp	r3, r2
 80075d2:	d037      	beq.n	8007644 <prvProcessIPPacket+0xc2>
        if( eReturn != eReleaseBuffer )
 80075d4:	2e00      	cmp	r6, #0
 80075d6:	d074      	beq.n	80076c2 <prvProcessIPPacket+0x140>
            if( ucProtocol != ( uint8_t ) ipPROTOCOL_UDP )
 80075d8:	f1b8 0f11 	cmp.w	r8, #17
 80075dc:	d141      	bne.n	8007662 <prvProcessIPPacket+0xe0>
            if( eReturn != eWaitingARPResolution )
 80075de:	2e04      	cmp	r6, #4
 80075e0:	d06f      	beq.n	80076c2 <prvProcessIPPacket+0x140>
                switch( ucProtocol )
 80075e2:	f1b8 0f11 	cmp.w	r8, #17
 80075e6:	d066      	beq.n	80076b6 <prvProcessIPPacket+0x134>
 80075e8:	d856      	bhi.n	8007698 <prvProcessIPPacket+0x116>
 80075ea:	f1b8 0f01 	cmp.w	r8, #1
 80075ee:	d05d      	beq.n	80076ac <prvProcessIPPacket+0x12a>
 80075f0:	f1b8 0f06 	cmp.w	r8, #6
 80075f4:	d14e      	bne.n	8007694 <prvProcessIPPacket+0x112>
                                if( xProcessReceivedTCPPacket( pxNetworkBuffer ) == pdPASS )
 80075f6:	4628      	mov	r0, r5
 80075f8:	f004 f9fc 	bl	800b9f4 <xProcessReceivedTCPPacket>
 80075fc:	2801      	cmp	r0, #1
 80075fe:	d160      	bne.n	80076c2 <prvProcessIPPacket+0x140>
                                    eReturn = eFrameConsumed;
 8007600:	2603      	movs	r6, #3
 8007602:	e05e      	b.n	80076c2 <prvProcessIPPacket+0x140>
                   size_t uxLength = ( size_t ) pxIPHeader->ucVersionHeaderLength;
 8007604:	7b87      	ldrb	r7, [r0, #14]
                   uxHeaderLength = ( size_t ) ( ( uxLength & 0x0FU ) << 2 );
 8007606:	00bf      	lsls	r7, r7, #2
 8007608:	f007 073c 	and.w	r7, r7, #60	@ 0x3c
                   if( ( uxHeaderLength > ( pxNetworkBuffer->xDataLength - ipSIZE_OF_ETH_HEADER ) ) ||
 800760c:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
 800760e:	3b0e      	subs	r3, #14
 8007610:	42bb      	cmp	r3, r7
 8007612:	d359      	bcc.n	80076c8 <prvProcessIPPacket+0x146>
 8007614:	2f13      	cmp	r7, #19
 8007616:	d801      	bhi.n	800761c <prvProcessIPPacket+0x9a>
                       eReturn = eReleaseBuffer;
 8007618:	2600      	movs	r6, #0
 800761a:	e052      	b.n	80076c2 <prvProcessIPPacket+0x140>
                       ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
 800761c:	f890 8017 	ldrb.w	r8, [r0, #23]
                       eReturn = prvAllowIPPacketIPv4( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8007620:	463a      	mov	r2, r7
 8007622:	f000 fe7d 	bl	8008320 <prvAllowIPPacketIPv4>
 8007626:	4606      	mov	r6, r0
                           pxNetworkBuffer->pucEthernetBuffer[ 0 - ( BaseType_t ) ipIP_TYPE_OFFSET ] = pxIPHeader->ucVersionHeaderLength;
 8007628:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800762a:	7ba2      	ldrb	r2, [r4, #14]
 800762c:	f803 2c06 	strb.w	r2, [r3, #-6]
        const IPHeader_IPv6_t * pxIPHeader_IPv6 = NULL;
 8007630:	f04f 0900 	mov.w	r9, #0
 8007634:	e7c5      	b.n	80075c2 <prvProcessIPPacket+0x40>
                    if( uxHeaderLength > ipSIZE_OF_IPv4_HEADER )
 8007636:	2f14      	cmp	r7, #20
 8007638:	d9cc      	bls.n	80075d4 <prvProcessIPPacket+0x52>
                        eReturn = prvCheckIP4HeaderOptions( pxNetworkBuffer );
 800763a:	4628      	mov	r0, r5
 800763c:	f000 fef0 	bl	8008420 <prvCheckIP4HeaderOptions>
 8007640:	4606      	mov	r6, r0
 8007642:	e7c7      	b.n	80075d4 <prvProcessIPPacket+0x52>
                    if( xGetExtensionOrder( ucProtocol, 0U ) > 0 )
 8007644:	2100      	movs	r1, #0
 8007646:	4640      	mov	r0, r8
 8007648:	f001 f88e 	bl	8008768 <xGetExtensionOrder>
 800764c:	2800      	cmp	r0, #0
 800764e:	ddc1      	ble.n	80075d4 <prvProcessIPPacket+0x52>
                        eReturn = eHandleIPv6ExtensionHeaders( pxNetworkBuffer, pdTRUE );
 8007650:	2101      	movs	r1, #1
 8007652:	4628      	mov	r0, r5
 8007654:	f001 f8b8 	bl	80087c8 <eHandleIPv6ExtensionHeaders>
                        if( eReturn != eReleaseBuffer )
 8007658:	4606      	mov	r6, r0
 800765a:	b390      	cbz	r0, 80076c2 <prvProcessIPPacket+0x140>
                            ucProtocol = pxIPHeader_IPv6->ucNextHeader;
 800765c:	f899 8006 	ldrb.w	r8, [r9, #6]
        if( eReturn != eReleaseBuffer )
 8007660:	e7ba      	b.n	80075d8 <prvProcessIPPacket+0x56>
                if( xCheckRequiresARPResolution( pxNetworkBuffer ) == pdTRUE )
 8007662:	4628      	mov	r0, r5
 8007664:	f7fe ff16 	bl	8006494 <xCheckRequiresARPResolution>
 8007668:	2801      	cmp	r0, #1
 800766a:	d02f      	beq.n	80076cc <prvProcessIPPacket+0x14a>
                    switch( pxIPPacket->xEthernetHeader.usFrameType ) /* LCOV_EXCL_BR_LINE */
 800766c:	89a3      	ldrh	r3, [r4, #12]
 800766e:	2b08      	cmp	r3, #8
 8007670:	d00a      	beq.n	8007688 <prvProcessIPPacket+0x106>
 8007672:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 8007676:	4293      	cmp	r3, r2
 8007678:	d1b1      	bne.n	80075de <prvProcessIPPacket+0x5c>
                                vNDRefreshCacheEntry( &( pxIPPacket->xEthernetHeader.xSourceAddress ), &( pxIPHeader_IPv6->xSourceAddress ), pxNetworkBuffer->pxEndPoint );
 800767a:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 800767c:	f109 0108 	add.w	r1, r9, #8
 8007680:	1da0      	adds	r0, r4, #6
 8007682:	f001 fc23 	bl	8008ecc <vNDRefreshCacheEntry>
                                break;
 8007686:	e7aa      	b.n	80075de <prvProcessIPPacket+0x5c>
                                vARPRefreshCacheEntryAge( &( pxIPPacket->xEthernetHeader.xSourceAddress ), pxIPHeader->ulSourceIPAddress );
 8007688:	f8d4 101a 	ldr.w	r1, [r4, #26]
 800768c:	1da0      	adds	r0, r4, #6
 800768e:	f7fe fc6f 	bl	8005f70 <vARPRefreshCacheEntryAge>
                                break;
 8007692:	e7a4      	b.n	80075de <prvProcessIPPacket+0x5c>
                switch( ucProtocol )
 8007694:	2600      	movs	r6, #0
 8007696:	e014      	b.n	80076c2 <prvProcessIPPacket+0x140>
 8007698:	f1b8 0f3a 	cmp.w	r8, #58	@ 0x3a
 800769c:	d104      	bne.n	80076a8 <prvProcessIPPacket+0x126>
                            eReturn = prvProcessICMPMessage_IPv6( pxNetworkBuffer );
 800769e:	4628      	mov	r0, r5
 80076a0:	f001 fd54 	bl	800914c <prvProcessICMPMessage_IPv6>
 80076a4:	4606      	mov	r6, r0
                            break;
 80076a6:	e00c      	b.n	80076c2 <prvProcessIPPacket+0x140>
                switch( ucProtocol )
 80076a8:	2600      	movs	r6, #0
 80076aa:	e00a      	b.n	80076c2 <prvProcessIPPacket+0x140>
                                eReturn = ProcessICMPPacket( pxNetworkBuffer );
 80076ac:	4628      	mov	r0, r5
 80076ae:	f7ff fd2c 	bl	800710a <ProcessICMPPacket>
 80076b2:	4606      	mov	r6, r0
                            break;
 80076b4:	e005      	b.n	80076c2 <prvProcessIPPacket+0x140>
                        eReturn = prvProcessUDPPacket( pxNetworkBuffer );
 80076b6:	4628      	mov	r0, r5
 80076b8:	f7ff ff18 	bl	80074ec <prvProcessUDPPacket>
 80076bc:	4606      	mov	r6, r0
                        break;
 80076be:	e000      	b.n	80076c2 <prvProcessIPPacket+0x140>
    switch( pxIPPacket->xEthernetHeader.usFrameType )
 80076c0:	2600      	movs	r6, #0
}
 80076c2:	4630      	mov	r0, r6
 80076c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                       eReturn = eReleaseBuffer;
 80076c8:	2600      	movs	r6, #0
 80076ca:	e7fa      	b.n	80076c2 <prvProcessIPPacket+0x140>
                    eReturn = eWaitingARPResolution;
 80076cc:	2604      	movs	r6, #4
 80076ce:	e7f8      	b.n	80076c2 <prvProcessIPPacket+0x140>

080076d0 <prvProcessEthernetPacket>:
{
 80076d0:	b510      	push	{r4, lr}
 80076d2:	4604      	mov	r4, r0
        if( ( pxNetworkBuffer->pxInterface == NULL ) || ( pxNetworkBuffer->pxEndPoint == NULL ) )
 80076d4:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 80076d6:	b17b      	cbz	r3, 80076f8 <prvProcessEthernetPacket+0x28>
 80076d8:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 80076da:	b16b      	cbz	r3, 80076f8 <prvProcessEthernetPacket+0x28>
        if( pxNetworkBuffer->xDataLength < sizeof( EthernetHeader_t ) )
 80076dc:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80076de:	2b0d      	cmp	r3, #13
 80076e0:	d90a      	bls.n	80076f8 <prvProcessEthernetPacket+0x28>
        pxEthernetHeader = ( ( const EthernetHeader_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80076e2:	6a40      	ldr	r0, [r0, #36]	@ 0x24
            switch( pxEthernetHeader->usFrameType )
 80076e4:	8982      	ldrh	r2, [r0, #12]
 80076e6:	f5b2 6fc1 	cmp.w	r2, #1544	@ 0x608
 80076ea:	d009      	beq.n	8007700 <prvProcessEthernetPacket+0x30>
 80076ec:	f64d 5186 	movw	r1, #56710	@ 0xdd86
 80076f0:	428a      	cmp	r2, r1
 80076f2:	d015      	beq.n	8007720 <prvProcessEthernetPacket+0x50>
 80076f4:	2a08      	cmp	r2, #8
 80076f6:	d013      	beq.n	8007720 <prvProcessEthernetPacket+0x50>
            vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80076f8:	4620      	mov	r0, r4
 80076fa:	f006 ffd1 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
}
 80076fe:	bd10      	pop	{r4, pc}
                        if( pxNetworkBuffer->xDataLength >= sizeof( ARPPacket_t ) )
 8007700:	2b29      	cmp	r3, #41	@ 0x29
 8007702:	d9f9      	bls.n	80076f8 <prvProcessEthernetPacket+0x28>
                            eReturned = eARPProcessPacket( pxNetworkBuffer );
 8007704:	4620      	mov	r0, r4
 8007706:	f7fe fdf3 	bl	80062f0 <eARPProcessPacket>
    switch( eReturned )
 800770a:	2803      	cmp	r0, #3
 800770c:	d0f7      	beq.n	80076fe <prvProcessEthernetPacket+0x2e>
 800770e:	2804      	cmp	r0, #4
 8007710:	d00c      	beq.n	800772c <prvProcessEthernetPacket+0x5c>
 8007712:	2802      	cmp	r0, #2
 8007714:	d1f0      	bne.n	80076f8 <prvProcessEthernetPacket+0x28>
            vReturnEthernetFrame( pxNetworkBuffer, pdTRUE );
 8007716:	2101      	movs	r1, #1
 8007718:	4620      	mov	r0, r4
 800771a:	f7ff fe59 	bl	80073d0 <vReturnEthernetFrame>
            break;
 800771e:	e7ee      	b.n	80076fe <prvProcessEthernetPacket+0x2e>
                    if( pxNetworkBuffer->xDataLength >= sizeof( IPPacket_t ) )
 8007720:	2b21      	cmp	r3, #33	@ 0x21
 8007722:	d9e9      	bls.n	80076f8 <prvProcessEthernetPacket+0x28>
                        eReturned = prvProcessIPPacket( ( ( IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer );
 8007724:	4621      	mov	r1, r4
 8007726:	f7ff ff2c 	bl	8007582 <prvProcessIPPacket>
 800772a:	e7ee      	b.n	800770a <prvProcessEthernetPacket+0x3a>
            if( pxARPWaitingNetworkBuffer == NULL )
 800772c:	4b06      	ldr	r3, [pc, #24]	@ (8007748 <prvProcessEthernetPacket+0x78>)
 800772e:	681b      	ldr	r3, [r3, #0]
 8007730:	b11b      	cbz	r3, 800773a <prvProcessEthernetPacket+0x6a>
                vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8007732:	4620      	mov	r0, r4
 8007734:	f006 ffb4 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 8007738:	e7e1      	b.n	80076fe <prvProcessEthernetPacket+0x2e>
                pxARPWaitingNetworkBuffer = pxNetworkBuffer;
 800773a:	4b03      	ldr	r3, [pc, #12]	@ (8007748 <prvProcessEthernetPacket+0x78>)
 800773c:	601c      	str	r4, [r3, #0]
                vIPTimerStartARPResolution( ipARP_RESOLUTION_MAX_DELAY );
 800773e:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
 8007742:	f000 f92d 	bl	80079a0 <vIPTimerStartARPResolution>
                iptraceDELAYED_ARP_REQUEST_STARTED();
 8007746:	e7da      	b.n	80076fe <prvProcessEthernetPacket+0x2e>
 8007748:	200133b4 	.word	0x200133b4

0800774c <prvHandleEthernetPacket>:
        if( pxBuffer != NULL )
 800774c:	b118      	cbz	r0, 8007756 <prvHandleEthernetPacket+0xa>
{
 800774e:	b508      	push	{r3, lr}
            prvProcessEthernetPacket( pxBuffer );
 8007750:	f7ff ffbe 	bl	80076d0 <prvProcessEthernetPacket>
}
 8007754:	bd08      	pop	{r3, pc}
 8007756:	4770      	bx	lr

08007758 <prvProcessIPEventsAndTimers>:
{
 8007758:	b510      	push	{r4, lr}
 800775a:	b088      	sub	sp, #32
    vCheckNetworkTimers();
 800775c:	f000 f990 	bl	8007a80 <vCheckNetworkTimers>
    xNextIPSleep = xCalculateSleepTime();
 8007760:	f000 f8ec 	bl	800793c <xCalculateSleepTime>
 8007764:	4602      	mov	r2, r0
    if( xQueueReceive( xNetworkEventQueue, ( void * ) &xReceivedEvent, xNextIPSleep ) == pdFALSE )
 8007766:	a906      	add	r1, sp, #24
 8007768:	4b4b      	ldr	r3, [pc, #300]	@ (8007898 <prvProcessIPEventsAndTimers+0x140>)
 800776a:	6818      	ldr	r0, [r3, #0]
 800776c:	f7fc fdf4 	bl	8004358 <xQueueReceive>
 8007770:	b910      	cbnz	r0, 8007778 <prvProcessIPEventsAndTimers+0x20>
        xReceivedEvent.eEventType = eNoEvent;
 8007772:	23ff      	movs	r3, #255	@ 0xff
 8007774:	f88d 3018 	strb.w	r3, [sp, #24]
    switch( xReceivedEvent.eEventType )
 8007778:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 800777c:	2b0d      	cmp	r3, #13
 800777e:	d85a      	bhi.n	8007836 <prvProcessIPEventsAndTimers+0xde>
 8007780:	e8df f003 	tbb	[pc, r3]
 8007784:	140f0b07 	.word	0x140f0b07
 8007788:	716d6561 	.word	0x716d6561
 800778c:	695d197f 	.word	0x695d197f
 8007790:	8259      	.short	0x8259
            prvProcessNetworkDownEvent( ( ( NetworkInterface_t * ) xReceivedEvent.pvData ) );
 8007792:	9807      	ldr	r0, [sp, #28]
 8007794:	f000 fb23 	bl	8007dde <prvProcessNetworkDownEvent>
            break;
 8007798:	e04d      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
            prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * ) xReceivedEvent.pvData );
 800779a:	9807      	ldr	r0, [sp, #28]
 800779c:	f7ff ffd6 	bl	800774c <prvHandleEthernetPacket>
            break;
 80077a0:	e049      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
            prvForwardTxPacket( ( ( NetworkBufferDescriptor_t * ) xReceivedEvent.pvData ), pdTRUE );
 80077a2:	2101      	movs	r1, #1
 80077a4:	9807      	ldr	r0, [sp, #28]
 80077a6:	f7ff fcc9 	bl	800713c <prvForwardTxPacket>
            break;
 80077aa:	e044      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                vARPAgeCache();
 80077ac:	f7fe fece 	bl	800654c <vARPAgeCache>
                vNDAgeCache();
 80077b0:	f001 fc98 	bl	80090e4 <vNDAgeCache>
            break;
 80077b4:	e03f      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
            pxSocket = ( ( FreeRTOS_Socket_t * ) xReceivedEvent.pvData );
 80077b6:	9c07      	ldr	r4, [sp, #28]
            xAddress.sin_len = ( uint8_t ) sizeof( xAddress );
 80077b8:	2318      	movs	r3, #24
 80077ba:	f88d 3000 	strb.w	r3, [sp]
            switch( pxSocket->bits.bIsIPv6 ) /* LCOV_EXCL_BR_LINE */
 80077be:	7a23      	ldrb	r3, [r4, #8]
 80077c0:	f013 0301 	ands.w	r3, r3, #1
 80077c4:	d011      	beq.n	80077ea <prvProcessIPEventsAndTimers+0x92>
 80077c6:	b313      	cbz	r3, 800780e <prvProcessIPEventsAndTimers+0xb6>
                        xAddress.sin_family = FREERTOS_AF_INET6;
 80077c8:	230a      	movs	r3, #10
 80077ca:	f88d 3001 	strb.w	r3, [sp, #1]
                        ( void ) memcpy( xAddress.sin_address.xIP_IPv6.ucBytes, pxSocket->xLocalAddress.xIP_IPv6.ucBytes, sizeof( xAddress.sin_address.xIP_IPv6.ucBytes ) );
 80077ce:	f10d 0c08 	add.w	ip, sp, #8
 80077d2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 80077d4:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 80077d6:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80077d8:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80077da:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
                        ( void ) memset( pxSocket->xLocalAddress.xIP_IPv6.ucBytes, 0, sizeof( pxSocket->xLocalAddress.xIP_IPv6.ucBytes ) );
 80077de:	2300      	movs	r3, #0
 80077e0:	62a3      	str	r3, [r4, #40]	@ 0x28
 80077e2:	62e3      	str	r3, [r4, #44]	@ 0x2c
 80077e4:	6323      	str	r3, [r4, #48]	@ 0x30
 80077e6:	6363      	str	r3, [r4, #52]	@ 0x34
                        break;
 80077e8:	e011      	b.n	800780e <prvProcessIPEventsAndTimers+0xb6>
                        xAddress.sin_family = FREERTOS_AF_INET;
 80077ea:	2302      	movs	r3, #2
 80077ec:	f88d 3001 	strb.w	r3, [sp, #1]
                        xAddress.sin_address.ulIP_IPv4 = FreeRTOS_htonl( pxSocket->xLocalAddress.ulIP_IPv4 );
 80077f0:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 80077f2:	0213      	lsls	r3, r2, #8
 80077f4:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 80077f8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80077fc:	0a11      	lsrs	r1, r2, #8
 80077fe:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 8007802:	430b      	orrs	r3, r1
 8007804:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8007808:	9302      	str	r3, [sp, #8]
                        pxSocket->xLocalAddress.ulIP_IPv4 = 0;
 800780a:	2300      	movs	r3, #0
 800780c:	62a3      	str	r3, [r4, #40]	@ 0x28
            xAddress.sin_port = FreeRTOS_ntohs( pxSocket->usLocalPort );
 800780e:	8f22      	ldrh	r2, [r4, #56]	@ 0x38
 8007810:	0213      	lsls	r3, r2, #8
 8007812:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8007816:	f8ad 3002 	strh.w	r3, [sp, #2]
            pxSocket->usLocalPort = 0U;
 800781a:	2300      	movs	r3, #0
 800781c:	8723      	strh	r3, [r4, #56]	@ 0x38
            ( void ) vSocketBind( pxSocket, &xAddress, sizeof( xAddress ), pdFALSE );
 800781e:	2218      	movs	r2, #24
 8007820:	4669      	mov	r1, sp
 8007822:	4620      	mov	r0, r4
 8007824:	f003 fcc0 	bl	800b1a8 <vSocketBind>
            pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_BOUND;
 8007828:	6823      	ldr	r3, [r4, #0]
 800782a:	f043 0310 	orr.w	r3, r3, #16
 800782e:	6023      	str	r3, [r4, #0]
            vSocketWakeUpUser( pxSocket );
 8007830:	4620      	mov	r0, r4
 8007832:	f002 fffa 	bl	800a82a <vSocketWakeUpUser>
    prvIPTask_CheckPendingEvents();
 8007836:	f7ff fcab 	bl	8007190 <prvIPTask_CheckPendingEvents>
}
 800783a:	b008      	add	sp, #32
 800783c:	bd10      	pop	{r4, pc}
            ( void ) vSocketClose( ( ( FreeRTOS_Socket_t * ) xReceivedEvent.pvData ) );
 800783e:	9807      	ldr	r0, [sp, #28]
 8007840:	f002 fed5 	bl	800a5ee <vSocketClose>
            break;
 8007844:	e7f7      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
            vProcessGeneratedUDPPacket( ( NetworkBufferDescriptor_t * ) xReceivedEvent.pvData );
 8007846:	9807      	ldr	r0, [sp, #28]
 8007848:	f006 fc68 	bl	800e11c <vProcessGeneratedUDPPacket>
            break;
 800784c:	e7f3      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
            prvCallDHCP_RA_Handler( ( ( NetworkEndPoint_t * ) xReceivedEvent.pvData ) );
 800784e:	9807      	ldr	r0, [sp, #28]
 8007850:	f7ff fc7e 	bl	8007150 <prvCallDHCP_RA_Handler>
            break;
 8007854:	e7ef      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                    vSocketSelect( ( ( SocketSelect_t * ) xReceivedEvent.pvData ) );
 8007856:	9807      	ldr	r0, [sp, #28]
 8007858:	f003 fd8a 	bl	800b370 <vSocketSelect>
            break;
 800785c:	e7eb      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                vIPSetTCPTimerExpiredState( pdTRUE );
 800785e:	2001      	movs	r0, #1
 8007860:	f000 f8c4 	bl	80079ec <vIPSetTCPTimerExpiredState>
            break;
 8007864:	e7e7      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                pxSocket = ( ( FreeRTOS_Socket_t * ) xReceivedEvent.pvData );
 8007866:	9c07      	ldr	r4, [sp, #28]
                if( xTCPCheckNewClient( pxSocket ) != pdFALSE )
 8007868:	4620      	mov	r0, r4
 800786a:	f004 f9f1 	bl	800bc50 <xTCPCheckNewClient>
 800786e:	2800      	cmp	r0, #0
 8007870:	d0e1      	beq.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                    pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_ACCEPT;
 8007872:	6823      	ldr	r3, [r4, #0]
 8007874:	f043 0304 	orr.w	r3, r3, #4
 8007878:	6023      	str	r3, [r4, #0]
                    vSocketWakeUpUser( pxSocket );
 800787a:	4620      	mov	r0, r4
 800787c:	f002 ffd5 	bl	800a82a <vSocketWakeUpUser>
 8007880:	e7d9      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                vTCPNetStat();
 8007882:	f003 fd4f 	bl	800b324 <vTCPNetStat>
            break;
 8007886:	e7d6      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
                SocketSelect_t * pxSocketSet = ( SocketSelect_t * ) ( xReceivedEvent.pvData );
 8007888:	9c07      	ldr	r4, [sp, #28]
                vEventGroupDelete( pxSocketSet->xSelectGroup );
 800788a:	6820      	ldr	r0, [r4, #0]
 800788c:	f7fc fa6a 	bl	8003d64 <vEventGroupDelete>
                vPortFree( ( void * ) pxSocketSet );
 8007890:	4620      	mov	r0, r4
 8007892:	f7fe fa89 	bl	8005da8 <vPortFree>
            break;
 8007896:	e7ce      	b.n	8007836 <prvProcessIPEventsAndTimers+0xde>
 8007898:	200133b0 	.word	0x200133b0

0800789c <prvIPTask>:
{
 800789c:	b508      	push	{r3, lr}
    prvIPTask_Initialise();
 800789e:	f7ff fd6b 	bl	8007378 <prvIPTask_Initialise>
        prvProcessIPEventsAndTimers();
 80078a2:	f7ff ff59 	bl	8007758 <prvProcessIPEventsAndTimers>
    while( ipFOREVER() == pdTRUE )
 80078a6:	e7fc      	b.n	80078a2 <prvIPTask+0x6>

080078a8 <uxIPHeaderSizeSocket>:
 */
size_t uxIPHeaderSizeSocket( const FreeRTOS_Socket_t * pxSocket )
{
    size_t uxResult;

    if( ( pxSocket != NULL ) && ( pxSocket->bits.bIsIPv6 != pdFALSE_UNSIGNED ) )
 80078a8:	b128      	cbz	r0, 80078b6 <uxIPHeaderSizeSocket+0xe>
 80078aa:	7a03      	ldrb	r3, [r0, #8]
 80078ac:	f013 0f01 	tst.w	r3, #1
 80078b0:	d103      	bne.n	80078ba <uxIPHeaderSizeSocket+0x12>
    {
        uxResult = ipSIZE_OF_IPv6_HEADER;
    }
    else
    {
        uxResult = ipSIZE_OF_IPv4_HEADER;
 80078b2:	2014      	movs	r0, #20
 80078b4:	4770      	bx	lr
 80078b6:	2014      	movs	r0, #20
 80078b8:	4770      	bx	lr
        uxResult = ipSIZE_OF_IPv6_HEADER;
 80078ba:	2028      	movs	r0, #40	@ 0x28
    }

    return uxResult;
}
 80078bc:	4770      	bx	lr

080078be <prvIPTimerStart>:
 *                     as expired.
 * @param[in] xTime Time to be loaded into the IP timer.
 */
static void prvIPTimerStart( IPTimer_t * pxTimer,
                             TickType_t xTime )
{
 80078be:	b538      	push	{r3, r4, r5, lr}
 80078c0:	4604      	mov	r4, r0
 80078c2:	460d      	mov	r5, r1
    vTaskSetTimeOutState( &pxTimer->xTimeOut );
 80078c4:	3004      	adds	r0, #4
 80078c6:	f7fd fc1d 	bl	8005104 <vTaskSetTimeOutState>
    pxTimer->ulRemainingTime = xTime;
 80078ca:	60e5      	str	r5, [r4, #12]

    if( xTime == ( TickType_t ) 0 )
 80078cc:	b945      	cbnz	r5, 80078e0 <prvIPTimerStart+0x22>
    {
        pxTimer->bExpired = pdTRUE_UNSIGNED;
 80078ce:	7823      	ldrb	r3, [r4, #0]
 80078d0:	f043 0302 	orr.w	r3, r3, #2
 80078d4:	7023      	strb	r3, [r4, #0]
    else
    {
        pxTimer->bExpired = pdFALSE_UNSIGNED;
    }

    pxTimer->bActive = pdTRUE_UNSIGNED;
 80078d6:	7823      	ldrb	r3, [r4, #0]
 80078d8:	f043 0301 	orr.w	r3, r3, #1
 80078dc:	7023      	strb	r3, [r4, #0]
}
 80078de:	bd38      	pop	{r3, r4, r5, pc}
        pxTimer->bExpired = pdFALSE_UNSIGNED;
 80078e0:	7823      	ldrb	r3, [r4, #0]
 80078e2:	f023 0302 	bic.w	r3, r3, #2
 80078e6:	7023      	strb	r3, [r4, #0]
 80078e8:	e7f5      	b.n	80078d6 <prvIPTimerStart+0x18>

080078ea <prvIPTimerReload>:
 * @param[in] pxTimer Pointer to the IP timer.
 * @param[in] xTime Time to be reloaded into the IP timer.
 */
static void prvIPTimerReload( IPTimer_t * pxTimer,
                              TickType_t xTime )
{
 80078ea:	b508      	push	{r3, lr}
    pxTimer->ulReloadTime = xTime;
 80078ec:	6101      	str	r1, [r0, #16]
    prvIPTimerStart( pxTimer, xTime );
 80078ee:	f7ff ffe6 	bl	80078be <prvIPTimerStart>
}
 80078f2:	bd08      	pop	{r3, pc}

080078f4 <prvIPTimerCheck>:
 */
static BaseType_t prvIPTimerCheck( IPTimer_t * pxTimer )
{
    BaseType_t xReturn;

    if( pxTimer->bActive == pdFALSE_UNSIGNED )
 80078f4:	7803      	ldrb	r3, [r0, #0]
 80078f6:	f013 0f01 	tst.w	r3, #1
 80078fa:	d01c      	beq.n	8007936 <prvIPTimerCheck+0x42>
{
 80078fc:	b510      	push	{r4, lr}
 80078fe:	4604      	mov	r4, r0
    }
    else
    {
        /* The timer might have set the bExpired flag already, if not, check the
         * value of xTimeOut against ulRemainingTime. */
        if( pxTimer->bExpired == pdFALSE_UNSIGNED )
 8007900:	f013 0f02 	tst.w	r3, #2
 8007904:	d005      	beq.n	8007912 <prvIPTimerCheck+0x1e>
            {
                pxTimer->bExpired = pdTRUE_UNSIGNED;
            }
        }

        if( pxTimer->bExpired != pdFALSE_UNSIGNED )
 8007906:	7823      	ldrb	r3, [r4, #0]
 8007908:	f013 0f02 	tst.w	r3, #2
 800790c:	d10d      	bne.n	800792a <prvIPTimerCheck+0x36>
            prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
            xReturn = pdTRUE;
        }
        else
        {
            xReturn = pdFALSE;
 800790e:	2000      	movs	r0, #0
        }
    }

    return xReturn;
}
 8007910:	bd10      	pop	{r4, pc}
            if( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE )
 8007912:	f100 010c 	add.w	r1, r0, #12
 8007916:	3004      	adds	r0, #4
 8007918:	f7fd fc1c 	bl	8005154 <xTaskCheckForTimeOut>
 800791c:	2800      	cmp	r0, #0
 800791e:	d0f2      	beq.n	8007906 <prvIPTimerCheck+0x12>
                pxTimer->bExpired = pdTRUE_UNSIGNED;
 8007920:	7823      	ldrb	r3, [r4, #0]
 8007922:	f043 0302 	orr.w	r3, r3, #2
 8007926:	7023      	strb	r3, [r4, #0]
 8007928:	e7ed      	b.n	8007906 <prvIPTimerCheck+0x12>
            prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
 800792a:	6921      	ldr	r1, [r4, #16]
 800792c:	4620      	mov	r0, r4
 800792e:	f7ff ffc6 	bl	80078be <prvIPTimerStart>
            xReturn = pdTRUE;
 8007932:	2001      	movs	r0, #1
 8007934:	e7ec      	b.n	8007910 <prvIPTimerCheck+0x1c>
        xReturn = pdFALSE;
 8007936:	2000      	movs	r0, #0
}
 8007938:	4770      	bx	lr
	...

0800793c <xCalculateSleepTime>:
    if( xARPTimer.bActive != pdFALSE_UNSIGNED )
 800793c:	4b15      	ldr	r3, [pc, #84]	@ (8007994 <xCalculateSleepTime+0x58>)
 800793e:	781b      	ldrb	r3, [r3, #0]
 8007940:	f013 0f01 	tst.w	r3, #1
 8007944:	d008      	beq.n	8007958 <xCalculateSleepTime+0x1c>
        if( xARPTimer.ulRemainingTime < uxMaximumSleepTime )
 8007946:	4b13      	ldr	r3, [pc, #76]	@ (8007994 <xCalculateSleepTime+0x58>)
 8007948:	68d8      	ldr	r0, [r3, #12]
 800794a:	f242 730f 	movw	r3, #9999	@ 0x270f
 800794e:	4298      	cmp	r0, r3
 8007950:	d904      	bls.n	800795c <xCalculateSleepTime+0x20>
    uxMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 8007952:	f242 7010 	movw	r0, #10000	@ 0x2710
 8007956:	e001      	b.n	800795c <xCalculateSleepTime+0x20>
 8007958:	f242 7010 	movw	r0, #10000	@ 0x2710
        const NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 800795c:	4b0e      	ldr	r3, [pc, #56]	@ (8007998 <xCalculateSleepTime+0x5c>)
 800795e:	681b      	ldr	r3, [r3, #0]
        while( pxEndPoint != NULL )
 8007960:	e001      	b.n	8007966 <xCalculateSleepTime+0x2a>
            pxEndPoint = pxEndPoint->pxNext;
 8007962:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8007966:	b153      	cbz	r3, 800797e <xCalculateSleepTime+0x42>
            if( pxEndPoint->xDHCP_RATimer.bActive != pdFALSE_UNSIGNED )
 8007968:	f893 20f8 	ldrb.w	r2, [r3, #248]	@ 0xf8
 800796c:	f012 0f01 	tst.w	r2, #1
 8007970:	d0f7      	beq.n	8007962 <xCalculateSleepTime+0x26>
                if( pxEndPoint->xDHCP_RATimer.ulRemainingTime < uxMaximumSleepTime )
 8007972:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
 8007976:	4282      	cmp	r2, r0
 8007978:	d2f3      	bcs.n	8007962 <xCalculateSleepTime+0x26>
                    uxMaximumSleepTime = pxEndPoint->xDHCP_RATimer.ulRemainingTime;
 800797a:	4610      	mov	r0, r2
 800797c:	e7f1      	b.n	8007962 <xCalculateSleepTime+0x26>
        if( xTCPTimer.bActive != pdFALSE_UNSIGNED )
 800797e:	4b07      	ldr	r3, [pc, #28]	@ (800799c <xCalculateSleepTime+0x60>)
 8007980:	781b      	ldrb	r3, [r3, #0]
 8007982:	f013 0f01 	tst.w	r3, #1
 8007986:	d004      	beq.n	8007992 <xCalculateSleepTime+0x56>
            if( xTCPTimer.ulRemainingTime < uxMaximumSleepTime )
 8007988:	4b04      	ldr	r3, [pc, #16]	@ (800799c <xCalculateSleepTime+0x60>)
 800798a:	68db      	ldr	r3, [r3, #12]
 800798c:	4283      	cmp	r3, r0
 800798e:	d200      	bcs.n	8007992 <xCalculateSleepTime+0x56>
                uxMaximumSleepTime = xTCPTimer.ulRemainingTime;
 8007990:	4618      	mov	r0, r3
}
 8007992:	4770      	bx	lr
 8007994:	200133e0 	.word	0x200133e0
 8007998:	20013778 	.word	0x20013778
 800799c:	200133cc 	.word	0x200133cc

080079a0 <vIPTimerStartARPResolution>:
{
 80079a0:	b508      	push	{r3, lr}
 80079a2:	4601      	mov	r1, r0
    prvIPTimerStart( &( xARPResolutionTimer ), xTime );
 80079a4:	4801      	ldr	r0, [pc, #4]	@ (80079ac <vIPTimerStartARPResolution+0xc>)
 80079a6:	f7ff ff8a 	bl	80078be <prvIPTimerStart>
}
 80079aa:	bd08      	pop	{r3, pc}
 80079ac:	200133f4 	.word	0x200133f4

080079b0 <vTCPTimerReload>:
    {
 80079b0:	b508      	push	{r3, lr}
 80079b2:	4601      	mov	r1, r0
        prvIPTimerReload( &xTCPTimer, xTime );
 80079b4:	4801      	ldr	r0, [pc, #4]	@ (80079bc <vTCPTimerReload+0xc>)
 80079b6:	f7ff ff98 	bl	80078ea <prvIPTimerReload>
    }
 80079ba:	bd08      	pop	{r3, pc}
 80079bc:	200133cc 	.word	0x200133cc

080079c0 <vARPTimerReload>:
{
 80079c0:	b508      	push	{r3, lr}
 80079c2:	4601      	mov	r1, r0
    prvIPTimerReload( &xARPTimer, xTime );
 80079c4:	4801      	ldr	r0, [pc, #4]	@ (80079cc <vARPTimerReload+0xc>)
 80079c6:	f7ff ff90 	bl	80078ea <prvIPTimerReload>
}
 80079ca:	bd08      	pop	{r3, pc}
 80079cc:	200133e0 	.word	0x200133e0

080079d0 <vDHCP_RATimerReload>:
    {
 80079d0:	b508      	push	{r3, lr}
        prvIPTimerReload( &( pxEndPoint->xDHCP_RATimer ), uxClockTicks );
 80079d2:	30f8      	adds	r0, #248	@ 0xf8
 80079d4:	f7ff ff89 	bl	80078ea <prvIPTimerReload>
    }
 80079d8:	bd08      	pop	{r3, pc}
	...

080079dc <vNetworkTimerReload>:
{
 80079dc:	b508      	push	{r3, lr}
 80079de:	4601      	mov	r1, r0
    prvIPTimerReload( &xNetworkTimer, xTime );
 80079e0:	4801      	ldr	r0, [pc, #4]	@ (80079e8 <vNetworkTimerReload+0xc>)
 80079e2:	f7ff ff82 	bl	80078ea <prvIPTimerReload>
}
 80079e6:	bd08      	pop	{r3, pc}
 80079e8:	200133b8 	.word	0x200133b8

080079ec <vIPSetTCPTimerExpiredState>:
 *
 * @param[in] xExpiredState pdTRUE - set as expired; pdFALSE - set as non-expired.
 */
    void vIPSetTCPTimerExpiredState( BaseType_t xExpiredState )
    {
        xTCPTimer.bActive = pdTRUE_UNSIGNED;
 80079ec:	4a08      	ldr	r2, [pc, #32]	@ (8007a10 <vIPSetTCPTimerExpiredState+0x24>)
 80079ee:	7813      	ldrb	r3, [r2, #0]
 80079f0:	f043 0301 	orr.w	r3, r3, #1
 80079f4:	7013      	strb	r3, [r2, #0]

        if( xExpiredState != pdFALSE )
 80079f6:	b120      	cbz	r0, 8007a02 <vIPSetTCPTimerExpiredState+0x16>
        {
            xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 80079f8:	b2db      	uxtb	r3, r3
 80079fa:	f043 0302 	orr.w	r3, r3, #2
 80079fe:	7013      	strb	r3, [r2, #0]
 8007a00:	4770      	bx	lr
        }
        else
        {
            xTCPTimer.bExpired = pdFALSE_UNSIGNED;
 8007a02:	4a03      	ldr	r2, [pc, #12]	@ (8007a10 <vIPSetTCPTimerExpiredState+0x24>)
 8007a04:	7813      	ldrb	r3, [r2, #0]
 8007a06:	f023 0302 	bic.w	r3, r3, #2
 8007a0a:	7013      	strb	r3, [r2, #0]
        }
    }
 8007a0c:	4770      	bx	lr
 8007a0e:	bf00      	nop
 8007a10:	200133cc 	.word	0x200133cc

08007a14 <vIPSetARPTimerEnableState>:
 *
 * @param[in] xEnableState pdTRUE - enable timer; pdFALSE - disable timer.
 */
void vIPSetARPTimerEnableState( BaseType_t xEnableState )
{
    if( xEnableState != pdFALSE )
 8007a14:	b128      	cbz	r0, 8007a22 <vIPSetARPTimerEnableState+0xe>
    {
        xARPTimer.bActive = pdTRUE_UNSIGNED;
 8007a16:	4a06      	ldr	r2, [pc, #24]	@ (8007a30 <vIPSetARPTimerEnableState+0x1c>)
 8007a18:	7813      	ldrb	r3, [r2, #0]
 8007a1a:	f043 0301 	orr.w	r3, r3, #1
 8007a1e:	7013      	strb	r3, [r2, #0]
 8007a20:	4770      	bx	lr
    }
    else
    {
        xARPTimer.bActive = pdFALSE_UNSIGNED;
 8007a22:	4a03      	ldr	r2, [pc, #12]	@ (8007a30 <vIPSetARPTimerEnableState+0x1c>)
 8007a24:	7813      	ldrb	r3, [r2, #0]
 8007a26:	f023 0301 	bic.w	r3, r3, #1
 8007a2a:	7013      	strb	r3, [r2, #0]
    }
}
 8007a2c:	4770      	bx	lr
 8007a2e:	bf00      	nop
 8007a30:	200133e0 	.word	0x200133e0

08007a34 <vIPSetARPResolutionTimerEnableState>:
 *
 * @param[in] xEnableState pdTRUE if the timer must be enabled, pdFALSE otherwise.
 */
void vIPSetARPResolutionTimerEnableState( BaseType_t xEnableState )
{
    if( xEnableState != pdFALSE )
 8007a34:	b128      	cbz	r0, 8007a42 <vIPSetARPResolutionTimerEnableState+0xe>
    {
        xARPResolutionTimer.bActive = pdTRUE_UNSIGNED;
 8007a36:	4a06      	ldr	r2, [pc, #24]	@ (8007a50 <vIPSetARPResolutionTimerEnableState+0x1c>)
 8007a38:	7813      	ldrb	r3, [r2, #0]
 8007a3a:	f043 0301 	orr.w	r3, r3, #1
 8007a3e:	7013      	strb	r3, [r2, #0]
 8007a40:	4770      	bx	lr
    }
    else
    {
        xARPResolutionTimer.bActive = pdFALSE_UNSIGNED;
 8007a42:	4a03      	ldr	r2, [pc, #12]	@ (8007a50 <vIPSetARPResolutionTimerEnableState+0x1c>)
 8007a44:	7813      	ldrb	r3, [r2, #0]
 8007a46:	f023 0301 	bic.w	r3, r3, #1
 8007a4a:	7013      	strb	r3, [r2, #0]
    }
}
 8007a4c:	4770      	bx	lr
 8007a4e:	bf00      	nop
 8007a50:	200133f4 	.word	0x200133f4

08007a54 <vIPSetDHCP_RATimerEnableState>:
                                        BaseType_t xEnableState )
    {
        FreeRTOS_printf( ( "vIPSetDHCP_RATimerEnableState: %s\n", ( xEnableState != 0 ) ? "On" : "Off" ) );

        /* 'xDHCP_RATimer' is shared between DHCP (IPv4) and RA/SLAAC (IPv6). */
        if( xEnableState != 0 )
 8007a54:	b131      	cbz	r1, 8007a64 <vIPSetDHCP_RATimerEnableState+0x10>
        {
            pxEndPoint->xDHCP_RATimer.bActive = pdTRUE_UNSIGNED;
 8007a56:	f890 30f8 	ldrb.w	r3, [r0, #248]	@ 0xf8
 8007a5a:	f043 0301 	orr.w	r3, r3, #1
 8007a5e:	f880 30f8 	strb.w	r3, [r0, #248]	@ 0xf8
 8007a62:	4770      	bx	lr
        }
        else
        {
            pxEndPoint->xDHCP_RATimer.bActive = pdFALSE_UNSIGNED;
 8007a64:	f890 30f8 	ldrb.w	r3, [r0, #248]	@ 0xf8
 8007a68:	f023 0301 	bic.w	r3, r3, #1
 8007a6c:	f880 30f8 	strb.w	r3, [r0, #248]	@ 0xf8
        }
    }
 8007a70:	4770      	bx	lr
	...

08007a74 <vSetAllNetworksUp>:
 * @brief Mark whether all interfaces are up or at least one interface is down.
 *        If all interfaces are up, the 'xNetworkTimer' will not be checked.
 */
void vSetAllNetworksUp( BaseType_t xIsAllNetworksUp )
{
    xAllNetworksUp = xIsAllNetworksUp;
 8007a74:	4b01      	ldr	r3, [pc, #4]	@ (8007a7c <vSetAllNetworksUp+0x8>)
 8007a76:	6018      	str	r0, [r3, #0]
}
 8007a78:	4770      	bx	lr
 8007a7a:	bf00      	nop
 8007a7c:	20013408 	.word	0x20013408

08007a80 <vCheckNetworkTimers>:
{
 8007a80:	b538      	push	{r3, r4, r5, lr}
    if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 8007a82:	4836      	ldr	r0, [pc, #216]	@ (8007b5c <vCheckNetworkTimers+0xdc>)
 8007a84:	f7ff ff36 	bl	80078f4 <prvIPTimerCheck>
 8007a88:	b990      	cbnz	r0, 8007ab0 <vCheckNetworkTimers+0x30>
    if( prvIPTimerCheck( &xARPResolutionTimer ) != pdFALSE )
 8007a8a:	4835      	ldr	r0, [pc, #212]	@ (8007b60 <vCheckNetworkTimers+0xe0>)
 8007a8c:	f7ff ff32 	bl	80078f4 <prvIPTimerCheck>
 8007a90:	b158      	cbz	r0, 8007aaa <vCheckNetworkTimers+0x2a>
        if( pxARPWaitingNetworkBuffer != NULL )
 8007a92:	4b34      	ldr	r3, [pc, #208]	@ (8007b64 <vCheckNetworkTimers+0xe4>)
 8007a94:	681b      	ldr	r3, [r3, #0]
 8007a96:	b143      	cbz	r3, 8007aaa <vCheckNetworkTimers+0x2a>
            vIPSetARPResolutionTimerEnableState( pdFALSE );
 8007a98:	2000      	movs	r0, #0
 8007a9a:	f7ff ffcb 	bl	8007a34 <vIPSetARPResolutionTimerEnableState>
            vReleaseNetworkBufferAndDescriptor( pxARPWaitingNetworkBuffer );
 8007a9e:	4c31      	ldr	r4, [pc, #196]	@ (8007b64 <vCheckNetworkTimers+0xe4>)
 8007aa0:	6820      	ldr	r0, [r4, #0]
 8007aa2:	f006 fdfd 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
            pxARPWaitingNetworkBuffer = NULL;
 8007aa6:	2300      	movs	r3, #0
 8007aa8:	6023      	str	r3, [r4, #0]
        NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8007aaa:	4b2f      	ldr	r3, [pc, #188]	@ (8007b68 <vCheckNetworkTimers+0xe8>)
 8007aac:	681c      	ldr	r4, [r3, #0]
        while( pxEndPoint != NULL )
 8007aae:	e00b      	b.n	8007ac8 <vCheckNetworkTimers+0x48>
        ( void ) xSendEventToIPTask( eARPTimerEvent );
 8007ab0:	2003      	movs	r0, #3
 8007ab2:	f7ff fc81 	bl	80073b8 <xSendEventToIPTask>
 8007ab6:	e7e8      	b.n	8007a8a <vCheckNetworkTimers+0xa>
                    if( END_POINT_USES_RA( pxEndPoint ) )
 8007ab8:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007abc:	f003 030c 	and.w	r3, r3, #12
 8007ac0:	2b0c      	cmp	r3, #12
 8007ac2:	d011      	beq.n	8007ae8 <vCheckNetworkTimers+0x68>
            pxEndPoint = pxEndPoint->pxNext;
 8007ac4:	f8d4 415c 	ldr.w	r4, [r4, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8007ac8:	b19c      	cbz	r4, 8007af2 <vCheckNetworkTimers+0x72>
            if( prvIPTimerCheck( &( pxEndPoint->xDHCP_RATimer ) ) != pdFALSE )
 8007aca:	f104 00f8 	add.w	r0, r4, #248	@ 0xf8
 8007ace:	f7ff ff11 	bl	80078f4 <prvIPTimerCheck>
 8007ad2:	2800      	cmp	r0, #0
 8007ad4:	d0f6      	beq.n	8007ac4 <vCheckNetworkTimers+0x44>
                    if( END_POINT_USES_DHCP( pxEndPoint ) )
 8007ad6:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007ada:	f013 0f02 	tst.w	r3, #2
 8007ade:	d0eb      	beq.n	8007ab8 <vCheckNetworkTimers+0x38>
                        ( void ) xSendDHCPEvent( pxEndPoint );
 8007ae0:	4620      	mov	r0, r4
 8007ae2:	f000 fbcf 	bl	8008284 <xSendDHCPEvent>
 8007ae6:	e7e7      	b.n	8007ab8 <vCheckNetworkTimers+0x38>
                        vRAProcess( pdFALSE, pxEndPoint );
 8007ae8:	4621      	mov	r1, r4
 8007aea:	2000      	movs	r0, #0
 8007aec:	f001 fe61 	bl	80097b2 <vRAProcess>
 8007af0:	e7e8      	b.n	8007ac4 <vCheckNetworkTimers+0x44>
        if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0U )
 8007af2:	4b1e      	ldr	r3, [pc, #120]	@ (8007b6c <vCheckNetworkTimers+0xec>)
 8007af4:	6818      	ldr	r0, [r3, #0]
 8007af6:	f7fc fdb1 	bl	800465c <uxQueueMessagesWaiting>
 8007afa:	b9b0      	cbnz	r0, 8007b2a <vCheckNetworkTimers+0xaa>
            xWillSleep = pdTRUE;
 8007afc:	2401      	movs	r4, #1
        xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
 8007afe:	481c      	ldr	r0, [pc, #112]	@ (8007b70 <vCheckNetworkTimers+0xf0>)
 8007b00:	f7ff fef8 	bl	80078f4 <prvIPTimerCheck>
        if( xWillSleep != pdFALSE )
 8007b04:	b904      	cbnz	r4, 8007b08 <vCheckNetworkTimers+0x88>
        if( xCheckTCPSockets != pdFALSE )
 8007b06:	b130      	cbz	r0, 8007b16 <vCheckNetworkTimers+0x96>
            xNextTime = xTCPTimerCheck( xWillSleep );
 8007b08:	4620      	mov	r0, r4
 8007b0a:	f002 feaf 	bl	800a86c <xTCPTimerCheck>
 8007b0e:	4601      	mov	r1, r0
            prvIPTimerStart( &xTCPTimer, xNextTime );
 8007b10:	4817      	ldr	r0, [pc, #92]	@ (8007b70 <vCheckNetworkTimers+0xf0>)
 8007b12:	f7ff fed4 	bl	80078be <prvIPTimerStart>
    vSocketCloseNextTime( NULL );
 8007b16:	2000      	movs	r0, #0
 8007b18:	f003 fd98 	bl	800b64c <vSocketCloseNextTime>
    vSocketListenNextTime( NULL );
 8007b1c:	2000      	movs	r0, #0
 8007b1e:	f003 fda3 	bl	800b668 <vSocketListenNextTime>
    if( xAllNetworksUp == pdFALSE )
 8007b22:	4b14      	ldr	r3, [pc, #80]	@ (8007b74 <vCheckNetworkTimers+0xf4>)
 8007b24:	681d      	ldr	r5, [r3, #0]
 8007b26:	b115      	cbz	r5, 8007b2e <vCheckNetworkTimers+0xae>
}
 8007b28:	bd38      	pop	{r3, r4, r5, pc}
            xWillSleep = pdFALSE;
 8007b2a:	2400      	movs	r4, #0
 8007b2c:	e7e7      	b.n	8007afe <vCheckNetworkTimers+0x7e>
        if( prvIPTimerCheck( &( xNetworkTimer ) ) != pdFALSE )
 8007b2e:	4812      	ldr	r0, [pc, #72]	@ (8007b78 <vCheckNetworkTimers+0xf8>)
 8007b30:	f7ff fee0 	bl	80078f4 <prvIPTimerCheck>
 8007b34:	2800      	cmp	r0, #0
 8007b36:	d0f7      	beq.n	8007b28 <vCheckNetworkTimers+0xa8>
            for( pxInterface = pxNetworkInterfaces; pxInterface != NULL; pxInterface = pxInterface->pxNext )
 8007b38:	4b10      	ldr	r3, [pc, #64]	@ (8007b7c <vCheckNetworkTimers+0xfc>)
 8007b3a:	681c      	ldr	r4, [r3, #0]
            BaseType_t xUp = pdTRUE;
 8007b3c:	2001      	movs	r0, #1
            for( pxInterface = pxNetworkInterfaces; pxInterface != NULL; pxInterface = pxInterface->pxNext )
 8007b3e:	e000      	b.n	8007b42 <vCheckNetworkTimers+0xc2>
 8007b40:	6a64      	ldr	r4, [r4, #36]	@ 0x24
 8007b42:	b144      	cbz	r4, 8007b56 <vCheckNetworkTimers+0xd6>
                if( pxInterface->bits.bInterfaceUp == pdFALSE_UNSIGNED )
 8007b44:	7f23      	ldrb	r3, [r4, #28]
 8007b46:	f013 0f01 	tst.w	r3, #1
 8007b4a:	d1f9      	bne.n	8007b40 <vCheckNetworkTimers+0xc0>
                    FreeRTOS_NetworkDown( pxInterface );
 8007b4c:	4620      	mov	r0, r4
 8007b4e:	f7ff fbf3 	bl	8007338 <FreeRTOS_NetworkDown>
                    xUp = pdFALSE;
 8007b52:	4628      	mov	r0, r5
 8007b54:	e7f4      	b.n	8007b40 <vCheckNetworkTimers+0xc0>
            vSetAllNetworksUp( xUp );
 8007b56:	f7ff ff8d 	bl	8007a74 <vSetAllNetworksUp>
}
 8007b5a:	e7e5      	b.n	8007b28 <vCheckNetworkTimers+0xa8>
 8007b5c:	200133e0 	.word	0x200133e0
 8007b60:	200133f4 	.word	0x200133f4
 8007b64:	200133b4 	.word	0x200133b4
 8007b68:	20013778 	.word	0x20013778
 8007b6c:	200133b0 	.word	0x200133b0
 8007b70:	200133cc 	.word	0x200133cc
 8007b74:	20013408 	.word	0x20013408
 8007b78:	200133b8 	.word	0x200133b8
 8007b7c:	20013774 	.word	0x20013774

08007b80 <prvSetChecksumInPacket>:
 * @param usChecksum Checksum value to be set.
 */
static void prvSetChecksumInPacket( const struct xPacketSummary * pxSet,
                                    uint16_t usChecksum )
{
    if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
 8007b80:	7d83      	ldrb	r3, [r0, #22]
 8007b82:	2b11      	cmp	r3, #17
 8007b84:	d00a      	beq.n	8007b9c <prvSetChecksumInPacket+0x1c>
    {
        pxSet->pxProtocolHeaders->xUDPHeader.usChecksum = usChecksum;
    }
    else if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
 8007b86:	2b06      	cmp	r3, #6
 8007b88:	d00b      	beq.n	8007ba2 <prvSetChecksumInPacket+0x22>
    {
        pxSet->pxProtocolHeaders->xTCPHeader.usChecksum = usChecksum;
    }
    else if( ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
 8007b8a:	1e5a      	subs	r2, r3, #1
 8007b8c:	b2d2      	uxtb	r2, r2
 8007b8e:	2a01      	cmp	r2, #1
 8007b90:	d90a      	bls.n	8007ba8 <prvSetChecksumInPacket+0x28>
             ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
    {
        pxSet->pxProtocolHeaders->xICMPHeader.usChecksum = usChecksum;
    }
    else if( ( pxSet->xIsIPv6 != pdFALSE ) && ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP_IPv6 ) )
 8007b92:	6802      	ldr	r2, [r0, #0]
 8007b94:	b10a      	cbz	r2, 8007b9a <prvSetChecksumInPacket+0x1a>
 8007b96:	2b3a      	cmp	r3, #58	@ 0x3a
 8007b98:	d009      	beq.n	8007bae <prvSetChecksumInPacket+0x2e>
    }
    else
    {
        /* Unhandled protocol. */
    }
}
 8007b9a:	4770      	bx	lr
        pxSet->pxProtocolHeaders->xUDPHeader.usChecksum = usChecksum;
 8007b9c:	69c3      	ldr	r3, [r0, #28]
 8007b9e:	80d9      	strh	r1, [r3, #6]
 8007ba0:	4770      	bx	lr
        pxSet->pxProtocolHeaders->xTCPHeader.usChecksum = usChecksum;
 8007ba2:	69c3      	ldr	r3, [r0, #28]
 8007ba4:	8219      	strh	r1, [r3, #16]
 8007ba6:	4770      	bx	lr
        pxSet->pxProtocolHeaders->xICMPHeader.usChecksum = usChecksum;
 8007ba8:	69c3      	ldr	r3, [r0, #28]
 8007baa:	8059      	strh	r1, [r3, #2]
 8007bac:	4770      	bx	lr
        pxSet->pxProtocolHeaders->xICMPHeaderIPv6.usChecksum = usChecksum;
 8007bae:	69c3      	ldr	r3, [r0, #28]
 8007bb0:	8059      	strh	r1, [r3, #2]
}
 8007bb2:	e7f2      	b.n	8007b9a <prvSetChecksumInPacket+0x1a>

08007bb4 <prvGetChecksumFromPacket>:
 */
static uint16_t prvGetChecksumFromPacket( const struct xPacketSummary * pxSet )
{
    uint16_t usChecksum;

    if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
 8007bb4:	7d83      	ldrb	r3, [r0, #22]
 8007bb6:	2b11      	cmp	r3, #17
 8007bb8:	d00c      	beq.n	8007bd4 <prvGetChecksumFromPacket+0x20>
    {
        usChecksum = pxSet->pxProtocolHeaders->xUDPHeader.usChecksum;
    }
    else if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
 8007bba:	2b06      	cmp	r3, #6
 8007bbc:	d00d      	beq.n	8007bda <prvGetChecksumFromPacket+0x26>
    {
        usChecksum = pxSet->pxProtocolHeaders->xTCPHeader.usChecksum;
    }
    else if( ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
 8007bbe:	1e5a      	subs	r2, r3, #1
 8007bc0:	b2d2      	uxtb	r2, r2
 8007bc2:	2a01      	cmp	r2, #1
 8007bc4:	d90c      	bls.n	8007be0 <prvGetChecksumFromPacket+0x2c>
             ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
    {
        usChecksum = pxSet->pxProtocolHeaders->xICMPHeader.usChecksum;
    }
    else if( ( pxSet->xIsIPv6 != pdFALSE ) && ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP_IPv6 ) )
 8007bc6:	6802      	ldr	r2, [r0, #0]
 8007bc8:	b182      	cbz	r2, 8007bec <prvGetChecksumFromPacket+0x38>
 8007bca:	2b3a      	cmp	r3, #58	@ 0x3a
 8007bcc:	d00b      	beq.n	8007be6 <prvGetChecksumFromPacket+0x32>
        usChecksum = pxSet->pxProtocolHeaders->xICMPHeaderIPv6.usChecksum;
    }
    else
    {
        /* Unhandled protocol. */
        usChecksum = ipUNHANDLED_PROTOCOL;
 8007bce:	f244 3021 	movw	r0, #17185	@ 0x4321
    }

    return usChecksum;
}
 8007bd2:	4770      	bx	lr
        usChecksum = pxSet->pxProtocolHeaders->xUDPHeader.usChecksum;
 8007bd4:	69c3      	ldr	r3, [r0, #28]
 8007bd6:	88d8      	ldrh	r0, [r3, #6]
 8007bd8:	4770      	bx	lr
        usChecksum = pxSet->pxProtocolHeaders->xTCPHeader.usChecksum;
 8007bda:	69c3      	ldr	r3, [r0, #28]
 8007bdc:	8a18      	ldrh	r0, [r3, #16]
 8007bde:	4770      	bx	lr
        usChecksum = pxSet->pxProtocolHeaders->xICMPHeader.usChecksum;
 8007be0:	69c3      	ldr	r3, [r0, #28]
 8007be2:	8858      	ldrh	r0, [r3, #2]
 8007be4:	4770      	bx	lr
        usChecksum = pxSet->pxProtocolHeaders->xICMPHeaderIPv6.usChecksum;
 8007be6:	69c3      	ldr	r3, [r0, #28]
 8007be8:	8858      	ldrh	r0, [r3, #2]
 8007bea:	4770      	bx	lr
        usChecksum = ipUNHANDLED_PROTOCOL;
 8007bec:	f244 3021 	movw	r0, #17185	@ 0x4321
 8007bf0:	4770      	bx	lr

08007bf2 <void_ptr_to_uintptr>:
     * Therefore, it is safe to use a union to convert it. */
    union uIntPtr intPtr;

    intPtr.pvPtr = pvPointer;
    return intPtr.uxPtr;
}
 8007bf2:	4770      	bx	lr

08007bf4 <prvPacketBuffer_to_NetworkBuffer>:
    if( pvBuffer == NULL )
 8007bf4:	b160      	cbz	r0, 8007c10 <prvPacketBuffer_to_NetworkBuffer+0x1c>
{
 8007bf6:	b510      	push	{r4, lr}
 8007bf8:	460c      	mov	r4, r1
        uxBuffer = void_ptr_to_uintptr( pvBuffer );
 8007bfa:	f7ff fffa 	bl	8007bf2 <void_ptr_to_uintptr>
        uxBuffer -= ( uxOffset + ipBUFFER_PADDING );
 8007bfe:	1b01      	subs	r1, r0, r4
 8007c00:	f1a1 030a 	sub.w	r3, r1, #10
        if( ( uxBuffer & ( ( ( uintptr_t ) sizeof( uxBuffer ) ) - 1U ) ) == ( uintptr_t ) 0U )
 8007c04:	f013 0f03 	tst.w	r3, #3
 8007c08:	d103      	bne.n	8007c12 <prvPacketBuffer_to_NetworkBuffer+0x1e>
            pxResult = *( ( NetworkBufferDescriptor_t ** ) uxBuffer );
 8007c0a:	f851 0c0a 	ldr.w	r0, [r1, #-10]
}
 8007c0e:	bd10      	pop	{r4, pc}
 8007c10:	4770      	bx	lr
            pxResult = NULL;
 8007c12:	2000      	movs	r0, #0
    return pxResult;
 8007c14:	e7fb      	b.n	8007c0e <prvPacketBuffer_to_NetworkBuffer+0x1a>

08007c16 <prvChecksumProtocolMTUCheck>:
     * ( headers and payload ). */

    /* The Ethernet header is excluded from the MTU. */
    uint32_t ulMaxLength = ipconfigNETWORK_MTU;

    ulMaxLength -= ( uint32_t ) pxSet->uxIPHeaderLength;
 8007c16:	68c3      	ldr	r3, [r0, #12]
 8007c18:	f5c3 63bb 	rsb	r3, r3, #1496	@ 0x5d8
 8007c1c:	3304      	adds	r3, #4

    if( ( pxSet->usProtocolBytes < ( uint16_t ) pxSet->uxProtocolHeaderLength ) ||
 8007c1e:	8c42      	ldrh	r2, [r0, #34]	@ 0x22
 8007c20:	8a01      	ldrh	r1, [r0, #16]
 8007c22:	428a      	cmp	r2, r1
 8007c24:	d303      	bcc.n	8007c2e <prvChecksumProtocolMTUCheck+0x18>
 8007c26:	429a      	cmp	r2, r3
 8007c28:	d801      	bhi.n	8007c2e <prvChecksumProtocolMTUCheck+0x18>
    BaseType_t xReturn = 0;
 8007c2a:	2000      	movs	r0, #0
        pxSet->usChecksum = ipINVALID_LENGTH;
        xReturn = 13;
    }

    return xReturn;
}
 8007c2c:	4770      	bx	lr
        pxSet->usChecksum = ipINVALID_LENGTH;
 8007c2e:	f241 2334 	movw	r3, #4660	@ 0x1234
 8007c32:	8283      	strh	r3, [r0, #20]
        xReturn = 13;
 8007c34:	200d      	movs	r0, #13
 8007c36:	4770      	bx	lr

08007c38 <prvChecksumProtocolSetChecksum>:
static void prvChecksumProtocolSetChecksum( BaseType_t xOutgoingPacket,
                                            const uint8_t * pucEthernetBuffer,
                                            size_t uxBufferLength,
                                            const struct xPacketSummary * pxSet )
{
    if( xOutgoingPacket != pdFALSE )
 8007c38:	b900      	cbnz	r0, 8007c3c <prvChecksumProtocolSetChecksum+0x4>
 8007c3a:	4770      	bx	lr
{
 8007c3c:	b508      	push	{r3, lr}
    {
        prvSetChecksumInPacket( pxSet, pxSet->usChecksum );
 8007c3e:	8a99      	ldrh	r1, [r3, #20]
 8007c40:	4618      	mov	r0, r3
 8007c42:	f7ff ff9d 	bl	8007b80 <prvSetChecksumInPacket>
    #endif /* ipconfigHAS_DEBUG_PRINTF != 0 */

    /* Mention parameters that are not used by the function. */
    ( void ) uxBufferLength;
    ( void ) pucEthernetBuffer;
}
 8007c46:	bd08      	pop	{r3, pc}

08007c48 <prvChecksumProtocolChecks>:
{
 8007c48:	b508      	push	{r3, lr}
    if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_UDP )
 8007c4a:	7d8b      	ldrb	r3, [r1, #22]
 8007c4c:	2b11      	cmp	r3, #17
 8007c4e:	d00e      	beq.n	8007c6e <prvChecksumProtocolChecks+0x26>
    else if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_TCP )
 8007c50:	2b06      	cmp	r3, #6
 8007c52:	d01e      	beq.n	8007c92 <prvChecksumProtocolChecks+0x4a>
    else if( ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) ||
 8007c54:	1e5a      	subs	r2, r3, #1
 8007c56:	b2d2      	uxtb	r2, r2
 8007c58:	2a01      	cmp	r2, #1
 8007c5a:	d938      	bls.n	8007cce <prvChecksumProtocolChecks+0x86>
    else if( ( pxSet->xIsIPv6 != pdFALSE ) && ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP_IPv6 ) )
 8007c5c:	680a      	ldr	r2, [r1, #0]
 8007c5e:	b10a      	cbz	r2, 8007c64 <prvChecksumProtocolChecks+0x1c>
 8007c60:	2b3a      	cmp	r3, #58	@ 0x3a
 8007c62:	d04c      	beq.n	8007cfe <prvChecksumProtocolChecks+0xb6>
        pxSet->usChecksum = ipUNHANDLED_PROTOCOL;
 8007c64:	f244 3321 	movw	r3, #17185	@ 0x4321
 8007c68:	828b      	strh	r3, [r1, #20]
        xReturn = 11;
 8007c6a:	200b      	movs	r0, #11
}
 8007c6c:	bd08      	pop	{r3, pc}
        if( ( pxSet->usProtocolBytes < ipSIZE_OF_UDP_HEADER ) ||
 8007c6e:	8c4b      	ldrh	r3, [r1, #34]	@ 0x22
 8007c70:	2b07      	cmp	r3, #7
 8007c72:	d909      	bls.n	8007c88 <prvChecksumProtocolChecks+0x40>
            ( uxBufferLength < ( ipSIZE_OF_ETH_HEADER + pxSet->uxIPHeaderLength + ipSIZE_OF_UDP_HEADER ) ) )
 8007c74:	68cb      	ldr	r3, [r1, #12]
 8007c76:	3316      	adds	r3, #22
        if( ( pxSet->usProtocolBytes < ipSIZE_OF_UDP_HEADER ) ||
 8007c78:	4283      	cmp	r3, r0
 8007c7a:	d805      	bhi.n	8007c88 <prvChecksumProtocolChecks+0x40>
            pxSet->uxProtocolHeaderLength = sizeof( pxSet->pxProtocolHeaders->xUDPHeader );
 8007c7c:	2308      	movs	r3, #8
 8007c7e:	610b      	str	r3, [r1, #16]
                pxSet->pcType = "UDP";
 8007c80:	4b20      	ldr	r3, [pc, #128]	@ (8007d04 <prvChecksumProtocolChecks+0xbc>)
 8007c82:	608b      	str	r3, [r1, #8]
    BaseType_t xReturn = 0;
 8007c84:	2000      	movs	r0, #0
 8007c86:	e7f1      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
            pxSet->usChecksum = ipINVALID_LENGTH;
 8007c88:	f241 2334 	movw	r3, #4660	@ 0x1234
 8007c8c:	828b      	strh	r3, [r1, #20]
            xReturn = 7;
 8007c8e:	2007      	movs	r0, #7
 8007c90:	e7ec      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
        if( ( pxSet->usProtocolBytes < ipSIZE_OF_TCP_HEADER ) ||
 8007c92:	8c4b      	ldrh	r3, [r1, #34]	@ 0x22
 8007c94:	2b13      	cmp	r3, #19
 8007c96:	d910      	bls.n	8007cba <prvChecksumProtocolChecks+0x72>
            ( uxBufferLength < ( ipSIZE_OF_ETH_HEADER + pxSet->uxIPHeaderLength + ipSIZE_OF_TCP_HEADER ) ) )
 8007c98:	68cb      	ldr	r3, [r1, #12]
 8007c9a:	3322      	adds	r3, #34	@ 0x22
        if( ( pxSet->usProtocolBytes < ipSIZE_OF_TCP_HEADER ) ||
 8007c9c:	4283      	cmp	r3, r0
 8007c9e:	d80c      	bhi.n	8007cba <prvChecksumProtocolChecks+0x72>
            uint8_t ucLength = pxSet->pxProtocolHeaders->xTCPHeader.ucTCPOffset >> 4U;
 8007ca0:	69cb      	ldr	r3, [r1, #28]
 8007ca2:	7b1a      	ldrb	r2, [r3, #12]
 8007ca4:	0913      	lsrs	r3, r2, #4
            if( ucLength < FREERTOS_MINIMUM_TCP_OFFSET )
 8007ca6:	2a4f      	cmp	r2, #79	@ 0x4f
 8007ca8:	d90c      	bls.n	8007cc4 <prvChecksumProtocolChecks+0x7c>
                uxOptionsLength = ( ( ( size_t ) ucLength - 5U ) << 2U );
 8007caa:	3b05      	subs	r3, #5
 8007cac:	009b      	lsls	r3, r3, #2
                pxSet->uxProtocolHeaderLength = ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 8007cae:	3314      	adds	r3, #20
 8007cb0:	610b      	str	r3, [r1, #16]
                    pxSet->pcType = "TCP";
 8007cb2:	4b15      	ldr	r3, [pc, #84]	@ (8007d08 <prvChecksumProtocolChecks+0xc0>)
 8007cb4:	608b      	str	r3, [r1, #8]
    BaseType_t xReturn = 0;
 8007cb6:	2000      	movs	r0, #0
 8007cb8:	e7d8      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
            pxSet->usChecksum = ipINVALID_LENGTH;
 8007cba:	f241 2334 	movw	r3, #4660	@ 0x1234
 8007cbe:	828b      	strh	r3, [r1, #20]
            xReturn = 8;
 8007cc0:	2008      	movs	r0, #8
 8007cc2:	e7d3      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
                pxSet->usChecksum = ipINVALID_LENGTH;
 8007cc4:	f241 2334 	movw	r3, #4660	@ 0x1234
 8007cc8:	828b      	strh	r3, [r1, #20]
                xReturn = 9;
 8007cca:	2009      	movs	r0, #9
 8007ccc:	e7ce      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
        if( ( pxSet->usProtocolBytes < ipSIZE_OF_ICMPv4_HEADER ) ||
 8007cce:	8c4a      	ldrh	r2, [r1, #34]	@ 0x22
 8007cd0:	2a07      	cmp	r2, #7
 8007cd2:	d90b      	bls.n	8007cec <prvChecksumProtocolChecks+0xa4>
            ( uxBufferLength < ( ipSIZE_OF_ETH_HEADER + pxSet->uxIPHeaderLength + ipSIZE_OF_ICMPv4_HEADER ) ) )
 8007cd4:	68ca      	ldr	r2, [r1, #12]
 8007cd6:	3216      	adds	r2, #22
        if( ( pxSet->usProtocolBytes < ipSIZE_OF_ICMPv4_HEADER ) ||
 8007cd8:	4282      	cmp	r2, r0
 8007cda:	d807      	bhi.n	8007cec <prvChecksumProtocolChecks+0xa4>
            pxSet->uxProtocolHeaderLength = sizeof( pxSet->pxProtocolHeaders->xICMPHeader );
 8007cdc:	2208      	movs	r2, #8
 8007cde:	610a      	str	r2, [r1, #16]
                if( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP )
 8007ce0:	2b01      	cmp	r3, #1
 8007ce2:	d008      	beq.n	8007cf6 <prvChecksumProtocolChecks+0xae>
                    pxSet->pcType = "IGMP";
 8007ce4:	4b09      	ldr	r3, [pc, #36]	@ (8007d0c <prvChecksumProtocolChecks+0xc4>)
 8007ce6:	608b      	str	r3, [r1, #8]
    BaseType_t xReturn = 0;
 8007ce8:	2000      	movs	r0, #0
 8007cea:	e7bf      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
            pxSet->usChecksum = ipINVALID_LENGTH;
 8007cec:	f241 2334 	movw	r3, #4660	@ 0x1234
 8007cf0:	828b      	strh	r3, [r1, #20]
            xReturn = 10;
 8007cf2:	200a      	movs	r0, #10
 8007cf4:	e7ba      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
                    pxSet->pcType = "ICMP";
 8007cf6:	4b06      	ldr	r3, [pc, #24]	@ (8007d10 <prvChecksumProtocolChecks+0xc8>)
 8007cf8:	608b      	str	r3, [r1, #8]
    BaseType_t xReturn = 0;
 8007cfa:	2000      	movs	r0, #0
 8007cfc:	e7b6      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
            xReturn = prvChecksumICMPv6Checks( uxBufferLength, pxSet );
 8007cfe:	f000 ff05 	bl	8008b0c <prvChecksumICMPv6Checks>
 8007d02:	e7b3      	b.n	8007c6c <prvChecksumProtocolChecks+0x24>
 8007d04:	080101c0 	.word	0x080101c0
 8007d08:	080101c4 	.word	0x080101c4
 8007d0c:	080101d0 	.word	0x080101d0
 8007d10:	080101c8 	.word	0x080101c8

08007d14 <pxDuplicateNetworkBufferWithDescriptor>:
{
 8007d14:	b570      	push	{r4, r5, r6, lr}
 8007d16:	4604      	mov	r4, r0
 8007d18:	460e      	mov	r6, r1
    pxNewBuffer = pxGetNetworkBufferWithDescriptor( uxNewLength, ( TickType_t ) 0 );
 8007d1a:	2100      	movs	r1, #0
 8007d1c:	4630      	mov	r0, r6
 8007d1e:	f006 fce5 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
    if( pxNewBuffer != NULL )
 8007d22:	4605      	mov	r5, r0
 8007d24:	b1c0      	cbz	r0, 8007d58 <pxDuplicateNetworkBufferWithDescriptor+0x44>
        configASSERT( pxNewBuffer->pucEthernetBuffer != NULL );
 8007d26:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 8007d28:	b1c0      	cbz	r0, 8007d5c <pxDuplicateNetworkBufferWithDescriptor+0x48>
        if( uxLengthToCopy > pxNetworkBuffer->xDataLength )
 8007d2a:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8007d2c:	42b2      	cmp	r2, r6
 8007d2e:	d300      	bcc.n	8007d32 <pxDuplicateNetworkBufferWithDescriptor+0x1e>
    size_t uxLengthToCopy = uxNewLength;
 8007d30:	4632      	mov	r2, r6
        pxNewBuffer->xDataLength = uxNewLength;
 8007d32:	62ae      	str	r6, [r5, #40]	@ 0x28
        pxNewBuffer->xIPAddress.ulIP_IPv4 = pxNetworkBuffer->xIPAddress.ulIP_IPv4;
 8007d34:	6963      	ldr	r3, [r4, #20]
 8007d36:	616b      	str	r3, [r5, #20]
        pxNewBuffer->usPort = pxNetworkBuffer->usPort;
 8007d38:	8ea3      	ldrh	r3, [r4, #52]	@ 0x34
 8007d3a:	86ab      	strh	r3, [r5, #52]	@ 0x34
        pxNewBuffer->usBoundPort = pxNetworkBuffer->usBoundPort;
 8007d3c:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8007d3e:	86eb      	strh	r3, [r5, #54]	@ 0x36
        pxNewBuffer->pxInterface = pxNetworkBuffer->pxInterface;
 8007d40:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8007d42:	62eb      	str	r3, [r5, #44]	@ 0x2c
        pxNewBuffer->pxEndPoint = pxNetworkBuffer->pxEndPoint;
 8007d44:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8007d46:	632b      	str	r3, [r5, #48]	@ 0x30
        ( void ) memcpy( pxNewBuffer->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, uxLengthToCopy );
 8007d48:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8007d4a:	f007 f88c 	bl	800ee66 <memcpy>
            if( uxIPHeaderSizePacket( pxNewBuffer ) == ipSIZE_OF_IPv6_HEADER )
 8007d4e:	4628      	mov	r0, r5
 8007d50:	f7ff fbc2 	bl	80074d8 <uxIPHeaderSizePacket>
 8007d54:	2828      	cmp	r0, #40	@ 0x28
 8007d56:	d00a      	beq.n	8007d6e <pxDuplicateNetworkBufferWithDescriptor+0x5a>
}
 8007d58:	4628      	mov	r0, r5
 8007d5a:	bd70      	pop	{r4, r5, r6, pc}
 8007d5c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007d60:	f383 8811 	msr	BASEPRI, r3
 8007d64:	f3bf 8f6f 	isb	sy
 8007d68:	f3bf 8f4f 	dsb	sy
        configASSERT( pxNewBuffer->pucEthernetBuffer != NULL );
 8007d6c:	e7fe      	b.n	8007d6c <pxDuplicateNetworkBufferWithDescriptor+0x58>
                ( void ) memcpy( pxNewBuffer->xIPAddress.xIP_IPv6.ucBytes, pxNetworkBuffer->xIPAddress.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8007d6e:	6960      	ldr	r0, [r4, #20]
 8007d70:	69a1      	ldr	r1, [r4, #24]
 8007d72:	69e2      	ldr	r2, [r4, #28]
 8007d74:	6a23      	ldr	r3, [r4, #32]
 8007d76:	6168      	str	r0, [r5, #20]
 8007d78:	61a9      	str	r1, [r5, #24]
 8007d7a:	61ea      	str	r2, [r5, #28]
 8007d7c:	622b      	str	r3, [r5, #32]
    return pxNewBuffer;
 8007d7e:	e7eb      	b.n	8007d58 <pxDuplicateNetworkBufferWithDescriptor+0x44>

08007d80 <pxUDPPayloadBuffer_to_NetworkBuffer>:
 * @param[in] pvBuffer Pointer to the UDP payload buffer.
 *
 * @return The network buffer if the alignment is correct. Else a NULL is returned.
 */
NetworkBufferDescriptor_t * pxUDPPayloadBuffer_to_NetworkBuffer( const void * pvBuffer )
{
 8007d80:	b510      	push	{r4, lr}
    NetworkBufferDescriptor_t * pxResult;

    if( pvBuffer == NULL )
 8007d82:	4604      	mov	r4, r0
 8007d84:	b1d0      	cbz	r0, 8007dbc <pxUDPPayloadBuffer_to_NetworkBuffer+0x3c>
        const uint8_t * pucIPType;
        uint8_t ucIPType;

        /* When IPv6 is supported, find out the type of the packet.
         * It is stored 48 bytes before the payload buffer as 0x40 or 0x60. */
        uxTypeOffset = void_ptr_to_uintptr( pvBuffer );
 8007d86:	f7ff ff34 	bl	8007bf2 <void_ptr_to_uintptr>
        /* coverity[misra_c_2012_rule_11_4_violation] */
        pucIPType = ( const uint8_t * ) uxTypeOffset;

        /* For an IPv4 packet, pucIPType points to 6 bytes before the pucEthernetBuffer,
         * for a IPv6 packet, pucIPType will point to the first byte of the IP-header: 'ucVersionTrafficClass'. */
        ucIPType = pucIPType[ 0 ] & 0xf0U;
 8007d8a:	f810 3c30 	ldrb.w	r3, [r0, #-48]
 8007d8e:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0

        /* To help the translation from a UDP payload pointer to a networkBuffer,
         * a byte was stored at a certain negative offset (-48 bytes).
         * It must have a value of either 0x4x or 0x6x. */
        configASSERT( ( ucIPType == ipTYPE_IPv4 ) || ( ucIPType == ipTYPE_IPv6 ) );
 8007d92:	2b40      	cmp	r3, #64	@ 0x40
 8007d94:	d00a      	beq.n	8007dac <pxUDPPayloadBuffer_to_NetworkBuffer+0x2c>
 8007d96:	2b60      	cmp	r3, #96	@ 0x60
 8007d98:	d008      	beq.n	8007dac <pxUDPPayloadBuffer_to_NetworkBuffer+0x2c>
 8007d9a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007d9e:	f383 8811 	msr	BASEPRI, r3
 8007da2:	f3bf 8f6f 	isb	sy
 8007da6:	f3bf 8f4f 	dsb	sy
 8007daa:	e7fe      	b.n	8007daa <pxUDPPayloadBuffer_to_NetworkBuffer+0x2a>

        switch( ucIPType ) /* LCOV_EXCL_BR_LINE */
 8007dac:	2b40      	cmp	r3, #64	@ 0x40
 8007dae:	d006      	beq.n	8007dbe <pxUDPPayloadBuffer_to_NetworkBuffer+0x3e>
 8007db0:	2b60      	cmp	r3, #96	@ 0x60
 8007db2:	d106      	bne.n	8007dc2 <pxUDPPayloadBuffer_to_NetworkBuffer+0x42>
 8007db4:	213e      	movs	r1, #62	@ 0x3e
                FreeRTOS_debug_printf( ( "pxUDPPayloadBuffer_to_NetworkBuffer: Undefined ucIPType \n" ) );
                uxOffset = sizeof( UDPPacket_t );
                break;
        }

        pxResult = prvPacketBuffer_to_NetworkBuffer( pvBuffer, uxOffset );
 8007db6:	4620      	mov	r0, r4
 8007db8:	f7ff ff1c 	bl	8007bf4 <prvPacketBuffer_to_NetworkBuffer>
    }

    return pxResult;
}
 8007dbc:	bd10      	pop	{r4, pc}
                    uxOffset = sizeof( UDPPacket_t );
 8007dbe:	212a      	movs	r1, #42	@ 0x2a
 8007dc0:	e7f9      	b.n	8007db6 <pxUDPPayloadBuffer_to_NetworkBuffer+0x36>
                uxOffset = sizeof( UDPPacket_t );
 8007dc2:	212a      	movs	r1, #42	@ 0x2a
 8007dc4:	e7f7      	b.n	8007db6 <pxUDPPayloadBuffer_to_NetworkBuffer+0x36>

08007dc6 <xIsCallingFromIPTask>:
 *
 * @note Very important: the IP-task is not allowed to call its own API's,
 *        because it would easily get into a dead-lock.
 */
BaseType_t xIsCallingFromIPTask( void )
{
 8007dc6:	b510      	push	{r4, lr}
    BaseType_t xReturn;
    const struct tskTaskControlBlock * const xCurrentHandle = xTaskGetCurrentTaskHandle();
 8007dc8:	f7fd fa0c 	bl	80051e4 <xTaskGetCurrentTaskHandle>
 8007dcc:	4604      	mov	r4, r0
    const struct tskTaskControlBlock * const xCurrentIPTaskHandle = FreeRTOS_GetIPTaskHandle();
 8007dce:	f7ff f9ff 	bl	80071d0 <FreeRTOS_GetIPTaskHandle>

    if( xCurrentHandle == xCurrentIPTaskHandle )
 8007dd2:	4284      	cmp	r4, r0
 8007dd4:	d001      	beq.n	8007dda <xIsCallingFromIPTask+0x14>
    {
        xReturn = pdTRUE;
    }
    else
    {
        xReturn = pdFALSE;
 8007dd6:	2000      	movs	r0, #0
    }

    return xReturn;
}
 8007dd8:	bd10      	pop	{r4, pc}
        xReturn = pdTRUE;
 8007dda:	2001      	movs	r0, #1
 8007ddc:	e7fc      	b.n	8007dd8 <xIsCallingFromIPTask+0x12>

08007dde <prvProcessNetworkDownEvent>:
/* MISRA Ref 8.9.1 [File scoped variables] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-89 */
/* coverity[misra_c_2012_rule_8_9_violation] */
/* coverity[single_use] */
void prvProcessNetworkDownEvent( struct xNetworkInterface * pxInterface )
{
 8007dde:	b538      	push	{r3, r4, r5, lr}
    NetworkEndPoint_t * pxEndPoint;

    configASSERT( pxInterface != NULL );
 8007de0:	b150      	cbz	r0, 8007df8 <prvProcessNetworkDownEvent+0x1a>
 8007de2:	4605      	mov	r5, r0
    configASSERT( pxInterface->pfInitialise != NULL );
 8007de4:	6883      	ldr	r3, [r0, #8]
 8007de6:	b183      	cbz	r3, 8007e0a <prvProcessNetworkDownEvent+0x2c>
    /* Stop the ARP timer while there is no network. */
    vIPSetARPTimerEnableState( pdFALSE );
 8007de8:	2000      	movs	r0, #0
 8007dea:	f7ff fe13 	bl	8007a14 <vIPSetARPTimerEnableState>

    /* The first network down event is generated by the IP stack itself to
     * initialise the network hardware, so do not call the network down event
     * the first time through. */

    for( pxEndPoint = FreeRTOS_FirstEndPoint( pxInterface );
 8007dee:	4628      	mov	r0, r5
 8007df0:	f001 fe1a 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8007df4:	4604      	mov	r4, r0
 8007df6:	e026      	b.n	8007e46 <prvProcessNetworkDownEvent+0x68>
 8007df8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007dfc:	f383 8811 	msr	BASEPRI, r3
 8007e00:	f3bf 8f6f 	isb	sy
 8007e04:	f3bf 8f4f 	dsb	sy
    configASSERT( pxInterface != NULL );
 8007e08:	e7fe      	b.n	8007e08 <prvProcessNetworkDownEvent+0x2a>
 8007e0a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007e0e:	f383 8811 	msr	BASEPRI, r3
 8007e12:	f3bf 8f6f 	isb	sy
 8007e16:	f3bf 8f4f 	dsb	sy
    configASSERT( pxInterface->pfInitialise != NULL );
 8007e1a:	e7fe      	b.n	8007e1a <prvProcessNetworkDownEvent+0x3c>

        if( pxEndPoint->bits.bIPv6 == pdTRUE_UNSIGNED )
        {
            /* IPv6 end-points have a solicited-node address that needs extra housekeeping. */
            #if ( ipconfigIS_ENABLED( ipconfigUSE_IPv6 ) )
                vManageSolicitedNodeAddress( pxEndPoint, pdFALSE );
 8007e1c:	2100      	movs	r1, #0
 8007e1e:	4620      	mov	r0, r4
 8007e20:	f000 ff01 	bl	8008c26 <vManageSolicitedNodeAddress>
 8007e24:	e01a      	b.n	8007e5c <prvProcessNetworkDownEvent+0x7e>
                {
                    vApplicationIPNetworkEventHook( eNetworkDown );
                }
                #else
                {
                    vApplicationIPNetworkEventHook_Multi( eNetworkDown, pxEndPoint );
 8007e26:	4621      	mov	r1, r4
 8007e28:	2001      	movs	r0, #1
 8007e2a:	f7f9 fb57 	bl	80014dc <vApplicationIPNetworkEventHook_Multi>
 8007e2e:	e020      	b.n	8007e72 <prvProcessNetworkDownEvent+0x94>
                }
            }
        #endif /* ( ipconfigUSE_DHCP == 1 ) */

        #if ( ( ipconfigUSE_RA != 0 ) && ( ipconfigUSE_IPv6 != 0 ) )
            if( END_POINT_USES_RA( pxEndPoint ) )
 8007e30:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007e34:	f003 030c 	and.w	r3, r3, #12
 8007e38:	2b0c      	cmp	r3, #12
 8007e3a:	d026      	beq.n	8007e8a <prvProcessNetworkDownEvent+0xac>
         pxEndPoint = FreeRTOS_NextEndPoint( pxInterface, pxEndPoint ) )
 8007e3c:	4621      	mov	r1, r4
 8007e3e:	4628      	mov	r0, r5
 8007e40:	f001 fe02 	bl	8009a48 <FreeRTOS_NextEndPoint>
 8007e44:	4604      	mov	r4, r0
         pxEndPoint != NULL;
 8007e46:	b32c      	cbz	r4, 8007e94 <prvProcessNetworkDownEvent+0xb6>
        pxEndPoint->bits.bEndPointUp = pdFALSE_UNSIGNED;
 8007e48:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007e4c:	f023 0320 	bic.w	r3, r3, #32
 8007e50:	f884 30f0 	strb.w	r3, [r4, #240]	@ 0xf0
        if( pxEndPoint->bits.bIPv6 == pdTRUE_UNSIGNED )
 8007e54:	b2db      	uxtb	r3, r3
 8007e56:	f013 0f08 	tst.w	r3, #8
 8007e5a:	d1df      	bne.n	8007e1c <prvProcessNetworkDownEvent+0x3e>
            if( pxEndPoint->bits.bCallDownHook != pdFALSE_UNSIGNED )
 8007e5c:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007e60:	f013 0f10 	tst.w	r3, #16
 8007e64:	d1df      	bne.n	8007e26 <prvProcessNetworkDownEvent+0x48>
                pxEndPoint->bits.bCallDownHook = pdTRUE_UNSIGNED;
 8007e66:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007e6a:	f043 0310 	orr.w	r3, r3, #16
 8007e6e:	f884 30f0 	strb.w	r3, [r4, #240]	@ 0xf0
        FreeRTOS_ClearARP( pxEndPoint );
 8007e72:	4620      	mov	r0, r4
 8007e74:	f7fe fbc6 	bl	8006604 <FreeRTOS_ClearARP>
            if( END_POINT_USES_DHCP( pxEndPoint ) )
 8007e78:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007e7c:	f013 0f02 	tst.w	r3, #2
 8007e80:	d0d6      	beq.n	8007e30 <prvProcessNetworkDownEvent+0x52>
                    vDHCPStop( pxEndPoint );
 8007e82:	4620      	mov	r0, r4
 8007e84:	f7ff f8fa 	bl	800707c <vDHCPStop>
 8007e88:	e7d2      	b.n	8007e30 <prvProcessNetworkDownEvent+0x52>
            {
                /* Stop the RA/SLAAC process for this end-point. */
                vIPSetDHCP_RATimerEnableState( pxEndPoint, pdFALSE );
 8007e8a:	2100      	movs	r1, #0
 8007e8c:	4620      	mov	r0, r4
 8007e8e:	f7ff fde1 	bl	8007a54 <vIPSetDHCP_RATimerEnableState>
 8007e92:	e7d3      	b.n	8007e3c <prvProcessNetworkDownEvent+0x5e>

    /* The network has been disconnected (or is being initialised for the first
     * time).  Perform whatever hardware processing is necessary to bring it up
     * again, or wait for it to be available again.  This is hardware dependent. */

    if( pxInterface->pfInitialise( pxInterface ) == pdPASS )
 8007e94:	68ab      	ldr	r3, [r5, #8]
 8007e96:	4628      	mov	r0, r5
 8007e98:	4798      	blx	r3
 8007e9a:	2801      	cmp	r0, #1
 8007e9c:	d003      	beq.n	8007ea6 <prvProcessNetworkDownEvent+0xc8>
        }
    }
    else
    {
        /* At least one interface is down. */
        vSetAllNetworksUp( pdFALSE );
 8007e9e:	2000      	movs	r0, #0
 8007ea0:	f7ff fde8 	bl	8007a74 <vSetAllNetworksUp>

        /* Nothing else to do. When the 'xNetworkTimer' expires, all interfaces
         * with bits.bInterfaceUp cleared will get a new 'eNetworkDownEvent' */
    }
}
 8007ea4:	bd38      	pop	{r3, r4, r5, pc}
        pxInterface->bits.bInterfaceUp = pdTRUE_UNSIGNED;
 8007ea6:	7f2b      	ldrb	r3, [r5, #28]
 8007ea8:	f043 0301 	orr.w	r3, r3, #1
 8007eac:	772b      	strb	r3, [r5, #28]
        for( pxEndPoint = FreeRTOS_FirstEndPoint( pxInterface );
 8007eae:	4628      	mov	r0, r5
 8007eb0:	f001 fdba 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8007eb4:	4604      	mov	r4, r0
 8007eb6:	e01f      	b.n	8007ef8 <prvProcessNetworkDownEvent+0x11a>
                        vDHCPProcess( pdTRUE, pxEndPoint );
 8007eb8:	4621      	mov	r1, r4
 8007eba:	2001      	movs	r0, #1
 8007ebc:	f7ff f856 	bl	8006f6c <vDHCPProcess>
 8007ec0:	e015      	b.n	8007eee <prvProcessNetworkDownEvent+0x110>
                    vRAProcess( pdTRUE, pxEndPoint );
 8007ec2:	4621      	mov	r1, r4
 8007ec4:	2001      	movs	r0, #1
 8007ec6:	f001 fc74 	bl	80097b2 <vRAProcess>
 8007eca:	e010      	b.n	8007eee <prvProcessNetworkDownEvent+0x110>
                            ( void ) memcpy( &( pxEndPoint->ipv4_settings ), &( pxEndPoint->ipv4_defaults ), sizeof( pxEndPoint->ipv4_settings ) );
 8007ecc:	69e1      	ldr	r1, [r4, #28]
 8007ece:	6a22      	ldr	r2, [r4, #32]
 8007ed0:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8007ed2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8007ed4:	6021      	str	r1, [r4, #0]
 8007ed6:	6062      	str	r2, [r4, #4]
 8007ed8:	60a3      	str	r3, [r4, #8]
 8007eda:	60e0      	str	r0, [r4, #12]
 8007edc:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8007ede:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8007ee0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8007ee2:	6121      	str	r1, [r4, #16]
 8007ee4:	6162      	str	r2, [r4, #20]
 8007ee6:	61a3      	str	r3, [r4, #24]
                vIPNetworkUpCalls( pxEndPoint );
 8007ee8:	4620      	mov	r0, r4
 8007eea:	f7ff f977 	bl	80071dc <vIPNetworkUpCalls>
             pxEndPoint = FreeRTOS_NextEndPoint( pxInterface, pxEndPoint ) )
 8007eee:	4621      	mov	r1, r4
 8007ef0:	4628      	mov	r0, r5
 8007ef2:	f001 fda9 	bl	8009a48 <FreeRTOS_NextEndPoint>
 8007ef6:	4604      	mov	r4, r0
             pxEndPoint != NULL;
 8007ef8:	2c00      	cmp	r4, #0
 8007efa:	d0d3      	beq.n	8007ea4 <prvProcessNetworkDownEvent+0xc6>
                if( END_POINT_USES_DHCP( pxEndPoint ) )
 8007efc:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007f00:	f013 0f02 	tst.w	r3, #2
 8007f04:	d1d8      	bne.n	8007eb8 <prvProcessNetworkDownEvent+0xda>
                if( END_POINT_USES_RA( pxEndPoint ) )
 8007f06:	f003 030c 	and.w	r3, r3, #12
 8007f0a:	2b0c      	cmp	r3, #12
 8007f0c:	d0d9      	beq.n	8007ec2 <prvProcessNetworkDownEvent+0xe4>
                switch( pxEndPoint->bits.bIPv6 ) /* LCOV_EXCL_BR_LINE */
 8007f0e:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8007f12:	f3c3 02c0 	ubfx	r2, r3, #3, #1
 8007f16:	f013 0f08 	tst.w	r3, #8
 8007f1a:	d0d7      	beq.n	8007ecc <prvProcessNetworkDownEvent+0xee>
 8007f1c:	2a00      	cmp	r2, #0
 8007f1e:	d0e3      	beq.n	8007ee8 <prvProcessNetworkDownEvent+0x10a>
                            ( void ) memcpy( &( pxEndPoint->ipv6_settings ), &( pxEndPoint->ipv6_defaults ), sizeof( pxEndPoint->ipv6_settings ) );
 8007f20:	2258      	movs	r2, #88	@ 0x58
 8007f22:	f104 0190 	add.w	r1, r4, #144	@ 0x90
 8007f26:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 8007f2a:	f006 ff9c 	bl	800ee66 <memcpy>
                            break;
 8007f2e:	e7db      	b.n	8007ee8 <prvProcessNetworkDownEvent+0x10a>

08007f30 <vPreCheckConfigs>:
/**
 * @brief Check the values of configuration options and assert on it. Also verify that the IP-task
 *        has not already been initialized.
 */
void vPreCheckConfigs( void )
{
 8007f30:	b508      	push	{r3, lr}
    /* This function should only be called once. */
    configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 8007f32:	f7ff f9d1 	bl	80072d8 <xIPIsNetworkTaskReady>
 8007f36:	b140      	cbz	r0, 8007f4a <vPreCheckConfigs+0x1a>
 8007f38:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f3c:	f383 8811 	msr	BASEPRI, r3
 8007f40:	f3bf 8f6f 	isb	sy
 8007f44:	f3bf 8f4f 	dsb	sy
 8007f48:	e7fe      	b.n	8007f48 <vPreCheckConfigs+0x18>
    configASSERT( xNetworkEventQueue == NULL );
 8007f4a:	4b0c      	ldr	r3, [pc, #48]	@ (8007f7c <vPreCheckConfigs+0x4c>)
 8007f4c:	681b      	ldr	r3, [r3, #0]
 8007f4e:	b143      	cbz	r3, 8007f62 <vPreCheckConfigs+0x32>
 8007f50:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f54:	f383 8811 	msr	BASEPRI, r3
 8007f58:	f3bf 8f6f 	isb	sy
 8007f5c:	f3bf 8f4f 	dsb	sy
 8007f60:	e7fe      	b.n	8007f60 <vPreCheckConfigs+0x30>
    configASSERT( FreeRTOS_GetIPTaskHandle() == NULL );
 8007f62:	f7ff f935 	bl	80071d0 <FreeRTOS_GetIPTaskHandle>
 8007f66:	b140      	cbz	r0, 8007f7a <vPreCheckConfigs+0x4a>
 8007f68:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8007f6c:	f383 8811 	msr	BASEPRI, r3
 8007f70:	f3bf 8f6f 	isb	sy
 8007f74:	f3bf 8f4f 	dsb	sy
 8007f78:	e7fe      	b.n	8007f78 <vPreCheckConfigs+0x48>
         * It's value MUST be > 0. Otherwise, storing the IPv4 version byte
         * will overwrite the Ethernet header. */
        configASSERT( ipIP_TYPE_OFFSET > 0 );
    }
    #endif /* if ( configASSERT_DEFINED == 1 ) */
}
 8007f7a:	bd08      	pop	{r3, pc}
 8007f7c:	200133b0 	.word	0x200133b0

08007f80 <usGenerateChecksum>:
 *         words in the header
 */
uint16_t usGenerateChecksum( uint16_t usSum,
                             const uint8_t * pucNextData,
                             size_t uxByteCount )
{
 8007f80:	b570      	push	{r4, r5, r6, lr}
 8007f82:	460c      	mov	r4, r1
    /* Small MCUs often spend up to 30% of the time doing checksum calculations
    * This function is optimised for 32-bit CPUs; Each time it will try to fetch
    * 32-bits, sums it with an accumulator and counts the number of carries. */

    /* Swap the input (little endian platform only). */
    usTemp = FreeRTOS_ntohs( usSum );
 8007f84:	0203      	lsls	r3, r0, #8
 8007f86:	ea43 2010 	orr.w	r0, r3, r0, lsr #8
 8007f8a:	b280      	uxth	r0, r0
    xSum.u32 = ( uint32_t ) usTemp;
 8007f8c:	4601      	mov	r1, r0
    xTerm.u32 = 0U;
 8007f8e:	2500      	movs	r5, #0

    xSource.u8ptr = pucNextData;
 8007f90:	4623      	mov	r3, r4

    /* MISRA Ref 11.4.3 [Casting pointer to int for verification] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-114 */
    /* coverity[misra_c_2012_rule_11_4_violation] */
    uxAlignBits = ( ( ( uintptr_t ) pucNextData ) & 0x03U );
 8007f92:	f004 0c03 	and.w	ip, r4, #3
    /*
     * If pucNextData is non-aligned then the checksum is starting at an
     * odd position and we need to make sure the usSum value now in xSum is
     * as if it had been "aligned" in the same way.
     */
    if( ( uxAlignBits & 1U ) != 0U )
 8007f96:	f014 0601 	ands.w	r6, r4, #1
 8007f9a:	d009      	beq.n	8007fb0 <usGenerateChecksum+0x30>
    {
        xSum.u32 = ( ( xSum.u32 & 0xffU ) << 8 ) | ( ( xSum.u32 & 0xff00U ) >> 8 );
 8007f9c:	0201      	lsls	r1, r0, #8
 8007f9e:	b289      	uxth	r1, r1
 8007fa0:	ea41 2110 	orr.w	r1, r1, r0, lsr #8
    }

    /* If byte (8-bit) aligned... */
    if( ( ( uxAlignBits & 1U ) != 0U ) && ( uxDataLengthBytes >= ( size_t ) 1U ) )
 8007fa4:	b122      	cbz	r2, 8007fb0 <usGenerateChecksum+0x30>
    {
        xTerm.u8[ 1 ] = *( xSource.u8ptr );
 8007fa6:	f813 0b01 	ldrb.w	r0, [r3], #1
 8007faa:	f360 250f 	bfi	r5, r0, #8, #8
        xSource.u8ptr++;
        uxDataLengthBytes--;
 8007fae:	3a01      	subs	r2, #1
        /* Now xSource is word (16-bit) aligned. */
    }

    /* If half-word (16-bit) aligned... */
    if( ( ( uxAlignBits == 1U ) || ( uxAlignBits == 2U ) ) && ( uxDataLengthBytes >= 2U ) )
 8007fb0:	f10c 30ff 	add.w	r0, ip, #4294967295
 8007fb4:	2801      	cmp	r0, #1
 8007fb6:	d907      	bls.n	8007fc8 <usGenerateChecksum+0x48>
        /* Now xSource is word (32-bit) aligned. */
    }

    /* Word (32-bit) aligned, do the most part. */

    uxSize = ( size_t ) ( ( uxDataLengthBytes / 4U ) * 4U );
 8007fb8:	f022 0403 	bic.w	r4, r2, #3

    if( uxSize >= ( 3U * sizeof( uint32_t ) ) )
 8007fbc:	2c0b      	cmp	r4, #11
 8007fbe:	d90c      	bls.n	8007fda <usGenerateChecksum+0x5a>
    {
        uxSize -= ( 3U * sizeof( uint32_t ) );
 8007fc0:	3c0c      	subs	r4, #12
    }

    /* In this loop, four 32-bit additions will be done, in total 16 bytes.
     * Indexing with constants (0,1,2,3) gives faster code than using
     * post-increments. */
    for( ulX = 0U; ulX < uxSize; ulX += 4U * sizeof( uint32_t ) )
 8007fc2:	2000      	movs	r0, #0
    uint32_t ulCarry = 0U;
 8007fc4:	4686      	mov	lr, r0
    for( ulX = 0U; ulX < uxSize; ulX += 4U * sizeof( uint32_t ) )
 8007fc6:	e00d      	b.n	8007fe4 <usGenerateChecksum+0x64>
    if( ( ( uxAlignBits == 1U ) || ( uxAlignBits == 2U ) ) && ( uxDataLengthBytes >= 2U ) )
 8007fc8:	2a01      	cmp	r2, #1
 8007fca:	d904      	bls.n	8007fd6 <usGenerateChecksum+0x56>
        xSum.u32 += *( xSource.u16ptr );
 8007fcc:	f833 0b02 	ldrh.w	r0, [r3], #2
 8007fd0:	4401      	add	r1, r0
        uxDataLengthBytes -= 2U;
 8007fd2:	3a02      	subs	r2, #2
 8007fd4:	e7f0      	b.n	8007fb8 <usGenerateChecksum+0x38>
        uxSize = 0U;
 8007fd6:	2400      	movs	r4, #0
 8007fd8:	e7f3      	b.n	8007fc2 <usGenerateChecksum+0x42>
 8007fda:	2400      	movs	r4, #0
 8007fdc:	e7f1      	b.n	8007fc2 <usGenerateChecksum+0x42>
        {
            ulCarry++;
        }

        /* And finally advance the pointer 4 * 4 = 16 bytes. */
        xSource.u32ptr = &( xSource.u32ptr[ 4 ] );
 8007fde:	f10c 0310 	add.w	r3, ip, #16
    for( ulX = 0U; ulX < uxSize; ulX += 4U * sizeof( uint32_t ) )
 8007fe2:	3010      	adds	r0, #16
 8007fe4:	4284      	cmp	r4, r0
 8007fe6:	d918      	bls.n	800801a <usGenerateChecksum+0x9a>
        xSum2.u32 = xSum.u32 + xSource.u32ptr[ 0 ];
 8007fe8:	469c      	mov	ip, r3
 8007fea:	681b      	ldr	r3, [r3, #0]
        if( xSum2.u32 < xSum.u32 )
 8007fec:	18cb      	adds	r3, r1, r3
 8007fee:	d301      	bcc.n	8007ff4 <usGenerateChecksum+0x74>
            ulCarry++;
 8007ff0:	f10e 0e01 	add.w	lr, lr, #1
        xSum.u32 = xSum2.u32 + xSource.u32ptr[ 1 ];
 8007ff4:	f8dc 1004 	ldr.w	r1, [ip, #4]
        if( xSum2.u32 > xSum.u32 )
 8007ff8:	185b      	adds	r3, r3, r1
 8007ffa:	d301      	bcc.n	8008000 <usGenerateChecksum+0x80>
            ulCarry++;
 8007ffc:	f10e 0e01 	add.w	lr, lr, #1
        xSum2.u32 = xSum.u32 + xSource.u32ptr[ 2 ];
 8008000:	f8dc 1008 	ldr.w	r1, [ip, #8]
        if( xSum2.u32 < xSum.u32 )
 8008004:	185b      	adds	r3, r3, r1
 8008006:	d301      	bcc.n	800800c <usGenerateChecksum+0x8c>
            ulCarry++;
 8008008:	f10e 0e01 	add.w	lr, lr, #1
        xSum.u32 = xSum2.u32 + xSource.u32ptr[ 3 ];
 800800c:	f8dc 100c 	ldr.w	r1, [ip, #12]
        if( xSum2.u32 > xSum.u32 )
 8008010:	1859      	adds	r1, r3, r1
 8008012:	d3e4      	bcc.n	8007fde <usGenerateChecksum+0x5e>
            ulCarry++;
 8008014:	f10e 0e01 	add.w	lr, lr, #1
 8008018:	e7e1      	b.n	8007fde <usGenerateChecksum+0x5e>
    }

    /* Now add all carries. */
    xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ] + ulCarry;
 800801a:	0c08      	lsrs	r0, r1, #16
 800801c:	fa10 f181 	uxtah	r1, r0, r1
 8008020:	4471      	add	r1, lr

    uxDataLengthBytes %= 16U;

    /* Half-word aligned. */
    uxSize = ( ( uxDataLengthBytes & ~( ( size_t ) 1U ) ) );
 8008022:	f002 0c0e 	and.w	ip, r2, #14

    for( ulX = 0U; ulX < uxSize; ulX += 1U * sizeof( uint16_t ) )
 8008026:	2000      	movs	r0, #0
 8008028:	e003      	b.n	8008032 <usGenerateChecksum+0xb2>
    {
        /* At least one more short. */
        xSum.u32 += xSource.u16ptr[ 0 ];
 800802a:	f833 4b02 	ldrh.w	r4, [r3], #2
 800802e:	4421      	add	r1, r4
    for( ulX = 0U; ulX < uxSize; ulX += 1U * sizeof( uint16_t ) )
 8008030:	3002      	adds	r0, #2
 8008032:	4560      	cmp	r0, ip
 8008034:	d3f9      	bcc.n	800802a <usGenerateChecksum+0xaa>
        xSource.u16ptr = &xSource.u16ptr[ 1 ];
    }

    if( ( uxDataLengthBytes & ( size_t ) 1U ) != 0U ) /* Maybe one more ? */
 8008036:	f012 0f01 	tst.w	r2, #1
 800803a:	d002      	beq.n	8008042 <usGenerateChecksum+0xc2>
    {
        xTerm.u8[ 0 ] = xSource.u8ptr[ 0 ];
 800803c:	781b      	ldrb	r3, [r3, #0]
 800803e:	f363 0507 	bfi	r5, r3, #0, #8

    /* MISRA Ref 2.2.1 [Unions and dead code] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-22 */
    /* coverity[misra_c_2012_rule_2_2_violation] */
    /* coverity[assigned_value] */
    xSum.u32 += xTerm.u32;
 8008042:	440d      	add	r5, r1
    /* Assigning value from "xTerm.u32" to "xSum.u32" here, but that stored value is overwritten before it can be used. */
    /* MISRA Ref 2.2.1 [Unions and dead code] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-22 */
    /* coverity[misra_c_2012_rule_2_2_violation] */
    /* coverity[value_overwrite] */
    xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ];
 8008044:	0c2b      	lsrs	r3, r5, #16
 8008046:	fa13 f585 	uxtah	r5, r3, r5

    /* MISRA Ref 2.2.1 [Unions and dead code] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-22 */
    /* coverity[misra_c_2012_rule_2_2_violation] */
    /* coverity[value_overwrite] */
    xSum.u32 = ( uint32_t ) xSum.u16[ 0 ] + xSum.u16[ 1 ];
 800804a:	0c29      	lsrs	r1, r5, #16
 800804c:	fa11 f185 	uxtah	r1, r1, r5

    if( ( uxAlignBits & 1U ) != 0U )
 8008050:	b126      	cbz	r6, 800805c <usGenerateChecksum+0xdc>
    {
        /* Quite unlikely, but pucNextData might be non-aligned, which would
        * mean that a checksum is calculated starting at an odd position. */
        xSum.u32 = ( ( xSum.u32 & 0xffU ) << 8 ) | ( ( xSum.u32 & 0xff00U ) >> 8 );
 8008052:	020b      	lsls	r3, r1, #8
 8008054:	b29b      	uxth	r3, r3
 8008056:	f3c1 2107 	ubfx	r1, r1, #8, #8
 800805a:	4319      	orrs	r1, r3
    }

    /* swap the output (little endian platform only). */
    return FreeRTOS_htons( ( ( uint16_t ) xSum.u32 ) );
 800805c:	b28b      	uxth	r3, r1
 800805e:	f3c1 2107 	ubfx	r1, r1, #8, #8
 8008062:	ea41 2003 	orr.w	r0, r1, r3, lsl #8
}
 8008066:	b280      	uxth	r0, r0
 8008068:	bd70      	pop	{r4, r5, r6, pc}

0800806a <prvChecksumProtocolCalculate>:
{
 800806a:	b570      	push	{r4, r5, r6, lr}
 800806c:	b082      	sub	sp, #8
 800806e:	4605      	mov	r5, r0
 8008070:	460e      	mov	r6, r1
 8008072:	4614      	mov	r4, r2
        if( pxSet->xIsIPv6 != pdFALSE )
 8008074:	6813      	ldr	r3, [r2, #0]
 8008076:	b9a3      	cbnz	r3, 80080a2 <prvChecksumProtocolCalculate+0x38>
    if( ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP ) || ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_IGMP ) )
 8008078:	7da0      	ldrb	r0, [r4, #22]
 800807a:	1e43      	subs	r3, r0, #1
 800807c:	b2db      	uxtb	r3, r3
 800807e:	2b01      	cmp	r3, #1
 8008080:	d927      	bls.n	80080d2 <prvChecksumProtocolCalculate+0x68>
    else if( ( pxSet->xIsIPv6 != pdFALSE ) && ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_ICMP_IPv6 ) )
 8008082:	6823      	ldr	r3, [r4, #0]
 8008084:	b10b      	cbz	r3, 800808a <prvChecksumProtocolCalculate+0x20>
 8008086:	283a      	cmp	r0, #58	@ 0x3a
 8008088:	d033      	beq.n	80080f2 <prvChecksumProtocolCalculate+0x88>
        switch( pxSet->xIsIPv6 ) /* LCOV_EXCL_BR_LINE */
 800808a:	2b00      	cmp	r3, #0
 800808c:	d039      	beq.n	8008102 <prvChecksumProtocolCalculate+0x98>
 800808e:	2b01      	cmp	r3, #1
 8008090:	d128      	bne.n	80080e4 <prvChecksumProtocolCalculate+0x7a>
                                        ( ~usGenerateChecksum( pxSet->usChecksum,
 8008092:	8c62      	ldrh	r2, [r4, #34]	@ 0x22
 8008094:	69e1      	ldr	r1, [r4, #28]
 8008096:	8aa0      	ldrh	r0, [r4, #20]
 8008098:	f7ff ff72 	bl	8007f80 <usGenerateChecksum>
                    pxSet->usChecksum = ( uint16_t )
 800809c:	43c0      	mvns	r0, r0
 800809e:	82a0      	strh	r0, [r4, #20]
                    break;
 80080a0:	e020      	b.n	80080e4 <prvChecksumProtocolCalculate+0x7a>
            pulHeader[ 0 ] = ( uint32_t ) pxSet->usProtocolBytes;
 80080a2:	8c52      	ldrh	r2, [r2, #34]	@ 0x22
 80080a4:	9200      	str	r2, [sp, #0]
            pulHeader[ 0 ] = FreeRTOS_htonl( pulHeader[ 0 ] );
 80080a6:	0213      	lsls	r3, r2, #8
 80080a8:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 80080ac:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80080b0:	9300      	str	r3, [sp, #0]
            pulHeader[ 1 ] = ( uint32_t ) pxSet->ucProtocol;
 80080b2:	7da3      	ldrb	r3, [r4, #22]
 80080b4:	9301      	str	r3, [sp, #4]
            pulHeader[ 1 ] = FreeRTOS_htonl( pulHeader[ 1 ] );
 80080b6:	061b      	lsls	r3, r3, #24
 80080b8:	9301      	str	r3, [sp, #4]
            pxSet->usChecksum = usGenerateChecksum( 0U,
 80080ba:	2220      	movs	r2, #32
 80080bc:	3116      	adds	r1, #22
 80080be:	2000      	movs	r0, #0
 80080c0:	f7ff ff5e 	bl	8007f80 <usGenerateChecksum>
 80080c4:	82a0      	strh	r0, [r4, #20]
            pxSet->usChecksum = usGenerateChecksum( pxSet->usChecksum,
 80080c6:	2208      	movs	r2, #8
 80080c8:	4669      	mov	r1, sp
 80080ca:	f7ff ff59 	bl	8007f80 <usGenerateChecksum>
 80080ce:	82a0      	strh	r0, [r4, #20]
 80080d0:	e7d2      	b.n	8008078 <prvChecksumProtocolCalculate+0xe>
                            ( ~usGenerateChecksum( 0U, &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + pxSet->uxIPHeaderLength ] ), ( size_t ) pxSet->usProtocolBytes ) );
 80080d2:	68e1      	ldr	r1, [r4, #12]
 80080d4:	310e      	adds	r1, #14
 80080d6:	8c62      	ldrh	r2, [r4, #34]	@ 0x22
 80080d8:	4431      	add	r1, r6
 80080da:	2000      	movs	r0, #0
 80080dc:	f7ff ff50 	bl	8007f80 <usGenerateChecksum>
        pxSet->usChecksum = ( uint16_t )
 80080e0:	43c0      	mvns	r0, r0
 80080e2:	82a0      	strh	r0, [r4, #20]
    if( xOutgoingPacket == pdFALSE )
 80080e4:	b9e5      	cbnz	r5, 8008120 <prvChecksumProtocolCalculate+0xb6>
        if( pxSet->usChecksum == 0U )
 80080e6:	8aa3      	ldrh	r3, [r4, #20]
 80080e8:	b9bb      	cbnz	r3, 800811a <prvChecksumProtocolCalculate+0xb0>
            pxSet->usChecksum = ( uint16_t ) ipCORRECT_CRC;
 80080ea:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80080ee:	82a3      	strh	r3, [r4, #20]
 80080f0:	e01c      	b.n	800812c <prvChecksumProtocolCalculate+0xc2>
                                ( ~usGenerateChecksum( pxSet->usChecksum,
 80080f2:	8c62      	ldrh	r2, [r4, #34]	@ 0x22
 80080f4:	69e1      	ldr	r1, [r4, #28]
 80080f6:	8aa0      	ldrh	r0, [r4, #20]
 80080f8:	f7ff ff42 	bl	8007f80 <usGenerateChecksum>
            pxSet->usChecksum = ( uint16_t )
 80080fc:	43c0      	mvns	r0, r0
 80080fe:	82a0      	strh	r0, [r4, #20]
 8008100:	e7f0      	b.n	80080e4 <prvChecksumProtocolCalculate+0x7a>
                       uint32_t ulByteCount = pxSet->usProtocolBytes;
 8008102:	8c62      	ldrh	r2, [r4, #34]	@ 0x22
                       pxSet->usChecksum = ( uint16_t ) ( pxSet->usProtocolBytes + ( ( uint16_t ) pxSet->ucProtocol ) );
 8008104:	4410      	add	r0, r2
 8008106:	b280      	uxth	r0, r0
 8008108:	82a0      	strh	r0, [r4, #20]
                                                                  ( const uint8_t * ) &( pxSet->pxIPPacket->xIPHeader.ulSourceIPAddress ),
 800810a:	69a1      	ldr	r1, [r4, #24]
                                           ( ~usGenerateChecksum( pxSet->usChecksum,
 800810c:	3208      	adds	r2, #8
 800810e:	311a      	adds	r1, #26
 8008110:	f7ff ff36 	bl	8007f80 <usGenerateChecksum>
                       pxSet->usChecksum = ( uint16_t )
 8008114:	43c0      	mvns	r0, r0
 8008116:	82a0      	strh	r0, [r4, #20]
                   break;
 8008118:	e7e4      	b.n	80080e4 <prvChecksumProtocolCalculate+0x7a>
            pxSet->usChecksum = ( uint16_t ) ipWRONG_CRC;
 800811a:	2300      	movs	r3, #0
 800811c:	82a3      	strh	r3, [r4, #20]
 800811e:	e005      	b.n	800812c <prvChecksumProtocolCalculate+0xc2>
        if( ( pxSet->usChecksum == 0U ) && ( pxSet->ucProtocol == ( uint8_t ) ipPROTOCOL_UDP ) )
 8008120:	6963      	ldr	r3, [r4, #20]
 8008122:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 8008126:	f5b3 1f88 	cmp.w	r3, #1114112	@ 0x110000
 800812a:	d006      	beq.n	800813a <prvChecksumProtocolCalculate+0xd0>
    pxSet->usChecksum = FreeRTOS_htons( pxSet->usChecksum );
 800812c:	8aa2      	ldrh	r2, [r4, #20]
 800812e:	0213      	lsls	r3, r2, #8
 8008130:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008134:	82a3      	strh	r3, [r4, #20]
}
 8008136:	b002      	add	sp, #8
 8008138:	bd70      	pop	{r4, r5, r6, pc}
            pxSet->usChecksum = ( uint16_t ) 0xffffu;
 800813a:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800813e:	82a3      	strh	r3, [r4, #20]
 8008140:	e7f4      	b.n	800812c <prvChecksumProtocolCalculate+0xc2>
	...

08008144 <usGenerateProtocolChecksum>:
{
 8008144:	b570      	push	{r4, r5, r6, lr}
 8008146:	b08a      	sub	sp, #40	@ 0x28
 8008148:	4604      	mov	r4, r0
 800814a:	460e      	mov	r6, r1
 800814c:	4615      	mov	r5, r2
    ( void ) memset( &( xSet ), 0, sizeof( xSet ) );
 800814e:	2224      	movs	r2, #36	@ 0x24
 8008150:	2100      	movs	r1, #0
 8008152:	a801      	add	r0, sp, #4
 8008154:	f006 fdae 	bl	800ecb4 <memset>
        xSet.pcType = "???";
 8008158:	4b2f      	ldr	r3, [pc, #188]	@ (8008218 <usGenerateProtocolChecksum+0xd4>)
 800815a:	9303      	str	r3, [sp, #12]
    configASSERT( ( ( ( IPPacket_t * ) pucEthernetBuffer )->xEthernetHeader.usFrameType == ipIPv4_FRAME_TYPE ) ||
 800815c:	89a3      	ldrh	r3, [r4, #12]
 800815e:	2b08      	cmp	r3, #8
 8008160:	d00c      	beq.n	800817c <usGenerateProtocolChecksum+0x38>
 8008162:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 8008166:	4293      	cmp	r3, r2
 8008168:	d008      	beq.n	800817c <usGenerateProtocolChecksum+0x38>
 800816a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800816e:	f383 8811 	msr	BASEPRI, r3
 8008172:	f3bf 8f6f 	isb	sy
 8008176:	f3bf 8f4f 	dsb	sy
 800817a:	e7fe      	b.n	800817a <usGenerateProtocolChecksum+0x36>
        xSet.pxIPPacket = ( ( const IPPacket_t * ) pucEthernetBuffer );
 800817c:	9407      	str	r4, [sp, #28]
        switch( xSet.pxIPPacket->xEthernetHeader.usFrameType ) /* LCOV_EXCL_BR_LINE */
 800817e:	89a3      	ldrh	r3, [r4, #12]
 8008180:	2b08      	cmp	r3, #8
 8008182:	d008      	beq.n	8008196 <usGenerateProtocolChecksum+0x52>
 8008184:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 8008188:	4293      	cmp	r3, r2
 800818a:	d00e      	beq.n	80081aa <usGenerateProtocolChecksum+0x66>
                xSet.usChecksum = ipINVALID_LENGTH;
 800818c:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008190:	f8ad 3018 	strh.w	r3, [sp, #24]
        if( xResult != 0 )
 8008194:	e005      	b.n	80081a2 <usGenerateProtocolChecksum+0x5e>
                    xResult = prvChecksumIPv4Checks( pucEthernetBuffer, uxBufferLength, &( xSet ) );
 8008196:	aa01      	add	r2, sp, #4
 8008198:	4631      	mov	r1, r6
 800819a:	4620      	mov	r0, r4
 800819c:	f000 f999 	bl	80084d2 <prvChecksumIPv4Checks>
        if( xResult != 0 )
 80081a0:	b160      	cbz	r0, 80081bc <usGenerateProtocolChecksum+0x78>
}
 80081a2:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 80081a6:	b00a      	add	sp, #40	@ 0x28
 80081a8:	bd70      	pop	{r4, r5, r6, pc}
                    xSet.pxIPPacket_IPv6 = ( ( const IPHeader_IPv6_t * ) &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 80081aa:	f104 030e 	add.w	r3, r4, #14
 80081ae:	9302      	str	r3, [sp, #8]
                    xResult = prvChecksumIPv6Checks( pucEthernetBuffer, uxBufferLength, &( xSet ) );
 80081b0:	aa01      	add	r2, sp, #4
 80081b2:	4631      	mov	r1, r6
 80081b4:	4620      	mov	r0, r4
 80081b6:	f000 fd06 	bl	8008bc6 <prvChecksumIPv6Checks>
                    break;
 80081ba:	e7f1      	b.n	80081a0 <usGenerateProtocolChecksum+0x5c>
            xResult = prvChecksumProtocolChecks( uxBufferLength, &( xSet ) );
 80081bc:	a901      	add	r1, sp, #4
 80081be:	4630      	mov	r0, r6
 80081c0:	f7ff fd42 	bl	8007c48 <prvChecksumProtocolChecks>
            if( xResult != 0 )
 80081c4:	2800      	cmp	r0, #0
 80081c6:	d1ec      	bne.n	80081a2 <usGenerateProtocolChecksum+0x5e>
        if( xOutgoingPacket != pdFALSE )
 80081c8:	b95d      	cbnz	r5, 80081e2 <usGenerateProtocolChecksum+0x9e>
        else if( ( prvGetChecksumFromPacket( &( xSet ) ) == 0U ) && ( xSet.ucProtocol == ( uint8_t ) ipPROTOCOL_UDP ) )
 80081ca:	a801      	add	r0, sp, #4
 80081cc:	f7ff fcf2 	bl	8007bb4 <prvGetChecksumFromPacket>
 80081d0:	b958      	cbnz	r0, 80081ea <usGenerateProtocolChecksum+0xa6>
 80081d2:	f89d 301a 	ldrb.w	r3, [sp, #26]
 80081d6:	2b11      	cmp	r3, #17
 80081d8:	d107      	bne.n	80081ea <usGenerateProtocolChecksum+0xa6>
                xSet.usChecksum = ipWRONG_CRC;
 80081da:	2300      	movs	r3, #0
 80081dc:	f8ad 3018 	strh.w	r3, [sp, #24]
            break;
 80081e0:	e7df      	b.n	80081a2 <usGenerateProtocolChecksum+0x5e>
            prvSetChecksumInPacket( &( xSet ), 0 );
 80081e2:	2100      	movs	r1, #0
 80081e4:	a801      	add	r0, sp, #4
 80081e6:	f7ff fccb 	bl	8007b80 <prvSetChecksumInPacket>
        xResult = prvChecksumProtocolMTUCheck( &( xSet ) );
 80081ea:	a801      	add	r0, sp, #4
 80081ec:	f7ff fd13 	bl	8007c16 <prvChecksumProtocolMTUCheck>
        if( xResult != 0 )
 80081f0:	2800      	cmp	r0, #0
 80081f2:	d1d6      	bne.n	80081a2 <usGenerateProtocolChecksum+0x5e>
        prvChecksumProtocolCalculate( xOutgoingPacket, pucEthernetBuffer, &( xSet ) );
 80081f4:	aa01      	add	r2, sp, #4
 80081f6:	4621      	mov	r1, r4
 80081f8:	4628      	mov	r0, r5
 80081fa:	f7ff ff36 	bl	800806a <prvChecksumProtocolCalculate>
        prvChecksumProtocolSetChecksum( xOutgoingPacket, pucEthernetBuffer, uxBufferLength, &( xSet ) );
 80081fe:	ab01      	add	r3, sp, #4
 8008200:	4632      	mov	r2, r6
 8008202:	4621      	mov	r1, r4
 8008204:	4628      	mov	r0, r5
 8008206:	f7ff fd17 	bl	8007c38 <prvChecksumProtocolSetChecksum>
        if( xOutgoingPacket != pdFALSE )
 800820a:	2d00      	cmp	r5, #0
 800820c:	d0c9      	beq.n	80081a2 <usGenerateProtocolChecksum+0x5e>
            xSet.usChecksum = ( uint16_t ) ipCORRECT_CRC;
 800820e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8008212:	f8ad 3018 	strh.w	r3, [sp, #24]
 8008216:	e7c4      	b.n	80081a2 <usGenerateProtocolChecksum+0x5e>
 8008218:	080101d8 	.word	0x080101d8

0800821c <FreeRTOS_max_size_t>:
 */
size_t FreeRTOS_max_size_t( size_t a,
                            size_t b )
{
    return ( a >= b ) ? a : b;
}
 800821c:	4288      	cmp	r0, r1
 800821e:	bf38      	it	cc
 8008220:	4608      	movcc	r0, r1
 8008222:	4770      	bx	lr

08008224 <FreeRTOS_min_int32>:
 */
int32_t FreeRTOS_min_int32( int32_t a,
                            int32_t b )
{
    return ( a <= b ) ? a : b;
}
 8008224:	4288      	cmp	r0, r1
 8008226:	bfa8      	it	ge
 8008228:	4608      	movge	r0, r1
 800822a:	4770      	bx	lr

0800822c <FreeRTOS_min_uint32>:
 */
uint32_t FreeRTOS_min_uint32( uint32_t a,
                              uint32_t b )
{
    return ( a <= b ) ? a : b;
}
 800822c:	4288      	cmp	r0, r1
 800822e:	bf28      	it	cs
 8008230:	4608      	movcs	r0, r1
 8008232:	4770      	bx	lr

08008234 <FreeRTOS_min_size_t>:
 */
size_t FreeRTOS_min_size_t( size_t a,
                            size_t b )
{
    return ( a <= b ) ? a : b;
}
 8008234:	4288      	cmp	r0, r1
 8008236:	bf28      	it	cs
 8008238:	4608      	movcs	r0, r1
 800823a:	4770      	bx	lr

0800823c <FreeRTOS_round_up>:
uint32_t FreeRTOS_round_up( uint32_t a,
                            uint32_t d )
{
    uint32_t ulResult = a;

    configASSERT( d != 0U );
 800823c:	b941      	cbnz	r1, 8008250 <FreeRTOS_round_up+0x14>
 800823e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008242:	f383 8811 	msr	BASEPRI, r3
 8008246:	f3bf 8f6f 	isb	sy
 800824a:	f3bf 8f4f 	dsb	sy
 800824e:	e7fe      	b.n	800824e <FreeRTOS_round_up+0x12>

    if( d != 0U )
    {
        ulResult = d * ( ( a + d - 1U ) / d );
 8008250:	1843      	adds	r3, r0, r1
 8008252:	3b01      	subs	r3, #1
 8008254:	fbb3 f3f1 	udiv	r3, r3, r1
    }

    return ulResult;
}
 8008258:	fb01 f003 	mul.w	r0, r1, r3
 800825c:	4770      	bx	lr

0800825e <ulChar2u32>:
 *        if they are not being used anywhere. But their use depends on the
 *        application and hence these functions are defined unconditionally.
 */
uint32_t ulChar2u32( const uint8_t * pucPtr )
{
    return ( ( ( uint32_t ) pucPtr[ 0 ] ) << 24 ) |
 800825e:	7802      	ldrb	r2, [r0, #0]
           ( ( ( uint32_t ) pucPtr[ 1 ] ) << 16 ) |
 8008260:	7843      	ldrb	r3, [r0, #1]
 8008262:	041b      	lsls	r3, r3, #16
    return ( ( ( uint32_t ) pucPtr[ 0 ] ) << 24 ) |
 8008264:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
           ( ( ( uint32_t ) pucPtr[ 2 ] ) << 8 ) |
 8008268:	7882      	ldrb	r2, [r0, #2]
           ( ( ( uint32_t ) pucPtr[ 1 ] ) << 16 ) |
 800826a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
           ( ( ( uint32_t ) pucPtr[ 3 ] ) );
 800826e:	78c0      	ldrb	r0, [r0, #3]
}
 8008270:	4318      	orrs	r0, r3
 8008272:	4770      	bx	lr

08008274 <usChar2u16>:
 *        application and hence these functions are defined unconditionally.
 */
uint16_t usChar2u16( const uint8_t * pucPtr )
{
    return ( uint16_t )
           ( ( ( ( uint32_t ) pucPtr[ 0 ] ) << 8 ) |
 8008274:	7802      	ldrb	r2, [r0, #0]
             ( ( ( uint32_t ) pucPtr[ 1 ] ) ) );
 8008276:	7840      	ldrb	r0, [r0, #1]
}
 8008278:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
 800827c:	4770      	bx	lr

0800827e <eGetDHCPState>:
 * @param[in] pxEndPoint the end-point which is going through the DHCP process.
 */
    eDHCPState_t eGetDHCPState( const struct xNetworkEndPoint * pxEndPoint )
    {
        return pxEndPoint->xDHCPData.eDHCPState;
    }
 800827e:	f890 012c 	ldrb.w	r0, [r0, #300]	@ 0x12c
 8008282:	4770      	bx	lr

08008284 <xSendDHCPEvent>:
    {
 8008284:	b510      	push	{r4, lr}
 8008286:	b082      	sub	sp, #8
 8008288:	4604      	mov	r4, r0
            eDHCPState_t uxOption = eGetDHCPState( pxEndPoint );
 800828a:	f7ff fff8 	bl	800827e <eGetDHCPState>
        xEventMessage.eEventType = eDHCPEvent;
 800828e:	2305      	movs	r3, #5
 8008290:	f88d 3000 	strb.w	r3, [sp]
        xEventMessage.pvData = ( void * ) pxEndPoint;
 8008294:	9401      	str	r4, [sp, #4]
            pxEndPoint->xDHCPData.eExpectedState = uxOption;
 8008296:	f884 012d 	strb.w	r0, [r4, #301]	@ 0x12d
        return xSendEventStructToIPTask( &xEventMessage, uxDontBlock );
 800829a:	2100      	movs	r1, #0
 800829c:	4668      	mov	r0, sp
 800829e:	f7ff f821 	bl	80072e4 <xSendEventStructToIPTask>
    }
 80082a2:	b002      	add	sp, #8
 80082a4:	bd10      	pop	{r4, pc}

080082a6 <xIsIPv4Multicast>:
 * @return pdTRUE if the IP address is a multicast address or else, pdFALSE.
 */
BaseType_t xIsIPv4Multicast( uint32_t ulIPAddress )
{
    BaseType_t xReturn;
    uint32_t ulIP = FreeRTOS_ntohl( ulIPAddress );
 80082a6:	0203      	lsls	r3, r0, #8
 80082a8:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 80082ac:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80082b0:	0a02      	lsrs	r2, r0, #8
 80082b2:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 80082b6:	4313      	orrs	r3, r2
 80082b8:	ea43 6310 	orr.w	r3, r3, r0, lsr #24

    if( ( ulIP >= ipFIRST_MULTI_CAST_IPv4 ) && ( ulIP < ipLAST_MULTI_CAST_IPv4 ) )
 80082bc:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 80082c0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 80082c4:	d201      	bcs.n	80082ca <xIsIPv4Multicast+0x24>
    {
        xReturn = pdTRUE;
 80082c6:	2001      	movs	r0, #1
 80082c8:	4770      	bx	lr
    }
    else
    {
        xReturn = pdFALSE;
 80082ca:	2000      	movs	r0, #0
    }

    return xReturn;
}
 80082cc:	4770      	bx	lr

080082ce <xIsIPv4Loopback>:
 * @return pdTRUE if the IP address is a loopback address or else, pdFALSE.
 */
BaseType_t xIsIPv4Loopback( uint32_t ulAddress )
{
    BaseType_t xReturn = pdFALSE;
    uint32_t ulIP = FreeRTOS_ntohl( ulAddress );
 80082ce:	0203      	lsls	r3, r0, #8
 80082d0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 80082d4:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80082d8:	0a02      	lsrs	r2, r0, #8
 80082da:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 80082de:	4313      	orrs	r3, r2
 80082e0:	ea43 6310 	orr.w	r3, r3, r0, lsr #24

    if( ( ulIP >= ipFIRST_LOOPBACK_IPv4 ) &&
 80082e4:	f103 4301 	add.w	r3, r3, #2164260864	@ 0x81000000
 80082e8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80082ec:	d301      	bcc.n	80082f2 <xIsIPv4Loopback+0x24>
    BaseType_t xReturn = pdFALSE;
 80082ee:	2000      	movs	r0, #0
 80082f0:	4770      	bx	lr
        ( ulIP < ipLAST_LOOPBACK_IPv4 ) )
    {
        xReturn = pdTRUE;
 80082f2:	2001      	movs	r0, #1
    }

    return xReturn;
}
 80082f4:	4770      	bx	lr

080082f6 <xBadIPv4Loopback>:
{
 80082f6:	b538      	push	{r3, r4, r5, lr}
 80082f8:	4604      	mov	r4, r0
    BaseType_t x1 = ( xIsIPv4Loopback( pxIPHeader->ulDestinationIPAddress ) != 0 ) ? pdTRUE : pdFALSE;
 80082fa:	6900      	ldr	r0, [r0, #16]
 80082fc:	f7ff ffe7 	bl	80082ce <xIsIPv4Loopback>
 8008300:	4605      	mov	r5, r0
 8008302:	b100      	cbz	r0, 8008306 <xBadIPv4Loopback+0x10>
 8008304:	2501      	movs	r5, #1
    BaseType_t x2 = ( xIsIPv4Loopback( pxIPHeader->ulSourceIPAddress ) != 0 ) ? pdTRUE : pdFALSE;
 8008306:	68e0      	ldr	r0, [r4, #12]
 8008308:	f7ff ffe1 	bl	80082ce <xIsIPv4Loopback>
 800830c:	4603      	mov	r3, r0
 800830e:	b100      	cbz	r0, 8008312 <xBadIPv4Loopback+0x1c>
 8008310:	2301      	movs	r3, #1
    if( x1 != x2 )
 8008312:	429d      	cmp	r5, r3
 8008314:	d001      	beq.n	800831a <xBadIPv4Loopback+0x24>
        xReturn = pdTRUE;
 8008316:	2001      	movs	r0, #1
}
 8008318:	bd38      	pop	{r3, r4, r5, pc}
    BaseType_t xReturn = pdFALSE;
 800831a:	2000      	movs	r0, #0
 800831c:	e7fc      	b.n	8008318 <xBadIPv4Loopback+0x22>
	...

08008320 <prvAllowIPPacketIPv4>:
 * @return Whether the packet should be processed or dropped.
 */
enum eFrameProcessingResult prvAllowIPPacketIPv4( const struct xIP_PACKET * const pxIPPacket,
                                                  const struct xNETWORK_BUFFER * const pxNetworkBuffer,
                                                  UBaseType_t uxHeaderLength )
{
 8008320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    #if ( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 0 )
    {
        /* In systems with a very small amount of RAM, it might be advantageous
         * to have incoming messages checked earlier, by the network card driver.
         * This method may decrease the usage of sparse network buffers. */
        uint32_t ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;
 8008324:	f8d0 701e 	ldr.w	r7, [r0, #30]
        uint32_t ulSourceIPAddress = pxIPHeader->ulSourceIPAddress;
 8008328:	f8d0 801a 	ldr.w	r8, [r0, #26]

        /* Ensure that the incoming packet is not fragmented because the stack
         * doesn't not support IP fragmentation. All but the last fragment coming in will have their
         * "more fragments" flag set and the last fragment will have a non-zero offset.
         * We need to drop the packet in either of those cases. */
        if( ( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U ) || ( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_FLAGS_MORE_FRAGMENTS ) != 0U ) )
 800832c:	8a83      	ldrh	r3, [r0, #20]
 800832e:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 8008332:	b29b      	uxth	r3, r3
 8008334:	2b00      	cmp	r3, #0
 8008336:	d165      	bne.n	8008404 <prvAllowIPPacketIPv4+0xe4>
 8008338:	4604      	mov	r4, r0
 800833a:	460e      	mov	r6, r1
 800833c:	4615      	mov	r5, r2
            eReturn = eReleaseBuffer;
        }

        /* Test if the length of the IP-header is between 20 and 60 bytes,
         * and if the IP-version is 4. */
        else if( ( pxIPHeader->ucVersionHeaderLength < ipIPV4_VERSION_HEADER_LENGTH_MIN ) ||
 800833e:	7b83      	ldrb	r3, [r0, #14]
 8008340:	3b45      	subs	r3, #69	@ 0x45
 8008342:	b2db      	uxtb	r3, r3
 8008344:	2b0a      	cmp	r3, #10
 8008346:	d860      	bhi.n	800840a <prvAllowIPPacketIPv4+0xea>
                 ( pxIPHeader->ucVersionHeaderLength > ipIPV4_VERSION_HEADER_LENGTH_MAX ) )
        {
            /* Can not handle, unknown or invalid header version. */
            eReturn = eReleaseBuffer;
        }
        else if( ( xIsIPv4Loopback( ulDestinationIPAddress ) == pdTRUE ) ||
 8008348:	4638      	mov	r0, r7
 800834a:	f7ff ffc0 	bl	80082ce <xIsIPv4Loopback>
 800834e:	2801      	cmp	r0, #1
 8008350:	d004      	beq.n	800835c <prvAllowIPPacketIPv4+0x3c>
                 ( xIsIPv4Loopback( ulSourceIPAddress ) == pdTRUE ) )
 8008352:	4640      	mov	r0, r8
 8008354:	f7ff ffbb 	bl	80082ce <xIsIPv4Loopback>
        else if( ( xIsIPv4Loopback( ulDestinationIPAddress ) == pdTRUE ) ||
 8008358:	2801      	cmp	r0, #1
 800835a:	d10c      	bne.n	8008376 <prvAllowIPPacketIPv4+0x56>
        {
            /* source OR destination is a loopback address. Make sure they BOTH are. */
            if( xBadIPv4Loopback( &( pxIPPacket->xIPHeader ) ) == pdTRUE )
 800835c:	f104 000e 	add.w	r0, r4, #14
 8008360:	f7ff ffc9 	bl	80082f6 <xBadIPv4Loopback>
 8008364:	2801      	cmp	r0, #1
 8008366:	d052      	beq.n	800840e <prvAllowIPPacketIPv4+0xee>
    {
        /* Some drivers of NIC's with checksum-offloading will enable the above
         * define, so that the checksum won't be checked again here */
        if( eReturn == eProcessBuffer )
        {
            const NetworkEndPoint_t * pxEndPoint = FreeRTOS_FindEndPointOnMAC( &( pxIPPacket->xEthernetHeader.xSourceAddress ), NULL );
 8008368:	2100      	movs	r1, #0
 800836a:	1da0      	adds	r0, r4, #6
 800836c:	f001 fba4 	bl	8009ab8 <FreeRTOS_FindEndPointOnMAC>

            /* Do not check the checksum of loop-back messages. */
            if( pxEndPoint == NULL )
 8008370:	b380      	cbz	r0, 80083d4 <prvAllowIPPacketIPv4+0xb4>
 8008372:	2001      	movs	r0, #1
 8008374:	e047      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
            ( FreeRTOS_FindEndPointOnIP_IPv4( ulDestinationIPAddress, 4 ) == NULL ) &&
 8008376:	2104      	movs	r1, #4
 8008378:	4638      	mov	r0, r7
 800837a:	f001 fb77 	bl	8009a6c <FreeRTOS_FindEndPointOnIP_IPv4>
        else if(
 800837e:	b170      	cbz	r0, 800839e <prvAllowIPPacketIPv4+0x7e>
        else if( ( FreeRTOS_ntohl( ulSourceIPAddress ) & 0xffU ) == 0xffU )
 8008380:	ea4f 6318 	mov.w	r3, r8, lsr #24
 8008384:	2bff      	cmp	r3, #255	@ 0xff
 8008386:	d044      	beq.n	8008412 <prvAllowIPPacketIPv4+0xf2>
        else if( ( memcmp( xBroadcastMACAddress.ucBytes,
 8008388:	2206      	movs	r2, #6
 800838a:	4621      	mov	r1, r4
 800838c:	4823      	ldr	r0, [pc, #140]	@ (800841c <prvAllowIPPacketIPv4+0xfc>)
 800838e:	f006 fc67 	bl	800ec60 <memcmp>
 8008392:	b990      	cbnz	r0, 80083ba <prvAllowIPPacketIPv4+0x9a>
                 ( ( FreeRTOS_ntohl( ulDestinationIPAddress ) & 0xffU ) != 0xffU ) )
 8008394:	0e3f      	lsrs	r7, r7, #24
                           sizeof( MACAddress_t ) ) == 0 ) &&
 8008396:	2fff      	cmp	r7, #255	@ 0xff
 8008398:	d00f      	beq.n	80083ba <prvAllowIPPacketIPv4+0x9a>
            eReturn = eReleaseBuffer;
 800839a:	2000      	movs	r0, #0
 800839c:	e033      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
            ( ( FreeRTOS_ntohl( ulDestinationIPAddress ) & 0xffU ) != 0xffU ) &&
 800839e:	0e3b      	lsrs	r3, r7, #24
            ( FreeRTOS_FindEndPointOnIP_IPv4( ulDestinationIPAddress, 4 ) == NULL ) &&
 80083a0:	2bff      	cmp	r3, #255	@ 0xff
 80083a2:	d0ed      	beq.n	8008380 <prvAllowIPPacketIPv4+0x60>
            ( xIsIPv4Multicast( ulDestinationIPAddress ) == pdFALSE ) &&
 80083a4:	4638      	mov	r0, r7
 80083a6:	f7ff ff7e 	bl	80082a6 <xIsIPv4Multicast>
            ( ( FreeRTOS_ntohl( ulDestinationIPAddress ) & 0xffU ) != 0xffU ) &&
 80083aa:	2800      	cmp	r0, #0
 80083ac:	d1e8      	bne.n	8008380 <prvAllowIPPacketIPv4+0x60>
            ( FreeRTOS_IsNetworkUp() != pdFALSE ) )
 80083ae:	f7ff f88e 	bl	80074ce <FreeRTOS_IsNetworkUp>
            ( xIsIPv4Multicast( ulDestinationIPAddress ) == pdFALSE ) &&
 80083b2:	2800      	cmp	r0, #0
 80083b4:	d0e4      	beq.n	8008380 <prvAllowIPPacketIPv4+0x60>
            eReturn = eReleaseBuffer;
 80083b6:	2000      	movs	r0, #0
 80083b8:	e025      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
        else if( memcmp( xBroadcastMACAddress.ucBytes,
 80083ba:	2206      	movs	r2, #6
 80083bc:	18a1      	adds	r1, r4, r2
 80083be:	4817      	ldr	r0, [pc, #92]	@ (800841c <prvAllowIPPacketIPv4+0xfc>)
 80083c0:	f006 fc4e 	bl	800ec60 <memcmp>
 80083c4:	b338      	cbz	r0, 8008416 <prvAllowIPPacketIPv4+0xf6>
        else if( xIsIPv4Multicast( ulSourceIPAddress ) == pdTRUE )
 80083c6:	4640      	mov	r0, r8
 80083c8:	f7ff ff6d 	bl	80082a6 <xIsIPv4Multicast>
 80083cc:	2801      	cmp	r0, #1
 80083ce:	d1cb      	bne.n	8008368 <prvAllowIPPacketIPv4+0x48>
            eReturn = eReleaseBuffer;
 80083d0:	2000      	movs	r0, #0
 80083d2:	e018      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
                 * the checksum field, the resulting value of the checksum always is 0xffff
                 * which is denoted by ipCORRECT_CRC. See this wiki for more information:
                 * https://en.wikipedia.org/wiki/IPv4_header_checksum#Verifying_the_IPv4_header_checksum
                 * and this RFC: https://tools.ietf.org/html/rfc1624#page-4
                 */
                if( usGenerateChecksum( 0U, ( const uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), ( size_t ) uxHeaderLength ) != ipCORRECT_CRC )
 80083d4:	462a      	mov	r2, r5
 80083d6:	f104 010e 	add.w	r1, r4, #14
 80083da:	f7ff fdd1 	bl	8007f80 <usGenerateChecksum>
 80083de:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80083e2:	4298      	cmp	r0, r3
 80083e4:	d001      	beq.n	80083ea <prvAllowIPPacketIPv4+0xca>
                {
                    /* Check sum in IP-header not correct. */
                    eReturn = eReleaseBuffer;
 80083e6:	2000      	movs	r0, #0
 80083e8:	e00d      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
                }
                /* Is the upper-layer checksum (TCP/UDP/ICMP) correct? */
                else if( usGenerateProtocolChecksum( ( uint8_t * ) ( pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer->xDataLength, pdFALSE ) != ipCORRECT_CRC )
 80083ea:	2200      	movs	r2, #0
 80083ec:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80083ee:	6a70      	ldr	r0, [r6, #36]	@ 0x24
 80083f0:	f7ff fea8 	bl	8008144 <usGenerateProtocolChecksum>
 80083f4:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80083f8:	4298      	cmp	r0, r3
 80083fa:	d001      	beq.n	8008400 <prvAllowIPPacketIPv4+0xe0>
                {
                    /* Protocol checksum not accepted. */
                    eReturn = eReleaseBuffer;
 80083fc:	2000      	movs	r0, #0
 80083fe:	e002      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
                else if( usGenerateProtocolChecksum( ( uint8_t * ) ( pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer->xDataLength, pdFALSE ) != ipCORRECT_CRC )
 8008400:	2001      	movs	r0, #1
 8008402:	e000      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
            eReturn = eReleaseBuffer;
 8008404:	2000      	movs	r0, #0
        ( void ) uxHeaderLength;
    }
    #endif /* ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM == 0 */

    return eReturn;
}
 8008406:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            eReturn = eReleaseBuffer;
 800840a:	2000      	movs	r0, #0
 800840c:	e7fb      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
                eReturn = eReleaseBuffer;
 800840e:	2000      	movs	r0, #0
 8008410:	e7f9      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
            eReturn = eReleaseBuffer;
 8008412:	2000      	movs	r0, #0
 8008414:	e7f7      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
            eReturn = eReleaseBuffer;
 8008416:	2000      	movs	r0, #0
 8008418:	e7f5      	b.n	8008406 <prvAllowIPPacketIPv4+0xe6>
 800841a:	bf00      	nop
 800841c:	080102c4 	.word	0x080102c4

08008420 <prvCheckIP4HeaderOptions>:
 * @param[in] pxNetworkBuffer the network buffer that contains the packet.
 *
 * @return Either 'eProcessBuffer' or 'eReleaseBuffer'
 */
enum eFrameProcessingResult prvCheckIP4HeaderOptions( struct xNETWORK_BUFFER * const pxNetworkBuffer )
{
 8008420:	b570      	push	{r4, r5, r6, lr}
 8008422:	4606      	mov	r6, r0
    #if ( ipconfigIP_PASS_PACKETS_WITH_IP_OPTIONS != 0 )
    {
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        IPHeader_t * pxIPHeader = ( ( IPHeader_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 8008424:	6a44      	ldr	r4, [r0, #36]	@ 0x24

        /* All structs of headers expect a IP header size of 20 bytes
         * IP header options were included, we'll ignore them and cut them out. */
        size_t uxLength = ( size_t ) pxIPHeader->ucVersionHeaderLength;
 8008426:	7ba1      	ldrb	r1, [r4, #14]

        /* Check if the IP headers are acceptable and if it has our destination.
         * The lowest four bits of 'ucVersionHeaderLength' indicate the IP-header
         * length in multiples of 4. */
        size_t uxHeaderLength = ( size_t ) ( ( uxLength & 0x0FU ) << 2 );
 8008428:	0089      	lsls	r1, r1, #2
 800842a:	f001 013c 	and.w	r1, r1, #60	@ 0x3c

        /* Number of bytes contained in IPv4 header options. */
        const size_t optlen = ( ( size_t ) uxHeaderLength ) - ipSIZE_OF_IPv4_HEADER;
 800842e:	f1a1 0514 	sub.w	r5, r1, #20
        /* From: the previous start of UDP/ICMP/TCP data. */
        const uint8_t * pucSource = ( const uint8_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( EthernetHeader_t ) + uxHeaderLength ] );
 8008432:	310e      	adds	r1, #14
        /* To: the usual start of UDP/ICMP/TCP data at offset 20 (decimal ) from IP header. */
        uint8_t * pucTarget = ( uint8_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ sizeof( EthernetHeader_t ) + ipSIZE_OF_IPv4_HEADER ] );
        /* How many: total length minus the options and the lower headers. */
        const size_t xMoveLen = pxNetworkBuffer->xDataLength - ( optlen + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_ETH_HEADER );
 8008434:	6a82      	ldr	r2, [r0, #40]	@ 0x28
 8008436:	1b52      	subs	r2, r2, r5

        ( void ) memmove( pucTarget, pucSource, xMoveLen );
 8008438:	3a22      	subs	r2, #34	@ 0x22
 800843a:	4421      	add	r1, r4
 800843c:	f104 0022 	add.w	r0, r4, #34	@ 0x22
 8008440:	f006 fc1e 	bl	800ec80 <memmove>
        pxNetworkBuffer->xDataLength -= optlen;
 8008444:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 8008446:	1b5b      	subs	r3, r3, r5
 8008448:	62b3      	str	r3, [r6, #40]	@ 0x28
        /* Update the total length of the IP packet after removing options. */
        pxIPHeader->usLength = FreeRTOS_htons( FreeRTOS_ntohs( pxIPHeader->usLength ) - optlen );
 800844a:	8a23      	ldrh	r3, [r4, #16]
 800844c:	021a      	lsls	r2, r3, #8
 800844e:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
 8008452:	b292      	uxth	r2, r2
 8008454:	1b53      	subs	r3, r2, r5
 8008456:	b29b      	uxth	r3, r3
 8008458:	021b      	lsls	r3, r3, #8
 800845a:	b29b      	uxth	r3, r3
 800845c:	1b52      	subs	r2, r2, r5
 800845e:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008462:	8223      	strh	r3, [r4, #16]

        /* Rewrite the Version/IHL byte to indicate that this packet has no IP options. */
        pxIPHeader->ucVersionHeaderLength = ( uint8_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0xF0U ) | /* High nibble is the version. */
 8008464:	7ba3      	ldrb	r3, [r4, #14]
 8008466:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800846a:	f043 0305 	orr.w	r3, r3, #5
 800846e:	73a3      	strb	r3, [r4, #14]
        eReturn = eReleaseBuffer;
    }
    #endif /* if ( ipconfigIP_PASS_PACKETS_WITH_IP_OPTIONS != 0 ) */

    return eReturn;
}
 8008470:	2001      	movs	r0, #1
 8008472:	bd70      	pop	{r4, r5, r6, pc}

08008474 <FreeRTOS_inet_ntop4>:
{
    uint32_t ulIPAddress;
    void * pvCopyDest;
    const char * pcReturn;

    if( uxSize < 16U )
 8008474:	2a0f      	cmp	r2, #15
 8008476:	d906      	bls.n	8008486 <FreeRTOS_inet_ntop4+0x12>
{
 8008478:	b510      	push	{r4, lr}
 800847a:	460c      	mov	r4, r1
    }
    else
    {
        pvCopyDest = ( void * ) &ulIPAddress;
        ( void ) memcpy( pvCopyDest, pvSource, sizeof( ulIPAddress ) );
        ( void ) FreeRTOS_inet_ntoa( ulIPAddress, pcDestination );
 800847c:	6800      	ldr	r0, [r0, #0]
 800847e:	f002 f941 	bl	800a704 <FreeRTOS_inet_ntoa>
        pcReturn = pcDestination;
 8008482:	4620      	mov	r0, r4
    }

    return pcReturn;
}
 8008484:	bd10      	pop	{r4, pc}
        pcReturn = NULL;
 8008486:	2000      	movs	r0, #0
}
 8008488:	4770      	bx	lr

0800848a <xSend_UDP_Update_IPv4>:
void * xSend_UDP_Update_IPv4( NetworkBufferDescriptor_t * pxNetworkBuffer,
                              const struct freertos_sockaddr * pxDestinationAddress )
{
    UDPPacket_t * pxUDPPacket;

    if( ( pxNetworkBuffer != NULL ) && ( pxDestinationAddress != NULL ) )
 800848a:	b138      	cbz	r0, 800849c <xSend_UDP_Update_IPv4+0x12>
 800848c:	b131      	cbz	r1, 800849c <xSend_UDP_Update_IPv4+0x12>
    {
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxUDPPacket = ( ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800848e:	6a42      	ldr	r2, [r0, #36]	@ 0x24

        pxNetworkBuffer->xIPAddress.ulIP_IPv4 = pxDestinationAddress->sin_address.ulIP_IPv4;
 8008490:	6889      	ldr	r1, [r1, #8]
 8008492:	6141      	str	r1, [r0, #20]
        /* Map the UDP packet onto the start of the frame. */
        pxUDPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
 8008494:	2308      	movs	r3, #8
 8008496:	7313      	strb	r3, [r2, #12]
 8008498:	2300      	movs	r3, #0
 800849a:	7353      	strb	r3, [r2, #13]
    }

    return NULL;
}
 800849c:	2000      	movs	r0, #0
 800849e:	4770      	bx	lr

080084a0 <xRecv_Update_IPv4>:
size_t xRecv_Update_IPv4( const NetworkBufferDescriptor_t * pxNetworkBuffer,
                          struct freertos_sockaddr * pxSourceAddress )
{
    size_t uxPayloadOffset = 0;

    if( ( pxNetworkBuffer != NULL ) && ( pxSourceAddress != NULL ) )
 80084a0:	b130      	cbz	r0, 80084b0 <xRecv_Update_IPv4+0x10>
 80084a2:	b129      	cbz	r1, 80084b0 <xRecv_Update_IPv4+0x10>
    {
        pxSourceAddress->sin_family = ( uint8_t ) FREERTOS_AF_INET;
 80084a4:	2202      	movs	r2, #2
 80084a6:	704a      	strb	r2, [r1, #1]
        pxSourceAddress->sin_address.ulIP_IPv4 = pxNetworkBuffer->xIPAddress.ulIP_IPv4;
 80084a8:	6942      	ldr	r2, [r0, #20]
 80084aa:	608a      	str	r2, [r1, #8]
        pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
 80084ac:	8e83      	ldrh	r3, [r0, #52]	@ 0x34
 80084ae:	804b      	strh	r3, [r1, #2]
    }

    uxPayloadOffset = ipUDP_PAYLOAD_OFFSET_IPv4;

    return uxPayloadOffset;
}
 80084b0:	202a      	movs	r0, #42	@ 0x2a
 80084b2:	4770      	bx	lr

080084b4 <vSetMultiCastIPv4MacAddress>:
void vSetMultiCastIPv4MacAddress( uint32_t ulIPAddress,
                                  MACAddress_t * pxMACAddress )
{
    uint32_t ulIP = FreeRTOS_ntohl( ulIPAddress );

    pxMACAddress->ucBytes[ 0 ] = ( uint8_t ) 0x01U;
 80084b4:	2301      	movs	r3, #1
 80084b6:	700b      	strb	r3, [r1, #0]
    pxMACAddress->ucBytes[ 1 ] = ( uint8_t ) 0x00U;
 80084b8:	2300      	movs	r3, #0
 80084ba:	704b      	strb	r3, [r1, #1]
    pxMACAddress->ucBytes[ 2 ] = ( uint8_t ) 0x5EU;
 80084bc:	235e      	movs	r3, #94	@ 0x5e
 80084be:	708b      	strb	r3, [r1, #2]
    pxMACAddress->ucBytes[ 3 ] = ( uint8_t ) ( ( ulIP >> 16 ) & 0x7fU ); /* Use 7 bits. */
 80084c0:	f3c0 2306 	ubfx	r3, r0, #8, #7
 80084c4:	70cb      	strb	r3, [r1, #3]
    pxMACAddress->ucBytes[ 4 ] = ( uint8_t ) ( ( ulIP >> 8 ) & 0xffU );  /* Use 8 bits. */
 80084c6:	f3c0 4307 	ubfx	r3, r0, #16, #8
 80084ca:	710b      	strb	r3, [r1, #4]
    pxMACAddress->ucBytes[ 5 ] = ( uint8_t ) ( ( ulIP ) & 0xffU );       /* Use 8 bits. */
 80084cc:	0e00      	lsrs	r0, r0, #24
 80084ce:	7148      	strb	r0, [r1, #5]
}
 80084d0:	4770      	bx	lr

080084d2 <prvChecksumIPv4Checks>:
 * @return Non-zero in case of an error.
 */
BaseType_t prvChecksumIPv4Checks( uint8_t * pucEthernetBuffer,
                                  size_t uxBufferLength,
                                  struct xPacketSummary * pxSet )
{
 80084d2:	b530      	push	{r4, r5, lr}
    BaseType_t xReturn = 0;
    uint8_t ucVersion;
    uint16_t usLength;

    pxSet->xIsIPv6 = pdFALSE;
 80084d4:	2300      	movs	r3, #0
 80084d6:	6013      	str	r3, [r2, #0]

    usLength = pxSet->pxIPPacket->xIPHeader.usLength;
 80084d8:	6994      	ldr	r4, [r2, #24]
 80084da:	8a23      	ldrh	r3, [r4, #16]
    usLength = FreeRTOS_ntohs( usLength );
 80084dc:	ea4f 2c03 	mov.w	ip, r3, lsl #8
 80084e0:	fa1f fc8c 	uxth.w	ip, ip
 80084e4:	ea4c 2c13 	orr.w	ip, ip, r3, lsr #8

    /* IPv4 : the lower nibble in 'ucVersionHeaderLength' indicates the length
     * of the IP-header, expressed in number of 4-byte words. Usually 5 words.
     */
    ucVersion = pxSet->pxIPPacket->xIPHeader.ucVersionHeaderLength & ( uint8_t ) 0x0FU;
 80084e8:	7ba3      	ldrb	r3, [r4, #14]
 80084ea:	f003 030f 	and.w	r3, r3, #15
    pxSet->uxIPHeaderLength = ( size_t ) ucVersion;
 80084ee:	60d3      	str	r3, [r2, #12]
    pxSet->uxIPHeaderLength *= 4U;
 80084f0:	009b      	lsls	r3, r3, #2
 80084f2:	60d3      	str	r3, [r2, #12]

    if( usLength < pxSet->uxIPHeaderLength )
 80084f4:	4563      	cmp	r3, ip
 80084f6:	d81c      	bhi.n	8008532 <prvChecksumIPv4Checks+0x60>
    }

    /* Check for minimum packet size. */
    if( xReturn == 0 )
    {
        if( uxBufferLength < sizeof( IPPacket_t ) )
 80084f8:	2921      	cmp	r1, #33	@ 0x21
 80084fa:	d91f      	bls.n	800853c <prvChecksumIPv4Checks+0x6a>
    }

    if( xReturn == 0 )
    {
        /* Check for minimum packet size. */
        if( uxBufferLength < ( ipSIZE_OF_ETH_HEADER + pxSet->uxIPHeaderLength ) )
 80084fc:	f103 0e0e 	add.w	lr, r3, #14
 8008500:	458e      	cmp	lr, r1
 8008502:	d820      	bhi.n	8008546 <prvChecksumIPv4Checks+0x74>

    if( xReturn == 0 )
    {
        size_t uxNeeded;
        /* xIPHeader.usLength is the total length, minus the Ethernet header. */
        pxSet->usPayloadLength = FreeRTOS_ntohs( pxSet->pxIPPacket->xIPHeader.usLength );
 8008504:	8a25      	ldrh	r5, [r4, #16]
 8008506:	ea4f 2c05 	mov.w	ip, r5, lsl #8
 800850a:	ea4c 2c15 	orr.w	ip, ip, r5, lsr #8
 800850e:	fa1f fc8c 	uxth.w	ip, ip
 8008512:	f8a2 c020 	strh.w	ip, [r2, #32]

        uxNeeded = pxSet->usPayloadLength;
        uxNeeded += ipSIZE_OF_ETH_HEADER;
 8008516:	f10c 050e 	add.w	r5, ip, #14

        if( uxBufferLength < uxNeeded )
 800851a:	42a9      	cmp	r1, r5
 800851c:	d318      	bcc.n	8008550 <prvChecksumIPv4Checks+0x7e>
    }

    if( xReturn == 0 )
    {
        /* Identify the next protocol. */
        pxSet->ucProtocol = pxSet->pxIPPacket->xIPHeader.ucProtocol;
 800851e:	7de1      	ldrb	r1, [r4, #23]
 8008520:	7591      	strb	r1, [r2, #22]
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxSet->pxProtocolHeaders = ( ( ProtocolHeaders_t * ) &( pucEthernetBuffer[ pxSet->uxIPHeaderLength + ipSIZE_OF_ETH_HEADER ] ) );
 8008522:	4470      	add	r0, lr
 8008524:	61d0      	str	r0, [r2, #28]
        /* For IPv4, the number of bytes in IP-header + the protocol is indicated. */
        pxSet->usProtocolBytes = ( uint16_t ) ( pxSet->usPayloadLength - pxSet->uxIPHeaderLength );
 8008526:	ebac 0c03 	sub.w	ip, ip, r3
 800852a:	f8a2 c022 	strh.w	ip, [r2, #34]	@ 0x22
 800852e:	2000      	movs	r0, #0
    }

    return xReturn;
 8008530:	e003      	b.n	800853a <prvChecksumIPv4Checks+0x68>
        pxSet->usChecksum = ipINVALID_LENGTH;
 8008532:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008536:	8293      	strh	r3, [r2, #20]
        xReturn = 3;
 8008538:	2003      	movs	r0, #3
}
 800853a:	bd30      	pop	{r4, r5, pc}
            pxSet->usChecksum = ipINVALID_LENGTH;
 800853c:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008540:	8293      	strh	r3, [r2, #20]
            xReturn = 4;
 8008542:	2004      	movs	r0, #4
 8008544:	e7f9      	b.n	800853a <prvChecksumIPv4Checks+0x68>
            pxSet->usChecksum = ipINVALID_LENGTH;
 8008546:	f241 2334 	movw	r3, #4660	@ 0x1234
 800854a:	8293      	strh	r3, [r2, #20]
            xReturn = 5;
 800854c:	2005      	movs	r0, #5
 800854e:	e7f4      	b.n	800853a <prvChecksumIPv4Checks+0x68>
            pxSet->usChecksum = ipINVALID_LENGTH;
 8008550:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008554:	8293      	strh	r3, [r2, #20]
            xReturn = 6;
 8008556:	2006      	movs	r0, #6
 8008558:	e7ef      	b.n	800853a <prvChecksumIPv4Checks+0x68>

0800855a <xGetIPv6MulticastGroupID>:
 * @param[out] pxReturnGroupID The buffer to store group ID.
 */
static void xGetIPv6MulticastGroupID( const IPv6_Address_t * pxIPv6Address,
                                      IPv6_Address_t * pxReturnGroupID )
{
    configASSERT( pxIPv6Address != NULL );
 800855a:	4603      	mov	r3, r0
 800855c:	b190      	cbz	r0, 8008584 <xGetIPv6MulticastGroupID+0x2a>
    configASSERT( pxReturnGroupID != NULL );
 800855e:	b1d1      	cbz	r1, 8008596 <xGetIPv6MulticastGroupID+0x3c>

    pxReturnGroupID->ucBytes[ 0 ] = 0U;
 8008560:	2200      	movs	r2, #0
 8008562:	700a      	strb	r2, [r1, #0]
    pxReturnGroupID->ucBytes[ 1 ] = 0U;
 8008564:	704a      	strb	r2, [r1, #1]
    ( void ) memcpy( &( pxReturnGroupID->ucBytes[ 2 ] ), &( pxIPv6Address->ucBytes[ 2 ] ), 14 );
 8008566:	f8d0 c002 	ldr.w	ip, [r0, #2]
 800856a:	f8d0 0006 	ldr.w	r0, [r0, #6]
 800856e:	f8d3 200a 	ldr.w	r2, [r3, #10]
 8008572:	f8c1 c002 	str.w	ip, [r1, #2]
 8008576:	f8c1 0006 	str.w	r0, [r1, #6]
 800857a:	f8c1 200a 	str.w	r2, [r1, #10]
 800857e:	89db      	ldrh	r3, [r3, #14]
 8008580:	81cb      	strh	r3, [r1, #14]
}
 8008582:	4770      	bx	lr
 8008584:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008588:	f383 8811 	msr	BASEPRI, r3
 800858c:	f3bf 8f6f 	isb	sy
 8008590:	f3bf 8f4f 	dsb	sy
    configASSERT( pxIPv6Address != NULL );
 8008594:	e7fe      	b.n	8008594 <xGetIPv6MulticastGroupID+0x3a>
 8008596:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800859a:	f383 8811 	msr	BASEPRI, r3
 800859e:	f3bf 8f6f 	isb	sy
 80085a2:	f3bf 8f4f 	dsb	sy
    configASSERT( pxReturnGroupID != NULL );
 80085a6:	e7fe      	b.n	80085a6 <xGetIPv6MulticastGroupID+0x4c>

080085a8 <xIsIPv6Loopback>:
 * @param[in] pxAddress The IP-address being checked.
 *
 * @return pdTRUE if the IP-address is a loopback address or else, pdFALSE.
 */
BaseType_t xIsIPv6Loopback( const IPv6_Address_t * pxAddress )
{
 80085a8:	b508      	push	{r3, lr}
    BaseType_t xReturn = pdFALSE;

    if( memcmp( pxAddress->ucBytes, FreeRTOS_in6addr_loopback.ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 80085aa:	2210      	movs	r2, #16
 80085ac:	4903      	ldr	r1, [pc, #12]	@ (80085bc <xIsIPv6Loopback+0x14>)
 80085ae:	f006 fb57 	bl	800ec60 <memcmp>
 80085b2:	b108      	cbz	r0, 80085b8 <xIsIPv6Loopback+0x10>
    BaseType_t xReturn = pdFALSE;
 80085b4:	2000      	movs	r0, #0
    {
        xReturn = pdTRUE;
    }

    return xReturn;
}
 80085b6:	bd08      	pop	{r3, pc}
        xReturn = pdTRUE;
 80085b8:	2001      	movs	r0, #1
    return xReturn;
 80085ba:	e7fc      	b.n	80085b6 <xIsIPv6Loopback+0xe>
 80085bc:	080102dc 	.word	0x080102dc

080085c0 <xBadIPv6Loopback>:
/* MISRA Ref 8.9.1 [File scoped variables] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-89 */
/* coverity[misra_c_2012_rule_8_9_violation] */
/* coverity[single_use] */
    BaseType_t xBadIPv6Loopback( const IPHeader_IPv6_t * const pxIPv6Header )
    {
 80085c0:	b538      	push	{r3, r4, r5, lr}
 80085c2:	4604      	mov	r4, r0
        BaseType_t xReturn = pdFALSE;
        const NetworkEndPoint_t * pxEndPoint = FreeRTOS_FindEndPointOnIP_IPv6( &( pxIPv6Header->xSourceAddress ) );
 80085c4:	f100 0508 	add.w	r5, r0, #8
 80085c8:	4628      	mov	r0, r5
 80085ca:	f001 faf1 	bl	8009bb0 <FreeRTOS_FindEndPointOnIP_IPv6>

        /* Allow loopback packets from this node itself only. */
        if( pxEndPoint != NULL )
 80085ce:	b190      	cbz	r0, 80085f6 <xBadIPv6Loopback+0x36>
        {
            BaseType_t x1 = ( xIsIPv6Loopback( &( pxIPv6Header->xDestinationAddress ) ) != 0 ) ? pdTRUE : pdFALSE;
 80085d0:	f104 0018 	add.w	r0, r4, #24
 80085d4:	f7ff ffe8 	bl	80085a8 <xIsIPv6Loopback>
 80085d8:	4604      	mov	r4, r0
 80085da:	b100      	cbz	r0, 80085de <xBadIPv6Loopback+0x1e>
 80085dc:	2401      	movs	r4, #1
            BaseType_t x2 = ( xIsIPv6Loopback( &( pxIPv6Header->xSourceAddress ) ) != 0 ) ? pdTRUE : pdFALSE;
 80085de:	4628      	mov	r0, r5
 80085e0:	f7ff ffe2 	bl	80085a8 <xIsIPv6Loopback>
 80085e4:	4603      	mov	r3, r0
 80085e6:	b100      	cbz	r0, 80085ea <xBadIPv6Loopback+0x2a>
 80085e8:	2301      	movs	r3, #1

            if( x1 != x2 )
 80085ea:	429c      	cmp	r4, r3
 80085ec:	d001      	beq.n	80085f2 <xBadIPv6Loopback+0x32>
            {
                /* Either source or the destination address is a loopback address. */
                xReturn = pdTRUE;
 80085ee:	2001      	movs	r0, #1
            }
        }

        return xReturn;
    }
 80085f0:	bd38      	pop	{r3, r4, r5, pc}
        BaseType_t xReturn = pdFALSE;
 80085f2:	2000      	movs	r0, #0
 80085f4:	e7fc      	b.n	80085f0 <xBadIPv6Loopback+0x30>
 80085f6:	2000      	movs	r0, #0
 80085f8:	e7fa      	b.n	80085f0 <xBadIPv6Loopback+0x30>
	...

080085fc <xIsIPv6AllowedMulticast>:
BaseType_t xIsIPv6AllowedMulticast( const IPv6_Address_t * pxIPAddress )
{
    BaseType_t xReturn = pdFALSE;
    IPv6_Address_t xGroupIDAddress;

    if( pxIPAddress->ucBytes[ 0 ] == 0xffU )
 80085fc:	7803      	ldrb	r3, [r0, #0]
 80085fe:	2bff      	cmp	r3, #255	@ 0xff
 8008600:	d001      	beq.n	8008606 <xIsIPv6AllowedMulticast+0xa>
    BaseType_t xReturn = pdFALSE;
 8008602:	2000      	movs	r0, #0
            xReturn = pdTRUE;
        }
    }

    return xReturn;
}
 8008604:	4770      	bx	lr
{
 8008606:	b510      	push	{r4, lr}
 8008608:	b084      	sub	sp, #16
 800860a:	4604      	mov	r4, r0
        IPv6MC_GET_GROUP_ID( pxIPAddress, &xGroupIDAddress );
 800860c:	4669      	mov	r1, sp
 800860e:	f7ff ffa4 	bl	800855a <xGetIPv6MulticastGroupID>
        if( IPv6MC_GET_SCOPE_VALUE( pxIPAddress ) == 0U )
 8008612:	7863      	ldrb	r3, [r4, #1]
 8008614:	f013 0f0f 	tst.w	r3, #15
 8008618:	d009      	beq.n	800862e <xIsIPv6AllowedMulticast+0x32>
        else if( ( IPv6MC_GET_FLAGS_VALUE( pxIPAddress ) == 0U ) &&
 800861a:	2b0f      	cmp	r3, #15
 800861c:	d80a      	bhi.n	8008634 <xIsIPv6AllowedMulticast+0x38>
                 ( memcmp( xGroupIDAddress.ucBytes, FreeRTOS_in6addr_any.ucBytes, sizeof( IPv6_Address_t ) ) == 0 ) )
 800861e:	2210      	movs	r2, #16
 8008620:	4905      	ldr	r1, [pc, #20]	@ (8008638 <xIsIPv6AllowedMulticast+0x3c>)
 8008622:	4668      	mov	r0, sp
 8008624:	f006 fb1c 	bl	800ec60 <memcmp>
        else if( ( IPv6MC_GET_FLAGS_VALUE( pxIPAddress ) == 0U ) &&
 8008628:	b110      	cbz	r0, 8008630 <xIsIPv6AllowedMulticast+0x34>
            xReturn = pdTRUE;
 800862a:	2001      	movs	r0, #1
 800862c:	e000      	b.n	8008630 <xIsIPv6AllowedMulticast+0x34>
            xReturn = pdFALSE;
 800862e:	2000      	movs	r0, #0
}
 8008630:	b004      	add	sp, #16
 8008632:	bd10      	pop	{r4, pc}
            xReturn = pdTRUE;
 8008634:	2001      	movs	r0, #1
    return xReturn;
 8008636:	e7fb      	b.n	8008630 <xIsIPv6AllowedMulticast+0x34>
 8008638:	080102ec 	.word	0x080102ec

0800863c <xCompareIPv6_Address>:
 * @return Returns 0 if it can handle it, else non zero .
 */
BaseType_t xCompareIPv6_Address( const IPv6_Address_t * pxLeft,
                                 const IPv6_Address_t * pxRight,
                                 size_t uxPrefixLength )
{
 800863c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800863e:	4606      	mov	r6, r0
 8008640:	460c      	mov	r4, r1
 8008642:	4615      	mov	r5, r2
    /* This variable is initialized by the system to contain the IPv6 multicast address for all nodes. */
    static const struct xIPv6_Address FreeRTOS_in6addr_allnodes = { { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 } };

    /* 0    2    4    6    8    10   12   14 */
    /* ff02:0000:0000:0000:0000:0001:ff66:4a81 */
    if( ( pxRight->ucBytes[ 0 ] == 0xffU ) &&
 8008644:	780f      	ldrb	r7, [r1, #0]
 8008646:	2fff      	cmp	r7, #255	@ 0xff
 8008648:	d016      	beq.n	8008678 <xCompareIPv6_Address+0x3c>
    {
        /* This is an LLMNR address. */
        xResult = memcmp( &( pxLeft->ucBytes[ 13 ] ), &( pxRight->ucBytes[ 13 ] ), 3 );
    }
    else
    if( memcmp( pxRight->ucBytes, FreeRTOS_in6addr_allnodes.ucBytes, sizeof( IPv6_Address_t ) ) == 0 )
 800864a:	2210      	movs	r2, #16
 800864c:	4922      	ldr	r1, [pc, #136]	@ (80086d8 <xCompareIPv6_Address+0x9c>)
 800864e:	4620      	mov	r0, r4
 8008650:	f006 fb06 	bl	800ec60 <memcmp>
 8008654:	2800      	cmp	r0, #0
 8008656:	d03d      	beq.n	80086d4 <xCompareIPv6_Address+0x98>
    {
        /* FF02::1 is all node address to reach out all nodes in the same link. */
        xResult = 0;
    }
    else
    if( ( pxRight->ucBytes[ 0 ] == 0xfeU ) &&
 8008658:	2ffe      	cmp	r7, #254	@ 0xfe
 800865a:	d019      	beq.n	8008690 <xCompareIPv6_Address+0x54>
        /* Both are local addresses. */
        xResult = 0;
    }
    else
    {
        if( uxPrefixLength == 0U )
 800865c:	2d00      	cmp	r5, #0
 800865e:	d038      	beq.n	80086d2 <xCompareIPv6_Address+0x96>
        {
            xResult = 0;
        }
        else if( uxPrefixLength == ( 8U * ipSIZE_OF_IPv6_ADDRESS ) )
 8008660:	2d80      	cmp	r5, #128	@ 0x80
 8008662:	d020      	beq.n	80086a6 <xCompareIPv6_Address+0x6a>
        {
            xResult = memcmp( pxLeft->ucBytes, pxRight->ucBytes, ipSIZE_OF_IPv6_ADDRESS );
        }
        else
        {
            size_t uxLength = uxPrefixLength / 8U;
 8008664:	08ef      	lsrs	r7, r5, #3

            xResult = 0;

            if( uxLength > 0U )
 8008666:	2d07      	cmp	r5, #7
 8008668:	d923      	bls.n	80086b2 <xCompareIPv6_Address+0x76>
            {
                xResult = memcmp( pxLeft->ucBytes, pxRight->ucBytes, uxLength );
 800866a:	463a      	mov	r2, r7
 800866c:	4621      	mov	r1, r4
 800866e:	4630      	mov	r0, r6
 8008670:	f006 faf6 	bl	800ec60 <memcmp>
            }

            if( ( xResult == 0 ) && ( ( uxPrefixLength % 8U ) != 0U ) )
 8008674:	bb70      	cbnz	r0, 80086d4 <xCompareIPv6_Address+0x98>
 8008676:	e01d      	b.n	80086b4 <xCompareIPv6_Address+0x78>
        ( pxRight->ucBytes[ 1 ] == 0x02U ) &&
 8008678:	784b      	ldrb	r3, [r1, #1]
    if( ( pxRight->ucBytes[ 0 ] == 0xffU ) &&
 800867a:	2b02      	cmp	r3, #2
 800867c:	d1e5      	bne.n	800864a <xCompareIPv6_Address+0xe>
        ( pxRight->ucBytes[ 12 ] == 0xffU ) )
 800867e:	7b0b      	ldrb	r3, [r1, #12]
        ( pxRight->ucBytes[ 1 ] == 0x02U ) &&
 8008680:	2bff      	cmp	r3, #255	@ 0xff
 8008682:	d1e2      	bne.n	800864a <xCompareIPv6_Address+0xe>
        xResult = memcmp( &( pxLeft->ucBytes[ 13 ] ), &( pxRight->ucBytes[ 13 ] ), 3 );
 8008684:	2203      	movs	r2, #3
 8008686:	310d      	adds	r1, #13
 8008688:	300d      	adds	r0, #13
 800868a:	f006 fae9 	bl	800ec60 <memcmp>
 800868e:	e021      	b.n	80086d4 <xCompareIPv6_Address+0x98>
        ( pxRight->ucBytes[ 1 ] == 0x80U ) &&
 8008690:	7863      	ldrb	r3, [r4, #1]
    if( ( pxRight->ucBytes[ 0 ] == 0xfeU ) &&
 8008692:	2b80      	cmp	r3, #128	@ 0x80
 8008694:	d1e2      	bne.n	800865c <xCompareIPv6_Address+0x20>
        ( pxLeft->ucBytes[ 0 ] == 0xfeU ) &&
 8008696:	7833      	ldrb	r3, [r6, #0]
        ( pxRight->ucBytes[ 1 ] == 0x80U ) &&
 8008698:	2bfe      	cmp	r3, #254	@ 0xfe
 800869a:	d1df      	bne.n	800865c <xCompareIPv6_Address+0x20>
        ( pxLeft->ucBytes[ 1 ] == 0x80U ) )
 800869c:	7873      	ldrb	r3, [r6, #1]
        ( pxLeft->ucBytes[ 0 ] == 0xfeU ) &&
 800869e:	2b80      	cmp	r3, #128	@ 0x80
 80086a0:	d1dc      	bne.n	800865c <xCompareIPv6_Address+0x20>
        xResult = 0;
 80086a2:	2000      	movs	r0, #0
 80086a4:	e016      	b.n	80086d4 <xCompareIPv6_Address+0x98>
            xResult = memcmp( pxLeft->ucBytes, pxRight->ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 80086a6:	2210      	movs	r2, #16
 80086a8:	4621      	mov	r1, r4
 80086aa:	4630      	mov	r0, r6
 80086ac:	f006 fad8 	bl	800ec60 <memcmp>
 80086b0:	e010      	b.n	80086d4 <xCompareIPv6_Address+0x98>
            xResult = 0;
 80086b2:	2000      	movs	r0, #0
            if( ( xResult == 0 ) && ( ( uxPrefixLength % 8U ) != 0U ) )
 80086b4:	f015 0507 	ands.w	r5, r5, #7
 80086b8:	d00c      	beq.n	80086d4 <xCompareIPv6_Address+0x98>
            {
                /* One byte has both a network- and a host-address. */
                size_t uxBits = uxPrefixLength % 8U;
                size_t uxHostLen = 8U - uxBits;
 80086ba:	f1c5 0508 	rsb	r5, r5, #8
                uint32_t uxHostMask = ( ( ( uint32_t ) 1U ) << uxHostLen ) - 1U;
 80086be:	2301      	movs	r3, #1
 80086c0:	40ab      	lsls	r3, r5
                uint8_t ucNetMask = ( uint8_t ) ~( uxHostMask );
 80086c2:	425b      	negs	r3, r3

                if( ( pxLeft->ucBytes[ uxLength ] & ucNetMask ) != ( pxRight->ucBytes[ uxLength ] & ucNetMask ) )
 80086c4:	5df2      	ldrb	r2, [r6, r7]
 80086c6:	5de1      	ldrb	r1, [r4, r7]
 80086c8:	404a      	eors	r2, r1
 80086ca:	4213      	tst	r3, r2
 80086cc:	d002      	beq.n	80086d4 <xCompareIPv6_Address+0x98>
                {
                    xResult = 1;
 80086ce:	2001      	movs	r0, #1
                }
            }
        }
    }

    return xResult;
 80086d0:	e000      	b.n	80086d4 <xCompareIPv6_Address+0x98>
            xResult = 0;
 80086d2:	2000      	movs	r0, #0
}
 80086d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80086d6:	bf00      	nop
 80086d8:	080102cc 	.word	0x080102cc

080086dc <prvAllowIPPacketIPv6>:
 * @return Whether the packet should be processed or dropped.
 */
eFrameProcessingResult_t prvAllowIPPacketIPv6( const IPHeader_IPv6_t * const pxIPv6Header,
                                               const NetworkBufferDescriptor_t * const pxNetworkBuffer,
                                               UBaseType_t uxHeaderLength )
{
 80086dc:	b570      	push	{r4, r5, r6, lr}
 80086de:	4604      	mov	r4, r0
 80086e0:	460e      	mov	r6, r1
    #if ( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 0 )
    {
        /* In systems with a very small amount of RAM, it might be advantageous
         * to have incoming messages checked earlier, by the network card driver.
         * This method may decrease the usage of sparse network buffers. */
        const IPv6_Address_t * pxDestinationIPAddress = &( pxIPv6Header->xDestinationAddress );
 80086e2:	f100 0518 	add.w	r5, r0, #24
        const IPv6_Address_t * pxSourceIPAddress = &( pxIPv6Header->xSourceAddress );
        BaseType_t xHasUnspecifiedAddress = pdFALSE;

        /* Drop if packet has unspecified IPv6 address (defined in RFC4291 - sec 2.5.2)
         * either in source or destination address. */
        if( ( memcmp( pxDestinationIPAddress->ucBytes, FreeRTOS_in6addr_any.ucBytes, sizeof( IPv6_Address_t ) ) == 0 ) ||
 80086e6:	2210      	movs	r2, #16
 80086e8:	491e      	ldr	r1, [pc, #120]	@ (8008764 <prvAllowIPPacketIPv6+0x88>)
 80086ea:	4628      	mov	r0, r5
 80086ec:	f006 fab8 	bl	800ec60 <memcmp>
 80086f0:	b398      	cbz	r0, 800875a <prvAllowIPPacketIPv6+0x7e>
            ( memcmp( pxSourceIPAddress->ucBytes, FreeRTOS_in6addr_any.ucBytes, sizeof( IPv6_Address_t ) ) == 0 ) )
 80086f2:	2210      	movs	r2, #16
 80086f4:	491b      	ldr	r1, [pc, #108]	@ (8008764 <prvAllowIPPacketIPv6+0x88>)
 80086f6:	f104 0008 	add.w	r0, r4, #8
 80086fa:	f006 fab1 	bl	800ec60 <memcmp>
        if( ( memcmp( pxDestinationIPAddress->ucBytes, FreeRTOS_in6addr_any.ucBytes, sizeof( IPv6_Address_t ) ) == 0 ) ||
 80086fe:	b370      	cbz	r0, 800875e <prvAllowIPPacketIPv6+0x82>
            xHasUnspecifiedAddress = pdTRUE;
        }

        /* Is the packet for this IP address? */
        if( ( xHasUnspecifiedAddress == pdFALSE ) &&
            ( pxNetworkBuffer->pxEndPoint != NULL ) &&
 8008700:	6b31      	ldr	r1, [r6, #48]	@ 0x30
        if( ( xHasUnspecifiedAddress == pdFALSE ) &&
 8008702:	b129      	cbz	r1, 8008710 <prvAllowIPPacketIPv6+0x34>
            ( memcmp( pxDestinationIPAddress->ucBytes, pxNetworkBuffer->pxEndPoint->ipv6_settings.xIPAddress.ucBytes, sizeof( IPv6_Address_t ) ) == 0 ) )
 8008704:	2210      	movs	r2, #16
 8008706:	3138      	adds	r1, #56	@ 0x38
 8008708:	4628      	mov	r0, r5
 800870a:	f006 faa9 	bl	800ec60 <memcmp>
            ( pxNetworkBuffer->pxEndPoint != NULL ) &&
 800870e:	b148      	cbz	r0, 8008724 <prvAllowIPPacketIPv6+0x48>
        {
            eReturn = eProcessBuffer;
        }
        /* Is it the legal multicast address? */
        else if( ( ( xHasUnspecifiedAddress == pdFALSE ) &&
                   ( xBadIPv6Loopback( pxIPv6Header ) == pdFALSE ) ) &&
 8008710:	4620      	mov	r0, r4
 8008712:	f7ff ff55 	bl	80085c0 <xBadIPv6Loopback>
        else if( ( ( xHasUnspecifiedAddress == pdFALSE ) &&
 8008716:	b108      	cbz	r0, 800871c <prvAllowIPPacketIPv6+0x40>
        }
        else
        {
            /* Packet is not for this node, or the network is still not up,
             * release it */
            eReturn = eReleaseBuffer;
 8008718:	2000      	movs	r0, #0
 800871a:	e01f      	b.n	800875c <prvAllowIPPacketIPv6+0x80>
                 ( ( xIsIPv6AllowedMulticast( pxDestinationIPAddress ) != pdFALSE ) ||
 800871c:	4628      	mov	r0, r5
 800871e:	f7ff ff6d 	bl	80085fc <xIsIPv6AllowedMulticast>
                   ( xBadIPv6Loopback( pxIPv6Header ) == pdFALSE ) ) &&
 8008722:	b138      	cbz	r0, 8008734 <prvAllowIPPacketIPv6+0x58>
        if( eReturn == eProcessBuffer )
        {
            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            const IPPacket_t * pxIPPacket = ( ( const IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 8008724:	6a70      	ldr	r0, [r6, #36]	@ 0x24
            const NetworkEndPoint_t * pxEndPoint = FreeRTOS_FindEndPointOnMAC( &( pxIPPacket->xEthernetHeader.xSourceAddress ), NULL );
 8008726:	2100      	movs	r1, #0
 8008728:	3006      	adds	r0, #6
 800872a:	f001 f9c5 	bl	8009ab8 <FreeRTOS_FindEndPointOnMAC>

            /* IPv6 does not have a separate checksum in the IP-header */
            /* Is the upper-layer checksum (TCP/UDP/ICMP) correct? */
            /* Do not check the checksum of loop-back messages. */
            if( pxEndPoint == NULL )
 800872e:	b138      	cbz	r0, 8008740 <prvAllowIPPacketIPv6+0x64>
 8008730:	2001      	movs	r0, #1
 8008732:	e013      	b.n	800875c <prvAllowIPPacketIPv6+0x80>
                   ( FreeRTOS_IsNetworkUp() == 0 ) ) )
 8008734:	f7fe fecb 	bl	80074ce <FreeRTOS_IsNetworkUp>
                 ( ( xIsIPv6AllowedMulticast( pxDestinationIPAddress ) != pdFALSE ) ||
 8008738:	2800      	cmp	r0, #0
 800873a:	d0f3      	beq.n	8008724 <prvAllowIPPacketIPv6+0x48>
            eReturn = eReleaseBuffer;
 800873c:	2000      	movs	r0, #0
 800873e:	e00d      	b.n	800875c <prvAllowIPPacketIPv6+0x80>
            {
                if( usGenerateProtocolChecksum( ( uint8_t * ) ( pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer->xDataLength, pdFALSE ) != ipCORRECT_CRC )
 8008740:	2200      	movs	r2, #0
 8008742:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8008744:	6a70      	ldr	r0, [r6, #36]	@ 0x24
 8008746:	f7ff fcfd 	bl	8008144 <usGenerateProtocolChecksum>
 800874a:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800874e:	4298      	cmp	r0, r3
 8008750:	d001      	beq.n	8008756 <prvAllowIPPacketIPv6+0x7a>
                {
                    /* Protocol checksum not accepted. */
                    eReturn = eReleaseBuffer;
 8008752:	2000      	movs	r0, #0
 8008754:	e002      	b.n	800875c <prvAllowIPPacketIPv6+0x80>
                if( usGenerateProtocolChecksum( ( uint8_t * ) ( pxNetworkBuffer->pucEthernetBuffer ), pxNetworkBuffer->xDataLength, pdFALSE ) != ipCORRECT_CRC )
 8008756:	2001      	movs	r0, #1
 8008758:	e000      	b.n	800875c <prvAllowIPPacketIPv6+0x80>
            eReturn = eReleaseBuffer;
 800875a:	2000      	movs	r0, #0
    }
    #endif /* ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM == 0 */
    ( void ) uxHeaderLength;

    return eReturn;
}
 800875c:	bd70      	pop	{r4, r5, r6, pc}
            eReturn = eReleaseBuffer;
 800875e:	2000      	movs	r0, #0
 8008760:	e7fc      	b.n	800875c <prvAllowIPPacketIPv6+0x80>
 8008762:	bf00      	nop
 8008764:	080102ec 	.word	0x080102ec

08008768 <xGetExtensionOrder>:
BaseType_t xGetExtensionOrder( uint8_t ucProtocol,
                               uint8_t ucNextHeader )
{
    BaseType_t xReturn;

    switch( ucProtocol )
 8008768:	283c      	cmp	r0, #60	@ 0x3c
 800876a:	d817      	bhi.n	800879c <xGetExtensionOrder+0x34>
 800876c:	282b      	cmp	r0, #43	@ 0x2b
 800876e:	d30d      	bcc.n	800878c <xGetExtensionOrder+0x24>
 8008770:	382b      	subs	r0, #43	@ 0x2b
 8008772:	2811      	cmp	r0, #17
 8008774:	d80f      	bhi.n	8008796 <xGetExtensionOrder+0x2e>
 8008776:	e8df f000 	tbb	[pc, r0]
 800877a:	200c      	.short	0x200c
 800877c:	0e0e0e0e 	.word	0x0e0e0e0e
 8008780:	0e191b0e 	.word	0x0e191b0e
 8008784:	0e0e0e0e 	.word	0x0e0e0e0e
 8008788:	150e0e0e 	.word	0x150e0e0e
 800878c:	b990      	cbnz	r0, 80087b4 <xGetExtensionOrder+0x4c>
 800878e:	2001      	movs	r0, #1
 8008790:	4770      	bx	lr
            }

            break;

        case ipIPv6_EXT_HEADER_ROUTING_HEADER:
            xReturn = 3;
 8008792:	2003      	movs	r0, #3
 8008794:	4770      	bx	lr
        case ipIPv6_EXT_HEADER_MOBILITY_HEADER:
            xReturn = 8;
            break;

        default:
            xReturn = -1;
 8008796:	f04f 30ff 	mov.w	r0, #4294967295
 800879a:	4770      	bx	lr
    switch( ucProtocol )
 800879c:	2887      	cmp	r0, #135	@ 0x87
 800879e:	d10e      	bne.n	80087be <xGetExtensionOrder+0x56>
            xReturn = 8;
 80087a0:	2008      	movs	r0, #8
 80087a2:	4770      	bx	lr
            if( ucNextHeader == ipIPv6_EXT_HEADER_ROUTING_HEADER )
 80087a4:	292b      	cmp	r1, #43	@ 0x2b
 80087a6:	d00d      	beq.n	80087c4 <xGetExtensionOrder+0x5c>
            xReturn = 7;
 80087a8:	2007      	movs	r0, #7
 80087aa:	4770      	bx	lr
            xReturn = 5;
 80087ac:	2005      	movs	r0, #5
            break;
 80087ae:	4770      	bx	lr
            xReturn = 6;
 80087b0:	2006      	movs	r0, #6
            break;
 80087b2:	4770      	bx	lr
            xReturn = -1;
 80087b4:	f04f 30ff 	mov.w	r0, #4294967295
 80087b8:	4770      	bx	lr
            xReturn = 4;
 80087ba:	2004      	movs	r0, #4
 80087bc:	4770      	bx	lr
            xReturn = -1;
 80087be:	f04f 30ff 	mov.w	r0, #4294967295
 80087c2:	4770      	bx	lr
                xReturn = 2;
 80087c4:	2002      	movs	r0, #2
            break;
    }

    return xReturn;
}
 80087c6:	4770      	bx	lr

080087c8 <eHandleIPv6ExtensionHeaders>:
 * @return eProcessBuffer in case the options are removed successfully, otherwise
 *         eReleaseBuffer.
 */
eFrameProcessingResult_t eHandleIPv6ExtensionHeaders( NetworkBufferDescriptor_t * const pxNetworkBuffer,
                                                      BaseType_t xDoRemove )
{
 80087c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80087cc:	b083      	sub	sp, #12
 80087ce:	4604      	mov	r4, r0
 80087d0:	460f      	mov	r7, r1
    eFrameProcessingResult_t eResult = eReleaseBuffer;
    const size_t uxMaxLength = pxNetworkBuffer->xDataLength;
 80087d2:	f8d0 9028 	ldr.w	r9, [r0, #40]	@ 0x28
    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    IPPacket_IPv6_t * pxIPPacket_IPv6 = ( ( IPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80087d6:	f8d0 8024 	ldr.w	r8, [r0, #36]	@ 0x24
    size_t xMoveLen = 0U;
    size_t uxRemovedBytes = 0U;
    uint8_t ucNextHeader = 0U;
 80087da:	2300      	movs	r3, #0
 80087dc:	f88d 3007 	strb.w	r3, [sp, #7]
    size_t uxIndex = 0U;

    uxRemovedBytes = usGetExtensionHeaderLength( pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength, &ucNextHeader );
 80087e0:	f10d 0207 	add.w	r2, sp, #7
 80087e4:	4649      	mov	r1, r9
 80087e6:	4640      	mov	r0, r8
 80087e8:	f000 f9b0 	bl	8008b4c <usGetExtensionHeaderLength>
    uxIndex = ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + uxRemovedBytes;
 80087ec:	f100 0136 	add.w	r1, r0, #54	@ 0x36

    if( uxIndex < uxMaxLength )
 80087f0:	4589      	cmp	r9, r1
 80087f2:	d925      	bls.n	8008840 <eHandleIPv6ExtensionHeaders+0x78>
 80087f4:	4605      	mov	r5, r0
    {
        uint8_t * pucTo;
        const uint8_t * pucFrom;
        uint16_t usPayloadLength = FreeRTOS_ntohs( pxIPPacket_IPv6->xIPHeader.usPayloadLength );
 80087f6:	f8b8 2012 	ldrh.w	r2, [r8, #18]
 80087fa:	0216      	lsls	r6, r2, #8
 80087fc:	ea46 2612 	orr.w	r6, r6, r2, lsr #8
 8008800:	b2b6      	uxth	r6, r6

        if( uxRemovedBytes >= ( size_t ) usPayloadLength )
 8008802:	4286      	cmp	r6, r0
 8008804:	d920      	bls.n	8008848 <eHandleIPv6ExtensionHeaders+0x80>
        {
            /* Can not remove more bytes than the payload length. */
        }
        else if( xDoRemove == pdTRUE )
 8008806:	2f01      	cmp	r7, #1
 8008808:	d001      	beq.n	800880e <eHandleIPv6ExtensionHeaders+0x46>
    eFrameProcessingResult_t eResult = eReleaseBuffer;
 800880a:	2000      	movs	r0, #0
 800880c:	e019      	b.n	8008842 <eHandleIPv6ExtensionHeaders+0x7a>
        {
            pxIPPacket_IPv6->xIPHeader.ucNextHeader = ucNextHeader;
 800880e:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8008812:	f888 2014 	strb.w	r2, [r8, #20]
            pucTo = &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER ] );
 8008816:	6a60      	ldr	r0, [r4, #36]	@ 0x24
            pucFrom = &( pxNetworkBuffer->pucEthernetBuffer[ uxIndex ] );
            xMoveLen = uxMaxLength - uxIndex;
            ( void ) memmove( pucTo, pucFrom, xMoveLen );
 8008818:	eba9 0201 	sub.w	r2, r9, r1
 800881c:	4401      	add	r1, r0
 800881e:	3036      	adds	r0, #54	@ 0x36
 8008820:	f006 fa2e 	bl	800ec80 <memmove>
            pxNetworkBuffer->xDataLength -= uxRemovedBytes;
 8008824:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8008826:	1b5b      	subs	r3, r3, r5
 8008828:	62a3      	str	r3, [r4, #40]	@ 0x28

            usPayloadLength = ( uint16_t ) ( usPayloadLength - uxRemovedBytes );
 800882a:	b2ad      	uxth	r5, r5
 800882c:	1b76      	subs	r6, r6, r5
 800882e:	b2b3      	uxth	r3, r6
            pxIPPacket_IPv6->xIPHeader.usPayloadLength = FreeRTOS_htons( usPayloadLength );
 8008830:	f3c6 2607 	ubfx	r6, r6, #8, #8
 8008834:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
 8008838:	f8a8 6012 	strh.w	r6, [r8, #18]
            eResult = eProcessBuffer;
 800883c:	2001      	movs	r0, #1
 800883e:	e000      	b.n	8008842 <eHandleIPv6ExtensionHeaders+0x7a>
    eFrameProcessingResult_t eResult = eReleaseBuffer;
 8008840:	2000      	movs	r0, #0
                       ( unsigned ) xMoveLen,
                       ( unsigned ) uxRemovedBytes,
                       FreeRTOS_ntohs( pxIPPacket_IPv6->xIPHeader.usPayloadLength ),
                       ( unsigned ) pxNetworkBuffer->xDataLength ) );
    return eResult;
}
 8008842:	b003      	add	sp, #12
 8008844:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    eFrameProcessingResult_t eResult = eReleaseBuffer;
 8008848:	2000      	movs	r0, #0
 800884a:	e7fa      	b.n	8008842 <eHandleIPv6ExtensionHeaders+0x7a>

0800884c <prv_ntop6_write_zeros>:
                                         struct sNTOP6_Set * pxSet )
{
    BaseType_t xReturn = pdPASS;
    const BaseType_t xShortCount = 8; /* An IPv6 address consists of 8 shorts. */

    if( pxSet->uxTargetIndex <= ( uxSize - 1U ) )
 800884c:	6913      	ldr	r3, [r2, #16]
 800884e:	3901      	subs	r1, #1
 8008850:	428b      	cmp	r3, r1
 8008852:	d81a      	bhi.n	800888a <prv_ntop6_write_zeros+0x3e>
{
 8008854:	b430      	push	{r4, r5}
    {
        pcDestination[ pxSet->uxTargetIndex ] = ':';
 8008856:	f04f 0c3a 	mov.w	ip, #58	@ 0x3a
 800885a:	f800 c003 	strb.w	ip, [r0, r3]
        pxSet->uxTargetIndex++;
 800885e:	6913      	ldr	r3, [r2, #16]
 8008860:	3301      	adds	r3, #1
 8008862:	6113      	str	r3, [r2, #16]

        if( ( pxSet->xIndex + pxSet->xZeroLength ) == xShortCount )
 8008864:	68d4      	ldr	r4, [r2, #12]
 8008866:	6895      	ldr	r5, [r2, #8]
 8008868:	eb04 0c05 	add.w	ip, r4, r5
 800886c:	f1bc 0f08 	cmp.w	ip, #8
 8008870:	d002      	beq.n	8008878 <prv_ntop6_write_zeros+0x2c>
    BaseType_t xReturn = pdPASS;
 8008872:	2001      	movs	r0, #1
        /* Can not write the first colon. */
        xReturn = pdFAIL;
    }

    return xReturn;
}
 8008874:	bc30      	pop	{r4, r5}
 8008876:	4770      	bx	lr
            if( pxSet->uxTargetIndex <= ( uxSize - 1U ) )
 8008878:	4299      	cmp	r1, r3
 800887a:	d308      	bcc.n	800888e <prv_ntop6_write_zeros+0x42>
                pcDestination[ pxSet->uxTargetIndex ] = ':';
 800887c:	213a      	movs	r1, #58	@ 0x3a
 800887e:	54c1      	strb	r1, [r0, r3]
                pxSet->uxTargetIndex++;
 8008880:	6913      	ldr	r3, [r2, #16]
 8008882:	3301      	adds	r3, #1
 8008884:	6113      	str	r3, [r2, #16]
    BaseType_t xReturn = pdPASS;
 8008886:	2001      	movs	r0, #1
 8008888:	e7f4      	b.n	8008874 <prv_ntop6_write_zeros+0x28>
        xReturn = pdFAIL;
 800888a:	2000      	movs	r0, #0
}
 800888c:	4770      	bx	lr
                xReturn = pdFAIL;
 800888e:	2000      	movs	r0, #0
    return xReturn;
 8008890:	e7f0      	b.n	8008874 <prv_ntop6_write_zeros+0x28>

08008892 <pxTCPSocketLookup_IPv6>:
    {
 8008892:	b510      	push	{r4, lr}
        if( ( pxSocket != NULL ) && ( pxAddress != NULL ) )
 8008894:	4604      	mov	r4, r0
 8008896:	b160      	cbz	r0, 80088b2 <pxTCPSocketLookup_IPv6+0x20>
 8008898:	b1b1      	cbz	r1, 80088c8 <pxTCPSocketLookup_IPv6+0x36>
            if( pxSocket->bits.bIsIPv6 != pdFALSE_UNSIGNED )
 800889a:	7a03      	ldrb	r3, [r0, #8]
 800889c:	f013 0f01 	tst.w	r3, #1
 80088a0:	d00a      	beq.n	80088b8 <pxTCPSocketLookup_IPv6+0x26>
                if( pxAddress->xIs_IPv6 != pdFALSE )
 80088a2:	690b      	ldr	r3, [r1, #16]
 80088a4:	b193      	cbz	r3, 80088cc <pxTCPSocketLookup_IPv6+0x3a>
                    if( memcmp( pxSocket->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, pxAddress->xIPAddress.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 80088a6:	2210      	movs	r2, #16
 80088a8:	3054      	adds	r0, #84	@ 0x54
 80088aa:	f006 f9d9 	bl	800ec60 <memcmp>
 80088ae:	b908      	cbnz	r0, 80088b4 <pxTCPSocketLookup_IPv6+0x22>
                        pxResult = pxSocket;
 80088b0:	4620      	mov	r0, r4
    }
 80088b2:	bd10      	pop	{r4, pc}
        FreeRTOS_Socket_t * pxResult = NULL;
 80088b4:	2000      	movs	r0, #0
 80088b6:	e7fc      	b.n	80088b2 <pxTCPSocketLookup_IPv6+0x20>
                if( pxAddress->xIs_IPv6 == pdFALSE )
 80088b8:	690b      	ldr	r3, [r1, #16]
 80088ba:	b94b      	cbnz	r3, 80088d0 <pxTCPSocketLookup_IPv6+0x3e>
                    if( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 == pxAddress->xIPAddress.ulIP_IPv4 )
 80088bc:	6d42      	ldr	r2, [r0, #84]	@ 0x54
 80088be:	680b      	ldr	r3, [r1, #0]
 80088c0:	429a      	cmp	r2, r3
 80088c2:	d0f6      	beq.n	80088b2 <pxTCPSocketLookup_IPv6+0x20>
        FreeRTOS_Socket_t * pxResult = NULL;
 80088c4:	2000      	movs	r0, #0
 80088c6:	e7f4      	b.n	80088b2 <pxTCPSocketLookup_IPv6+0x20>
 80088c8:	4608      	mov	r0, r1
 80088ca:	e7f2      	b.n	80088b2 <pxTCPSocketLookup_IPv6+0x20>
 80088cc:	2000      	movs	r0, #0
 80088ce:	e7f0      	b.n	80088b2 <pxTCPSocketLookup_IPv6+0x20>
 80088d0:	2000      	movs	r0, #0
 80088d2:	e7ee      	b.n	80088b2 <pxTCPSocketLookup_IPv6+0x20>

080088d4 <xSend_UDP_Update_IPv6>:
    UDPPacket_IPv6_t * pxUDPPacket_IPv6 = ( ( UDPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80088d4:	6a42      	ldr	r2, [r0, #36]	@ 0x24
    pxNetworkBuffer->xIPAddress.ulIP_IPv4 = 0U;
 80088d6:	2300      	movs	r3, #0
 80088d8:	6143      	str	r3, [r0, #20]
    configASSERT( pxDestinationAddress != NULL );
 80088da:	b319      	cbz	r1, 8008924 <xSend_UDP_Update_IPv6+0x50>
{
 80088dc:	b510      	push	{r4, lr}
 80088de:	460b      	mov	r3, r1
    ( void ) memcpy( pxUDPPacket_IPv6->xIPHeader.xDestinationAddress.ucBytes, pxDestinationAddress->sin_address.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 80088e0:	688c      	ldr	r4, [r1, #8]
 80088e2:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 80088e6:	f8d1 c010 	ldr.w	ip, [r1, #16]
 80088ea:	6949      	ldr	r1, [r1, #20]
 80088ec:	f8c2 4026 	str.w	r4, [r2, #38]	@ 0x26
 80088f0:	f8c2 e02a 	str.w	lr, [r2, #42]	@ 0x2a
 80088f4:	f8c2 c02e 	str.w	ip, [r2, #46]	@ 0x2e
 80088f8:	f8c2 1032 	str.w	r1, [r2, #50]	@ 0x32
    ( void ) memcpy( pxNetworkBuffer->xIPAddress.xIP_IPv6.ucBytes, pxDestinationAddress->sin_address.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 80088fc:	f8d3 e008 	ldr.w	lr, [r3, #8]
 8008900:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8008904:	6919      	ldr	r1, [r3, #16]
 8008906:	695b      	ldr	r3, [r3, #20]
 8008908:	f8c0 e014 	str.w	lr, [r0, #20]
 800890c:	f8c0 c018 	str.w	ip, [r0, #24]
 8008910:	61c1      	str	r1, [r0, #28]
 8008912:	6203      	str	r3, [r0, #32]
    pxUDPPacket_IPv6->xEthernetHeader.usFrameType = ipIPv6_FRAME_TYPE;
 8008914:	f06f 0379 	mvn.w	r3, #121	@ 0x79
 8008918:	7313      	strb	r3, [r2, #12]
 800891a:	f06f 0322 	mvn.w	r3, #34	@ 0x22
 800891e:	7353      	strb	r3, [r2, #13]
}
 8008920:	2000      	movs	r0, #0
 8008922:	bd10      	pop	{r4, pc}
 8008924:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008928:	f383 8811 	msr	BASEPRI, r3
 800892c:	f3bf 8f6f 	isb	sy
 8008930:	f3bf 8f4f 	dsb	sy
    configASSERT( pxDestinationAddress != NULL );
 8008934:	e7fe      	b.n	8008934 <xSend_UDP_Update_IPv6+0x60>

08008936 <xRecv_Update_IPv6>:
    const UDPPacket_IPv6_t * pxUDPPacketV6 = ( ( const UDPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 8008936:	6a43      	ldr	r3, [r0, #36]	@ 0x24
    if( pxUDPPacketV6->xEthernetHeader.usFrameType == ipIPv6_FRAME_TYPE )
 8008938:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
 800893c:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 8008940:	4594      	cmp	ip, r2
 8008942:	d001      	beq.n	8008948 <xRecv_Update_IPv6+0x12>
    size_t uxPayloadOffset = 0;
 8008944:	2000      	movs	r0, #0
 8008946:	4770      	bx	lr
        if( pxSourceAddress != NULL )
 8008948:	b1a9      	cbz	r1, 8008976 <xRecv_Update_IPv6+0x40>
{
 800894a:	b500      	push	{lr}
            ( void ) memcpy( ( void * ) pxSourceAddress->sin_address.xIP_IPv6.ucBytes,
 800894c:	f8d3 e016 	ldr.w	lr, [r3, #22]
 8008950:	f8d3 c01a 	ldr.w	ip, [r3, #26]
 8008954:	f8d3 201e 	ldr.w	r2, [r3, #30]
 8008958:	f8d3 3022 	ldr.w	r3, [r3, #34]	@ 0x22
 800895c:	f8c1 e008 	str.w	lr, [r1, #8]
 8008960:	f8c1 c00c 	str.w	ip, [r1, #12]
 8008964:	610a      	str	r2, [r1, #16]
 8008966:	614b      	str	r3, [r1, #20]
            pxSourceAddress->sin_family = ( uint8_t ) FREERTOS_AF_INET6;
 8008968:	230a      	movs	r3, #10
 800896a:	704b      	strb	r3, [r1, #1]
            pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
 800896c:	8e83      	ldrh	r3, [r0, #52]	@ 0x34
 800896e:	804b      	strh	r3, [r1, #2]
        uxPayloadOffset = ipUDP_PAYLOAD_OFFSET_IPv6;
 8008970:	203e      	movs	r0, #62	@ 0x3e
}
 8008972:	f85d fb04 	ldr.w	pc, [sp], #4
        uxPayloadOffset = ipUDP_PAYLOAD_OFFSET_IPv6;
 8008976:	203e      	movs	r0, #62	@ 0x3e
}
 8008978:	4770      	bx	lr

0800897a <cHexToChar>:
    if( usValue <= 9U )
 800897a:	2809      	cmp	r0, #9
 800897c:	d803      	bhi.n	8008986 <cHexToChar+0xc>
        cReturn = ( char ) ( cReturn + usValue );
 800897e:	b2c0      	uxtb	r0, r0
 8008980:	3030      	adds	r0, #48	@ 0x30
 8008982:	b2c0      	uxtb	r0, r0
 8008984:	4770      	bx	lr
    else if( usValue <= 15U )
 8008986:	280f      	cmp	r0, #15
 8008988:	d803      	bhi.n	8008992 <cHexToChar+0x18>
        cReturn = ( char ) ( cReturn + ( usValue - ( uint16_t ) 10 ) );
 800898a:	b2c0      	uxtb	r0, r0
 800898c:	3057      	adds	r0, #87	@ 0x57
 800898e:	b2c0      	uxtb	r0, r0
}
 8008990:	4770      	bx	lr
 8008992:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008996:	f383 8811 	msr	BASEPRI, r3
 800899a:	f3bf 8f6f 	isb	sy
 800899e:	f3bf 8f4f 	dsb	sy
        configASSERT( 0 == 1 );
 80089a2:	e7fe      	b.n	80089a2 <cHexToChar+0x28>

080089a4 <uxHexPrintShort>:
{
 80089a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80089a8:	4681      	mov	r9, r0
 80089aa:	4688      	mov	r8, r1
 80089ac:	4614      	mov	r4, r2
    BaseType_t xHadNonZero = pdFALSE;
 80089ae:	2700      	movs	r7, #0
    socklen_t uxIndex = 0U;
 80089b0:	463e      	mov	r6, r7
    for( uxNibble = 0; uxNibble < uxNibbleCount; uxNibble++ )
 80089b2:	463d      	mov	r5, r7
 80089b4:	e00c      	b.n	80089d0 <uxHexPrintShort+0x2c>
            xHadNonZero = pdTRUE;
 80089b6:	2701      	movs	r7, #1
            if( uxIndex >= ( uxBufferSize - 1U ) )
 80089b8:	f108 33ff 	add.w	r3, r8, #4294967295
 80089bc:	42b3      	cmp	r3, r6
 80089be:	d910      	bls.n	80089e2 <uxHexPrintShort+0x3e>
            pcBuffer[ uxIndex ] = cHexToChar( usNibble );
 80089c0:	f7ff ffdb 	bl	800897a <cHexToChar>
 80089c4:	f809 0006 	strb.w	r0, [r9, r6]
            uxIndex++;
 80089c8:	3601      	adds	r6, #1
        usShifter = ( uint16_t ) ( usShifter << 4 );
 80089ca:	0124      	lsls	r4, r4, #4
 80089cc:	b2a4      	uxth	r4, r4
    for( uxNibble = 0; uxNibble < uxNibbleCount; uxNibble++ )
 80089ce:	3501      	adds	r5, #1
 80089d0:	2d03      	cmp	r5, #3
 80089d2:	d806      	bhi.n	80089e2 <uxHexPrintShort+0x3e>
        if( usNibble != 0U )
 80089d4:	0b20      	lsrs	r0, r4, #12
 80089d6:	d1ee      	bne.n	80089b6 <uxHexPrintShort+0x12>
        if( ( xHadNonZero != pdFALSE ) || ( uxNibble == ( uxNibbleCount - 1U ) ) )
 80089d8:	2f00      	cmp	r7, #0
 80089da:	d1ed      	bne.n	80089b8 <uxHexPrintShort+0x14>
 80089dc:	2d03      	cmp	r5, #3
 80089de:	d1f4      	bne.n	80089ca <uxHexPrintShort+0x26>
 80089e0:	e7ea      	b.n	80089b8 <uxHexPrintShort+0x14>
}
 80089e2:	4630      	mov	r0, r6
 80089e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080089e8 <prv_ntop6_write_short>:
 *       null-terminated later on.
 */
static BaseType_t prv_ntop6_write_short( char * pcDestination,
                                         size_t uxSize,
                                         struct sNTOP6_Set * pxSet )
{
 80089e8:	b510      	push	{r4, lr}
 80089ea:	4614      	mov	r4, r2
    socklen_t uxLength;
    BaseType_t xReturn = pdPASS;
    const size_t uxBytesPerShortValue = 4U;

    if( pxSet->xIndex > 0 )
 80089ec:	68d3      	ldr	r3, [r2, #12]
 80089ee:	2b00      	cmp	r3, #0
 80089f0:	dd08      	ble.n	8008a04 <prv_ntop6_write_short+0x1c>
    {
        if( pxSet->uxTargetIndex >= ( uxSize - 1U ) )
 80089f2:	6913      	ldr	r3, [r2, #16]
 80089f4:	1e4a      	subs	r2, r1, #1
 80089f6:	4293      	cmp	r3, r2
 80089f8:	d21b      	bcs.n	8008a32 <prv_ntop6_write_short+0x4a>
        {
            xReturn = pdFAIL;
        }
        else
        {
            pcDestination[ pxSet->uxTargetIndex ] = ':';
 80089fa:	223a      	movs	r2, #58	@ 0x3a
 80089fc:	54c2      	strb	r2, [r0, r3]
            pxSet->uxTargetIndex++;
 80089fe:	6923      	ldr	r3, [r4, #16]
 8008a00:	3301      	adds	r3, #1
 8008a02:	6123      	str	r3, [r4, #16]
    }

    if( xReturn == pdPASS )
    {
        /* If there is enough space to write a short. */
        if( pxSet->uxTargetIndex <= ( uxSize - uxBytesPerShortValue ) )
 8008a04:	6923      	ldr	r3, [r4, #16]
 8008a06:	3904      	subs	r1, #4
 8008a08:	428b      	cmp	r3, r1
 8008a0a:	d901      	bls.n	8008a10 <prv_ntop6_write_short+0x28>
            /* uxLength will be non zero and positive always. */
            pxSet->uxTargetIndex += uxLength;
        }
        else
        {
            xReturn = pdFAIL;
 8008a0c:	2000      	movs	r0, #0
        }
    }

    return xReturn;
}
 8008a0e:	bd10      	pop	{r4, pc}
                                        FreeRTOS_ntohs( pxSet->pusAddress[ pxSet->xIndex ] ) );
 8008a10:	6822      	ldr	r2, [r4, #0]
 8008a12:	68e1      	ldr	r1, [r4, #12]
 8008a14:	f832 1011 	ldrh.w	r1, [r2, r1, lsl #1]
            uxLength = uxHexPrintShort( &( pcDestination[ pxSet->uxTargetIndex ] ),
 8008a18:	020a      	lsls	r2, r1, #8
 8008a1a:	ea42 2211 	orr.w	r2, r2, r1, lsr #8
 8008a1e:	b292      	uxth	r2, r2
 8008a20:	2105      	movs	r1, #5
 8008a22:	4418      	add	r0, r3
 8008a24:	f7ff ffbe 	bl	80089a4 <uxHexPrintShort>
            pxSet->uxTargetIndex += uxLength;
 8008a28:	6923      	ldr	r3, [r4, #16]
 8008a2a:	4403      	add	r3, r0
 8008a2c:	6123      	str	r3, [r4, #16]
 8008a2e:	2001      	movs	r0, #1
 8008a30:	e7ed      	b.n	8008a0e <prv_ntop6_write_short+0x26>
            xReturn = pdFAIL;
 8008a32:	2000      	movs	r0, #0
 8008a34:	e7eb      	b.n	8008a0e <prv_ntop6_write_short+0x26>

08008a36 <prv_ntop6_search_zeros>:
{
 8008a36:	b410      	push	{r4}
    pxSet->xZeroStart = -1;
 8008a38:	f04f 33ff 	mov.w	r3, #4294967295
 8008a3c:	6043      	str	r3, [r0, #4]
    BaseType_t xCurLength = 0;        /* The number of zero's seen so far. */
 8008a3e:	2200      	movs	r2, #0
    BaseType_t xCurStart = 0;         /* The position of the first zero found so far. */
 8008a40:	4614      	mov	r4, r2
    BaseType_t xIndex = 0;            /* The index in the IPv6 address: 0..7. */
 8008a42:	4613      	mov	r3, r2
    for( ; xIndex < xShortCount; xIndex++ )
 8008a44:	e003      	b.n	8008a4e <prv_ntop6_search_zeros+0x18>
            xCurLength++;
 8008a46:	3201      	adds	r2, #1
        if( ( usValue != 0U ) || ( xIndex == ( xShortCount - 1 ) ) )
 8008a48:	2b07      	cmp	r3, #7
 8008a4a:	d00a      	beq.n	8008a62 <prv_ntop6_search_zeros+0x2c>
    for( ; xIndex < xShortCount; xIndex++ )
 8008a4c:	3301      	adds	r3, #1
 8008a4e:	2b07      	cmp	r3, #7
 8008a50:	dc14      	bgt.n	8008a7c <prv_ntop6_search_zeros+0x46>
        uint16_t usValue = pxSet->pusAddress[ xIndex ];
 8008a52:	6801      	ldr	r1, [r0, #0]
 8008a54:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
        if( usValue == 0U )
 8008a58:	b919      	cbnz	r1, 8008a62 <prv_ntop6_search_zeros+0x2c>
            if( xCurLength == 0 )
 8008a5a:	2a00      	cmp	r2, #0
 8008a5c:	d1f3      	bne.n	8008a46 <prv_ntop6_search_zeros+0x10>
                xCurStart = xIndex;
 8008a5e:	461c      	mov	r4, r3
 8008a60:	e7f1      	b.n	8008a46 <prv_ntop6_search_zeros+0x10>
            if( ( xCurLength > 1 ) && ( pxSet->xZeroLength < xCurLength ) )
 8008a62:	2a01      	cmp	r2, #1
 8008a64:	dd06      	ble.n	8008a74 <prv_ntop6_search_zeros+0x3e>
 8008a66:	6881      	ldr	r1, [r0, #8]
 8008a68:	4291      	cmp	r1, r2
 8008a6a:	da05      	bge.n	8008a78 <prv_ntop6_search_zeros+0x42>
                pxSet->xZeroLength = xCurLength;
 8008a6c:	6082      	str	r2, [r0, #8]
                pxSet->xZeroStart = xCurStart;
 8008a6e:	6044      	str	r4, [r0, #4]
            xCurLength = 0;
 8008a70:	2200      	movs	r2, #0
 8008a72:	e7eb      	b.n	8008a4c <prv_ntop6_search_zeros+0x16>
 8008a74:	2200      	movs	r2, #0
 8008a76:	e7e9      	b.n	8008a4c <prv_ntop6_search_zeros+0x16>
 8008a78:	2200      	movs	r2, #0
 8008a7a:	e7e7      	b.n	8008a4c <prv_ntop6_search_zeros+0x16>
}
 8008a7c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008a80:	4770      	bx	lr

08008a82 <FreeRTOS_inet_ntop6>:
 * @return pdPASS if the translation was successful or else pdFAIL.
 */
const char * FreeRTOS_inet_ntop6( const void * pvSource,
                                  char * pcDestination,
                                  socklen_t uxSize )
{
 8008a82:	b530      	push	{r4, r5, lr}
 8008a84:	b087      	sub	sp, #28
 8008a86:	460c      	mov	r4, r1
    const char * pcReturn;  /* The return value, which is either 'pcDestination' or NULL. */
    struct sNTOP6_Set xSet; /* A set of values for easy exchange with the helper functions prv_ntop6_xxx(). */

    ( void ) memset( &( xSet ), 0, sizeof( xSet ) );
 8008a88:	2300      	movs	r3, #0
 8008a8a:	9301      	str	r3, [sp, #4]
 8008a8c:	9302      	str	r3, [sp, #8]
 8008a8e:	9303      	str	r3, [sp, #12]
 8008a90:	9304      	str	r3, [sp, #16]
 8008a92:	9305      	str	r3, [sp, #20]

    xSet.pusAddress = pvSource;
 8008a94:	9001      	str	r0, [sp, #4]

    if( uxSize < 3U )
 8008a96:	2a02      	cmp	r2, #2
 8008a98:	d808      	bhi.n	8008aac <FreeRTOS_inet_ntop6+0x2a>
                xSet.xIndex++;
            }
        }
    }

    if( xSet.xIndex < 8 )
 8008a9a:	9b04      	ldr	r3, [sp, #16]
 8008a9c:	2b07      	cmp	r3, #7
 8008a9e:	dd26      	ble.n	8008aee <FreeRTOS_inet_ntop6+0x6c>
        /* Didn't reach the last nibble: clear the string. */
        pcReturn = NULL;
    }
    else
    {
        pcDestination[ xSet.uxTargetIndex ] = '\0';
 8008aa0:	9b05      	ldr	r3, [sp, #20]
 8008aa2:	2200      	movs	r2, #0
 8008aa4:	54e2      	strb	r2, [r4, r3]
        pcReturn = pcDestination;
 8008aa6:	4620      	mov	r0, r4
    }

    return pcReturn;
}
 8008aa8:	b007      	add	sp, #28
 8008aaa:	bd30      	pop	{r4, r5, pc}
 8008aac:	4615      	mov	r5, r2
        prv_ntop6_search_zeros( &( xSet ) );
 8008aae:	a801      	add	r0, sp, #4
 8008ab0:	f7ff ffc1 	bl	8008a36 <prv_ntop6_search_zeros>
        while( xSet.xIndex < 8 )
 8008ab4:	e00a      	b.n	8008acc <FreeRTOS_inet_ntop6+0x4a>
                if( prv_ntop6_write_zeros( pcDestination, uxSize, &( xSet ) ) == pdFAIL )
 8008ab6:	aa01      	add	r2, sp, #4
 8008ab8:	4629      	mov	r1, r5
 8008aba:	4620      	mov	r0, r4
 8008abc:	f7ff fec6 	bl	800884c <prv_ntop6_write_zeros>
 8008ac0:	2800      	cmp	r0, #0
 8008ac2:	d0ea      	beq.n	8008a9a <FreeRTOS_inet_ntop6+0x18>
                xSet.xIndex += xSet.xZeroLength;
 8008ac4:	9b04      	ldr	r3, [sp, #16]
 8008ac6:	9a03      	ldr	r2, [sp, #12]
 8008ac8:	4413      	add	r3, r2
 8008aca:	9304      	str	r3, [sp, #16]
        while( xSet.xIndex < 8 )
 8008acc:	9b04      	ldr	r3, [sp, #16]
 8008ace:	2b07      	cmp	r3, #7
 8008ad0:	dce3      	bgt.n	8008a9a <FreeRTOS_inet_ntop6+0x18>
            if( xSet.xIndex == xSet.xZeroStart )
 8008ad2:	9802      	ldr	r0, [sp, #8]
 8008ad4:	4298      	cmp	r0, r3
 8008ad6:	d0ee      	beq.n	8008ab6 <FreeRTOS_inet_ntop6+0x34>
                if( prv_ntop6_write_short( pcDestination, uxSize, &( xSet ) ) == pdFAIL )
 8008ad8:	aa01      	add	r2, sp, #4
 8008ada:	4629      	mov	r1, r5
 8008adc:	4620      	mov	r0, r4
 8008ade:	f7ff ff83 	bl	80089e8 <prv_ntop6_write_short>
 8008ae2:	2800      	cmp	r0, #0
 8008ae4:	d0d9      	beq.n	8008a9a <FreeRTOS_inet_ntop6+0x18>
                xSet.xIndex++;
 8008ae6:	9b04      	ldr	r3, [sp, #16]
 8008ae8:	3301      	adds	r3, #1
 8008aea:	9304      	str	r3, [sp, #16]
 8008aec:	e7ee      	b.n	8008acc <FreeRTOS_inet_ntop6+0x4a>
        pcReturn = NULL;
 8008aee:	2000      	movs	r0, #0
    return pcReturn;
 8008af0:	e7da      	b.n	8008aa8 <FreeRTOS_inet_ntop6+0x26>

08008af2 <vSetMultiCastIPv6MacAddress>:
 * @param[out] pxMACAddress Pointer to MAC address.
 */
void vSetMultiCastIPv6MacAddress( const IPv6_Address_t * pxAddress,
                                  MACAddress_t * pxMACAddress )
{
    pxMACAddress->ucBytes[ 0 ] = 0x33U;
 8008af2:	2333      	movs	r3, #51	@ 0x33
 8008af4:	700b      	strb	r3, [r1, #0]
    pxMACAddress->ucBytes[ 1 ] = 0x33U;
 8008af6:	704b      	strb	r3, [r1, #1]
    pxMACAddress->ucBytes[ 2 ] = pxAddress->ucBytes[ 12 ];
 8008af8:	7b03      	ldrb	r3, [r0, #12]
 8008afa:	708b      	strb	r3, [r1, #2]
    pxMACAddress->ucBytes[ 3 ] = pxAddress->ucBytes[ 13 ];
 8008afc:	7b43      	ldrb	r3, [r0, #13]
 8008afe:	70cb      	strb	r3, [r1, #3]
    pxMACAddress->ucBytes[ 4 ] = pxAddress->ucBytes[ 14 ];
 8008b00:	7b83      	ldrb	r3, [r0, #14]
 8008b02:	710b      	strb	r3, [r1, #4]
    pxMACAddress->ucBytes[ 5 ] = pxAddress->ucBytes[ 15 ];
 8008b04:	7bc3      	ldrb	r3, [r0, #15]
 8008b06:	714b      	strb	r3, [r1, #5]
}
 8008b08:	4770      	bx	lr
	...

08008b0c <prvChecksumICMPv6Checks>:
                                    struct xPacketSummary * pxSet )
{
    BaseType_t xReturn = 0;
    size_t xICMPLength;

    switch( pxSet->pxProtocolHeaders->xICMPHeaderIPv6.ucTypeOfMessage )
 8008b0c:	69cb      	ldr	r3, [r1, #28]
 8008b0e:	781b      	ldrb	r3, [r3, #0]
 8008b10:	2b81      	cmp	r3, #129	@ 0x81
 8008b12:	d80c      	bhi.n	8008b2e <prvChecksumICMPv6Checks+0x22>
 8008b14:	2b80      	cmp	r3, #128	@ 0x80
 8008b16:	d30e      	bcc.n	8008b36 <prvChecksumICMPv6Checks+0x2a>
 8008b18:	2208      	movs	r2, #8
        default:
            xICMPLength = ipSIZE_OF_ICMPv6_HEADER;
            break;
    }

    if( uxBufferLength < ( ipSIZE_OF_ETH_HEADER + pxSet->uxIPHeaderLength + xICMPLength ) )
 8008b1a:	68cb      	ldr	r3, [r1, #12]
 8008b1c:	4413      	add	r3, r2
 8008b1e:	330e      	adds	r3, #14
 8008b20:	4283      	cmp	r3, r0
 8008b22:	d80c      	bhi.n	8008b3e <prvChecksumICMPv6Checks+0x32>
        xReturn = 10;
    }

    if( xReturn == 0 )
    {
        pxSet->uxProtocolHeaderLength = xICMPLength;
 8008b24:	610a      	str	r2, [r1, #16]
        #if ( ipconfigHAS_DEBUG_PRINTF != 0 )
        {
            pxSet->pcType = "ICMP_IPv6";
 8008b26:	4b08      	ldr	r3, [pc, #32]	@ (8008b48 <prvChecksumICMPv6Checks+0x3c>)
 8008b28:	608b      	str	r3, [r1, #8]
    BaseType_t xReturn = 0;
 8008b2a:	2000      	movs	r0, #0
 8008b2c:	4770      	bx	lr
    switch( pxSet->pxProtocolHeaders->xICMPHeaderIPv6.ucTypeOfMessage )
 8008b2e:	2b85      	cmp	r3, #133	@ 0x85
 8008b30:	d103      	bne.n	8008b3a <prvChecksumICMPv6Checks+0x2e>
 8008b32:	2208      	movs	r2, #8
 8008b34:	e7f1      	b.n	8008b1a <prvChecksumICMPv6Checks+0xe>
            xICMPLength = ipSIZE_OF_ICMPv6_HEADER;
 8008b36:	2218      	movs	r2, #24
 8008b38:	e7ef      	b.n	8008b1a <prvChecksumICMPv6Checks+0xe>
 8008b3a:	2218      	movs	r2, #24
 8008b3c:	e7ed      	b.n	8008b1a <prvChecksumICMPv6Checks+0xe>
        pxSet->usChecksum = ipINVALID_LENGTH;
 8008b3e:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008b42:	828b      	strh	r3, [r1, #20]
        xReturn = 10;
 8008b44:	200a      	movs	r0, #10
        }
        #endif /* ipconfigHAS_DEBUG_PRINTF != 0 */
    }

    return xReturn;
}
 8008b46:	4770      	bx	lr
 8008b48:	080101dc 	.word	0x080101dc

08008b4c <usGetExtensionHeaderLength>:
 * @return The total length of all extension headers, or whole buffer length when error detected.
 */
size_t usGetExtensionHeaderLength( const uint8_t * pucEthernetBuffer,
                                   size_t uxBufferLength,
                                   uint8_t * pucProtocol )
{
 8008b4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008b50:	460e      	mov	r6, r1
    size_t uxHopSize = 0U;
    BaseType_t xCurrentOrder = 0;
    BaseType_t xNextOrder = 0;
    size_t uxReturn = uxBufferLength;

    if( ( pucEthernetBuffer != NULL ) && ( pucProtocol != NULL ) )
 8008b52:	b3a8      	cbz	r0, 8008bc0 <usGetExtensionHeaderLength+0x74>
 8008b54:	4690      	mov	r8, r2
 8008b56:	4607      	mov	r7, r0
 8008b58:	b392      	cbz	r2, 8008bc0 <usGetExtensionHeaderLength+0x74>
    {
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxIPPacket_IPv6 = ( ( const IPPacket_IPv6_t * ) pucEthernetBuffer );
        ucCurrentHeader = pxIPPacket_IPv6->xIPHeader.ucNextHeader;
 8008b5a:	f890 9014 	ldrb.w	r9, [r0, #20]

        /* Check if packet has extension header. */
        if( xGetExtensionOrder( ucCurrentHeader, 0U ) > 0 )
 8008b5e:	2100      	movs	r1, #0
 8008b60:	4648      	mov	r0, r9
 8008b62:	f7ff fe01 	bl	8008768 <xGetExtensionOrder>
 8008b66:	2800      	cmp	r0, #0
 8008b68:	dd27      	ble.n	8008bba <usGetExtensionHeaderLength+0x6e>
    size_t uxIndex = ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER;
 8008b6a:	2436      	movs	r4, #54	@ 0x36
        {
            while( ( uxIndex + 8U ) < uxBufferLength )
 8008b6c:	f104 0308 	add.w	r3, r4, #8
 8008b70:	42b3      	cmp	r3, r6
 8008b72:	d225      	bcs.n	8008bc0 <usGetExtensionHeaderLength+0x74>
            {
                ucNextHeader = pucEthernetBuffer[ uxIndex ];
 8008b74:	eb07 0a04 	add.w	sl, r7, r4
 8008b78:	5d3d      	ldrb	r5, [r7, r4]

                xCurrentOrder = xGetExtensionOrder( ucCurrentHeader, ucNextHeader );
 8008b7a:	4629      	mov	r1, r5
 8008b7c:	4648      	mov	r0, r9
 8008b7e:	f7ff fdf3 	bl	8008768 <xGetExtensionOrder>

                /* To avoid compile warning if debug print is disabled. */
                ( void ) xCurrentOrder;

                /* Read the length expressed in number of octets. */
                uxHopSize = ( size_t ) pucEthernetBuffer[ uxIndex + 1U ];
 8008b82:	f89a 3001 	ldrb.w	r3, [sl, #1]
                /* And multiply by 8 and add the minimum size of 8. */
                uxHopSize = ( uxHopSize * 8U ) + 8U;
 8008b86:	3301      	adds	r3, #1

                if( ( uxIndex + uxHopSize ) >= uxBufferLength )
 8008b88:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 8008b8c:	42b4      	cmp	r4, r6
 8008b8e:	d217      	bcs.n	8008bc0 <usGetExtensionHeaderLength+0x74>
                    break;
                }

                uxIndex = uxIndex + uxHopSize;

                if( ( ucNextHeader == ipPROTOCOL_TCP ) ||
 8008b90:	2d06      	cmp	r5, #6
 8008b92:	d00d      	beq.n	8008bb0 <usGetExtensionHeaderLength+0x64>
 8008b94:	2d11      	cmp	r5, #17
 8008b96:	d00b      	beq.n	8008bb0 <usGetExtensionHeaderLength+0x64>
                    ( ucNextHeader == ipPROTOCOL_UDP ) ||
 8008b98:	2d3a      	cmp	r5, #58	@ 0x3a
 8008b9a:	d009      	beq.n	8008bb0 <usGetExtensionHeaderLength+0x64>
                    uxReturn = uxIndex - ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER );
                    *pucProtocol = ucNextHeader;
                    break;
                }

                xNextOrder = xGetExtensionOrder( ucNextHeader, pucEthernetBuffer[ uxIndex ] );
 8008b9c:	5d39      	ldrb	r1, [r7, r4]
 8008b9e:	4628      	mov	r0, r5
 8008ba0:	f7ff fde2 	bl	8008768 <xGetExtensionOrder>
                 * any order and occurring any number of times in the same packet,
                 * except for the Hop-by-Hop Options header which is restricted to
                 * appear immediately after an IPv6 header only. Outlined
                 * by RFC 2460 section 4.1  Extension Header Order.
                 */
                if( xNextOrder == 1 ) /* ipIPv6_EXT_HEADER_HOP_BY_HOP */
 8008ba4:	2801      	cmp	r0, #1
 8008ba6:	d00b      	beq.n	8008bc0 <usGetExtensionHeaderLength+0x74>
                {
                    FreeRTOS_printf( ( "Wrong order. Hop-by-Hop Options header restricted to appear immediately after an IPv6 header\n" ) );
                    break;
                }
                else if( xNextOrder < 0 )
 8008ba8:	2800      	cmp	r0, #0
 8008baa:	db09      	blt.n	8008bc0 <usGetExtensionHeaderLength+0x74>
                else
                {
                    /* Do nothing, coverity happy. */
                }

                ucCurrentHeader = ucNextHeader;
 8008bac:	46a9      	mov	r9, r5
 8008bae:	e7dd      	b.n	8008b6c <usGetExtensionHeaderLength+0x20>
                    uxReturn = uxIndex - ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER );
 8008bb0:	f1a4 0636 	sub.w	r6, r4, #54	@ 0x36
                    *pucProtocol = ucNextHeader;
 8008bb4:	f888 5000 	strb.w	r5, [r8]
                    break;
 8008bb8:	e002      	b.n	8008bc0 <usGetExtensionHeaderLength+0x74>
            }
        }
        else
        {
            /* No extension headers. */
            *pucProtocol = ucCurrentHeader;
 8008bba:	f888 9000 	strb.w	r9, [r8]
            uxReturn = 0;
 8008bbe:	2600      	movs	r6, #0
        }
    }

    return uxReturn;
}
 8008bc0:	4630      	mov	r0, r6
 8008bc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08008bc6 <prvChecksumIPv6Checks>:
{
 8008bc6:	b570      	push	{r4, r5, r6, lr}
 8008bc8:	4614      	mov	r4, r2
    pxSet->xIsIPv6 = pdTRUE;
 8008bca:	2301      	movs	r3, #1
 8008bcc:	6013      	str	r3, [r2, #0]
    pxSet->uxIPHeaderLength = ipSIZE_OF_IPv6_HEADER;
 8008bce:	2328      	movs	r3, #40	@ 0x28
 8008bd0:	60d3      	str	r3, [r2, #12]
    if( uxBufferLength < sizeof( IPPacket_IPv6_t ) )
 8008bd2:	2935      	cmp	r1, #53	@ 0x35
 8008bd4:	d804      	bhi.n	8008be0 <prvChecksumIPv6Checks+0x1a>
        pxSet->usChecksum = ipINVALID_LENGTH;
 8008bd6:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008bda:	8293      	strh	r3, [r2, #20]
        xReturn = 1;
 8008bdc:	2001      	movs	r0, #1
}
 8008bde:	bd70      	pop	{r4, r5, r6, pc}
 8008be0:	4606      	mov	r6, r0
 8008be2:	460d      	mov	r5, r1
        uxExtensionHeaderLength = usGetExtensionHeaderLength( pucEthernetBuffer, uxBufferLength, &pxSet->ucProtocol );
 8008be4:	3216      	adds	r2, #22
 8008be6:	f7ff ffb1 	bl	8008b4c <usGetExtensionHeaderLength>
        if( uxExtensionHeaderLength >= uxBufferLength )
 8008bea:	4285      	cmp	r5, r0
 8008bec:	d911      	bls.n	8008c12 <prvChecksumIPv6Checks+0x4c>
            pxSet->pxProtocolHeaders = ( ( ProtocolHeaders_t * ) &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + uxExtensionHeaderLength ] ) );
 8008bee:	f100 0336 	add.w	r3, r0, #54	@ 0x36
 8008bf2:	441e      	add	r6, r3
 8008bf4:	61e6      	str	r6, [r4, #28]
            pxSet->usPayloadLength = FreeRTOS_ntohs( pxSet->pxIPPacket_IPv6->usPayloadLength );
 8008bf6:	6863      	ldr	r3, [r4, #4]
 8008bf8:	889a      	ldrh	r2, [r3, #4]
 8008bfa:	0213      	lsls	r3, r2, #8
 8008bfc:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 8008c00:	b29b      	uxth	r3, r3
 8008c02:	8423      	strh	r3, [r4, #32]
            pxSet->usProtocolBytes = ( uint16_t ) ( pxSet->usPayloadLength - uxExtensionHeaderLength );
 8008c04:	1a18      	subs	r0, r3, r0
 8008c06:	8460      	strh	r0, [r4, #34]	@ 0x22
            uxNeeded += ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER;
 8008c08:	3336      	adds	r3, #54	@ 0x36
            if( uxBufferLength < uxNeeded )
 8008c0a:	429d      	cmp	r5, r3
 8008c0c:	d306      	bcc.n	8008c1c <prvChecksumIPv6Checks+0x56>
    BaseType_t xReturn = 0;
 8008c0e:	2000      	movs	r0, #0
    return xReturn;
 8008c10:	e7e5      	b.n	8008bde <prvChecksumIPv6Checks+0x18>
            pxSet->usChecksum = ipINVALID_LENGTH;
 8008c12:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008c16:	82a3      	strh	r3, [r4, #20]
            xReturn = 3;
 8008c18:	2003      	movs	r0, #3
 8008c1a:	e7e0      	b.n	8008bde <prvChecksumIPv6Checks+0x18>
                pxSet->usChecksum = ipINVALID_LENGTH;
 8008c1c:	f241 2334 	movw	r3, #4660	@ 0x1234
 8008c20:	82a3      	strh	r3, [r4, #20]
                xReturn = 2;
 8008c22:	2002      	movs	r0, #2
 8008c24:	e7db      	b.n	8008bde <prvChecksumIPv6Checks+0x18>

08008c26 <vManageSolicitedNodeAddress>:
                                  BaseType_t xNetworkGoingUp )
{
    IPv6_Type_t xAddressType;
    MACAddress_t xMACAddress;

    configASSERT( pxEndPoint != NULL );
 8008c26:	b348      	cbz	r0, 8008c7c <vManageSolicitedNodeAddress+0x56>
{
 8008c28:	b530      	push	{r4, r5, lr}
 8008c2a:	b083      	sub	sp, #12
 8008c2c:	460d      	mov	r5, r1
 8008c2e:	4604      	mov	r4, r0
    configASSERT( pxEndPoint->pxNetworkInterface != NULL );
 8008c30:	f8d0 3158 	ldr.w	r3, [r0, #344]	@ 0x158
 8008c34:	b35b      	cbz	r3, 8008c8e <vManageSolicitedNodeAddress+0x68>
         * therefore the calculated MAC address will be incorrect. Nothing bad will happen though, because the address
         * type check below will kick us out before the call to pfRemoveAllowedMAC(). Without the check below, the network
         * driver ends up being called once to register 33:33:FF:00:00:00 and that MAC never gets unregistered. */

        /* Solicited-node multicast addresses only apply to normal unicast non-loopback addresses. */
        xAddressType = xIPv6_GetIPType( &( pxEndPoint->ipv6_settings.xIPAddress ) );
 8008c36:	3038      	adds	r0, #56	@ 0x38
 8008c38:	f000 ffe6 	bl	8009c08 <xIPv6_GetIPType>

        if( ( xAddressType != eIPv6_LinkLocal ) && ( xAddressType != eIPv6_SiteLocal ) && ( xAddressType != eIPv6_Global ) )
 8008c3c:	2802      	cmp	r0, #2
 8008c3e:	d81b      	bhi.n	8008c78 <vManageSolicitedNodeAddress+0x52>
             * solicited-node multicast address that we need to manage. Do nothing.*/
            break;
        }

        /* Calculate the multicast MAC that corresponds to this endpoint's IPv6 address. */
        xMACAddress.ucBytes[ 0 ] = ipMULTICAST_MAC_ADDRESS_IPv6_0;
 8008c40:	2333      	movs	r3, #51	@ 0x33
 8008c42:	f88d 3000 	strb.w	r3, [sp]
        xMACAddress.ucBytes[ 1 ] = ipMULTICAST_MAC_ADDRESS_IPv6_0;
 8008c46:	f88d 3001 	strb.w	r3, [sp, #1]
        xMACAddress.ucBytes[ 2 ] = 0xFFU;
 8008c4a:	23ff      	movs	r3, #255	@ 0xff
 8008c4c:	f88d 3002 	strb.w	r3, [sp, #2]
        xMACAddress.ucBytes[ 3 ] = pxEndPoint->ipv6_settings.xIPAddress.ucBytes[ 13 ];
 8008c50:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8008c54:	f88d 3003 	strb.w	r3, [sp, #3]
        xMACAddress.ucBytes[ 4 ] = pxEndPoint->ipv6_settings.xIPAddress.ucBytes[ 14 ];
 8008c58:	f894 3046 	ldrb.w	r3, [r4, #70]	@ 0x46
 8008c5c:	f88d 3004 	strb.w	r3, [sp, #4]
        xMACAddress.ucBytes[ 5 ] = pxEndPoint->ipv6_settings.xIPAddress.ucBytes[ 15 ];
 8008c60:	f894 3047 	ldrb.w	r3, [r4, #71]	@ 0x47
 8008c64:	f88d 3005 	strb.w	r3, [sp, #5]

        /* Update the network driver filter */
        if( xNetworkGoingUp == pdTRUE )
 8008c68:	2d01      	cmp	r5, #1
 8008c6a:	d019      	beq.n	8008ca0 <vManageSolicitedNodeAddress+0x7a>
                pxEndPoint->pxNetworkInterface->pfAddAllowedMAC( pxEndPoint->pxNetworkInterface, xMACAddress.ucBytes );
            }
        }
        else
        {
            if( pxEndPoint->pxNetworkInterface->pfRemoveAllowedMAC != NULL )
 8008c6c:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
 8008c70:	6983      	ldr	r3, [r0, #24]
 8008c72:	b10b      	cbz	r3, 8008c78 <vManageSolicitedNodeAddress+0x52>
            {
                pxEndPoint->pxNetworkInterface->pfRemoveAllowedMAC( pxEndPoint->pxNetworkInterface, xMACAddress.ucBytes );
 8008c74:	4669      	mov	r1, sp
 8008c76:	4798      	blx	r3
            }
        }
    } while( pdFALSE );
}
 8008c78:	b003      	add	sp, #12
 8008c7a:	bd30      	pop	{r4, r5, pc}
 8008c7c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008c80:	f383 8811 	msr	BASEPRI, r3
 8008c84:	f3bf 8f6f 	isb	sy
 8008c88:	f3bf 8f4f 	dsb	sy
    configASSERT( pxEndPoint != NULL );
 8008c8c:	e7fe      	b.n	8008c8c <vManageSolicitedNodeAddress+0x66>
 8008c8e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8008c92:	f383 8811 	msr	BASEPRI, r3
 8008c96:	f3bf 8f6f 	isb	sy
 8008c9a:	f3bf 8f4f 	dsb	sy
    configASSERT( pxEndPoint->pxNetworkInterface != NULL );
 8008c9e:	e7fe      	b.n	8008c9e <vManageSolicitedNodeAddress+0x78>
            if( pxEndPoint->pxNetworkInterface->pfAddAllowedMAC != NULL )
 8008ca0:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
 8008ca4:	6943      	ldr	r3, [r0, #20]
 8008ca6:	2b00      	cmp	r3, #0
 8008ca8:	d0e6      	beq.n	8008c78 <vManageSolicitedNodeAddress+0x52>
                pxEndPoint->pxNetworkInterface->pfAddAllowedMAC( pxEndPoint->pxNetworkInterface, xMACAddress.ucBytes );
 8008caa:	4669      	mov	r1, sp
 8008cac:	4798      	blx	r3
 8008cae:	e7e3      	b.n	8008c78 <vManageSolicitedNodeAddress+0x52>

08008cb0 <pxFindLocalEndpoint>:
 * @brief Find the first end-point of type IPv6.
 *
 * @return The first IPv6 end-point found.
 */
    static NetworkEndPoint_t * pxFindLocalEndpoint( void )
    {
 8008cb0:	b510      	push	{r4, lr}
        NetworkEndPoint_t * pxEndPoint;

        for( pxEndPoint = FreeRTOS_FirstEndPoint( NULL );
 8008cb2:	2000      	movs	r0, #0
 8008cb4:	f000 feb8 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8008cb8:	4604      	mov	r4, r0
 8008cba:	e004      	b.n	8008cc6 <pxFindLocalEndpoint+0x16>
             pxEndPoint != NULL;
             pxEndPoint = FreeRTOS_NextEndPoint( NULL, pxEndPoint ) )
 8008cbc:	4621      	mov	r1, r4
 8008cbe:	2000      	movs	r0, #0
 8008cc0:	f000 fec2 	bl	8009a48 <FreeRTOS_NextEndPoint>
 8008cc4:	4604      	mov	r4, r0
             pxEndPoint != NULL;
 8008cc6:	b154      	cbz	r4, 8008cde <pxFindLocalEndpoint+0x2e>
        {
            if( pxEndPoint->bits.bIPv6 == pdTRUE_UNSIGNED )
 8008cc8:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8008ccc:	f013 0f08 	tst.w	r3, #8
 8008cd0:	d0f4      	beq.n	8008cbc <pxFindLocalEndpoint+0xc>
            {
                IPv6_Type_t eType = xIPv6_GetIPType( &( pxEndPoint->ipv6_settings.xIPAddress ) );
 8008cd2:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 8008cd6:	f000 ff97 	bl	8009c08 <xIPv6_GetIPType>

                if( eType == eIPv6_LinkLocal )
 8008cda:	2801      	cmp	r0, #1
 8008cdc:	d1ee      	bne.n	8008cbc <pxFindLocalEndpoint+0xc>
                }
            }
        }

        return pxEndPoint;
    }
 8008cde:	4620      	mov	r0, r4
 8008ce0:	bd10      	pop	{r4, pc}

08008ce2 <prvMACResolve>:
 * @return An enum, either eARPCacheHit or eARPCacheMiss.
 */
    static eARPLookupResult_t prvMACResolve( const IPv6_Address_t * pxAddressToLookup,
                                             MACAddress_t * const pxMACAddress,
                                             NetworkEndPoint_t ** ppxEndPoint )
    {
 8008ce2:	b570      	push	{r4, r5, r6, lr}
 8008ce4:	4605      	mov	r5, r0
 8008ce6:	460e      	mov	r6, r1
 8008ce8:	4614      	mov	r4, r2
        eARPLookupResult_t eReturn;

        /* Mostly used multi-cast address is ff02::. */
        if( xIsIPv6AllowedMulticast( pxAddressToLookup ) != pdFALSE )
 8008cea:	f7ff fc87 	bl	80085fc <xIsIPv6AllowedMulticast>
 8008cee:	b908      	cbnz	r0, 8008cf4 <prvMACResolve+0x12>
            eReturn = eARPCacheHit;
        }
        else
        {
            /* Not a multicast IP address. */
            eReturn = eARPCacheMiss;
 8008cf0:	2000      	movs	r0, #0
        }

        return eReturn;
    }
 8008cf2:	bd70      	pop	{r4, r5, r6, pc}
            vSetMultiCastIPv6MacAddress( pxAddressToLookup, pxMACAddress );
 8008cf4:	4631      	mov	r1, r6
 8008cf6:	4628      	mov	r0, r5
 8008cf8:	f7ff fefb 	bl	8008af2 <vSetMultiCastIPv6MacAddress>
            if( ppxEndPoint != NULL )
 8008cfc:	b124      	cbz	r4, 8008d08 <prvMACResolve+0x26>
                *ppxEndPoint = pxFindLocalEndpoint();
 8008cfe:	f7ff ffd7 	bl	8008cb0 <pxFindLocalEndpoint>
 8008d02:	6020      	str	r0, [r4, #0]
            eReturn = eARPCacheHit;
 8008d04:	2001      	movs	r0, #1
 8008d06:	e7f4      	b.n	8008cf2 <prvMACResolve+0x10>
 8008d08:	2001      	movs	r0, #1
 8008d0a:	e7f2      	b.n	8008cf2 <prvMACResolve+0x10>

08008d0c <prvNDCacheLookup>:
 * @return An enum: either eARPCacheHit or eARPCacheMiss.
 */
    static eARPLookupResult_t prvNDCacheLookup( const IPv6_Address_t * pxAddressToLookup,
                                                MACAddress_t * const pxMACAddress,
                                                NetworkEndPoint_t ** ppxEndPoint )
    {
 8008d0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008d0e:	4605      	mov	r5, r0
 8008d10:	460f      	mov	r7, r1
 8008d12:	4616      	mov	r6, r2
        BaseType_t x;
        eARPLookupResult_t eReturn = eARPCacheMiss;

        /* For each entry in the ND cache table. */
        for( x = 0; x < ipconfigND_CACHE_ENTRIES; x++ )
 8008d14:	2400      	movs	r4, #0
 8008d16:	e000      	b.n	8008d1a <prvNDCacheLookup+0xe>
 8008d18:	3401      	adds	r4, #1
 8008d1a:	2c17      	cmp	r4, #23
 8008d1c:	dc1d      	bgt.n	8008d5a <prvNDCacheLookup+0x4e>
        {
            if( xNDCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8008d1e:	4b13      	ldr	r3, [pc, #76]	@ (8008d6c <prvNDCacheLookup+0x60>)
 8008d20:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8008d24:	7f5b      	ldrb	r3, [r3, #29]
 8008d26:	2b00      	cmp	r3, #0
 8008d28:	d0f6      	beq.n	8008d18 <prvNDCacheLookup+0xc>
            {
                /* Skip invalid entries. */
            }
            else if( memcmp( xNDCache[ x ].xIPAddress.ucBytes, pxAddressToLookup->ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 8008d2a:	2210      	movs	r2, #16
 8008d2c:	4629      	mov	r1, r5
 8008d2e:	480f      	ldr	r0, [pc, #60]	@ (8008d6c <prvNDCacheLookup+0x60>)
 8008d30:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 8008d34:	f005 ff94 	bl	800ec60 <memcmp>
 8008d38:	2800      	cmp	r0, #0
 8008d3a:	d1ed      	bne.n	8008d18 <prvNDCacheLookup+0xc>
            {
                ( void ) memcpy( pxMACAddress->ucBytes, xNDCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 8008d3c:	0163      	lsls	r3, r4, #5
 8008d3e:	3310      	adds	r3, #16
 8008d40:	4a0a      	ldr	r2, [pc, #40]	@ (8008d6c <prvNDCacheLookup+0x60>)
 8008d42:	1899      	adds	r1, r3, r2
 8008d44:	58d3      	ldr	r3, [r2, r3]
 8008d46:	603b      	str	r3, [r7, #0]
 8008d48:	888b      	ldrh	r3, [r1, #4]
 8008d4a:	80bb      	strh	r3, [r7, #4]
                eReturn = eARPCacheHit;

                if( ppxEndPoint != NULL )
 8008d4c:	b14e      	cbz	r6, 8008d62 <prvNDCacheLookup+0x56>
                {
                    *ppxEndPoint = xNDCache[ x ].pxEndPoint;
 8008d4e:	eb02 1344 	add.w	r3, r2, r4, lsl #5
 8008d52:	699b      	ldr	r3, [r3, #24]
 8008d54:	6033      	str	r3, [r6, #0]
                eReturn = eARPCacheHit;
 8008d56:	2001      	movs	r0, #1
 8008d58:	e002      	b.n	8008d60 <prvNDCacheLookup+0x54>

        if( eReturn == eARPCacheMiss )
        {
            FreeRTOS_printf( ( "prvNDCacheLookup %pip Miss\n", ( void * ) pxAddressToLookup->ucBytes ) );

            if( ppxEndPoint != NULL )
 8008d5a:	b126      	cbz	r6, 8008d66 <prvNDCacheLookup+0x5a>
            {
                *ppxEndPoint = NULL;
 8008d5c:	2000      	movs	r0, #0
 8008d5e:	6030      	str	r0, [r6, #0]
            }
        }

        return eReturn;
    }
 8008d60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                eReturn = eARPCacheHit;
 8008d62:	2001      	movs	r0, #1
 8008d64:	e7fc      	b.n	8008d60 <prvNDCacheLookup+0x54>
 8008d66:	2000      	movs	r0, #0
 8008d68:	e7fa      	b.n	8008d60 <prvNDCacheLookup+0x54>
 8008d6a:	bf00      	nop
 8008d6c:	2001340c 	.word	0x2001340c

08008d70 <prvReturnICMP_IPv6>:
 * @param[in] pxNetworkBuffer The Ethernet packet.
 * @param[in] uxICMPSize The number of bytes to be sent.
 */
    static void prvReturnICMP_IPv6( NetworkBufferDescriptor_t * const pxNetworkBuffer,
                                    size_t uxICMPSize )
    {
 8008d70:	b538      	push	{r3, r4, r5, lr}
 8008d72:	4604      	mov	r4, r0
        const NetworkEndPoint_t * pxEndPoint = pxNetworkBuffer->pxEndPoint;
 8008d74:	6b02      	ldr	r2, [r0, #48]	@ 0x30

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ICMPPacket_IPv6_t * pxICMPPacket = ( ( ICMPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 8008d76:	6a43      	ldr	r3, [r0, #36]	@ 0x24

        ( void ) memcpy( pxICMPPacket->xIPHeader.xDestinationAddress.ucBytes, pxICMPPacket->xIPHeader.xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8008d78:	f8d3 5016 	ldr.w	r5, [r3, #22]
 8008d7c:	f8d3 e01a 	ldr.w	lr, [r3, #26]
 8008d80:	f8d3 c01e 	ldr.w	ip, [r3, #30]
 8008d84:	f8d3 0022 	ldr.w	r0, [r3, #34]	@ 0x22
 8008d88:	f8c3 5026 	str.w	r5, [r3, #38]	@ 0x26
 8008d8c:	f8c3 e02a 	str.w	lr, [r3, #42]	@ 0x2a
 8008d90:	f8c3 c02e 	str.w	ip, [r3, #46]	@ 0x2e
 8008d94:	f8c3 0032 	str.w	r0, [r3, #50]	@ 0x32
        ( void ) memcpy( pxICMPPacket->xIPHeader.xSourceAddress.ucBytes, pxEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8008d98:	f8d2 e038 	ldr.w	lr, [r2, #56]	@ 0x38
 8008d9c:	f8d2 c03c 	ldr.w	ip, [r2, #60]	@ 0x3c
 8008da0:	6c10      	ldr	r0, [r2, #64]	@ 0x40
 8008da2:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 8008da4:	f8c3 e016 	str.w	lr, [r3, #22]
 8008da8:	f8c3 c01a 	str.w	ip, [r3, #26]
 8008dac:	f8c3 001e 	str.w	r0, [r3, #30]
 8008db0:	f8c3 2022 	str.w	r2, [r3, #34]	@ 0x22
        pxICMPPacket->xIPHeader.usPayloadLength = FreeRTOS_htons( uxICMPSize );
 8008db4:	020a      	lsls	r2, r1, #8
 8008db6:	b292      	uxth	r2, r2
 8008db8:	ea42 2211 	orr.w	r2, r2, r1, lsr #8
 8008dbc:	825a      	strh	r2, [r3, #18]

        /* Important: tell NIC driver how many bytes must be sent */
        pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + uxICMPSize );
 8008dbe:	3136      	adds	r1, #54	@ 0x36
 8008dc0:	62a1      	str	r1, [r4, #40]	@ 0x28

        #if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
        {
            /* calculate the ICMPv6 checksum for outgoing package */
            ( void ) usGenerateProtocolChecksum( pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength, pdTRUE );
 8008dc2:	2201      	movs	r2, #1
 8008dc4:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8008dc6:	f7ff f9bd 	bl	8008144 <usGenerateProtocolChecksum>
            pxICMPPacket->xICMPHeaderIPv6.usChecksum = 0;
        }
        #endif

        /* This function will fill in the Ethernet addresses and send the packet */
        vReturnEthernetFrame( pxNetworkBuffer, pdFALSE );
 8008dca:	2100      	movs	r1, #0
 8008dcc:	4620      	mov	r0, r4
 8008dce:	f7fe faff 	bl	80073d0 <vReturnEthernetFrame>
    }
 8008dd2:	bd38      	pop	{r3, r4, r5, pc}

08008dd4 <prvCheckWaitingBuffer>:
 * @brief When a neighbour advertisement has been received, check if 'pxARPWaitingNetworkBuffer'
 *        was waiting for this new address look-up. If so, feed it to the IP-task as a new
 *        incoming packet.
 */
    static void prvCheckWaitingBuffer( const IPv6_Address_t * pxIPv6Address )
    {
 8008dd4:	b510      	push	{r4, lr}
 8008dd6:	b082      	sub	sp, #8
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const IPPacket_IPv6_t * pxIPPacket = ( ( IPPacket_IPv6_t * ) pxARPWaitingNetworkBuffer->pucEthernetBuffer );
 8008dd8:	4b0f      	ldr	r3, [pc, #60]	@ (8008e18 <prvCheckWaitingBuffer+0x44>)
 8008dda:	681c      	ldr	r4, [r3, #0]
 8008ddc:	6a61      	ldr	r1, [r4, #36]	@ 0x24
        const IPHeader_IPv6_t * pxIPHeader = &( pxIPPacket->xIPHeader );

        if( memcmp( pxIPv6Address->ucBytes, pxIPHeader->xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 8008dde:	2210      	movs	r2, #16
 8008de0:	3116      	adds	r1, #22
 8008de2:	f005 ff3d 	bl	800ec60 <memcmp>
 8008de6:	b108      	cbz	r0, 8008dec <prvCheckWaitingBuffer+0x18>
            /* Found an ARP resolution, disable ARP resolution timer. */
            vIPSetARPResolutionTimerEnableState( pdFALSE );

            iptrace_DELAYED_ARP_REQUEST_REPLIED();
        }
    }
 8008de8:	b002      	add	sp, #8
 8008dea:	bd10      	pop	{r4, pc}
            xEventMessage.eEventType = eNetworkRxEvent;
 8008dec:	2301      	movs	r3, #1
 8008dee:	f88d 3000 	strb.w	r3, [sp]
            xEventMessage.pvData = ( void * ) pxARPWaitingNetworkBuffer;
 8008df2:	9401      	str	r4, [sp, #4]
            if( xSendEventStructToIPTask( &xEventMessage, xDontBlock ) != pdPASS )
 8008df4:	2100      	movs	r1, #0
 8008df6:	4668      	mov	r0, sp
 8008df8:	f7fe fa74 	bl	80072e4 <xSendEventStructToIPTask>
 8008dfc:	2801      	cmp	r0, #1
 8008dfe:	d105      	bne.n	8008e0c <prvCheckWaitingBuffer+0x38>
            pxARPWaitingNetworkBuffer = NULL;
 8008e00:	2000      	movs	r0, #0
 8008e02:	4b05      	ldr	r3, [pc, #20]	@ (8008e18 <prvCheckWaitingBuffer+0x44>)
 8008e04:	6018      	str	r0, [r3, #0]
            vIPSetARPResolutionTimerEnableState( pdFALSE );
 8008e06:	f7fe fe15 	bl	8007a34 <vIPSetARPResolutionTimerEnableState>
    }
 8008e0a:	e7ed      	b.n	8008de8 <prvCheckWaitingBuffer+0x14>
                vReleaseNetworkBufferAndDescriptor( BUFFER_FROM_WHERE_CALL( 140 ) pxARPWaitingNetworkBuffer );
 8008e0c:	4b02      	ldr	r3, [pc, #8]	@ (8008e18 <prvCheckWaitingBuffer+0x44>)
 8008e0e:	6818      	ldr	r0, [r3, #0]
 8008e10:	f005 fc46 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 8008e14:	e7f4      	b.n	8008e00 <prvCheckWaitingBuffer+0x2c>
 8008e16:	bf00      	nop
 8008e18:	200133b4 	.word	0x200133b4

08008e1c <eNDGetCacheEntry>:
    {
 8008e1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008e20:	4607      	mov	r7, r0
 8008e22:	460e      	mov	r6, r1
 8008e24:	4615      	mov	r5, r2
        eReturn = prvMACResolve( pxIPAddress, pxMACAddress, ppxEndPoint );
 8008e26:	f7ff ff5c 	bl	8008ce2 <prvMACResolve>
        if( eReturn == eARPCacheMiss )
 8008e2a:	4604      	mov	r4, r0
 8008e2c:	b110      	cbz	r0, 8008e34 <eNDGetCacheEntry+0x18>
    }
 8008e2e:	4620      	mov	r0, r4
 8008e30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            eReturn = prvNDCacheLookup( pxIPAddress, pxMACAddress, ppxEndPoint );
 8008e34:	462a      	mov	r2, r5
 8008e36:	4631      	mov	r1, r6
 8008e38:	4638      	mov	r0, r7
 8008e3a:	f7ff ff67 	bl	8008d0c <prvNDCacheLookup>
        if( eReturn == eARPCacheMiss )
 8008e3e:	4604      	mov	r4, r0
 8008e40:	2800      	cmp	r0, #0
 8008e42:	d1f4      	bne.n	8008e2e <eNDGetCacheEntry+0x12>
            IPv6_Type_t eIPType = xIPv6_GetIPType( pxIPAddress );
 8008e44:	4638      	mov	r0, r7
 8008e46:	f000 fedf 	bl	8009c08 <xIPv6_GetIPType>
 8008e4a:	4681      	mov	r9, r0
            pxEndPoint = FreeRTOS_FindEndPointOnIP_IPv6( pxIPAddress );
 8008e4c:	4638      	mov	r0, r7
 8008e4e:	f000 feaf 	bl	8009bb0 <FreeRTOS_FindEndPointOnIP_IPv6>
            if( pxEndPoint != NULL )
 8008e52:	b118      	cbz	r0, 8008e5c <eNDGetCacheEntry+0x40>
                if( ppxEndPoint != NULL )
 8008e54:	2d00      	cmp	r5, #0
 8008e56:	d0ea      	beq.n	8008e2e <eNDGetCacheEntry+0x12>
                    *( ppxEndPoint ) = pxEndPoint;
 8008e58:	6028      	str	r0, [r5, #0]
 8008e5a:	e7e8      	b.n	8008e2e <eNDGetCacheEntry+0x12>
                if( eIPType == eIPv6_LinkLocal )
 8008e5c:	f1b9 0f01 	cmp.w	r9, #1
 8008e60:	d019      	beq.n	8008e96 <eNDGetCacheEntry+0x7a>
                    pxEndPoint = FreeRTOS_FindGateWay( ( BaseType_t ) ipTYPE_IPv6 );
 8008e62:	2060      	movs	r0, #96	@ 0x60
 8008e64:	f000 feaa 	bl	8009bbc <FreeRTOS_FindGateWay>
                    if( pxEndPoint != NULL )
 8008e68:	4680      	mov	r8, r0
 8008e6a:	2800      	cmp	r0, #0
 8008e6c:	d0df      	beq.n	8008e2e <eNDGetCacheEntry+0x12>
                        ( void ) memcpy( pxIPAddress->ucBytes, pxEndPoint->ipv6_settings.xGatewayAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8008e6e:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
 8008e70:	f8d8 1060 	ldr.w	r1, [r8, #96]	@ 0x60
 8008e74:	f8d8 2064 	ldr.w	r2, [r8, #100]	@ 0x64
 8008e78:	f8d8 3068 	ldr.w	r3, [r8, #104]	@ 0x68
 8008e7c:	6038      	str	r0, [r7, #0]
 8008e7e:	6079      	str	r1, [r7, #4]
 8008e80:	60ba      	str	r2, [r7, #8]
 8008e82:	60fb      	str	r3, [r7, #12]
                        eReturn = prvNDCacheLookup( pxIPAddress, pxMACAddress, ppxEndPoint );
 8008e84:	462a      	mov	r2, r5
 8008e86:	4631      	mov	r1, r6
 8008e88:	4638      	mov	r0, r7
 8008e8a:	f7ff ff3f 	bl	8008d0c <prvNDCacheLookup>
 8008e8e:	4604      	mov	r4, r0
                        *( ppxEndPoint ) = pxEndPoint;
 8008e90:	f8c5 8000 	str.w	r8, [r5]
 8008e94:	e7cb      	b.n	8008e2e <eNDGetCacheEntry+0x12>
                    for( pxEndPoint = FreeRTOS_FirstEndPoint( NULL );
 8008e96:	2000      	movs	r0, #0
 8008e98:	f000 fdc6 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8008e9c:	4680      	mov	r8, r0
                         pxEndPoint != NULL;
 8008e9e:	f1b8 0f00 	cmp.w	r8, #0
 8008ea2:	d0c4      	beq.n	8008e2e <eNDGetCacheEntry+0x12>
                        IPv6_Type_t eMyType = xIPv6_GetIPType( &( pxEndPoint->ipv6_settings.xIPAddress ) );
 8008ea4:	f108 0038 	add.w	r0, r8, #56	@ 0x38
 8008ea8:	f000 feae 	bl	8009c08 <xIPv6_GetIPType>
                        if( eMyType == eIPType )
 8008eac:	4581      	cmp	r9, r0
 8008eae:	d005      	beq.n	8008ebc <eNDGetCacheEntry+0xa0>
                         pxEndPoint = FreeRTOS_NextEndPoint( NULL, pxEndPoint ) )
 8008eb0:	4641      	mov	r1, r8
 8008eb2:	2000      	movs	r0, #0
 8008eb4:	f000 fdc8 	bl	8009a48 <FreeRTOS_NextEndPoint>
 8008eb8:	4680      	mov	r8, r0
 8008eba:	e7f0      	b.n	8008e9e <eNDGetCacheEntry+0x82>
                            eReturn = prvNDCacheLookup( pxIPAddress, pxMACAddress, ppxEndPoint );
 8008ebc:	462a      	mov	r2, r5
 8008ebe:	4631      	mov	r1, r6
 8008ec0:	4638      	mov	r0, r7
 8008ec2:	f7ff ff23 	bl	8008d0c <prvNDCacheLookup>
 8008ec6:	4604      	mov	r4, r0
                            break;
 8008ec8:	e7b1      	b.n	8008e2e <eNDGetCacheEntry+0x12>
	...

08008ecc <vNDRefreshCacheEntry>:
    {
 8008ecc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008ed0:	4681      	mov	r9, r0
 8008ed2:	460d      	mov	r5, r1
 8008ed4:	4692      	mov	sl, r2
        BaseType_t xOldestEntry = 0;
 8008ed6:	f04f 0800 	mov.w	r8, #0
        uint16_t xOldestValue = ipconfigMAX_ARP_AGE + 1;
 8008eda:	2797      	movs	r7, #151	@ 0x97
        BaseType_t xFreeEntry = -1, xEntryFound = -1;
 8008edc:	f04f 36ff 	mov.w	r6, #4294967295
        for( x = 0; x < ipconfigND_CACHE_ENTRIES; x++ )
 8008ee0:	4644      	mov	r4, r8
 8008ee2:	e00e      	b.n	8008f02 <vNDRefreshCacheEntry+0x36>
            else if( memcmp( xNDCache[ x ].xIPAddress.ucBytes, pxIPAddress->ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 8008ee4:	2210      	movs	r2, #16
 8008ee6:	4629      	mov	r1, r5
 8008ee8:	4821      	ldr	r0, [pc, #132]	@ (8008f70 <vNDRefreshCacheEntry+0xa4>)
 8008eea:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 8008eee:	f005 feb7 	bl	800ec60 <memcmp>
 8008ef2:	b1c0      	cbz	r0, 8008f26 <vNDRefreshCacheEntry+0x5a>
                if( xNDCache[ x ].ucAge < xOldestValue )
 8008ef4:	4b1e      	ldr	r3, [pc, #120]	@ (8008f70 <vNDRefreshCacheEntry+0xa4>)
 8008ef6:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8008efa:	7f1b      	ldrb	r3, [r3, #28]
 8008efc:	42bb      	cmp	r3, r7
 8008efe:	d30d      	bcc.n	8008f1c <vNDRefreshCacheEntry+0x50>
        for( x = 0; x < ipconfigND_CACHE_ENTRIES; x++ )
 8008f00:	3401      	adds	r4, #1
 8008f02:	2c17      	cmp	r4, #23
 8008f04:	dc0d      	bgt.n	8008f22 <vNDRefreshCacheEntry+0x56>
            if( xNDCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8008f06:	4b1a      	ldr	r3, [pc, #104]	@ (8008f70 <vNDRefreshCacheEntry+0xa4>)
 8008f08:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8008f0c:	7f5b      	ldrb	r3, [r3, #29]
 8008f0e:	2b00      	cmp	r3, #0
 8008f10:	d1e8      	bne.n	8008ee4 <vNDRefreshCacheEntry+0x18>
                if( xFreeEntry == -1 )
 8008f12:	f1b6 3fff 	cmp.w	r6, #4294967295
 8008f16:	d1f3      	bne.n	8008f00 <vNDRefreshCacheEntry+0x34>
                    xFreeEntry = x;
 8008f18:	4626      	mov	r6, r4
 8008f1a:	e7f1      	b.n	8008f00 <vNDRefreshCacheEntry+0x34>
                    xOldestEntry = x;
 8008f1c:	46a0      	mov	r8, r4
                    xOldestValue = xNDCache[ x ].ucAge;
 8008f1e:	461f      	mov	r7, r3
 8008f20:	e7ee      	b.n	8008f00 <vNDRefreshCacheEntry+0x34>
        BaseType_t xFreeEntry = -1, xEntryFound = -1;
 8008f22:	f04f 34ff 	mov.w	r4, #4294967295
        if( xEntryFound < 0 )
 8008f26:	2c00      	cmp	r4, #0
 8008f28:	db1b      	blt.n	8008f62 <vNDRefreshCacheEntry+0x96>
        ( void ) memcpy( xNDCache[ xEntryFound ].xIPAddress.ucBytes, pxIPAddress->ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8008f2a:	0163      	lsls	r3, r4, #5
 8008f2c:	4a10      	ldr	r2, [pc, #64]	@ (8008f70 <vNDRefreshCacheEntry+0xa4>)
 8008f2e:	eb02 1444 	add.w	r4, r2, r4, lsl #5
 8008f32:	682f      	ldr	r7, [r5, #0]
 8008f34:	686e      	ldr	r6, [r5, #4]
 8008f36:	68a8      	ldr	r0, [r5, #8]
 8008f38:	68e9      	ldr	r1, [r5, #12]
 8008f3a:	50d7      	str	r7, [r2, r3]
 8008f3c:	6066      	str	r6, [r4, #4]
 8008f3e:	60a0      	str	r0, [r4, #8]
 8008f40:	60e1      	str	r1, [r4, #12]
        ( void ) memcpy( xNDCache[ xEntryFound ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( MACAddress_t ) );
 8008f42:	3310      	adds	r3, #16
 8008f44:	1899      	adds	r1, r3, r2
 8008f46:	f8d9 0000 	ldr.w	r0, [r9]
 8008f4a:	50d0      	str	r0, [r2, r3]
 8008f4c:	f8b9 3004 	ldrh.w	r3, [r9, #4]
 8008f50:	808b      	strh	r3, [r1, #4]
        xNDCache[ xEntryFound ].pxEndPoint = pxEndPoint;
 8008f52:	f8c4 a018 	str.w	sl, [r4, #24]
        xNDCache[ xEntryFound ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 8008f56:	2396      	movs	r3, #150	@ 0x96
 8008f58:	7723      	strb	r3, [r4, #28]
        xNDCache[ xEntryFound ].ucValid = ( uint8_t ) pdTRUE;
 8008f5a:	2301      	movs	r3, #1
 8008f5c:	7763      	strb	r3, [r4, #29]
    }
 8008f5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if( xFreeEntry >= 0 )
 8008f62:	2e00      	cmp	r6, #0
 8008f64:	db01      	blt.n	8008f6a <vNDRefreshCacheEntry+0x9e>
                xEntryFound = xFreeEntry;
 8008f66:	4634      	mov	r4, r6
 8008f68:	e7df      	b.n	8008f2a <vNDRefreshCacheEntry+0x5e>
                xEntryFound = xOldestEntry;
 8008f6a:	4644      	mov	r4, r8
 8008f6c:	e7dd      	b.n	8008f2a <vNDRefreshCacheEntry+0x5e>
 8008f6e:	bf00      	nop
 8008f70:	2001340c 	.word	0x2001340c

08008f74 <vNDSendNeighbourSolicitation>:
    {
 8008f74:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008f78:	b087      	sub	sp, #28
 8008f7a:	4605      	mov	r5, r0
        const NetworkEndPoint_t * pxEndPoint = pxNetworkBuffer->pxEndPoint;
 8008f7c:	6b07      	ldr	r7, [r0, #48]	@ 0x30
        if( ( pxEndPoint != NULL ) && ( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED ) )
 8008f7e:	2f00      	cmp	r7, #0
 8008f80:	f000 80a6 	beq.w	80090d0 <vNDSendNeighbourSolicitation+0x15c>
 8008f84:	460e      	mov	r6, r1
 8008f86:	f897 30f0 	ldrb.w	r3, [r7, #240]	@ 0xf0
 8008f8a:	f013 0f08 	tst.w	r3, #8
 8008f8e:	f000 809c 	beq.w	80090ca <vNDSendNeighbourSolicitation+0x156>
            if( pxDescriptor->xDataLength < uxNeededSize )
 8008f92:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 8008f94:	2b55      	cmp	r3, #85	@ 0x55
 8008f96:	d80a      	bhi.n	8008fae <vNDSendNeighbourSolicitation+0x3a>
                pxNewDescriptor = pxDuplicateNetworkBufferWithDescriptor( pxDescriptor, uxNeededSize );
 8008f98:	2156      	movs	r1, #86	@ 0x56
 8008f9a:	f7fe febb 	bl	8007d14 <pxDuplicateNetworkBufferWithDescriptor>
 8008f9e:	4604      	mov	r4, r0
                vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 8008fa0:	4628      	mov	r0, r5
 8008fa2:	f005 fb7d 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
            if( pxDescriptor != NULL )
 8008fa6:	2c00      	cmp	r4, #0
 8008fa8:	f000 8094 	beq.w	80090d4 <vNDSendNeighbourSolicitation+0x160>
 8008fac:	4625      	mov	r5, r4
                pxICMPPacket = ( ( ICMPPacket_IPv6_t * ) pxDescriptor->pucEthernetBuffer );
 8008fae:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
                pxDescriptor->xDataLength = uxNeededSize;
 8008fb0:	2356      	movs	r3, #86	@ 0x56
 8008fb2:	62ab      	str	r3, [r5, #40]	@ 0x28
                xMultiCastMacAddress.ucBytes[ 0 ] = 0x33U;
 8008fb4:	2333      	movs	r3, #51	@ 0x33
 8008fb6:	f88d 3000 	strb.w	r3, [sp]
                xMultiCastMacAddress.ucBytes[ 1 ] = 0x33U;
 8008fba:	f88d 3001 	strb.w	r3, [sp, #1]
                xMultiCastMacAddress.ucBytes[ 2 ] = 0xffU;
 8008fbe:	22ff      	movs	r2, #255	@ 0xff
 8008fc0:	f88d 2002 	strb.w	r2, [sp, #2]
                xMultiCastMacAddress.ucBytes[ 3 ] = pxIPAddress->ucBytes[ 13 ];
 8008fc4:	7b73      	ldrb	r3, [r6, #13]
 8008fc6:	f88d 3003 	strb.w	r3, [sp, #3]
                xMultiCastMacAddress.ucBytes[ 4 ] = pxIPAddress->ucBytes[ 14 ];
 8008fca:	7bb3      	ldrb	r3, [r6, #14]
 8008fcc:	f88d 3004 	strb.w	r3, [sp, #4]
                xMultiCastMacAddress.ucBytes[ 5 ] = pxIPAddress->ucBytes[ 15 ];
 8008fd0:	7bf3      	ldrb	r3, [r6, #15]
 8008fd2:	f88d 3005 	strb.w	r3, [sp, #5]
                ( void ) memcpy( pxICMPPacket->xEthernetHeader.xSourceAddress.ucBytes, xMultiCastMacAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES );
 8008fd6:	9800      	ldr	r0, [sp, #0]
 8008fd8:	f8c4 0006 	str.w	r0, [r4, #6]
 8008fdc:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8008fe0:	8163      	strh	r3, [r4, #10]
                ( void ) memcpy( pxICMPPacket->xEthernetHeader.xDestinationAddress.ucBytes, pxEndPoint->xMACAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES );
 8008fe2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8008fe6:	6023      	str	r3, [r4, #0]
 8008fe8:	f8b7 30ec 	ldrh.w	r3, [r7, #236]	@ 0xec
 8008fec:	80a3      	strh	r3, [r4, #4]
                pxICMPPacket->xEthernetHeader.usFrameType = ipIPv6_FRAME_TYPE;
 8008fee:	2300      	movs	r3, #0
 8008ff0:	f06f 0179 	mvn.w	r1, #121	@ 0x79
 8008ff4:	7321      	strb	r1, [r4, #12]
 8008ff6:	f06f 0122 	mvn.w	r1, #34	@ 0x22
 8008ffa:	7361      	strb	r1, [r4, #13]
                pxICMPPacket->xIPHeader.ucVersionTrafficClass = 0x60U;
 8008ffc:	2160      	movs	r1, #96	@ 0x60
 8008ffe:	73a1      	strb	r1, [r4, #14]
                pxICMPPacket->xIPHeader.ucTrafficClassFlow = 0U;
 8009000:	73e3      	strb	r3, [r4, #15]
                pxICMPPacket->xIPHeader.usFlowLabel = 0U;
 8009002:	7423      	strb	r3, [r4, #16]
 8009004:	7463      	strb	r3, [r4, #17]
                pxICMPPacket->xIPHeader.usPayloadLength = FreeRTOS_htons( ulPayloadLength );
 8009006:	74a3      	strb	r3, [r4, #18]
 8009008:	2120      	movs	r1, #32
 800900a:	74e1      	strb	r1, [r4, #19]
                pxICMPPacket->xIPHeader.ucNextHeader = ipPROTOCOL_ICMP_IPv6;
 800900c:	213a      	movs	r1, #58	@ 0x3a
 800900e:	7521      	strb	r1, [r4, #20]
                pxICMPPacket->xIPHeader.ucHopLimit = 255U;
 8009010:	7562      	strb	r2, [r4, #21]
                ( void ) memcpy( pxICMPPacket->xIPHeader.xSourceAddress.ucBytes, pxEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8009012:	f8d7 e038 	ldr.w	lr, [r7, #56]	@ 0x38
 8009016:	f8d7 c03c 	ldr.w	ip, [r7, #60]	@ 0x3c
 800901a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800901c:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800901e:	f8c4 e016 	str.w	lr, [r4, #22]
 8009022:	f8c4 c01a 	str.w	ip, [r4, #26]
 8009026:	f8c4 001e 	str.w	r0, [r4, #30]
 800902a:	f8c4 1022 	str.w	r1, [r4, #34]	@ 0x22
                ( void ) memset( xTargetIPAddress.ucBytes, 0, sizeof( xTargetIPAddress.ucBytes ) );
 800902e:	9302      	str	r3, [sp, #8]
 8009030:	9303      	str	r3, [sp, #12]
 8009032:	9304      	str	r3, [sp, #16]
 8009034:	9305      	str	r3, [sp, #20]
                xTargetIPAddress.ucBytes[ 0 ] = 0xff;
 8009036:	f88d 2008 	strb.w	r2, [sp, #8]
                xTargetIPAddress.ucBytes[ 1 ] = 0x02;
 800903a:	2302      	movs	r3, #2
 800903c:	f88d 3009 	strb.w	r3, [sp, #9]
                xTargetIPAddress.ucBytes[ 11 ] = 0x01;
 8009040:	f04f 0801 	mov.w	r8, #1
 8009044:	f88d 8013 	strb.w	r8, [sp, #19]
                xTargetIPAddress.ucBytes[ 12 ] = 0xff;
 8009048:	f88d 2014 	strb.w	r2, [sp, #20]
                xTargetIPAddress.ucBytes[ 13 ] = pxIPAddress->ucBytes[ 13 ];
 800904c:	7b73      	ldrb	r3, [r6, #13]
 800904e:	f88d 3015 	strb.w	r3, [sp, #21]
                xTargetIPAddress.ucBytes[ 14 ] = pxIPAddress->ucBytes[ 14 ];
 8009052:	7bb3      	ldrb	r3, [r6, #14]
 8009054:	f88d 3016 	strb.w	r3, [sp, #22]
                xTargetIPAddress.ucBytes[ 15 ] = pxIPAddress->ucBytes[ 15 ];
 8009058:	7bf3      	ldrb	r3, [r6, #15]
 800905a:	f88d 3017 	strb.w	r3, [sp, #23]
                ( void ) memcpy( pxICMPPacket->xIPHeader.xDestinationAddress.ucBytes, xTargetIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800905e:	f10d 0c08 	add.w	ip, sp, #8
 8009062:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8009066:	f8c4 0026 	str.w	r0, [r4, #38]	@ 0x26
 800906a:	f8c4 102a 	str.w	r1, [r4, #42]	@ 0x2a
 800906e:	f8c4 202e 	str.w	r2, [r4, #46]	@ 0x2e
 8009072:	f8c4 3032 	str.w	r3, [r4, #50]	@ 0x32
                ( void ) memset( pxICMPHeader_IPv6, 0, sizeof( *pxICMPHeader_IPv6 ) );
 8009076:	2220      	movs	r2, #32
 8009078:	f104 0036 	add.w	r0, r4, #54	@ 0x36
 800907c:	f005 fe1a 	bl	800ecb4 <memset>
                pxICMPHeader_IPv6->ucTypeOfMessage = ipICMP_NEIGHBOR_SOLICITATION_IPv6;
 8009080:	2387      	movs	r3, #135	@ 0x87
 8009082:	f884 3036 	strb.w	r3, [r4, #54]	@ 0x36
                ( void ) memcpy( pxICMPHeader_IPv6->xIPv6Address.ucBytes, pxIPAddress->ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8009086:	6830      	ldr	r0, [r6, #0]
 8009088:	6871      	ldr	r1, [r6, #4]
 800908a:	68b2      	ldr	r2, [r6, #8]
 800908c:	68f3      	ldr	r3, [r6, #12]
 800908e:	f8c4 003e 	str.w	r0, [r4, #62]	@ 0x3e
 8009092:	f8c4 1042 	str.w	r1, [r4, #66]	@ 0x42
 8009096:	f8c4 2046 	str.w	r2, [r4, #70]	@ 0x46
 800909a:	f8c4 304a 	str.w	r3, [r4, #74]	@ 0x4a
                pxICMPHeader_IPv6->ucOptionType = ndICMP_SOURCE_LINK_LAYER_ADDRESS;
 800909e:	f884 804e 	strb.w	r8, [r4, #78]	@ 0x4e
                pxICMPHeader_IPv6->ucOptionLength = 1U; /* times 8 bytes. */
 80090a2:	f884 804f 	strb.w	r8, [r4, #79]	@ 0x4f
                ( void ) memcpy( pxICMPHeader_IPv6->ucOptionBytes, pxEndPoint->xMACAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES );
 80090a6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80090aa:	6523      	str	r3, [r4, #80]	@ 0x50
 80090ac:	f8b7 30ec 	ldrh.w	r3, [r7, #236]	@ 0xec
 80090b0:	f8a4 3054 	strh.w	r3, [r4, #84]	@ 0x54
                    ( void ) usGenerateProtocolChecksum( pxDescriptor->pucEthernetBuffer, pxDescriptor->xDataLength, pdTRUE );
 80090b4:	4642      	mov	r2, r8
 80090b6:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
 80090b8:	6a68      	ldr	r0, [r5, #36]	@ 0x24
 80090ba:	f7ff f843 	bl	8008144 <usGenerateProtocolChecksum>
                vReturnEthernetFrame( pxDescriptor, pdTRUE );
 80090be:	4641      	mov	r1, r8
 80090c0:	4628      	mov	r0, r5
 80090c2:	f7fe f985 	bl	80073d0 <vReturnEthernetFrame>
                xReleased = pdTRUE;
 80090c6:	4643      	mov	r3, r8
 80090c8:	e003      	b.n	80090d2 <vNDSendNeighbourSolicitation+0x15e>
        if( ( pxDescriptor != NULL ) && ( xReleased == pdFALSE ) )
 80090ca:	b118      	cbz	r0, 80090d4 <vNDSendNeighbourSolicitation+0x160>
 80090cc:	2300      	movs	r3, #0
 80090ce:	e000      	b.n	80090d2 <vNDSendNeighbourSolicitation+0x15e>
        BaseType_t xReleased = pdFALSE;
 80090d0:	2300      	movs	r3, #0
        if( ( pxDescriptor != NULL ) && ( xReleased == pdFALSE ) )
 80090d2:	b113      	cbz	r3, 80090da <vNDSendNeighbourSolicitation+0x166>
    }
 80090d4:	b007      	add	sp, #28
 80090d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 80090da:	4628      	mov	r0, r5
 80090dc:	f005 fae0 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
    }
 80090e0:	e7f8      	b.n	80090d4 <vNDSendNeighbourSolicitation+0x160>
	...

080090e4 <vNDAgeCache>:
    {
 80090e4:	b510      	push	{r4, lr}
        for( x = 0; x < ipconfigND_CACHE_ENTRIES; x++ )
 80090e6:	2400      	movs	r4, #0
 80090e8:	e007      	b.n	80090fa <vNDAgeCache+0x16>
                    ( void ) memset( &( xNDCache[ x ] ), 0, sizeof( xNDCache[ x ] ) );
 80090ea:	2220      	movs	r2, #32
 80090ec:	2100      	movs	r1, #0
 80090ee:	4816      	ldr	r0, [pc, #88]	@ (8009148 <vNDAgeCache+0x64>)
 80090f0:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 80090f4:	f005 fdde 	bl	800ecb4 <memset>
        for( x = 0; x < ipconfigND_CACHE_ENTRIES; x++ )
 80090f8:	3401      	adds	r4, #1
 80090fa:	2c17      	cmp	r4, #23
 80090fc:	dc22      	bgt.n	8009144 <vNDAgeCache+0x60>
            if( xNDCache[ x ].ucAge > 0U )
 80090fe:	4b12      	ldr	r3, [pc, #72]	@ (8009148 <vNDAgeCache+0x64>)
 8009100:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8009104:	7f1b      	ldrb	r3, [r3, #28]
 8009106:	2b00      	cmp	r3, #0
 8009108:	d0f6      	beq.n	80090f8 <vNDAgeCache+0x14>
                ( xNDCache[ x ].ucAge )--;
 800910a:	3b01      	subs	r3, #1
 800910c:	b2db      	uxtb	r3, r3
 800910e:	4a0e      	ldr	r2, [pc, #56]	@ (8009148 <vNDAgeCache+0x64>)
 8009110:	eb02 1244 	add.w	r2, r2, r4, lsl #5
 8009114:	7713      	strb	r3, [r2, #28]
                if( xNDCache[ x ].ucAge == 0U )
 8009116:	2b00      	cmp	r3, #0
 8009118:	d0e7      	beq.n	80090ea <vNDAgeCache+0x6>
                    if( xNDCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 800911a:	4a0b      	ldr	r2, [pc, #44]	@ (8009148 <vNDAgeCache+0x64>)
 800911c:	eb02 1244 	add.w	r2, r2, r4, lsl #5
 8009120:	7f52      	ldrb	r2, [r2, #29]
 8009122:	b10a      	cbz	r2, 8009128 <vNDAgeCache+0x44>
                    else if( xNDCache[ x ].ucAge <= ( uint8_t ) ndMAX_CACHE_AGE_BEFORE_NEW_ND_SOLICITATION )
 8009124:	2b03      	cmp	r3, #3
 8009126:	d8e7      	bhi.n	80090f8 <vNDAgeCache+0x14>
                        pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxNeededSize, 0U );
 8009128:	2100      	movs	r1, #0
 800912a:	2056      	movs	r0, #86	@ 0x56
 800912c:	f005 fade 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
                        if( pxNetworkBuffer != NULL )
 8009130:	2800      	cmp	r0, #0
 8009132:	d0e1      	beq.n	80090f8 <vNDAgeCache+0x14>
                            pxNetworkBuffer->pxEndPoint = xNDCache[ x ].pxEndPoint;
 8009134:	4904      	ldr	r1, [pc, #16]	@ (8009148 <vNDAgeCache+0x64>)
 8009136:	eb01 1144 	add.w	r1, r1, r4, lsl #5
 800913a:	698a      	ldr	r2, [r1, #24]
 800913c:	6302      	str	r2, [r0, #48]	@ 0x30
                            vNDSendNeighbourSolicitation( pxNetworkBuffer, &( xNDCache[ x ].xIPAddress ) );
 800913e:	f7ff ff19 	bl	8008f74 <vNDSendNeighbourSolicitation>
 8009142:	e7d9      	b.n	80090f8 <vNDAgeCache+0x14>
    }
 8009144:	bd10      	pop	{r4, pc}
 8009146:	bf00      	nop
 8009148:	2001340c 	.word	0x2001340c

0800914c <prvProcessICMPMessage_IPv6>:
 * @param[in] pxNetworkBuffer The Ethernet packet which contains an IPv6 message.
 *
 * @return A const value 'eReleaseBuffer' which means that the network must still be released.
 */
    eFrameProcessingResult_t prvProcessICMPMessage_IPv6( NetworkBufferDescriptor_t * const pxNetworkBuffer )
    {
 800914c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ICMPPacket_IPv6_t * pxICMPPacket = ( ( ICMPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 8009150:	6a46      	ldr	r6, [r0, #36]	@ 0x24
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ICMPHeader_IPv6_t * pxICMPHeader_IPv6 = ( ( ICMPHeader_IPv6_t * ) &( pxICMPPacket->xICMPHeaderIPv6 ) );
        /* Note: pxNetworkBuffer->pxEndPoint is already verified to be non-NULL in prvProcessEthernetPacket() */
        NetworkEndPoint_t * pxEndPoint = pxNetworkBuffer->pxEndPoint;
 8009152:	6b05      	ldr	r5, [r0, #48]	@ 0x30
                                   pcEndpointName( pxEndPoint, pcAddress, sizeof( pcAddress ) ) ) );
            }
        }
        #endif /* ( ipconfigHAS_PRINTF == 1 ) */

        if( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED )
 8009154:	f895 30f0 	ldrb.w	r3, [r5, #240]	@ 0xf0
 8009158:	f013 0f08 	tst.w	r3, #8
 800915c:	d07f      	beq.n	800925e <prvProcessICMPMessage_IPv6+0x112>
 800915e:	4604      	mov	r4, r0
        {
            switch( pxICMPHeader_IPv6->ucTypeOfMessage )
 8009160:	f896 3036 	ldrb.w	r3, [r6, #54]	@ 0x36
 8009164:	3b80      	subs	r3, #128	@ 0x80
 8009166:	2b08      	cmp	r3, #8
 8009168:	d879      	bhi.n	800925e <prvProcessICMPMessage_IPv6+0x112>
 800916a:	e8df f003 	tbb	[pc, r3]
 800916e:	7805      	.short	0x7805
 8009170:	78787878 	.word	0x78787878
 8009174:	1576      	.short	0x1576
 8009176:	60          	.byte	0x60
 8009177:	00          	.byte	0x00
                   {
                       size_t uxICMPSize;
                       uint16_t usICMPSize;

                       /* Lint would complain about casting '()' immediately. */
                       usICMPSize = FreeRTOS_ntohs( pxICMPPacket->xIPHeader.usPayloadLength );
 8009178:	8a73      	ldrh	r3, [r6, #18]
 800917a:	0219      	lsls	r1, r3, #8
 800917c:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
 8009180:	b289      	uxth	r1, r1
                       uxICMPSize = ( size_t ) usICMPSize;
                       uxNeededSize = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + uxICMPSize );
 8009182:	f101 0336 	add.w	r3, r1, #54	@ 0x36

                       if( uxNeededSize > pxNetworkBuffer->xDataLength )
 8009186:	6a82      	ldr	r2, [r0, #40]	@ 0x28
 8009188:	429a      	cmp	r2, r3
 800918a:	d368      	bcc.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                       {
                           FreeRTOS_printf( ( "Too small\n" ) );
                           break;
                       }

                       pxICMPHeader_IPv6->ucTypeOfMessage = ipICMP_PING_REPLY_IPv6;
 800918c:	2381      	movs	r3, #129	@ 0x81
 800918e:	f886 3036 	strb.w	r3, [r6, #54]	@ 0x36

                       /* MISRA Ref 4.14.1 [The validity of values received from external sources]. */
                       /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#directive-414. */
                       /* coverity[misra_c_2012_directive_4_14_violation] */
                       prvReturnICMP_IPv6( pxNetworkBuffer, uxICMPSize );
 8009192:	f7ff fded 	bl	8008d70 <prvReturnICMP_IPv6>
                   }
                   break;
 8009196:	e062      	b.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                case ipICMP_NEIGHBOR_SOLICITATION_IPv6:
                   {
                       size_t uxICMPSize;
                       BaseType_t xCompare;
                       const NetworkEndPoint_t * pxTargetedEndPoint = pxEndPoint;
                       const NetworkEndPoint_t * pxEndPointInSameSubnet = FreeRTOS_InterfaceEPInSameSubnet_IPv6( pxNetworkBuffer->pxInterface, &( pxICMPHeader_IPv6->xIPv6Address ) );
 8009198:	f106 013e 	add.w	r1, r6, #62	@ 0x3e
 800919c:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 800919e:	f000 fce5 	bl	8009b6c <FreeRTOS_InterfaceEPInSameSubnet_IPv6>

                       if( pxEndPointInSameSubnet != NULL )
 80091a2:	4607      	mov	r7, r0
 80091a4:	2800      	cmp	r0, #0
 80091a6:	d040      	beq.n	800922a <prvProcessICMPMessage_IPv6+0xde>
                       }

                       uxICMPSize = sizeof( ICMPHeader_IPv6_t );
                       uxNeededSize = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + uxICMPSize );

                       if( uxNeededSize > pxNetworkBuffer->xDataLength )
 80091a8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80091aa:	2b55      	cmp	r3, #85	@ 0x55
 80091ac:	d957      	bls.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                       {
                           FreeRTOS_printf( ( "Too small\n" ) );
                           break;
                       }

                       xCompare = memcmp( pxICMPHeader_IPv6->xIPv6Address.ucBytes, pxTargetedEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 80091ae:	f106 053e 	add.w	r5, r6, #62	@ 0x3e
 80091b2:	f107 0838 	add.w	r8, r7, #56	@ 0x38
 80091b6:	2210      	movs	r2, #16
 80091b8:	4641      	mov	r1, r8
 80091ba:	4628      	mov	r0, r5
 80091bc:	f005 fd50 	bl	800ec60 <memcmp>
                       FreeRTOS_printf( ( "ND NS for %pip endpoint %pip %s\n",
                                          ( void * ) pxICMPHeader_IPv6->xIPv6Address.ucBytes,
                                          ( void * ) pxNetworkBuffer->pxEndPoint->ipv6_settings.xIPAddress.ucBytes,
                                          ( xCompare == 0 ) ? "Reply" : "Ignore" ) );

                       if( xCompare == 0 )
 80091c0:	2800      	cmp	r0, #0
 80091c2:	d14c      	bne.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                       {
                           pxICMPHeader_IPv6->ucTypeOfMessage = ipICMP_NEIGHBOR_ADVERTISEMENT_IPv6;
 80091c4:	2388      	movs	r3, #136	@ 0x88
 80091c6:	f886 3036 	strb.w	r3, [r6, #54]	@ 0x36
                           pxICMPHeader_IPv6->ucTypeOfService = 0U;
 80091ca:	2300      	movs	r3, #0
 80091cc:	f886 3037 	strb.w	r3, [r6, #55]	@ 0x37
                           pxICMPHeader_IPv6->ulReserved = ndICMPv6_FLAG_SOLICITED | ndICMPv6_FLAG_UPDATE;
 80091d0:	f886 303a 	strb.w	r3, [r6, #58]	@ 0x3a
 80091d4:	f886 303b 	strb.w	r3, [r6, #59]	@ 0x3b
 80091d8:	f886 303c 	strb.w	r3, [r6, #60]	@ 0x3c
 80091dc:	2260      	movs	r2, #96	@ 0x60
 80091de:	f886 203d 	strb.w	r2, [r6, #61]	@ 0x3d
                           pxICMPHeader_IPv6->ulReserved = FreeRTOS_htonl( pxICMPHeader_IPv6->ulReserved );
 80091e2:	f886 203a 	strb.w	r2, [r6, #58]	@ 0x3a
 80091e6:	f886 303d 	strb.w	r3, [r6, #61]	@ 0x3d

                           /* Type of option. */
                           pxICMPHeader_IPv6->ucOptionType = ndICMP_TARGET_LINK_LAYER_ADDRESS;
 80091ea:	2302      	movs	r3, #2
 80091ec:	f886 304e 	strb.w	r3, [r6, #78]	@ 0x4e
                           /* Length of option in units of 8 bytes. */
                           pxICMPHeader_IPv6->ucOptionLength = 1U;
 80091f0:	2301      	movs	r3, #1
 80091f2:	f886 304f 	strb.w	r3, [r6, #79]	@ 0x4f
                           ( void ) memcpy( pxICMPHeader_IPv6->ucOptionBytes, pxTargetedEndPoint->xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 80091f6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80091fa:	6533      	str	r3, [r6, #80]	@ 0x50
 80091fc:	f8b7 30ec 	ldrh.w	r3, [r7, #236]	@ 0xec
 8009200:	f8a6 3054 	strh.w	r3, [r6, #84]	@ 0x54
                           pxICMPPacket->xIPHeader.ucHopLimit = 255U;
 8009204:	23ff      	movs	r3, #255	@ 0xff
 8009206:	7573      	strb	r3, [r6, #21]
                           ( void ) memcpy( pxICMPHeader_IPv6->xIPv6Address.ucBytes, pxTargetedEndPoint->ipv6_settings.xIPAddress.ucBytes, sizeof( pxICMPHeader_IPv6->xIPv6Address.ucBytes ) );
 8009208:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800920a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800920c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800920e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8009210:	f8c6 003e 	str.w	r0, [r6, #62]	@ 0x3e
 8009214:	f8c6 1042 	str.w	r1, [r6, #66]	@ 0x42
 8009218:	f8c6 2046 	str.w	r2, [r6, #70]	@ 0x46
 800921c:	f8c6 304a 	str.w	r3, [r6, #74]	@ 0x4a
                           prvReturnICMP_IPv6( pxNetworkBuffer, uxICMPSize );
 8009220:	2120      	movs	r1, #32
 8009222:	4620      	mov	r0, r4
 8009224:	f7ff fda4 	bl	8008d70 <prvReturnICMP_IPv6>
 8009228:	e019      	b.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                       const NetworkEndPoint_t * pxTargetedEndPoint = pxEndPoint;
 800922a:	462f      	mov	r7, r5
 800922c:	e7bc      	b.n	80091a8 <prvProcessICMPMessage_IPv6+0x5c>
                case ipICMP_NEIGHBOR_ADVERTISEMENT_IPv6:
                    /* MISRA Ref 11.3.1 [Misaligned access] */
                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
                    /* coverity[misra_c_2012_rule_11_3_violation] */
                    vNDRefreshCacheEntry( ( ( const MACAddress_t * ) pxICMPHeader_IPv6->ucOptionBytes ),
                                          &( pxICMPHeader_IPv6->xIPv6Address ),
 800922e:	f106 073e 	add.w	r7, r6, #62	@ 0x3e
                    vNDRefreshCacheEntry( ( ( const MACAddress_t * ) pxICMPHeader_IPv6->ucOptionBytes ),
 8009232:	462a      	mov	r2, r5
 8009234:	4639      	mov	r1, r7
 8009236:	f106 0050 	add.w	r0, r6, #80	@ 0x50
 800923a:	f7ff fe47 	bl	8008ecc <vNDRefreshCacheEntry>

                    #if ( ipconfigUSE_RA != 0 )

                        /* Receive a NA ( Neighbour Advertisement ) message to see if a chosen IP-address is already in use.
                         * This is important during SLAAC. */
                        vReceiveNA( pxNetworkBuffer );
 800923e:	4620      	mov	r0, r4
 8009240:	f000 fa8b 	bl	800975a <vReceiveNA>
                    #endif

                    if( ( pxARPWaitingNetworkBuffer != NULL ) &&
 8009244:	4b07      	ldr	r3, [pc, #28]	@ (8009264 <prvProcessICMPMessage_IPv6+0x118>)
 8009246:	6818      	ldr	r0, [r3, #0]
 8009248:	b148      	cbz	r0, 800925e <prvProcessICMPMessage_IPv6+0x112>
                        ( uxIPHeaderSizePacket( pxARPWaitingNetworkBuffer ) == ipSIZE_OF_IPv6_HEADER ) )
 800924a:	f7fe f945 	bl	80074d8 <uxIPHeaderSizePacket>
                    if( ( pxARPWaitingNetworkBuffer != NULL ) &&
 800924e:	2828      	cmp	r0, #40	@ 0x28
 8009250:	d105      	bne.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                    {
                        prvCheckWaitingBuffer( &( pxICMPHeader_IPv6->xIPv6Address ) );
 8009252:	4638      	mov	r0, r7
 8009254:	f7ff fdbe 	bl	8008dd4 <prvCheckWaitingBuffer>
 8009258:	e001      	b.n	800925e <prvProcessICMPMessage_IPv6+0x112>
                case ipICMP_ROUTER_SOLICITATION_IPv6:
                    break;

                    #if ( ipconfigUSE_RA != 0 )
                        case ipICMP_ROUTER_ADVERTISEMENT_IPv6:
                            vReceiveRA( pxNetworkBuffer );
 800925a:	f000 facf 	bl	80097fc <vReceiveRA>
                    break;
            } /* switch( pxICMPHeader_IPv6->ucTypeOfMessage ) */
        }     /* if( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED ) */

        return eReleaseBuffer;
    }
 800925e:	2000      	movs	r0, #0
 8009260:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009264:	200133b4 	.word	0x200133b4

08009268 <FreeRTOS_OutputAdvertiseIPv6>:
    /* MISRA Ref 8.9.1 [File scoped variables] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-89 */
    /* coverity[misra_c_2012_rule_8_9_violation] */
    /* coverity[single_use] */
    void FreeRTOS_OutputAdvertiseIPv6( NetworkEndPoint_t * pxEndPoint )
    {
 8009268:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800926c:	4605      	mov	r5, r0

        uxPacketSize = ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + sizeof( ICMPHeader_IPv6_t );

        /* This is called from the context of the IP event task, so a block time
         * must not be used. */
        pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxPacketSize, ndDONT_BLOCK );
 800926e:	2100      	movs	r1, #0
 8009270:	2056      	movs	r0, #86	@ 0x56
 8009272:	f005 fa3b 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>

        if( pxNetworkBuffer != NULL )
 8009276:	2800      	cmp	r0, #0
 8009278:	d07f      	beq.n	800937a <FreeRTOS_OutputAdvertiseIPv6+0x112>
 800927a:	4606      	mov	r6, r0
        {
            ( void ) memset( pxNetworkBuffer->xIPAddress.xIP_IPv6.ucBytes, 0, ipSIZE_OF_IPv6_ADDRESS );
 800927c:	2300      	movs	r3, #0
 800927e:	6143      	str	r3, [r0, #20]
 8009280:	6183      	str	r3, [r0, #24]
 8009282:	61c3      	str	r3, [r0, #28]
 8009284:	6203      	str	r3, [r0, #32]
            pxNetworkBuffer->pxEndPoint = pxEndPoint;
 8009286:	6305      	str	r5, [r0, #48]	@ 0x30

            pxInterface = pxEndPoint->pxNetworkInterface;
 8009288:	f8d5 7158 	ldr.w	r7, [r5, #344]	@ 0x158

            configASSERT( pxInterface != NULL );
 800928c:	2f00      	cmp	r7, #0
 800928e:	d076      	beq.n	800937e <FreeRTOS_OutputAdvertiseIPv6+0x116>

            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxICMPPacket = ( ( ICMPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 8009290:	6a44      	ldr	r4, [r0, #36]	@ 0x24
            pxICMPHeader_IPv6 = ( ( ICMPHeader_IPv6_t * ) &( pxICMPPacket->xICMPHeaderIPv6 ) );

            ( void ) memcpy( pxICMPPacket->xEthernetHeader.xDestinationAddress.ucBytes, pcLOCAL_ALL_NODES_MULTICAST_MAC, ipMAC_ADDRESS_LENGTH_BYTES );
 8009292:	4b3f      	ldr	r3, [pc, #252]	@ (8009390 <FreeRTOS_OutputAdvertiseIPv6+0x128>)
 8009294:	6818      	ldr	r0, [r3, #0]
 8009296:	6020      	str	r0, [r4, #0]
 8009298:	889a      	ldrh	r2, [r3, #4]
 800929a:	80a2      	strh	r2, [r4, #4]
            ( void ) memcpy( pxICMPPacket->xEthernetHeader.xSourceAddress.ucBytes, pxEndPoint->xMACAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES );
 800929c:	f8d5 20e8 	ldr.w	r2, [r5, #232]	@ 0xe8
 80092a0:	f8c4 2006 	str.w	r2, [r4, #6]
 80092a4:	f8b5 20ec 	ldrh.w	r2, [r5, #236]	@ 0xec
 80092a8:	8162      	strh	r2, [r4, #10]
            pxICMPPacket->xEthernetHeader.usFrameType = ipIPv6_FRAME_TYPE; /* 12 + 2 = 14 */
 80092aa:	f04f 0e00 	mov.w	lr, #0
 80092ae:	f06f 0279 	mvn.w	r2, #121	@ 0x79
 80092b2:	7322      	strb	r2, [r4, #12]
 80092b4:	f06f 0222 	mvn.w	r2, #34	@ 0x22
 80092b8:	7362      	strb	r2, [r4, #13]

            pxICMPPacket->xIPHeader.ucVersionTrafficClass = 0x60;
 80092ba:	2260      	movs	r2, #96	@ 0x60
 80092bc:	73a2      	strb	r2, [r4, #14]
            pxICMPPacket->xIPHeader.ucTrafficClassFlow = 0;
 80092be:	f884 e00f 	strb.w	lr, [r4, #15]
            pxICMPPacket->xIPHeader.usFlowLabel = 0;
 80092c2:	f884 e010 	strb.w	lr, [r4, #16]
 80092c6:	f884 e011 	strb.w	lr, [r4, #17]

            pxICMPPacket->xIPHeader.usPayloadLength = FreeRTOS_htons( sizeof( ICMPHeader_IPv6_t ) );
 80092ca:	f884 e012 	strb.w	lr, [r4, #18]
 80092ce:	2220      	movs	r2, #32
 80092d0:	74e2      	strb	r2, [r4, #19]
            pxICMPPacket->xIPHeader.ucNextHeader = ipPROTOCOL_ICMP_IPv6;
 80092d2:	223a      	movs	r2, #58	@ 0x3a
 80092d4:	7522      	strb	r2, [r4, #20]
            pxICMPPacket->xIPHeader.ucHopLimit = 255;
 80092d6:	22ff      	movs	r2, #255	@ 0xff
 80092d8:	7562      	strb	r2, [r4, #21]
            ( void ) memcpy( pxICMPPacket->xIPHeader.xSourceAddress.ucBytes, pxEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 80092da:	f8d5 c038 	ldr.w	ip, [r5, #56]	@ 0x38
 80092de:	6be8      	ldr	r0, [r5, #60]	@ 0x3c
 80092e0:	6c29      	ldr	r1, [r5, #64]	@ 0x40
 80092e2:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
 80092e4:	f8c4 c016 	str.w	ip, [r4, #22]
 80092e8:	f8c4 001a 	str.w	r0, [r4, #26]
 80092ec:	f8c4 101e 	str.w	r1, [r4, #30]
 80092f0:	f8c4 2022 	str.w	r2, [r4, #34]	@ 0x22
            ( void ) memcpy( pxICMPPacket->xIPHeader.xDestinationAddress.ucBytes, pcLOCAL_ALL_NODES_MULTICAST_IP, ipSIZE_OF_IPv6_ADDRESS );
 80092f4:	f103 0c08 	add.w	ip, r3, #8
 80092f8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80092fc:	f8c4 0026 	str.w	r0, [r4, #38]	@ 0x26
 8009300:	f8c4 102a 	str.w	r1, [r4, #42]	@ 0x2a
 8009304:	f8c4 202e 	str.w	r2, [r4, #46]	@ 0x2e
 8009308:	f8c4 3032 	str.w	r3, [r4, #50]	@ 0x32

            uxICMPSize = sizeof( ICMPHeader_IPv6_t );
            pxICMPHeader_IPv6->ucTypeOfMessage = ipICMP_NEIGHBOR_ADVERTISEMENT_IPv6;
 800930c:	2388      	movs	r3, #136	@ 0x88
 800930e:	f884 3036 	strb.w	r3, [r4, #54]	@ 0x36
            pxICMPHeader_IPv6->ucTypeOfService = 0;
 8009312:	f884 e037 	strb.w	lr, [r4, #55]	@ 0x37
            pxICMPHeader_IPv6->ulReserved = ndICMPv6_FLAG_SOLICITED | ndICMPv6_FLAG_UPDATE;
 8009316:	f884 e03a 	strb.w	lr, [r4, #58]	@ 0x3a
 800931a:	f884 e03b 	strb.w	lr, [r4, #59]	@ 0x3b
 800931e:	f884 e03c 	strb.w	lr, [r4, #60]	@ 0x3c
 8009322:	2360      	movs	r3, #96	@ 0x60
 8009324:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
            pxICMPHeader_IPv6->ulReserved = FreeRTOS_htonl( pxICMPHeader_IPv6->ulReserved );
 8009328:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
 800932c:	f884 e03d 	strb.w	lr, [r4, #61]	@ 0x3d

            /* Type of option. */
            pxICMPHeader_IPv6->ucOptionType = ndICMP_TARGET_LINK_LAYER_ADDRESS;
 8009330:	2302      	movs	r3, #2
 8009332:	f884 304e 	strb.w	r3, [r4, #78]	@ 0x4e
            /* Length of option in units of 8 bytes. */
            pxICMPHeader_IPv6->ucOptionLength = 1;
 8009336:	f04f 0801 	mov.w	r8, #1
 800933a:	f884 804f 	strb.w	r8, [r4, #79]	@ 0x4f
            ( void ) memcpy( pxICMPHeader_IPv6->ucOptionBytes, pxEndPoint->xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 800933e:	f8d5 30e8 	ldr.w	r3, [r5, #232]	@ 0xe8
 8009342:	6523      	str	r3, [r4, #80]	@ 0x50
 8009344:	f8b5 30ec 	ldrh.w	r3, [r5, #236]	@ 0xec
 8009348:	f8a4 3054 	strh.w	r3, [r4, #84]	@ 0x54
            pxICMPPacket->xIPHeader.ucHopLimit = 255;
            ( void ) memcpy( pxICMPHeader_IPv6->xIPv6Address.ucBytes, pxEndPoint->ipv6_settings.xIPAddress.ucBytes, sizeof( pxICMPHeader_IPv6->xIPv6Address.ucBytes ) );
 800934c:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 800934e:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8009350:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
 8009352:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 8009354:	f8c4 003e 	str.w	r0, [r4, #62]	@ 0x3e
 8009358:	f8c4 1042 	str.w	r1, [r4, #66]	@ 0x42
 800935c:	f8c4 2046 	str.w	r2, [r4, #70]	@ 0x46
 8009360:	f8c4 304a 	str.w	r3, [r4, #74]	@ 0x4a

            /* Important: tell NIC driver how many bytes must be sent */
            pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + uxICMPSize );
 8009364:	2156      	movs	r1, #86	@ 0x56
 8009366:	62b1      	str	r1, [r6, #40]	@ 0x28

            #if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
            {
                /* calculate the ICMPv6 checksum for outgoing package */
                ( void ) usGenerateProtocolChecksum( pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength, pdTRUE );
 8009368:	4642      	mov	r2, r8
 800936a:	6a70      	ldr	r0, [r6, #36]	@ 0x24
 800936c:	f7fe feea 	bl	8008144 <usGenerateProtocolChecksum>
                pxICMPHeader_IPv6->usChecksum = 0;
            }
            #endif

            /* Set the parameter 'bReleaseAfterSend'. */
            ( void ) pxInterface->pfOutput( pxInterface, pxNetworkBuffer, pdTRUE );
 8009370:	68fb      	ldr	r3, [r7, #12]
 8009372:	4642      	mov	r2, r8
 8009374:	4631      	mov	r1, r6
 8009376:	4638      	mov	r0, r7
 8009378:	4798      	blx	r3
        }
    }
 800937a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800937e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009382:	f383 8811 	msr	BASEPRI, r3
 8009386:	f3bf 8f6f 	isb	sy
 800938a:	f3bf 8f4f 	dsb	sy
            configASSERT( pxInterface != NULL );
 800938e:	e7fe      	b.n	800938e <FreeRTOS_OutputAdvertiseIPv6+0x126>
 8009390:	0800ff34 	.word	0x0800ff34

08009394 <FreeRTOS_CreateIPv6Address>:
 */
    BaseType_t FreeRTOS_CreateIPv6Address( IPv6_Address_t * pxIPAddress,
                                           const IPv6_Address_t * pxPrefix,
                                           size_t uxPrefixLength,
                                           BaseType_t xDoRandom )
    {
 8009394:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009398:	b084      	sub	sp, #16
 800939a:	4606      	mov	r6, r0
 800939c:	4688      	mov	r8, r1
 800939e:	4615      	mov	r5, r2
        uint32_t pulRandom[ 4 ];
        uint8_t * pucSource;
        BaseType_t xIndex, xResult = pdPASS;

        if( xDoRandom != pdFALSE )
 80093a0:	b18b      	cbz	r3, 80093c6 <FreeRTOS_CreateIPv6Address+0x32>
            /* Create an IP-address, based on a net prefix and a
             * random host address.
             * ARRAY_SIZE_X() returns the size of an array as a
             * signed value ( BaseType_t ).
             */
            for( xIndex = 0; xIndex < ARRAY_SIZE_X( pulRandom ); xIndex++ )
 80093a2:	2400      	movs	r4, #0
 80093a4:	2c03      	cmp	r4, #3
 80093a6:	dc07      	bgt.n	80093b8 <FreeRTOS_CreateIPv6Address+0x24>
            {
                if( xApplicationGetRandomNumber( &( pulRandom[ xIndex ] ) ) == pdFAIL )
 80093a8:	eb0d 0084 	add.w	r0, sp, r4, lsl #2
 80093ac:	f7f8 f8a6 	bl	80014fc <xApplicationGetRandomNumber>
 80093b0:	4607      	mov	r7, r0
 80093b2:	b110      	cbz	r0, 80093ba <FreeRTOS_CreateIPv6Address+0x26>
            for( xIndex = 0; xIndex < ARRAY_SIZE_X( pulRandom ); xIndex++ )
 80093b4:	3401      	adds	r4, #1
 80093b6:	e7f5      	b.n	80093a4 <FreeRTOS_CreateIPv6Address+0x10>
        BaseType_t xIndex, xResult = pdPASS;
 80093b8:	2701      	movs	r7, #1
        else
        {
            ( void ) memset( pulRandom, 0, sizeof( pulRandom ) );
        }

        if( xResult == pdPASS )
 80093ba:	2f01      	cmp	r7, #1
 80093bc:	d009      	beq.n	80093d2 <FreeRTOS_CreateIPv6Address+0x3e>
                ( void ) memcpy( &( pxIPAddress->ucBytes[ uxIndex ] ), pucSource, ipSIZE_OF_IPv6_ADDRESS - uxIndex );
            }
        }

        return xResult;
    }
 80093be:	4638      	mov	r0, r7
 80093c0:	b004      	add	sp, #16
 80093c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ( void ) memset( pulRandom, 0, sizeof( pulRandom ) );
 80093c6:	2300      	movs	r3, #0
 80093c8:	9300      	str	r3, [sp, #0]
 80093ca:	9301      	str	r3, [sp, #4]
 80093cc:	9302      	str	r3, [sp, #8]
 80093ce:	9303      	str	r3, [sp, #12]
        BaseType_t xIndex, xResult = pdPASS;
 80093d0:	2701      	movs	r7, #1
            configASSERT( ( uxPrefixLength > 0U ) && ( uxPrefixLength <= ( 8U * ipSIZE_OF_IPv6_ADDRESS ) ) );
 80093d2:	1e6b      	subs	r3, r5, #1
 80093d4:	2b7f      	cmp	r3, #127	@ 0x7f
 80093d6:	d908      	bls.n	80093ea <FreeRTOS_CreateIPv6Address+0x56>
 80093d8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80093dc:	f383 8811 	msr	BASEPRI, r3
 80093e0:	f3bf 8f6f 	isb	sy
 80093e4:	f3bf 8f4f 	dsb	sy
 80093e8:	e7fe      	b.n	80093e8 <FreeRTOS_CreateIPv6Address+0x54>
            if( uxPrefixLength >= 8U )
 80093ea:	2d07      	cmp	r5, #7
 80093ec:	d81c      	bhi.n	8009428 <FreeRTOS_CreateIPv6Address+0x94>
            uxIndex = uxPrefixLength / 8U;
 80093ee:	08e8      	lsrs	r0, r5, #3
            if( ( uxPrefixLength % 8U ) != 0U )
 80093f0:	f015 0507 	ands.w	r5, r5, #7
 80093f4:	d01f      	beq.n	8009436 <FreeRTOS_CreateIPv6Address+0xa2>
                size_t uxHostLen = 8U - ( uxPrefixLength % 8U );
 80093f6:	f1c5 0508 	rsb	r5, r5, #8
                uint32_t uxHostMask = ( ( ( uint32_t ) 1U ) << uxHostLen ) - 1U;
 80093fa:	2301      	movs	r3, #1
 80093fc:	40ab      	lsls	r3, r5
 80093fe:	1e5a      	subs	r2, r3, #1
                uint8_t ucNetMask = ( uint8_t ) ~( uxHostMask );
 8009400:	425b      	negs	r3, r3
                pxIPAddress->ucBytes[ uxIndex ] &= ucNetMask;
 8009402:	5c31      	ldrb	r1, [r6, r0]
 8009404:	400b      	ands	r3, r1
 8009406:	5433      	strb	r3, [r6, r0]
                pxIPAddress->ucBytes[ uxIndex ] |= ( pucSource[ 0 ] & ( ( uint8_t ) uxHostMask ) );
 8009408:	f89d 1000 	ldrb.w	r1, [sp]
 800940c:	400a      	ands	r2, r1
 800940e:	4313      	orrs	r3, r2
 8009410:	5433      	strb	r3, [r6, r0]
                uxIndex++;
 8009412:	3001      	adds	r0, #1
                pucSource = &( pucSource[ 1 ] );
 8009414:	f10d 0101 	add.w	r1, sp, #1
            if( uxIndex < ipSIZE_OF_IPv6_ADDRESS )
 8009418:	280f      	cmp	r0, #15
 800941a:	d8d0      	bhi.n	80093be <FreeRTOS_CreateIPv6Address+0x2a>
                ( void ) memcpy( &( pxIPAddress->ucBytes[ uxIndex ] ), pucSource, ipSIZE_OF_IPv6_ADDRESS - uxIndex );
 800941c:	f1c0 0210 	rsb	r2, r0, #16
 8009420:	4430      	add	r0, r6
 8009422:	f005 fd20 	bl	800ee66 <memcpy>
        return xResult;
 8009426:	e7ca      	b.n	80093be <FreeRTOS_CreateIPv6Address+0x2a>
                ( void ) memcpy( pxIPAddress->ucBytes, pxPrefix->ucBytes, ( uxPrefixLength + 7U ) / 8U );
 8009428:	1dea      	adds	r2, r5, #7
 800942a:	08d2      	lsrs	r2, r2, #3
 800942c:	4641      	mov	r1, r8
 800942e:	4630      	mov	r0, r6
 8009430:	f005 fd19 	bl	800ee66 <memcpy>
 8009434:	e7db      	b.n	80093ee <FreeRTOS_CreateIPv6Address+0x5a>
            pucSource = ( uint8_t * ) pulRandom;
 8009436:	4669      	mov	r1, sp
 8009438:	e7ee      	b.n	8009418 <FreeRTOS_CreateIPv6Address+0x84>

0800943a <vRAProcessInit>:
 *
 * @param[in] pxEndPoint The end-point for which Router Advertisement is required.
 */
    static void vRAProcessInit( NetworkEndPoint_t * pxEndPoint )
    {
        pxEndPoint->xRAData.uxRetryCount = 0U;
 800943a:	2300      	movs	r3, #0
 800943c:	f8c0 3150 	str.w	r3, [r0, #336]	@ 0x150
        pxEndPoint->xRAData.eRAState = eRAStateApply;
 8009440:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
    }
 8009444:	4770      	bx	lr

08009446 <xGetLinkLocalAddress>:
    {
 8009446:	b538      	push	{r3, r4, r5, lr}
 8009448:	4604      	mov	r4, r0
 800944a:	460d      	mov	r5, r1
        for( pxEndPoint = FreeRTOS_FirstEndPoint( pxInterface );
 800944c:	f000 faec 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8009450:	4601      	mov	r1, r0
 8009452:	e003      	b.n	800945c <xGetLinkLocalAddress+0x16>
             pxEndPoint = FreeRTOS_NextEndPoint( pxInterface, pxEndPoint ) )
 8009454:	4620      	mov	r0, r4
 8009456:	f000 faf7 	bl	8009a48 <FreeRTOS_NextEndPoint>
 800945a:	4601      	mov	r1, r0
             pxEndPoint != NULL;
 800945c:	b199      	cbz	r1, 8009486 <xGetLinkLocalAddress+0x40>
            if( ( pxEndPoint->ipv6_settings.xIPAddress.ucBytes[ 0 ] == 0xfeU ) &&
 800945e:	f891 3038 	ldrb.w	r3, [r1, #56]	@ 0x38
 8009462:	2bfe      	cmp	r3, #254	@ 0xfe
 8009464:	d1f6      	bne.n	8009454 <xGetLinkLocalAddress+0xe>
                ( ( pxEndPoint->ipv6_settings.xIPAddress.ucBytes[ 1 ] & 0xc0U ) == 0x80U ) )
 8009466:	f891 3039 	ldrb.w	r3, [r1, #57]	@ 0x39
            if( ( pxEndPoint->ipv6_settings.xIPAddress.ucBytes[ 0 ] == 0xfeU ) &&
 800946a:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 800946e:	2b80      	cmp	r3, #128	@ 0x80
 8009470:	d1f0      	bne.n	8009454 <xGetLinkLocalAddress+0xe>
                ( void ) memcpy( pxAddress->ucBytes, pxEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8009472:	6b8c      	ldr	r4, [r1, #56]	@ 0x38
 8009474:	6bc8      	ldr	r0, [r1, #60]	@ 0x3c
 8009476:	6c0a      	ldr	r2, [r1, #64]	@ 0x40
 8009478:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
 800947a:	602c      	str	r4, [r5, #0]
 800947c:	6068      	str	r0, [r5, #4]
 800947e:	60aa      	str	r2, [r5, #8]
 8009480:	60eb      	str	r3, [r5, #12]
                xResult = pdPASS;
 8009482:	2001      	movs	r0, #1
                break;
 8009484:	e000      	b.n	8009488 <xGetLinkLocalAddress+0x42>
        BaseType_t xResult = pdFAIL;
 8009486:	2000      	movs	r0, #0
    }
 8009488:	bd38      	pop	{r3, r4, r5, pc}

0800948a <vReceiveRA_ReadReply>:
    {
 800948a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        const size_t uxLast = pxNetworkBuffer->xDataLength - uxNeededSize;
 800948c:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 800948e:	3e46      	subs	r6, #70	@ 0x46
        uint8_t * pucBytes = &( pxNetworkBuffer->pucEthernetBuffer[ uxNeededSize ] );
 8009490:	6a45      	ldr	r5, [r0, #36]	@ 0x24
 8009492:	3546      	adds	r5, #70	@ 0x46
        ICMPPrefixOption_IPv6_t * pxPrefixOption = NULL;
 8009494:	2700      	movs	r7, #0
        size_t uxIndex = 0U;
 8009496:	4638      	mov	r0, r7
        while( ( uxIndex + 1U ) < uxLast )
 8009498:	e004      	b.n	80094a4 <vReceiveRA_ReadReply+0x1a>
                       ulMTU = ulChar2u32( &( pucBytes[ uxIndex + 4U ] ) );
 800949a:	3004      	adds	r0, #4
 800949c:	4428      	add	r0, r5
 800949e:	f7fe fede 	bl	800825e <ulChar2u32>
                    pxPrefixOption = ( ( ICMPPrefixOption_IPv6_t * ) &( pucBytes[ uxIndex ] ) );
 80094a2:	4620      	mov	r0, r4
        while( ( uxIndex + 1U ) < uxLast )
 80094a4:	1c43      	adds	r3, r0, #1
 80094a6:	42b3      	cmp	r3, r6
 80094a8:	d20e      	bcs.n	80094c8 <vReceiveRA_ReadReply+0x3e>
            uint8_t ucType = pucBytes[ uxIndex ];
 80094aa:	1829      	adds	r1, r5, r0
 80094ac:	5c2a      	ldrb	r2, [r5, r0]
            size_t uxPrefixLength = ( size_t ) pucBytes[ uxIndex + 1U ];
 80094ae:	5ceb      	ldrb	r3, [r5, r3]
            size_t uxLength = uxPrefixLength * 8U;
 80094b0:	00dc      	lsls	r4, r3, #3
            if( uxPrefixLength == 0U )
 80094b2:	b14b      	cbz	r3, 80094c8 <vReceiveRA_ReadReply+0x3e>
            if( uxLast < ( uxIndex + uxLength ) )
 80094b4:	4404      	add	r4, r0
 80094b6:	42b4      	cmp	r4, r6
 80094b8:	d806      	bhi.n	80094c8 <vReceiveRA_ReadReply+0x3e>
            switch( ucType )
 80094ba:	2a03      	cmp	r2, #3
 80094bc:	d002      	beq.n	80094c4 <vReceiveRA_ReadReply+0x3a>
 80094be:	2a05      	cmp	r2, #5
 80094c0:	d1ef      	bne.n	80094a2 <vReceiveRA_ReadReply+0x18>
 80094c2:	e7ea      	b.n	800949a <vReceiveRA_ReadReply+0x10>
                    pxPrefixOption = ( ( ICMPPrefixOption_IPv6_t * ) &( pucBytes[ uxIndex ] ) );
 80094c4:	460f      	mov	r7, r1
 80094c6:	e7ec      	b.n	80094a2 <vReceiveRA_ReadReply+0x18>
    }
 80094c8:	4638      	mov	r0, r7
 80094ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080094cc <xRAProcess_HandleWaitStates>:
    {
 80094cc:	b538      	push	{r3, r4, r5, lr}
 80094ce:	4604      	mov	r4, r0
 80094d0:	460d      	mov	r5, r1
        if( pxEndPoint->xRAData.eRAState == eRAStateWait )
 80094d2:	f890 3154 	ldrb.w	r3, [r0, #340]	@ 0x154
 80094d6:	2b01      	cmp	r3, #1
 80094d8:	d003      	beq.n	80094e2 <xRAProcess_HandleWaitStates+0x16>
        else if( pxEndPoint->xRAData.eRAState == eRAStateIPWait )
 80094da:	2b03      	cmp	r3, #3
 80094dc:	d025      	beq.n	800952a <xRAProcess_HandleWaitStates+0x5e>
    }
 80094de:	4628      	mov	r0, r5
 80094e0:	bd38      	pop	{r3, r4, r5, pc}
            pxEndPoint->xRAData.uxRetryCount++;
 80094e2:	f8d0 3150 	ldr.w	r3, [r0, #336]	@ 0x150
 80094e6:	3301      	adds	r3, #1
 80094e8:	f8c0 3150 	str.w	r3, [r0, #336]	@ 0x150
            if( pxEndPoint->xRAData.uxRetryCount < ( UBaseType_t ) ipconfigRA_SEARCH_COUNT )
 80094ec:	2b02      	cmp	r3, #2
 80094ee:	d803      	bhi.n	80094f8 <xRAProcess_HandleWaitStates+0x2c>
                pxEndPoint->xRAData.eRAState = eRAStateApply;
 80094f0:	2300      	movs	r3, #0
 80094f2:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
 80094f6:	e7f2      	b.n	80094de <xRAProcess_HandleWaitStates+0x12>
                ( void ) memcpy( &( pxEndPoint->ipv6_settings ), &( pxEndPoint->ipv6_defaults ), sizeof( pxEndPoint->ipv6_settings ) );
 80094f8:	2258      	movs	r2, #88	@ 0x58
 80094fa:	f100 0190 	add.w	r1, r0, #144	@ 0x90
 80094fe:	3038      	adds	r0, #56	@ 0x38
 8009500:	f005 fcb1 	bl	800ee66 <memcpy>
                pxEndPoint->xRAData.bits.bRouterReplied = pdFALSE_UNSIGNED;
 8009504:	f894 3148 	ldrb.w	r3, [r4, #328]	@ 0x148
 8009508:	f023 0301 	bic.w	r3, r3, #1
 800950c:	f884 3148 	strb.w	r3, [r4, #328]	@ 0x148
                pxEndPoint->xRAData.uxRetryCount = 0U;
 8009510:	2300      	movs	r3, #0
 8009512:	f8c4 3150 	str.w	r3, [r4, #336]	@ 0x150
                pxEndPoint->xRAData.bits.bIPAddressInUse = pdTRUE_UNSIGNED;
 8009516:	f894 3148 	ldrb.w	r3, [r4, #328]	@ 0x148
 800951a:	f043 0302 	orr.w	r3, r3, #2
 800951e:	f884 3148 	strb.w	r3, [r4, #328]	@ 0x148
                pxEndPoint->xRAData.eRAState = eRAStateIPTest;
 8009522:	2302      	movs	r3, #2
 8009524:	f884 3154 	strb.w	r3, [r4, #340]	@ 0x154
 8009528:	e7d9      	b.n	80094de <xRAProcess_HandleWaitStates+0x12>
            if( pxEndPoint->xRAData.bits.bIPAddressInUse != pdFALSE_UNSIGNED )
 800952a:	f890 3148 	ldrb.w	r3, [r0, #328]	@ 0x148
 800952e:	f013 0f02 	tst.w	r3, #2
 8009532:	d116      	bne.n	8009562 <xRAProcess_HandleWaitStates+0x96>
            else if( pxEndPoint->xRAData.uxRetryCount < ( UBaseType_t ) ipconfigRA_IP_TEST_COUNT )
 8009534:	f8d0 2150 	ldr.w	r2, [r0, #336]	@ 0x150
 8009538:	2a02      	cmp	r2, #2
 800953a:	d91b      	bls.n	8009574 <xRAProcess_HandleWaitStates+0xa8>
                if( pxEndPoint->xRAData.bits.bRouterReplied != pdFALSE_UNSIGNED )
 800953c:	f013 0f01 	tst.w	r3, #1
 8009540:	d021      	beq.n	8009586 <xRAProcess_HandleWaitStates+0xba>
                    uxNewReloadTime = pdMS_TO_TICKS( ( 1000U * ( uint64_t ) pxEndPoint->xRAData.ulPreferredLifeTime ) );
 8009542:	f8d0 314c 	ldr.w	r3, [r0, #332]	@ 0x14c
 8009546:	4d12      	ldr	r5, [pc, #72]	@ (8009590 <xRAProcess_HandleWaitStates+0xc4>)
 8009548:	fb03 f505 	mul.w	r5, r3, r5
 800954c:	4b11      	ldr	r3, [pc, #68]	@ (8009594 <xRAProcess_HandleWaitStates+0xc8>)
 800954e:	fba3 3505 	umull	r3, r5, r3, r5
 8009552:	09ad      	lsrs	r5, r5, #6
                    pxEndPoint->xRAData.eRAState = eRAStatePreLease;
 8009554:	2304      	movs	r3, #4
 8009556:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
                vIPNetworkUpCalls( pxEndPoint );
 800955a:	4620      	mov	r0, r4
 800955c:	f7fd fe3e 	bl	80071dc <vIPNetworkUpCalls>
 8009560:	e7bd      	b.n	80094de <xRAProcess_HandleWaitStates+0x12>
                pxEndPoint->xRAData.uxRetryCount = 0U;
 8009562:	2300      	movs	r3, #0
 8009564:	f8c0 3150 	str.w	r3, [r0, #336]	@ 0x150
                pxEndPoint->xRAData.eRAState = eRAStateIPTest;
 8009568:	2302      	movs	r3, #2
 800956a:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
                uxNewReloadTime = pdMS_TO_TICKS( ipconfigRA_IP_TEST_TIME_OUT_MSEC );
 800956e:	f240 55dc 	movw	r5, #1500	@ 0x5dc
 8009572:	e7b4      	b.n	80094de <xRAProcess_HandleWaitStates+0x12>
                pxEndPoint->xRAData.uxRetryCount++;
 8009574:	3201      	adds	r2, #1
 8009576:	f8c0 2150 	str.w	r2, [r0, #336]	@ 0x150
                pxEndPoint->xRAData.eRAState = eRAStateIPTest;
 800957a:	2302      	movs	r3, #2
 800957c:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
                uxNewReloadTime = pdMS_TO_TICKS( ipconfigRA_IP_TEST_TIME_OUT_MSEC );
 8009580:	f240 55dc 	movw	r5, #1500	@ 0x5dc
 8009584:	e7ab      	b.n	80094de <xRAProcess_HandleWaitStates+0x12>
                    pxEndPoint->xRAData.eRAState = eRAStateFailed;
 8009586:	2306      	movs	r3, #6
 8009588:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
                    uxNewReloadTime = 0U;
 800958c:	2500      	movs	r5, #0
 800958e:	e7e4      	b.n	800955a <xRAProcess_HandleWaitStates+0x8e>
 8009590:	000f4240 	.word	0x000f4240
 8009594:	10624dd3 	.word	0x10624dd3

08009598 <vNDSendRouterSolicitation>:
    {
 8009598:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800959c:	b086      	sub	sp, #24
        const NetworkEndPoint_t * pxEndPoint = pxNetworkBuffer->pxEndPoint;
 800959e:	6b06      	ldr	r6, [r0, #48]	@ 0x30
        configASSERT( pxEndPoint != NULL );
 80095a0:	b17e      	cbz	r6, 80095c2 <vNDSendRouterSolicitation+0x2a>
 80095a2:	4604      	mov	r4, r0
 80095a4:	460f      	mov	r7, r1
        configASSERT( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED );
 80095a6:	f896 30f0 	ldrb.w	r3, [r6, #240]	@ 0xf0
 80095aa:	f013 0f08 	tst.w	r3, #8
 80095ae:	d111      	bne.n	80095d4 <vNDSendRouterSolicitation+0x3c>
 80095b0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80095b4:	f383 8811 	msr	BASEPRI, r3
 80095b8:	f3bf 8f6f 	isb	sy
 80095bc:	f3bf 8f4f 	dsb	sy
 80095c0:	e7fe      	b.n	80095c0 <vNDSendRouterSolicitation+0x28>
 80095c2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80095c6:	f383 8811 	msr	BASEPRI, r3
 80095ca:	f3bf 8f6f 	isb	sy
 80095ce:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEndPoint != NULL );
 80095d2:	e7fe      	b.n	80095d2 <vNDSendRouterSolicitation+0x3a>
        xHasLocal = xGetLinkLocalAddress( pxEndPoint->pxNetworkInterface, &( xSourceAddress ) );
 80095d4:	4669      	mov	r1, sp
 80095d6:	f8d6 0158 	ldr.w	r0, [r6, #344]	@ 0x158
 80095da:	f7ff ff34 	bl	8009446 <xGetLinkLocalAddress>
        if( xHasLocal == pdFAIL )
 80095de:	2800      	cmp	r0, #0
 80095e0:	d05e      	beq.n	80096a0 <vNDSendRouterSolicitation+0x108>
        if( pxDescriptor->xDataLength < uxNeededSize )
 80095e2:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80095e4:	2b3d      	cmp	r3, #61	@ 0x3d
 80095e6:	d80a      	bhi.n	80095fe <vNDSendRouterSolicitation+0x66>
            pxNewDescriptor = pxDuplicateNetworkBufferWithDescriptor( pxDescriptor, uxNeededSize );
 80095e8:	213e      	movs	r1, #62	@ 0x3e
 80095ea:	4620      	mov	r0, r4
 80095ec:	f7fe fb92 	bl	8007d14 <pxDuplicateNetworkBufferWithDescriptor>
 80095f0:	4605      	mov	r5, r0
            vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 80095f2:	4620      	mov	r0, r4
 80095f4:	f005 f854 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
        if( pxDescriptor != NULL )
 80095f8:	2d00      	cmp	r5, #0
 80095fa:	d04e      	beq.n	800969a <vNDSendRouterSolicitation+0x102>
 80095fc:	462c      	mov	r4, r5
            pxICMPPacket = ( ( ICMPPacket_IPv6_t * ) pxDescriptor->pucEthernetBuffer );
 80095fe:	6a65      	ldr	r5, [r4, #36]	@ 0x24
            pxDescriptor->xDataLength = uxNeededSize;
 8009600:	233e      	movs	r3, #62	@ 0x3e
 8009602:	62a3      	str	r3, [r4, #40]	@ 0x28
            ( void ) eNDGetCacheEntry( pxIPAddress, &( xMultiCastMacAddress ), NULL );
 8009604:	2200      	movs	r2, #0
 8009606:	a904      	add	r1, sp, #16
 8009608:	4638      	mov	r0, r7
 800960a:	f7ff fc07 	bl	8008e1c <eNDGetCacheEntry>
            ( void ) memcpy( pxICMPPacket->xEthernetHeader.xSourceAddress.ucBytes, xMultiCastMacAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES );
 800960e:	9804      	ldr	r0, [sp, #16]
 8009610:	f8c5 0006 	str.w	r0, [r5, #6]
 8009614:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8009618:	816b      	strh	r3, [r5, #10]
            ( void ) memcpy( pxICMPPacket->xEthernetHeader.xDestinationAddress.ucBytes, pxEndPoint->xMACAddress.ucBytes, ipMAC_ADDRESS_LENGTH_BYTES );
 800961a:	f8d6 30e8 	ldr.w	r3, [r6, #232]	@ 0xe8
 800961e:	602b      	str	r3, [r5, #0]
 8009620:	f8b6 30ec 	ldrh.w	r3, [r6, #236]	@ 0xec
 8009624:	80ab      	strh	r3, [r5, #4]
            pxICMPPacket->xEthernetHeader.usFrameType = ipIPv6_FRAME_TYPE;
 8009626:	2600      	movs	r6, #0
 8009628:	f06f 0379 	mvn.w	r3, #121	@ 0x79
 800962c:	732b      	strb	r3, [r5, #12]
 800962e:	f06f 0322 	mvn.w	r3, #34	@ 0x22
 8009632:	736b      	strb	r3, [r5, #13]
            pxICMPPacket->xIPHeader.ucVersionTrafficClass = raDEFAULT_VERSION_TRAFFIC_CLASS;
 8009634:	2360      	movs	r3, #96	@ 0x60
 8009636:	73ab      	strb	r3, [r5, #14]
            pxICMPPacket->xIPHeader.ucTrafficClassFlow = 0U;
 8009638:	73ee      	strb	r6, [r5, #15]
            pxICMPPacket->xIPHeader.usFlowLabel = 0U;
 800963a:	742e      	strb	r6, [r5, #16]
 800963c:	746e      	strb	r6, [r5, #17]
            pxICMPPacket->xIPHeader.usPayloadLength = FreeRTOS_htons( sizeof( ICMPRouterSolicitation_IPv6_t ) );
 800963e:	74ae      	strb	r6, [r5, #18]
 8009640:	2308      	movs	r3, #8
 8009642:	74eb      	strb	r3, [r5, #19]
            pxICMPPacket->xIPHeader.ucNextHeader = ipPROTOCOL_ICMP_IPv6;
 8009644:	233a      	movs	r3, #58	@ 0x3a
 8009646:	752b      	strb	r3, [r5, #20]
            pxICMPPacket->xIPHeader.ucHopLimit = raDEFAULT_HOP_LIMIT;
 8009648:	23ff      	movs	r3, #255	@ 0xff
 800964a:	756b      	strb	r3, [r5, #21]
            ( void ) memcpy( pxICMPPacket->xIPHeader.xSourceAddress.ucBytes, xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800964c:	46ec      	mov	ip, sp
 800964e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8009652:	f8c5 0016 	str.w	r0, [r5, #22]
 8009656:	f8c5 101a 	str.w	r1, [r5, #26]
 800965a:	f8c5 201e 	str.w	r2, [r5, #30]
 800965e:	f8c5 3022 	str.w	r3, [r5, #34]	@ 0x22
            ( void ) memcpy( pxICMPPacket->xIPHeader.xDestinationAddress.ucBytes, pxIPAddress->ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 8009662:	6838      	ldr	r0, [r7, #0]
 8009664:	6879      	ldr	r1, [r7, #4]
 8009666:	68ba      	ldr	r2, [r7, #8]
 8009668:	68fb      	ldr	r3, [r7, #12]
 800966a:	f8c5 0026 	str.w	r0, [r5, #38]	@ 0x26
 800966e:	f8c5 102a 	str.w	r1, [r5, #42]	@ 0x2a
 8009672:	f8c5 202e 	str.w	r2, [r5, #46]	@ 0x2e
 8009676:	f8c5 3032 	str.w	r3, [r5, #50]	@ 0x32
            ( void ) memset( xRASolicitationRequest, 0, sizeof( *xRASolicitationRequest ) );
 800967a:	f8c5 6036 	str.w	r6, [r5, #54]	@ 0x36
 800967e:	f8c5 603a 	str.w	r6, [r5, #58]	@ 0x3a
            xRASolicitationRequest->ucTypeOfMessage = ipICMP_ROUTER_SOLICITATION_IPv6;
 8009682:	2385      	movs	r3, #133	@ 0x85
 8009684:	f885 3036 	strb.w	r3, [r5, #54]	@ 0x36
                ( void ) usGenerateProtocolChecksum( pxDescriptor->pucEthernetBuffer, pxDescriptor->xDataLength, pdTRUE );
 8009688:	2201      	movs	r2, #1
 800968a:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800968c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 800968e:	f7fe fd59 	bl	8008144 <usGenerateProtocolChecksum>
            vReturnEthernetFrame( pxDescriptor, pdTRUE );
 8009692:	2101      	movs	r1, #1
 8009694:	4620      	mov	r0, r4
 8009696:	f7fd fe9b 	bl	80073d0 <vReturnEthernetFrame>
    }
 800969a:	b006      	add	sp, #24
 800969c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ( void ) memset( xSourceAddress.ucBytes, 0, ipSIZE_OF_IPv6_ADDRESS );
 80096a0:	2300      	movs	r3, #0
 80096a2:	9300      	str	r3, [sp, #0]
 80096a4:	9301      	str	r3, [sp, #4]
 80096a6:	9302      	str	r3, [sp, #8]
 80096a8:	9303      	str	r3, [sp, #12]
 80096aa:	e79a      	b.n	80095e2 <vNDSendRouterSolicitation+0x4a>

080096ac <xRAProcess_HandleOtherStates>:
    {
 80096ac:	b510      	push	{r4, lr}
 80096ae:	b084      	sub	sp, #16
 80096b0:	4604      	mov	r4, r0
        switch( pxEndPoint->xRAData.eRAState )
 80096b2:	f890 3154 	ldrb.w	r3, [r0, #340]	@ 0x154
 80096b6:	2b05      	cmp	r3, #5
 80096b8:	d84c      	bhi.n	8009754 <xRAProcess_HandleOtherStates+0xa8>
 80096ba:	e8df f003 	tbb	[pc, r3]
 80096be:	4b03      	.short	0x4b03
 80096c0:	46414b1e 	.word	0x46414b1e
                   ( void ) memset( xIPAddress.ucBytes, 0, sizeof( xIPAddress.ucBytes ) );
 80096c4:	2100      	movs	r1, #0
 80096c6:	9100      	str	r1, [sp, #0]
 80096c8:	9101      	str	r1, [sp, #4]
 80096ca:	9102      	str	r1, [sp, #8]
 80096cc:	9103      	str	r1, [sp, #12]
                   xIPAddress.ucBytes[ 0 ] = 0xffU;
 80096ce:	23ff      	movs	r3, #255	@ 0xff
 80096d0:	f88d 3000 	strb.w	r3, [sp]
                   xIPAddress.ucBytes[ 1 ] = 0x02U;
 80096d4:	2302      	movs	r3, #2
 80096d6:	f88d 3001 	strb.w	r3, [sp, #1]
                   xIPAddress.ucBytes[ 15 ] = 0x02U;
 80096da:	f88d 300f 	strb.w	r3, [sp, #15]
                   pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxNeededSize, raDONT_BLOCK );
 80096de:	203e      	movs	r0, #62	@ 0x3e
 80096e0:	f005 f804 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
                   if( pxNetworkBuffer != NULL )
 80096e4:	b118      	cbz	r0, 80096ee <xRAProcess_HandleOtherStates+0x42>
                       pxNetworkBuffer->pxEndPoint = pxEndPoint;
 80096e6:	6304      	str	r4, [r0, #48]	@ 0x30
                       vNDSendRouterSolicitation( pxNetworkBuffer, &( xIPAddress ) );
 80096e8:	4669      	mov	r1, sp
 80096ea:	f7ff ff55 	bl	8009598 <vNDSendRouterSolicitation>
                   pxEndPoint->xRAData.eRAState = eRAStateWait;
 80096ee:	2301      	movs	r3, #1
 80096f0:	f884 3154 	strb.w	r3, [r4, #340]	@ 0x154
                   uxNewReloadTime = pdMS_TO_TICKS( ipconfigRA_SEARCH_TIME_OUT_MSEC );
 80096f4:	f242 7010 	movw	r0, #10000	@ 0x2710
               break;
 80096f8:	e02d      	b.n	8009756 <xRAProcess_HandleOtherStates+0xaa>
                   if( pxEndPoint->xRAData.bits.bIPAddressInUse != 0U )
 80096fa:	f890 3148 	ldrb.w	r3, [r0, #328]	@ 0x148
 80096fe:	f013 0f02 	tst.w	r3, #2
 8009702:	d10f      	bne.n	8009724 <xRAProcess_HandleOtherStates+0x78>
                   pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxNeededSize, raDONT_BLOCK );
 8009704:	2100      	movs	r1, #0
 8009706:	2056      	movs	r0, #86	@ 0x56
 8009708:	f004 fff0 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
                   if( pxNetworkBuffer != NULL )
 800970c:	b120      	cbz	r0, 8009718 <xRAProcess_HandleOtherStates+0x6c>
                       pxNetworkBuffer->pxEndPoint = pxEndPoint;
 800970e:	6304      	str	r4, [r0, #48]	@ 0x30
                       vNDSendNeighbourSolicitation( pxNetworkBuffer, &( pxEndPoint->ipv6_settings.xIPAddress ) );
 8009710:	f104 0138 	add.w	r1, r4, #56	@ 0x38
 8009714:	f7ff fc2e 	bl	8008f74 <vNDSendNeighbourSolicitation>
                   pxEndPoint->xRAData.eRAState = eRAStateIPWait;
 8009718:	2303      	movs	r3, #3
 800971a:	f884 3154 	strb.w	r3, [r4, #340]	@ 0x154
                   uxNewReloadTime = pdMS_TO_TICKS( 1000U );
 800971e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
               break;
 8009722:	e018      	b.n	8009756 <xRAProcess_HandleOtherStates+0xaa>
                       pxEndPoint->xRAData.bits.bIPAddressInUse = pdFALSE_UNSIGNED;
 8009724:	f890 3148 	ldrb.w	r3, [r0, #328]	@ 0x148
 8009728:	f023 0302 	bic.w	r3, r3, #2
 800972c:	f880 3148 	strb.w	r3, [r0, #328]	@ 0x148
                       ( void ) FreeRTOS_CreateIPv6Address( &pxEndPoint->ipv6_settings.xIPAddress, &pxEndPoint->ipv6_settings.xPrefix, pxEndPoint->ipv6_settings.uxPrefixLength, pdTRUE );
 8009730:	2301      	movs	r3, #1
 8009732:	6c82      	ldr	r2, [r0, #72]	@ 0x48
 8009734:	f100 014c 	add.w	r1, r0, #76	@ 0x4c
 8009738:	3038      	adds	r0, #56	@ 0x38
 800973a:	f7ff fe2b 	bl	8009394 <FreeRTOS_CreateIPv6Address>
 800973e:	e7e1      	b.n	8009704 <xRAProcess_HandleOtherStates+0x58>
                pxEndPoint->xRAData.eRAState = eRAStateLease;
 8009740:	2305      	movs	r3, #5
 8009742:	f880 3154 	strb.w	r3, [r0, #340]	@ 0x154
        TickType_t uxNewReloadTime = uxReloadTime;
 8009746:	4608      	mov	r0, r1
                break;
 8009748:	e005      	b.n	8009756 <xRAProcess_HandleOtherStates+0xaa>
                vRAProcessInit( pxEndPoint );
 800974a:	f7ff fe76 	bl	800943a <vRAProcessInit>
                uxNewReloadTime = pdMS_TO_TICKS( 1000U );
 800974e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
                break;
 8009752:	e000      	b.n	8009756 <xRAProcess_HandleOtherStates+0xaa>
        switch( pxEndPoint->xRAData.eRAState )
 8009754:	4608      	mov	r0, r1
    }
 8009756:	b004      	add	sp, #16
 8009758:	bd10      	pop	{r4, pc}

0800975a <vReceiveNA>:
    {
 800975a:	b570      	push	{r4, r5, r6, lr}
        const NetworkInterface_t * pxInterface = pxNetworkBuffer->pxInterface;
 800975c:	6ac5      	ldr	r5, [r0, #44]	@ 0x2c
        const ICMPPacket_IPv6_t * pxICMPPacket = ( ( const ICMPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800975e:	6a46      	ldr	r6, [r0, #36]	@ 0x24
        for( pxPoint = FreeRTOS_FirstEndPoint( pxInterface );
 8009760:	4628      	mov	r0, r5
 8009762:	f000 f961 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8009766:	4604      	mov	r4, r0
 8009768:	e004      	b.n	8009774 <vReceiveNA+0x1a>
             pxPoint = FreeRTOS_NextEndPoint( pxInterface, pxPoint ) )
 800976a:	4621      	mov	r1, r4
 800976c:	4628      	mov	r0, r5
 800976e:	f000 f96b 	bl	8009a48 <FreeRTOS_NextEndPoint>
 8009772:	4604      	mov	r4, r0
             pxPoint != NULL;
 8009774:	b1e4      	cbz	r4, 80097b0 <vReceiveNA+0x56>
            if( ( pxPoint->bits.bWantRA != pdFALSE_UNSIGNED ) && ( pxPoint->xRAData.eRAState == eRAStateIPWait ) )
 8009776:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 800977a:	f013 0f04 	tst.w	r3, #4
 800977e:	d0f4      	beq.n	800976a <vReceiveNA+0x10>
 8009780:	f894 3154 	ldrb.w	r3, [r4, #340]	@ 0x154
 8009784:	2b03      	cmp	r3, #3
 8009786:	d1f0      	bne.n	800976a <vReceiveNA+0x10>
                if( memcmp( pxPoint->ipv6_settings.xIPAddress.ucBytes, pxICMPHeader_IPv6->xIPv6Address.ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 8009788:	2210      	movs	r2, #16
 800978a:	f106 013e 	add.w	r1, r6, #62	@ 0x3e
 800978e:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 8009792:	f005 fa65 	bl	800ec60 <memcmp>
 8009796:	2800      	cmp	r0, #0
 8009798:	d1e7      	bne.n	800976a <vReceiveNA+0x10>
                    pxPoint->xRAData.bits.bIPAddressInUse = pdTRUE_UNSIGNED;
 800979a:	f894 3148 	ldrb.w	r3, [r4, #328]	@ 0x148
 800979e:	f043 0302 	orr.w	r3, r3, #2
 80097a2:	f884 3148 	strb.w	r3, [r4, #328]	@ 0x148
                    vDHCP_RATimerReload( pxPoint, 100U );
 80097a6:	2164      	movs	r1, #100	@ 0x64
 80097a8:	4620      	mov	r0, r4
 80097aa:	f7fe f911 	bl	80079d0 <vDHCP_RATimerReload>
 80097ae:	e7dc      	b.n	800976a <vReceiveNA+0x10>
    }
 80097b0:	bd70      	pop	{r4, r5, r6, pc}

080097b2 <vRAProcess>:

        #if ( ipconfigHAS_PRINTF == 1 )
            eRAState_t eRAState;
        #endif

        configASSERT( pxEndPoint != NULL );
 80097b2:	b189      	cbz	r1, 80097d8 <vRAProcess+0x26>
    {
 80097b4:	b510      	push	{r4, lr}
 80097b6:	460c      	mov	r4, r1
        #if ( ipconfigHAS_PRINTF == 1 )
            /* Remember the initial state, just for logging. */
            eRAState = pxEndPoint->xRAData.eRAState;
        #endif

        if( xDoReset != pdFALSE )
 80097b8:	b9b8      	cbnz	r0, 80097ea <vRAProcess+0x38>
            vRAProcessInit( pxEndPoint );
        }

        /* First handle the states that are limited by a timer. See if some
         * timer has expired. */
        uxReloadTime = xRAProcess_HandleWaitStates( pxEndPoint, uxReloadTime );
 80097ba:	f241 3188 	movw	r1, #5000	@ 0x1388
 80097be:	4620      	mov	r0, r4
 80097c0:	f7ff fe84 	bl	80094cc <xRAProcess_HandleWaitStates>
 80097c4:	4601      	mov	r1, r0

        /* Now handle the other states. */
        uxReloadTime = xRAProcess_HandleOtherStates( pxEndPoint, uxReloadTime );
 80097c6:	4620      	mov	r0, r4
 80097c8:	f7ff ff70 	bl	80096ac <xRAProcess_HandleOtherStates>
                               eRAState,
                               pxEndPoint->xRAData.eRAState ) );
        }
        #endif /* ( ipconfigHAS_PRINTF == 1 ) */

        if( uxReloadTime != 0U )
 80097cc:	4601      	mov	r1, r0
 80097ce:	b180      	cbz	r0, 80097f2 <vRAProcess+0x40>
        {
            FreeRTOS_printf( ( "RA: Reload %u seconds\n", ( unsigned ) ( uxReloadTime / 1000U ) ) );
            vDHCP_RATimerReload( pxEndPoint, uxReloadTime );
 80097d0:	4620      	mov	r0, r4
 80097d2:	f7fe f8fd 	bl	80079d0 <vDHCP_RATimerReload>
        {
            /* Disable the timer, this function vRAProcess() won't be called anymore for this end-point. */
            FreeRTOS_printf( ( "RA: Disabled timer.\n" ) );
            vIPSetDHCP_RATimerEnableState( pxEndPoint, pdFALSE );
        }
    }
 80097d6:	bd10      	pop	{r4, pc}
 80097d8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80097dc:	f383 8811 	msr	BASEPRI, r3
 80097e0:	f3bf 8f6f 	isb	sy
 80097e4:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEndPoint != NULL );
 80097e8:	e7fe      	b.n	80097e8 <vRAProcess+0x36>
            vRAProcessInit( pxEndPoint );
 80097ea:	4608      	mov	r0, r1
 80097ec:	f7ff fe25 	bl	800943a <vRAProcessInit>
 80097f0:	e7e3      	b.n	80097ba <vRAProcess+0x8>
            vIPSetDHCP_RATimerEnableState( pxEndPoint, pdFALSE );
 80097f2:	2100      	movs	r1, #0
 80097f4:	4620      	mov	r0, r4
 80097f6:	f7fe f92d 	bl	8007a54 <vIPSetDHCP_RATimerEnableState>
    }
 80097fa:	e7ec      	b.n	80097d6 <vRAProcess+0x24>

080097fc <vReceiveRA>:
    {
 80097fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        const ICMPPacket_IPv6_t * pxICMPPacket = ( ( const ICMPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80097fe:	6a46      	ldr	r6, [r0, #36]	@ 0x24
        if( uxNeededSize > pxNetworkBuffer->xDataLength )
 8009800:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 8009802:	2b45      	cmp	r3, #69	@ 0x45
 8009804:	d902      	bls.n	800980c <vReceiveRA+0x10>
 8009806:	4604      	mov	r4, r0
            if( pxAdvertisement->usLifetime != 0U )
 8009808:	8fb3      	ldrh	r3, [r6, #60]	@ 0x3c
 800980a:	b903      	cbnz	r3, 800980e <vReceiveRA+0x12>
    }
 800980c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                pxPrefixOption = vReceiveRA_ReadReply( pxNetworkBuffer );
 800980e:	f7ff fe3c 	bl	800948a <vReceiveRA_ReadReply>
 8009812:	4607      	mov	r7, r0
                configASSERT( pxNetworkBuffer->pxInterface != NULL );
 8009814:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8009816:	b128      	cbz	r0, 8009824 <vReceiveRA+0x28>
                if( pxPrefixOption != NULL )
 8009818:	2f00      	cmp	r7, #0
 800981a:	d0f7      	beq.n	800980c <vReceiveRA+0x10>
                    for( pxEndPoint = FreeRTOS_FirstEndPoint( pxNetworkBuffer->pxInterface );
 800981c:	f000 f904 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 8009820:	4605      	mov	r5, r0
 8009822:	e00d      	b.n	8009840 <vReceiveRA+0x44>
 8009824:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009828:	f383 8811 	msr	BASEPRI, r3
 800982c:	f3bf 8f6f 	isb	sy
 8009830:	f3bf 8f4f 	dsb	sy
                configASSERT( pxNetworkBuffer->pxInterface != NULL );
 8009834:	e7fe      	b.n	8009834 <vReceiveRA+0x38>
                         pxEndPoint = FreeRTOS_NextEndPoint( pxNetworkBuffer->pxInterface, pxEndPoint ) )
 8009836:	4629      	mov	r1, r5
 8009838:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 800983a:	f000 f905 	bl	8009a48 <FreeRTOS_NextEndPoint>
 800983e:	4605      	mov	r5, r0
                         pxEndPoint != NULL;
 8009840:	2d00      	cmp	r5, #0
 8009842:	d0e3      	beq.n	800980c <vReceiveRA+0x10>
                        if( ( pxEndPoint->bits.bWantRA != pdFALSE_UNSIGNED ) && ( pxEndPoint->xRAData.eRAState == eRAStateWait ) )
 8009844:	f895 30f0 	ldrb.w	r3, [r5, #240]	@ 0xf0
 8009848:	f013 0f04 	tst.w	r3, #4
 800984c:	d0f3      	beq.n	8009836 <vReceiveRA+0x3a>
 800984e:	f895 3154 	ldrb.w	r3, [r5, #340]	@ 0x154
 8009852:	2b01      	cmp	r3, #1
 8009854:	d1ef      	bne.n	8009836 <vReceiveRA+0x3a>
                            pxEndPoint->ipv6_settings.uxPrefixLength = pxPrefixOption->ucPrefixLength;
 8009856:	78bb      	ldrb	r3, [r7, #2]
 8009858:	64ab      	str	r3, [r5, #72]	@ 0x48
                            ( void ) memcpy( pxEndPoint->ipv6_settings.xPrefix.ucBytes, pxPrefixOption->ucPrefix, ipSIZE_OF_IPv6_ADDRESS );
 800985a:	6938      	ldr	r0, [r7, #16]
 800985c:	6979      	ldr	r1, [r7, #20]
 800985e:	69ba      	ldr	r2, [r7, #24]
 8009860:	69fb      	ldr	r3, [r7, #28]
 8009862:	64e8      	str	r0, [r5, #76]	@ 0x4c
 8009864:	6529      	str	r1, [r5, #80]	@ 0x50
 8009866:	656a      	str	r2, [r5, #84]	@ 0x54
 8009868:	65ab      	str	r3, [r5, #88]	@ 0x58
                            ( void ) memcpy( pxEndPoint->ipv6_settings.xGatewayAddress.ucBytes, pxICMPPacket->xIPHeader.xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800986a:	f8d6 0016 	ldr.w	r0, [r6, #22]
 800986e:	f8d6 101a 	ldr.w	r1, [r6, #26]
 8009872:	f8d6 201e 	ldr.w	r2, [r6, #30]
 8009876:	f8d6 3022 	ldr.w	r3, [r6, #34]	@ 0x22
 800987a:	65e8      	str	r0, [r5, #92]	@ 0x5c
 800987c:	6629      	str	r1, [r5, #96]	@ 0x60
 800987e:	666a      	str	r2, [r5, #100]	@ 0x64
 8009880:	66ab      	str	r3, [r5, #104]	@ 0x68
                            pxEndPoint->xRAData.bits.bRouterReplied = pdTRUE_UNSIGNED;
 8009882:	f895 3148 	ldrb.w	r3, [r5, #328]	@ 0x148
 8009886:	f043 0301 	orr.w	r3, r3, #1
 800988a:	f885 3148 	strb.w	r3, [r5, #328]	@ 0x148
                            pxEndPoint->xRAData.uxRetryCount = 0U;
 800988e:	2000      	movs	r0, #0
 8009890:	f8c5 0150 	str.w	r0, [r5, #336]	@ 0x150
                            pxEndPoint->xRAData.ulPreferredLifeTime = FreeRTOS_ntohl( pxPrefixOption->ulPreferredLifeTime );
 8009894:	68ba      	ldr	r2, [r7, #8]
 8009896:	0213      	lsls	r3, r2, #8
 8009898:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800989c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80098a0:	0a11      	lsrs	r1, r2, #8
 80098a2:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 80098a6:	430b      	orrs	r3, r1
 80098a8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80098ac:	f8c5 314c 	str.w	r3, [r5, #332]	@ 0x14c
                            pxEndPoint->xRAData.bits.bIPAddressInUse = pdTRUE_UNSIGNED;
 80098b0:	f895 3148 	ldrb.w	r3, [r5, #328]	@ 0x148
 80098b4:	f043 0302 	orr.w	r3, r3, #2
 80098b8:	f885 3148 	strb.w	r3, [r5, #328]	@ 0x148
                            pxEndPoint->xRAData.eRAState = eRAStateIPTest;
 80098bc:	2302      	movs	r3, #2
 80098be:	f885 3154 	strb.w	r3, [r5, #340]	@ 0x154
                            vRAProcess( pdFALSE, pxEndPoint );
 80098c2:	4629      	mov	r1, r5
 80098c4:	f7ff ff75 	bl	80097b2 <vRAProcess>
 80098c8:	e7b5      	b.n	8009836 <vReceiveRA+0x3a>
	...

080098cc <FreeRTOS_AddEndPoint>:
 *
 * @return The value of the parameter 'pxEndPoint'.
 */
    static NetworkEndPoint_t * FreeRTOS_AddEndPoint( NetworkInterface_t * pxInterface,
                                                     NetworkEndPoint_t * pxEndPoint )
    {
 80098cc:	4603      	mov	r3, r0
 80098ce:	4608      	mov	r0, r1
        NetworkEndPoint_t * pxIterator = NULL;

        /* Double link between the NetworkInterface_t that is using the addressing
         * defined by this NetworkEndPoint_t structure. */
        pxEndPoint->pxNetworkInterface = pxInterface;
 80098d0:	f8c1 3158 	str.w	r3, [r1, #344]	@ 0x158

        if( pxInterface->pxEndPoint == NULL )
 80098d4:	6a1a      	ldr	r2, [r3, #32]
 80098d6:	b13a      	cbz	r2, 80098e8 <FreeRTOS_AddEndPoint+0x1c>
            /*_RB_ When would pxInterface->pxEndPoint ever not be NULL unless this is called twice? */
            /*_HT_ It may be called twice. */
            pxInterface->pxEndPoint = pxEndPoint;
        }

        if( pxNetworkEndPoints == NULL )
 80098d8:	4b0a      	ldr	r3, [pc, #40]	@ (8009904 <FreeRTOS_AddEndPoint+0x38>)
 80098da:	681b      	ldr	r3, [r3, #0]
 80098dc:	b93b      	cbnz	r3, 80098ee <FreeRTOS_AddEndPoint+0x22>
        {
            /* No other end points are defined yet - so this is the first in the
             * list. */
            pxEndPoint->pxNext = NULL;
 80098de:	f8c0 315c 	str.w	r3, [r0, #348]	@ 0x15c
            pxNetworkEndPoints = pxEndPoint;
 80098e2:	4b08      	ldr	r3, [pc, #32]	@ (8009904 <FreeRTOS_AddEndPoint+0x38>)
 80098e4:	6018      	str	r0, [r3, #0]
 80098e6:	4770      	bx	lr
            pxInterface->pxEndPoint = pxEndPoint;
 80098e8:	6219      	str	r1, [r3, #32]
 80098ea:	e7f5      	b.n	80098d8 <FreeRTOS_AddEndPoint+0xc>
                    pxEndPoint->pxNext = NULL;
                    pxIterator->pxNext = pxEndPoint;
                    break;
                }

                pxIterator = pxIterator->pxNext;
 80098ec:	4613      	mov	r3, r2
                if( pxIterator == pxEndPoint )
 80098ee:	4283      	cmp	r3, r0
 80098f0:	d007      	beq.n	8009902 <FreeRTOS_AddEndPoint+0x36>
                if( pxIterator->pxNext == NULL )
 80098f2:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
 80098f6:	2a00      	cmp	r2, #0
 80098f8:	d1f8      	bne.n	80098ec <FreeRTOS_AddEndPoint+0x20>
                    pxEndPoint->pxNext = NULL;
 80098fa:	f8c0 215c 	str.w	r2, [r0, #348]	@ 0x15c
                    pxIterator->pxNext = pxEndPoint;
 80098fe:	f8c3 015c 	str.w	r0, [r3, #348]	@ 0x15c
                                   ( unsigned ) FreeRTOS_ntohl( pxEndPoint->ipv4_defaults.ulIPAddress ) ) );
            }
        #endif /* ( ipconfigUSE_IPv4 != 0 ) */

        return pxEndPoint;
    }
 8009902:	4770      	bx	lr
 8009904:	20013778 	.word	0x20013778

08009908 <FreeRTOS_FillEndPoint>:
    {
 8009908:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800990c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8009910:	f8dd 8024 	ldr.w	r8, [sp, #36]	@ 0x24
        if( ( pxNetworkInterface == NULL ) || ( pxEndPoint == NULL ) )
 8009914:	2800      	cmp	r0, #0
 8009916:	d062      	beq.n	80099de <FreeRTOS_FillEndPoint+0xd6>
 8009918:	460c      	mov	r4, r1
 800991a:	4616      	mov	r6, r2
 800991c:	461d      	mov	r5, r3
 800991e:	4607      	mov	r7, r0
 8009920:	2900      	cmp	r1, #0
 8009922:	d05c      	beq.n	80099de <FreeRTOS_FillEndPoint+0xd6>
            NetworkEndPoint_t * pxNext = pxEndPoint->pxNext;
 8009924:	f8d1 a15c 	ldr.w	sl, [r1, #348]	@ 0x15c
            ( void ) memset( pxEndPoint, 0, sizeof( *pxEndPoint ) );
 8009928:	f44f 72b0 	mov.w	r2, #352	@ 0x160
 800992c:	2100      	movs	r1, #0
 800992e:	4620      	mov	r0, r4
 8009930:	f005 f9c0 	bl	800ecb4 <memset>
            pxEndPoint->pxNext = pxNext;
 8009934:	f8c4 a15c 	str.w	sl, [r4, #348]	@ 0x15c
            ulIPAddress = FreeRTOS_inet_addr_quick( ucIPAddress[ 0 ], ucIPAddress[ 1 ], ucIPAddress[ 2 ], ucIPAddress[ 3 ] );
 8009938:	78f3      	ldrb	r3, [r6, #3]
 800993a:	78b2      	ldrb	r2, [r6, #2]
 800993c:	0412      	lsls	r2, r2, #16
 800993e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8009942:	7873      	ldrb	r3, [r6, #1]
 8009944:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8009948:	7833      	ldrb	r3, [r6, #0]
 800994a:	431a      	orrs	r2, r3
            pxEndPoint->ipv4_settings.ulNetMask = FreeRTOS_inet_addr_quick( ucNetMask[ 0 ], ucNetMask[ 1 ], ucNetMask[ 2 ], ucNetMask[ 3 ] );
 800994c:	78e9      	ldrb	r1, [r5, #3]
 800994e:	78ab      	ldrb	r3, [r5, #2]
 8009950:	041b      	lsls	r3, r3, #16
 8009952:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8009956:	7869      	ldrb	r1, [r5, #1]
 8009958:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800995c:	7829      	ldrb	r1, [r5, #0]
 800995e:	430b      	orrs	r3, r1
 8009960:	6063      	str	r3, [r4, #4]
            pxEndPoint->ipv4_settings.ulGatewayAddress = FreeRTOS_inet_addr_quick( ucGatewayAddress[ 0 ], ucGatewayAddress[ 1 ], ucGatewayAddress[ 2 ], ucGatewayAddress[ 3 ] );
 8009962:	f899 0003 	ldrb.w	r0, [r9, #3]
 8009966:	f899 1002 	ldrb.w	r1, [r9, #2]
 800996a:	0409      	lsls	r1, r1, #16
 800996c:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 8009970:	f899 0001 	ldrb.w	r0, [r9, #1]
 8009974:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8009978:	f899 0000 	ldrb.w	r0, [r9]
 800997c:	4301      	orrs	r1, r0
 800997e:	60a1      	str	r1, [r4, #8]
            pxEndPoint->ipv4_settings.ulDNSServerAddresses[ 0 ] = FreeRTOS_inet_addr_quick( ucDNSServerAddress[ 0 ], ucDNSServerAddress[ 1 ], ucDNSServerAddress[ 2 ], ucDNSServerAddress[ 3 ] );
 8009980:	f898 0003 	ldrb.w	r0, [r8, #3]
 8009984:	f898 1002 	ldrb.w	r1, [r8, #2]
 8009988:	0409      	lsls	r1, r1, #16
 800998a:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 800998e:	f898 0001 	ldrb.w	r0, [r8, #1]
 8009992:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8009996:	f898 0000 	ldrb.w	r0, [r8]
 800999a:	4301      	orrs	r1, r0
 800999c:	60e1      	str	r1, [r4, #12]
            pxEndPoint->ipv4_settings.ulBroadcastAddress = ulIPAddress | ~( pxEndPoint->ipv4_settings.ulNetMask );
 800999e:	ea62 0303 	orn	r3, r2, r3
 80099a2:	6163      	str	r3, [r4, #20]
            ( void ) memcpy( &( pxEndPoint->ipv4_defaults ), &( pxEndPoint->ipv4_settings ), sizeof( pxEndPoint->ipv4_defaults ) );
 80099a4:	4623      	mov	r3, r4
 80099a6:	f853 5b1c 	ldr.w	r5, [r3], #28
 80099aa:	6860      	ldr	r0, [r4, #4]
 80099ac:	68a1      	ldr	r1, [r4, #8]
 80099ae:	68e6      	ldr	r6, [r4, #12]
 80099b0:	61e5      	str	r5, [r4, #28]
 80099b2:	6058      	str	r0, [r3, #4]
 80099b4:	6099      	str	r1, [r3, #8]
 80099b6:	60de      	str	r6, [r3, #12]
 80099b8:	6925      	ldr	r5, [r4, #16]
 80099ba:	6960      	ldr	r0, [r4, #20]
 80099bc:	69a1      	ldr	r1, [r4, #24]
 80099be:	611d      	str	r5, [r3, #16]
 80099c0:	6158      	str	r0, [r3, #20]
 80099c2:	6199      	str	r1, [r3, #24]
            pxEndPoint->ipv4_defaults.ulIPAddress = ulIPAddress;
 80099c4:	61e2      	str	r2, [r4, #28]
            ( void ) memcpy( pxEndPoint->xMACAddress.ucBytes, ucMACAddress, sizeof( pxEndPoint->xMACAddress ) );
 80099c6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80099c8:	681b      	ldr	r3, [r3, #0]
 80099ca:	f8c4 30e8 	str.w	r3, [r4, #232]	@ 0xe8
 80099ce:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80099d0:	889b      	ldrh	r3, [r3, #4]
 80099d2:	f8a4 30ec 	strh.w	r3, [r4, #236]	@ 0xec
            ( void ) FreeRTOS_AddEndPoint( pxNetworkInterface, pxEndPoint );
 80099d6:	4621      	mov	r1, r4
 80099d8:	4638      	mov	r0, r7
 80099da:	f7ff ff77 	bl	80098cc <FreeRTOS_AddEndPoint>
    }
 80099de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

080099e4 <FreeRTOS_AddNetworkInterface>:
        if( pxInterface != NULL )
 80099e4:	4601      	mov	r1, r0
 80099e6:	b180      	cbz	r0, 8009a0a <FreeRTOS_AddNetworkInterface+0x26>
            if( pxNetworkInterfaces == NULL )
 80099e8:	4b09      	ldr	r3, [pc, #36]	@ (8009a10 <FreeRTOS_AddNetworkInterface+0x2c>)
 80099ea:	681b      	ldr	r3, [r3, #0]
 80099ec:	b92b      	cbnz	r3, 80099fa <FreeRTOS_AddNetworkInterface+0x16>
                pxNetworkInterfaces = pxInterface;
 80099ee:	4b08      	ldr	r3, [pc, #32]	@ (8009a10 <FreeRTOS_AddNetworkInterface+0x2c>)
 80099f0:	6018      	str	r0, [r3, #0]
                pxInterface->pxNext = NULL;
 80099f2:	2300      	movs	r3, #0
 80099f4:	6243      	str	r3, [r0, #36]	@ 0x24
 80099f6:	e008      	b.n	8009a0a <FreeRTOS_AddNetworkInterface+0x26>
                    pxIterator = pxIterator->pxNext;
 80099f8:	4613      	mov	r3, r2
                    if( pxIterator == pxInterface )
 80099fa:	428b      	cmp	r3, r1
 80099fc:	d005      	beq.n	8009a0a <FreeRTOS_AddNetworkInterface+0x26>
                    if( pxIterator->pxNext == NULL )
 80099fe:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8009a00:	2a00      	cmp	r2, #0
 8009a02:	d1f9      	bne.n	80099f8 <FreeRTOS_AddNetworkInterface+0x14>
                        pxIterator->pxNext = pxInterface;
 8009a04:	6259      	str	r1, [r3, #36]	@ 0x24
                        pxInterface->pxNext = NULL;
 8009a06:	2300      	movs	r3, #0
 8009a08:	624b      	str	r3, [r1, #36]	@ 0x24
    }
 8009a0a:	4608      	mov	r0, r1
 8009a0c:	4770      	bx	lr
 8009a0e:	bf00      	nop
 8009a10:	20013774 	.word	0x20013774

08009a14 <FreeRTOS_FirstNetworkInterface>:
    }
 8009a14:	4b01      	ldr	r3, [pc, #4]	@ (8009a1c <FreeRTOS_FirstNetworkInterface+0x8>)
 8009a16:	6818      	ldr	r0, [r3, #0]
 8009a18:	4770      	bx	lr
 8009a1a:	bf00      	nop
 8009a1c:	20013774 	.word	0x20013774

08009a20 <FreeRTOS_NextNetworkInterface>:
        if( pxInterface != NULL )
 8009a20:	b108      	cbz	r0, 8009a26 <FreeRTOS_NextNetworkInterface+0x6>
            pxReturn = pxInterface->pxNext;
 8009a22:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 8009a24:	4770      	bx	lr
    }
 8009a26:	4770      	bx	lr

08009a28 <FreeRTOS_FirstEndPoint>:
 *
 * @return The first end-point that is found to the interface, or NULL when the
 *         interface doesn't have any end-point yet.
 */
    NetworkEndPoint_t * FreeRTOS_FirstEndPoint( const NetworkInterface_t * pxInterface )
    {
 8009a28:	4603      	mov	r3, r0
        NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8009a2a:	4a06      	ldr	r2, [pc, #24]	@ (8009a44 <FreeRTOS_FirstEndPoint+0x1c>)
 8009a2c:	6810      	ldr	r0, [r2, #0]

        /* Find and return the NetworkEndPoint_t structure that is associated with
         * the pxInterface NetworkInterface_t. *//*_RB_ Could this be made a two way link, so the NetworkEndPoint_t can just be read from the NetworkInterface_t structure?  Looks like there is a pointer in the struct already. */
        while( pxEndPoint != NULL )
 8009a2e:	e001      	b.n	8009a34 <FreeRTOS_FirstEndPoint+0xc>
            if( ( pxInterface == NULL ) || ( pxEndPoint->pxNetworkInterface == pxInterface ) )
            {
                break;
            }

            pxEndPoint = pxEndPoint->pxNext;
 8009a30:	f8d0 015c 	ldr.w	r0, [r0, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8009a34:	b120      	cbz	r0, 8009a40 <FreeRTOS_FirstEndPoint+0x18>
            if( ( pxInterface == NULL ) || ( pxEndPoint->pxNetworkInterface == pxInterface ) )
 8009a36:	b11b      	cbz	r3, 8009a40 <FreeRTOS_FirstEndPoint+0x18>
 8009a38:	f8d0 2158 	ldr.w	r2, [r0, #344]	@ 0x158
 8009a3c:	429a      	cmp	r2, r3
 8009a3e:	d1f7      	bne.n	8009a30 <FreeRTOS_FirstEndPoint+0x8>
        }

        return pxEndPoint;
    }
 8009a40:	4770      	bx	lr
 8009a42:	bf00      	nop
 8009a44:	20013778 	.word	0x20013778

08009a48 <FreeRTOS_NextEndPoint>:
 *
 * @return The end-point that is found, or NULL when there are no more end-points in the list.
 */
    NetworkEndPoint_t * FreeRTOS_NextEndPoint( const NetworkInterface_t * pxInterface,
                                               NetworkEndPoint_t * pxEndPoint )
    {
 8009a48:	b508      	push	{r3, lr}
 8009a4a:	4603      	mov	r3, r0
        NetworkEndPoint_t * pxResult = pxEndPoint;

        if( pxResult != NULL )
 8009a4c:	b151      	cbz	r1, 8009a64 <FreeRTOS_NextEndPoint+0x1c>
        {
            pxResult = pxResult->pxNext;
 8009a4e:	f8d1 015c 	ldr.w	r0, [r1, #348]	@ 0x15c

            while( pxResult != NULL )
 8009a52:	b148      	cbz	r0, 8009a68 <FreeRTOS_NextEndPoint+0x20>
            {
                if( ( pxInterface == NULL ) || ( pxResult->pxNetworkInterface == pxInterface ) )
 8009a54:	b143      	cbz	r3, 8009a68 <FreeRTOS_NextEndPoint+0x20>
 8009a56:	f8d0 2158 	ldr.w	r2, [r0, #344]	@ 0x158
 8009a5a:	429a      	cmp	r2, r3
 8009a5c:	d004      	beq.n	8009a68 <FreeRTOS_NextEndPoint+0x20>
                {
                    break;
                }

                pxResult = pxResult->pxNext;
 8009a5e:	f8d0 015c 	ldr.w	r0, [r0, #348]	@ 0x15c
 8009a62:	e7f6      	b.n	8009a52 <FreeRTOS_NextEndPoint+0xa>
            }
        }
        else
        {
            pxResult = FreeRTOS_FirstEndPoint( pxInterface );
 8009a64:	f7ff ffe0 	bl	8009a28 <FreeRTOS_FirstEndPoint>
        }

        return pxResult;
    }
 8009a68:	bd08      	pop	{r3, pc}
	...

08009a6c <FreeRTOS_FindEndPointOnIP_IPv4>:
 *
 * @return The end-point found or NULL.
 */
    NetworkEndPoint_t * FreeRTOS_FindEndPointOnIP_IPv4( uint32_t ulIPAddress,
                                                        uint32_t ulWhere )
    {
 8009a6c:	b410      	push	{r4}
 8009a6e:	4602      	mov	r2, r0
        NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8009a70:	4b0f      	ldr	r3, [pc, #60]	@ (8009ab0 <FreeRTOS_FindEndPointOnIP_IPv4+0x44>)
 8009a72:	6818      	ldr	r0, [r3, #0]

        #if ( ipconfigHAS_ROUTING_STATISTICS == 1 )
            uint32_t ulLocationCount = ( uint32_t ) ( sizeof( xRoutingStatistics.ulLocationsIP ) / sizeof( xRoutingStatistics.ulLocationsIP[ 0 ] ) );

            xRoutingStatistics.ulOnIp++;
 8009a74:	4c0f      	ldr	r4, [pc, #60]	@ (8009ab4 <FreeRTOS_FindEndPointOnIP_IPv4+0x48>)
 8009a76:	6823      	ldr	r3, [r4, #0]
 8009a78:	3301      	adds	r3, #1
 8009a7a:	6023      	str	r3, [r4, #0]

            if( ulWhere < ulLocationCount )
 8009a7c:	2907      	cmp	r1, #7
 8009a7e:	d808      	bhi.n	8009a92 <FreeRTOS_FindEndPointOnIP_IPv4+0x26>
            {
                xRoutingStatistics.ulLocationsIP[ ulWhere ]++;
 8009a80:	3112      	adds	r1, #18
 8009a82:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 8009a86:	3301      	adds	r3, #1
 8009a88:	f844 3021 	str.w	r3, [r4, r1, lsl #2]
 8009a8c:	e001      	b.n	8009a92 <FreeRTOS_FindEndPointOnIP_IPv4+0x26>
                        break;
                    }
                }
            #endif /* ( ipconfigUSE_IPv4 != 0 ) */

            pxEndPoint = pxEndPoint->pxNext;
 8009a8e:	f8d0 015c 	ldr.w	r0, [r0, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8009a92:	b148      	cbz	r0, 8009aa8 <FreeRTOS_FindEndPointOnIP_IPv4+0x3c>
                    if( pxEndPoint->bits.bIPv6 == 0U )
 8009a94:	f890 30f0 	ldrb.w	r3, [r0, #240]	@ 0xf0
 8009a98:	f013 0f08 	tst.w	r3, #8
 8009a9c:	d1f7      	bne.n	8009a8e <FreeRTOS_FindEndPointOnIP_IPv4+0x22>
                    if( ( ulIPAddress == 0U ) ||
 8009a9e:	b11a      	cbz	r2, 8009aa8 <FreeRTOS_FindEndPointOnIP_IPv4+0x3c>
                        ( pxEndPoint->ipv4_settings.ulIPAddress == 0U ) ||
 8009aa0:	6803      	ldr	r3, [r0, #0]
                    if( ( ulIPAddress == 0U ) ||
 8009aa2:	b10b      	cbz	r3, 8009aa8 <FreeRTOS_FindEndPointOnIP_IPv4+0x3c>
                        ( pxEndPoint->ipv4_settings.ulIPAddress == 0U ) ||
 8009aa4:	4293      	cmp	r3, r2
 8009aa6:	d1f2      	bne.n	8009a8e <FreeRTOS_FindEndPointOnIP_IPv4+0x22>
        }

        ( void ) ulIPAddress;

        return pxEndPoint;
    }
 8009aa8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009aac:	4770      	bx	lr
 8009aae:	bf00      	nop
 8009ab0:	20013778 	.word	0x20013778
 8009ab4:	2001370c 	.word	0x2001370c

08009ab8 <FreeRTOS_FindEndPointOnMAC>:
 *
 * @return The end-point that has the given MAC-address.
 */
    NetworkEndPoint_t * FreeRTOS_FindEndPointOnMAC( const MACAddress_t * pxMACAddress,
                                                    const NetworkInterface_t * pxInterface )
    {
 8009ab8:	b570      	push	{r4, r5, r6, lr}
 8009aba:	460d      	mov	r5, r1
        NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8009abc:	4b0e      	ldr	r3, [pc, #56]	@ (8009af8 <FreeRTOS_FindEndPointOnMAC+0x40>)
 8009abe:	681c      	ldr	r4, [r3, #0]

        #if ( ipconfigHAS_ROUTING_STATISTICS == 1 )
        {
            xRoutingStatistics.ulOnMAC++;
 8009ac0:	4a0e      	ldr	r2, [pc, #56]	@ (8009afc <FreeRTOS_FindEndPointOnMAC+0x44>)
 8009ac2:	6853      	ldr	r3, [r2, #4]
 8009ac4:	3301      	adds	r3, #1
 8009ac6:	6053      	str	r3, [r2, #4]
        }
        #endif

        /* If input MAC address is NULL, return NULL. */
        if( pxMACAddress == NULL )
 8009ac8:	4606      	mov	r6, r0
 8009aca:	b950      	cbnz	r0, 8009ae2 <FreeRTOS_FindEndPointOnMAC+0x2a>
        {
            pxEndPoint = NULL;
 8009acc:	4604      	mov	r4, r0
 8009ace:	e008      	b.n	8009ae2 <FreeRTOS_FindEndPointOnMAC+0x2a>
        /* Find the end-point with given MAC-address. */
        while( pxEndPoint != NULL )
        {
            if( ( pxInterface == NULL ) || ( pxInterface == pxEndPoint->pxNetworkInterface ) )
            {
                if( memcmp( pxEndPoint->xMACAddress.ucBytes, pxMACAddress->ucBytes, ipMAC_ADDRESS_LENGTH_BYTES ) == 0 )
 8009ad0:	2206      	movs	r2, #6
 8009ad2:	4631      	mov	r1, r6
 8009ad4:	f104 00e8 	add.w	r0, r4, #232	@ 0xe8
 8009ad8:	f005 f8c2 	bl	800ec60 <memcmp>
 8009adc:	b148      	cbz	r0, 8009af2 <FreeRTOS_FindEndPointOnMAC+0x3a>
                {
                    break;
                }
            }

            pxEndPoint = pxEndPoint->pxNext;
 8009ade:	f8d4 415c 	ldr.w	r4, [r4, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8009ae2:	b134      	cbz	r4, 8009af2 <FreeRTOS_FindEndPointOnMAC+0x3a>
            if( ( pxInterface == NULL ) || ( pxInterface == pxEndPoint->pxNetworkInterface ) )
 8009ae4:	2d00      	cmp	r5, #0
 8009ae6:	d0f3      	beq.n	8009ad0 <FreeRTOS_FindEndPointOnMAC+0x18>
 8009ae8:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
 8009aec:	42ab      	cmp	r3, r5
 8009aee:	d1f6      	bne.n	8009ade <FreeRTOS_FindEndPointOnMAC+0x26>
 8009af0:	e7ee      	b.n	8009ad0 <FreeRTOS_FindEndPointOnMAC+0x18>
        }

        return pxEndPoint;
    }
 8009af2:	4620      	mov	r0, r4
 8009af4:	bd70      	pop	{r4, r5, r6, pc}
 8009af6:	bf00      	nop
 8009af8:	20013778 	.word	0x20013778
 8009afc:	2001370c 	.word	0x2001370c

08009b00 <FreeRTOS_InterfaceEndPointOnNetMask>:
 * @return An end-point that has the same network mask as the given IP-address.
 */
    NetworkEndPoint_t * FreeRTOS_InterfaceEndPointOnNetMask( const NetworkInterface_t * pxInterface,
                                                             uint32_t ulIPAddress,
                                                             uint32_t ulWhere )
    {
 8009b00:	b430      	push	{r4, r5}
 8009b02:	4603      	mov	r3, r0
        NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8009b04:	4813      	ldr	r0, [pc, #76]	@ (8009b54 <FreeRTOS_InterfaceEndPointOnNetMask+0x54>)
 8009b06:	6800      	ldr	r0, [r0, #0]

        #if ( ipconfigHAS_ROUTING_STATISTICS == 1 )
            uint32_t ulLocationCount = ( uint32_t ) ( sizeof( xRoutingStatistics.ulLocations ) / sizeof( xRoutingStatistics.ulLocations[ 0 ] ) );

            xRoutingStatistics.ulOnNetMask++;
 8009b08:	4d13      	ldr	r5, [pc, #76]	@ (8009b58 <FreeRTOS_InterfaceEndPointOnNetMask+0x58>)
 8009b0a:	68ac      	ldr	r4, [r5, #8]
 8009b0c:	3401      	adds	r4, #1
 8009b0e:	60ac      	str	r4, [r5, #8]

            if( ulWhere < ulLocationCount )
 8009b10:	2a0d      	cmp	r2, #13
 8009b12:	d815      	bhi.n	8009b40 <FreeRTOS_InterfaceEndPointOnNetMask+0x40>
            {
                xRoutingStatistics.ulLocations[ ulWhere ]++;
 8009b14:	3204      	adds	r2, #4
 8009b16:	f855 4022 	ldr.w	r4, [r5, r2, lsl #2]
 8009b1a:	3401      	adds	r4, #1
 8009b1c:	f845 4022 	str.w	r4, [r5, r2, lsl #2]
 8009b20:	e00e      	b.n	8009b40 <FreeRTOS_InterfaceEndPointOnNetMask+0x40>
        {
            if( ( pxInterface == NULL ) || ( pxEndPoint->pxNetworkInterface == pxInterface ) )
            {
                #if ( ipconfigUSE_IPv4 != 0 )
                    #if ( ipconfigUSE_IPv6 != 0 )
                        if( pxEndPoint->bits.bIPv6 == pdFALSE_UNSIGNED )
 8009b22:	f890 20f0 	ldrb.w	r2, [r0, #240]	@ 0xf0
 8009b26:	f012 0f08 	tst.w	r2, #8
 8009b2a:	d107      	bne.n	8009b3c <FreeRTOS_InterfaceEndPointOnNetMask+0x3c>
                    #endif
                    {
                        if( ( ulIPAddress == ~0U ) ||
 8009b2c:	f1b1 3fff 	cmp.w	r1, #4294967295
 8009b30:	d00e      	beq.n	8009b50 <FreeRTOS_InterfaceEndPointOnNetMask+0x50>
                            ( ( ulIPAddress & pxEndPoint->ipv4_settings.ulNetMask ) == ( pxEndPoint->ipv4_settings.ulIPAddress & pxEndPoint->ipv4_settings.ulNetMask ) ) )
 8009b32:	6802      	ldr	r2, [r0, #0]
 8009b34:	404a      	eors	r2, r1
                        if( ( ulIPAddress == ~0U ) ||
 8009b36:	6844      	ldr	r4, [r0, #4]
 8009b38:	4222      	tst	r2, r4
 8009b3a:	d009      	beq.n	8009b50 <FreeRTOS_InterfaceEndPointOnNetMask+0x50>
                        }
                    }
                #endif /* if ( ipconfigUSE_IPv4 != 0 ) */
            }

            pxEndPoint = pxEndPoint->pxNext;
 8009b3c:	f8d0 015c 	ldr.w	r0, [r0, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8009b40:	b130      	cbz	r0, 8009b50 <FreeRTOS_InterfaceEndPointOnNetMask+0x50>
            if( ( pxInterface == NULL ) || ( pxEndPoint->pxNetworkInterface == pxInterface ) )
 8009b42:	2b00      	cmp	r3, #0
 8009b44:	d0ed      	beq.n	8009b22 <FreeRTOS_InterfaceEndPointOnNetMask+0x22>
 8009b46:	f8d0 2158 	ldr.w	r2, [r0, #344]	@ 0x158
 8009b4a:	429a      	cmp	r2, r3
 8009b4c:	d1f6      	bne.n	8009b3c <FreeRTOS_InterfaceEndPointOnNetMask+0x3c>
 8009b4e:	e7e8      	b.n	8009b22 <FreeRTOS_InterfaceEndPointOnNetMask+0x22>
            FreeRTOS_debug_printf( ( "FreeRTOS_FindEndPointOnNetMask[%d]: No match for %xip\n",
                                     ( unsigned ) ulWhere, ( unsigned ) FreeRTOS_ntohl( ulIPAddress ) ) );
        }

        return pxEndPoint;
    }
 8009b50:	bc30      	pop	{r4, r5}
 8009b52:	4770      	bx	lr
 8009b54:	20013778 	.word	0x20013778
 8009b58:	2001370c 	.word	0x2001370c

08009b5c <FreeRTOS_FindEndPointOnNetMask>:
    {
 8009b5c:	b508      	push	{r3, lr}
 8009b5e:	460a      	mov	r2, r1
        return FreeRTOS_InterfaceEndPointOnNetMask( NULL, ulIPAddress, ulWhere );
 8009b60:	4601      	mov	r1, r0
 8009b62:	2000      	movs	r0, #0
 8009b64:	f7ff ffcc 	bl	8009b00 <FreeRTOS_InterfaceEndPointOnNetMask>
    }
 8009b68:	bd08      	pop	{r3, pc}
	...

08009b6c <FreeRTOS_InterfaceEPInSameSubnet_IPv6>:
 * @param[in] pxIPAddress The IPv6-address for which an end-point is looked-up.
 * @return An end-point that is in the same subnet as the given IP-address.
 */
        NetworkEndPoint_t * FreeRTOS_InterfaceEPInSameSubnet_IPv6( const NetworkInterface_t * pxInterface,
                                                                   const IPv6_Address_t * pxIPAddress )
        {
 8009b6c:	b570      	push	{r4, r5, r6, lr}
 8009b6e:	4605      	mov	r5, r0
 8009b70:	460e      	mov	r6, r1
            NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8009b72:	4b0e      	ldr	r3, [pc, #56]	@ (8009bac <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0x40>)
 8009b74:	681c      	ldr	r4, [r3, #0]

            /* Find the best fitting end-point to reach a given IP-address. */

            while( pxEndPoint != NULL )
 8009b76:	e006      	b.n	8009b86 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0x1a>
            {
                if( ( pxInterface == NULL ) || ( pxEndPoint->pxNetworkInterface == pxInterface ) )
                {
                    if( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED )
 8009b78:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8009b7c:	f013 0f08 	tst.w	r3, #8
 8009b80:	d109      	bne.n	8009b96 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0x2a>
                            break;
                        }
                    }
                }

                pxEndPoint = pxEndPoint->pxNext;
 8009b82:	f8d4 415c 	ldr.w	r4, [r4, #348]	@ 0x15c
            while( pxEndPoint != NULL )
 8009b86:	b174      	cbz	r4, 8009ba6 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0x3a>
                if( ( pxInterface == NULL ) || ( pxEndPoint->pxNetworkInterface == pxInterface ) )
 8009b88:	2d00      	cmp	r5, #0
 8009b8a:	d0f5      	beq.n	8009b78 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0xc>
 8009b8c:	f8d4 3158 	ldr.w	r3, [r4, #344]	@ 0x158
 8009b90:	42ab      	cmp	r3, r5
 8009b92:	d1f6      	bne.n	8009b82 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0x16>
 8009b94:	e7f0      	b.n	8009b78 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0xc>
                        if( xCompareIPv6_Address( &( pxEndPoint->ipv6_settings.xIPAddress ), pxIPAddress, pxEndPoint->ipv6_settings.uxPrefixLength ) == 0 )
 8009b96:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8009b98:	4631      	mov	r1, r6
 8009b9a:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 8009b9e:	f7fe fd4d 	bl	800863c <xCompareIPv6_Address>
 8009ba2:	2800      	cmp	r0, #0
 8009ba4:	d1ed      	bne.n	8009b82 <FreeRTOS_InterfaceEPInSameSubnet_IPv6+0x16>
            }

            return pxEndPoint;
        }
 8009ba6:	4620      	mov	r0, r4
 8009ba8:	bd70      	pop	{r4, r5, r6, pc}
 8009baa:	bf00      	nop
 8009bac:	20013778 	.word	0x20013778

08009bb0 <FreeRTOS_FindEndPointOnIP_IPv6>:
        {
 8009bb0:	b508      	push	{r3, lr}
 8009bb2:	4601      	mov	r1, r0
            return FreeRTOS_InterfaceEPInSameSubnet_IPv6( NULL, pxIPAddress );
 8009bb4:	2000      	movs	r0, #0
 8009bb6:	f7ff ffd9 	bl	8009b6c <FreeRTOS_InterfaceEPInSameSubnet_IPv6>
        }
 8009bba:	bd08      	pop	{r3, pc}

08009bbc <FreeRTOS_FindGateWay>:
 * @param[in] xIPType The type of Gateway to look for ( ipTYPE_IPv4 or ipTYPE_IPv6 ).
 *
 * @return The end-point that will lead to the gateway, or NULL when no gateway was found.
 */
    NetworkEndPoint_t * FreeRTOS_FindGateWay( BaseType_t xIPType )
    {
 8009bbc:	b538      	push	{r3, r4, r5, lr}
 8009bbe:	4605      	mov	r5, r0
        NetworkEndPoint_t * pxEndPoint = pxNetworkEndPoints;
 8009bc0:	4b0f      	ldr	r3, [pc, #60]	@ (8009c00 <FreeRTOS_FindGateWay+0x44>)
 8009bc2:	681c      	ldr	r4, [r3, #0]

        while( pxEndPoint != NULL )
 8009bc4:	e00d      	b.n	8009be2 <FreeRTOS_FindGateWay+0x26>
                if( pxEndPoint->ipv4_settings.ulGatewayAddress != 0U ) /* access to ipv4_settings is checked. */
                {
                    break;
                }
            #else
                if( ( xIPType == ( BaseType_t ) ipTYPE_IPv6 ) && ( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED ) )
 8009bc6:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8009bca:	f013 0f08 	tst.w	r3, #8
 8009bce:	d00b      	beq.n	8009be8 <FreeRTOS_FindGateWay+0x2c>
                {
                    /* Check if the IP-address is non-zero. */
                    if( memcmp( FreeRTOS_in6addr_any.ucBytes, pxEndPoint->ipv6_settings.xGatewayAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS ) != 0 )
 8009bd0:	2210      	movs	r2, #16
 8009bd2:	f104 015c 	add.w	r1, r4, #92	@ 0x5c
 8009bd6:	480b      	ldr	r0, [pc, #44]	@ (8009c04 <FreeRTOS_FindGateWay+0x48>)
 8009bd8:	f005 f842 	bl	800ec60 <memcmp>
 8009bdc:	b970      	cbnz	r0, 8009bfc <FreeRTOS_FindGateWay+0x40>
                else
                {
                    /* This end-point is not the right IP-type. */
                }
            #endif /* ( ipconfigUSE_IPv6 != 0 ) */
            pxEndPoint = pxEndPoint->pxNext;
 8009bde:	f8d4 415c 	ldr.w	r4, [r4, #348]	@ 0x15c
        while( pxEndPoint != NULL )
 8009be2:	b15c      	cbz	r4, 8009bfc <FreeRTOS_FindGateWay+0x40>
                if( ( xIPType == ( BaseType_t ) ipTYPE_IPv6 ) && ( pxEndPoint->bits.bIPv6 != pdFALSE_UNSIGNED ) )
 8009be4:	2d60      	cmp	r5, #96	@ 0x60
 8009be6:	d0ee      	beq.n	8009bc6 <FreeRTOS_FindGateWay+0xa>
                    if( ( xIPType == ( BaseType_t ) ipTYPE_IPv4 ) && ( pxEndPoint->bits.bIPv6 == pdFALSE_UNSIGNED ) )
 8009be8:	2d40      	cmp	r5, #64	@ 0x40
 8009bea:	d1f8      	bne.n	8009bde <FreeRTOS_FindGateWay+0x22>
 8009bec:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 8009bf0:	f013 0f08 	tst.w	r3, #8
 8009bf4:	d1f3      	bne.n	8009bde <FreeRTOS_FindGateWay+0x22>
                        if( pxEndPoint->ipv4_settings.ulGatewayAddress != 0U )
 8009bf6:	68a3      	ldr	r3, [r4, #8]
 8009bf8:	2b00      	cmp	r3, #0
 8009bfa:	d0f0      	beq.n	8009bde <FreeRTOS_FindGateWay+0x22>
        }

        return pxEndPoint;
    }
 8009bfc:	4620      	mov	r0, r4
 8009bfe:	bd38      	pop	{r3, r4, r5, pc}
 8009c00:	20013778 	.word	0x20013778
 8009c04:	080102ec 	.word	0x080102ec

08009c08 <xIPv6_GetIPType>:
 * @param[in] pxAddress The IPv6 address whose type needs to be returned.
 * @returns The IP type of the given address.
 */
#if ( ipconfigUSE_IPv6 != 0 )
    IPv6_Type_t xIPv6_GetIPType( const IPv6_Address_t * pxAddress )
    {
 8009c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            { eIPv6_SiteLocal, 0xFFC0U, 0xFEC0U }, /* 1111 1110 11 */
            { eIPv6_Multicast, 0xFF00U, 0xFF00U }, /* 1111 1111 */
            { eIPv6_Loopback,  0xFFFFU, 0x0000U }, /* 0000 0000 ::1 */
        };

        if( pxAddress != NULL )
 8009c0a:	b110      	cbz	r0, 8009c12 <xIPv6_GetIPType+0xa>
 8009c0c:	4606      	mov	r6, r0
        {
            for( xIndex = 0; xIndex < ARRAY_SIZE_X( xIPCouples ); xIndex++ )
 8009c0e:	2400      	movs	r4, #0
 8009c10:	e00c      	b.n	8009c2c <xIPv6_GetIPType+0x24>
        IPv6_Type_t eResult = eIPv6_Unknown;
 8009c12:	2705      	movs	r7, #5
 8009c14:	e01e      	b.n	8009c54 <xIPv6_GetIPType+0x4c>
                        eResult = eIPv6_Loopback;
                        break;
                    }
                }

                if( ( usAddress & xIPCouples[ xIndex ].usMask ) == xIPCouples[ xIndex ].usExpected )
 8009c16:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8009c1a:	4b0f      	ldr	r3, [pc, #60]	@ (8009c58 <xIPv6_GetIPType+0x50>)
 8009c1c:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8009c20:	885a      	ldrh	r2, [r3, #2]
 8009c22:	402a      	ands	r2, r5
 8009c24:	889b      	ldrh	r3, [r3, #4]
 8009c26:	429a      	cmp	r2, r3
 8009c28:	d014      	beq.n	8009c54 <xIPv6_GetIPType+0x4c>
            for( xIndex = 0; xIndex < ARRAY_SIZE_X( xIPCouples ); xIndex++ )
 8009c2a:	3401      	adds	r4, #1
 8009c2c:	2c04      	cmp	r4, #4
 8009c2e:	dc10      	bgt.n	8009c52 <xIPv6_GetIPType+0x4a>
                    ( uint16_t ) ( ( ( ( uint16_t ) pxAddress->ucBytes[ 0 ] ) << 8 ) |
 8009c30:	7833      	ldrb	r3, [r6, #0]
                                   ( ( uint16_t ) pxAddress->ucBytes[ 1 ] ) );
 8009c32:	7875      	ldrb	r5, [r6, #1]
                uint16_t usAddress =
 8009c34:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
                if( xIPCouples[ xIndex ].eType == eIPv6_Loopback )
 8009c38:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8009c3c:	4a06      	ldr	r2, [pc, #24]	@ (8009c58 <xIPv6_GetIPType+0x50>)
 8009c3e:	f812 7013 	ldrb.w	r7, [r2, r3, lsl #1]
 8009c42:	2f04      	cmp	r7, #4
 8009c44:	d1e7      	bne.n	8009c16 <xIPv6_GetIPType+0xe>
                    if( xIsIPv6Loopback( pxAddress ) != pdFALSE )
 8009c46:	4630      	mov	r0, r6
 8009c48:	f7fe fcae 	bl	80085a8 <xIsIPv6Loopback>
 8009c4c:	2800      	cmp	r0, #0
 8009c4e:	d0e2      	beq.n	8009c16 <xIPv6_GetIPType+0xe>
 8009c50:	e000      	b.n	8009c54 <xIPv6_GetIPType+0x4c>
        IPv6_Type_t eResult = eIPv6_Unknown;
 8009c52:	2705      	movs	r7, #5
                }
            }
        }

        return eResult;
    }
 8009c54:	4638      	mov	r0, r7
 8009c56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009c58:	080102fc 	.word	0x080102fc

08009c5c <prvSetOptionLowHighWater>:
                                                const void * pvOptionValue )
    {
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
        const LowHighWater_t * pxLowHighWater = ( const LowHighWater_t * ) pvOptionValue;

        if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009c5c:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 8009c60:	2b06      	cmp	r3, #6
 8009c62:	d111      	bne.n	8009c88 <prvSetOptionLowHighWater+0x2c>
        {
            /* It is not allowed to access 'pxSocket->u.xTCP'. */
            FreeRTOS_debug_printf( ( "FREERTOS_SO_SET_LOW_HIGH_WATER: wrong socket type\n" ) );
        }
        else if( ( pxLowHighWater->uxLittleSpace >= pxLowHighWater->uxEnoughSpace ) ||
 8009c64:	680a      	ldr	r2, [r1, #0]
 8009c66:	684b      	ldr	r3, [r1, #4]
 8009c68:	429a      	cmp	r2, r3
 8009c6a:	d210      	bcs.n	8009c8e <prvSetOptionLowHighWater+0x32>
    {
 8009c6c:	b410      	push	{r4}
        else if( ( pxLowHighWater->uxLittleSpace >= pxLowHighWater->uxEnoughSpace ) ||
 8009c6e:	f8d0 4094 	ldr.w	r4, [r0, #148]	@ 0x94
 8009c72:	42a3      	cmp	r3, r4
 8009c74:	d80e      	bhi.n	8009c94 <prvSetOptionLowHighWater+0x38>
            FreeRTOS_debug_printf( ( "FREERTOS_SO_SET_LOW_HIGH_WATER: bad values\n" ) );
        }
        else
        {
            /* Send a STOP when buffer space drops below 'uxLittleSpace' bytes. */
            pxSocket->u.xTCP.uxLittleSpace = pxLowHighWater->uxLittleSpace;
 8009c76:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
            /* Send a GO when buffer space grows above 'uxEnoughSpace' bytes. */
            pxSocket->u.xTCP.uxEnoughSpace = pxLowHighWater->uxEnoughSpace;
 8009c7a:	684b      	ldr	r3, [r1, #4]
 8009c7c:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
            xReturn = 0;
 8009c80:	2000      	movs	r0, #0
        }

        return xReturn;
    }
 8009c82:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009c86:	4770      	bx	lr
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009c88:	f06f 0015 	mvn.w	r0, #21
 8009c8c:	4770      	bx	lr
 8009c8e:	f06f 0015 	mvn.w	r0, #21
    }
 8009c92:	4770      	bx	lr
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009c94:	f06f 0015 	mvn.w	r0, #21
        return xReturn;
 8009c98:	e7f3      	b.n	8009c82 <prvSetOptionLowHighWater+0x26>

08009c9a <prvSetOptionTimeout>:
 */
static void prvSetOptionTimeout( FreeRTOS_Socket_t * pxSocket,
                                 const void * pvOptionValue,
                                 BaseType_t xForSend )
{
    TickType_t xBlockTime = *( ( const TickType_t * ) pvOptionValue );
 8009c9a:	680b      	ldr	r3, [r1, #0]

    if( xForSend == pdTRUE )
 8009c9c:	2a01      	cmp	r2, #1
 8009c9e:	d001      	beq.n	8009ca4 <prvSetOptionTimeout+0xa>

        pxSocket->xSendBlockTime = xBlockTime;
    }
    else
    {
        pxSocket->xReceiveBlockTime = xBlockTime;
 8009ca0:	6203      	str	r3, [r0, #32]
    }
}
 8009ca2:	4770      	bx	lr
        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8009ca4:	f890 203b 	ldrb.w	r2, [r0, #59]	@ 0x3b
 8009ca8:	2a11      	cmp	r2, #17
 8009caa:	d001      	beq.n	8009cb0 <prvSetOptionTimeout+0x16>
        pxSocket->xSendBlockTime = xBlockTime;
 8009cac:	6243      	str	r3, [r0, #36]	@ 0x24
 8009cae:	4770      	bx	lr
            if( xBlockTime > ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS )
 8009cb0:	f241 3288 	movw	r2, #5000	@ 0x1388
 8009cb4:	4293      	cmp	r3, r2
 8009cb6:	d9f9      	bls.n	8009cac <prvSetOptionTimeout+0x12>
                xBlockTime = ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS;
 8009cb8:	4613      	mov	r3, r2
 8009cba:	e7f7      	b.n	8009cac <prvSetOptionTimeout+0x12>

08009cbc <prvSetOptionReuseListenSocket>:
 * @param[in] pxSocket The TCP socket used for the connection.
 * @param[in] pvOptionValue The option name like FREERTOS_SO_xxx_HANDLER.
 */
    static BaseType_t prvSetOptionReuseListenSocket( FreeRTOS_Socket_t * pxSocket,
                                                     const void * pvOptionValue )
    {
 8009cbc:	4603      	mov	r3, r0
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;

        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009cbe:	f890 203b 	ldrb.w	r2, [r0, #59]	@ 0x3b
 8009cc2:	2a06      	cmp	r2, #6
 8009cc4:	d110      	bne.n	8009ce8 <prvSetOptionReuseListenSocket+0x2c>
        {
            if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 8009cc6:	6808      	ldr	r0, [r1, #0]
 8009cc8:	b138      	cbz	r0, 8009cda <prvSetOptionReuseListenSocket+0x1e>
            {
                pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE_UNSIGNED;
 8009cca:	f893 2068 	ldrb.w	r2, [r3, #104]	@ 0x68
 8009cce:	f042 0208 	orr.w	r2, r2, #8
 8009cd2:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
            else
            {
                pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE_UNSIGNED;
            }

            xReturn = 0;
 8009cd6:	2000      	movs	r0, #0
 8009cd8:	4770      	bx	lr
                pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE_UNSIGNED;
 8009cda:	f893 2068 	ldrb.w	r2, [r3, #104]	@ 0x68
 8009cde:	f022 0208 	bic.w	r2, r2, #8
 8009ce2:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
 8009ce6:	4770      	bx	lr
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009ce8:	f06f 0015 	mvn.w	r0, #21
        }

        return xReturn;
    }
 8009cec:	4770      	bx	lr

08009cee <prvSetOptionCloseAfterSend>:
 * @param[in] pvOptionValue A pointer to a binary value of size
 *            BaseType_t.
 */
    static BaseType_t prvSetOptionCloseAfterSend( FreeRTOS_Socket_t * pxSocket,
                                                  const void * pvOptionValue )
    {
 8009cee:	4603      	mov	r3, r0
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;

        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009cf0:	f890 203b 	ldrb.w	r2, [r0, #59]	@ 0x3b
 8009cf4:	2a06      	cmp	r2, #6
 8009cf6:	d110      	bne.n	8009d1a <prvSetOptionCloseAfterSend+0x2c>
        {
            if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 8009cf8:	6808      	ldr	r0, [r1, #0]
 8009cfa:	b138      	cbz	r0, 8009d0c <prvSetOptionCloseAfterSend+0x1e>
            {
                pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE_UNSIGNED;
 8009cfc:	f893 2068 	ldrb.w	r2, [r3, #104]	@ 0x68
 8009d00:	f042 0210 	orr.w	r2, r2, #16
 8009d04:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
            else
            {
                pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE_UNSIGNED;
            }

            xReturn = 0;
 8009d08:	2000      	movs	r0, #0
 8009d0a:	4770      	bx	lr
                pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE_UNSIGNED;
 8009d0c:	f893 2068 	ldrb.w	r2, [r3, #104]	@ 0x68
 8009d10:	f022 0210 	bic.w	r2, r2, #16
 8009d14:	f883 2068 	strb.w	r2, [r3, #104]	@ 0x68
 8009d18:	4770      	bx	lr
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009d1a:	f06f 0015 	mvn.w	r0, #21
        }

        return xReturn;
    }
 8009d1e:	4770      	bx	lr

08009d20 <bMayConnect>:
 */
    static BaseType_t bMayConnect( FreeRTOS_Socket_t const * pxSocket )
    {
        BaseType_t xResult;

        eIPTCPState_t eState = pxSocket->u.xTCP.eTCPState;
 8009d20:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79

        switch( eState )
 8009d24:	2b02      	cmp	r3, #2
 8009d26:	d007      	beq.n	8009d38 <bMayConnect+0x18>
 8009d28:	2b08      	cmp	r3, #8
 8009d2a:	d008      	beq.n	8009d3e <bMayConnect+0x1e>
 8009d2c:	b113      	cbz	r3, 8009d34 <bMayConnect+0x14>
            case eFIN_WAIT_2:
            case eCLOSING:
            case eLAST_ACK:
            case eTIME_WAIT:
            default:
                xResult = -pdFREERTOS_ERRNO_EAGAIN;
 8009d2e:	f06f 000a 	mvn.w	r0, #10
                break;
        }

        return xResult;
    }
 8009d32:	4770      	bx	lr
        switch( eState )
 8009d34:	2000      	movs	r0, #0
 8009d36:	4770      	bx	lr
                xResult = -pdFREERTOS_ERRNO_EINPROGRESS;
 8009d38:	f06f 0076 	mvn.w	r0, #118	@ 0x76
 8009d3c:	4770      	bx	lr
        switch( eState )
 8009d3e:	2000      	movs	r0, #0
 8009d40:	4770      	bx	lr
	...

08009d44 <prvDetermineSocketSize>:
{
 8009d44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009d46:	4604      	mov	r4, r0
 8009d48:	460f      	mov	r7, r1
 8009d4a:	4616      	mov	r6, r2
 8009d4c:	461d      	mov	r5, r3
    if( xIPIsNetworkTaskReady() == pdFALSE )
 8009d4e:	f7fd fac3 	bl	80072d8 <xIPIsNetworkTaskReady>
 8009d52:	4603      	mov	r3, r0
 8009d54:	2800      	cmp	r0, #0
 8009d56:	d048      	beq.n	8009dea <prvDetermineSocketSize+0xa6>
            if( ( xDomain != FREERTOS_AF_INET ) && ( xDomain != FREERTOS_AF_INET6 ) )
 8009d58:	2c02      	cmp	r4, #2
 8009d5a:	d00f      	beq.n	8009d7c <prvDetermineSocketSize+0x38>
 8009d5c:	2c0a      	cmp	r4, #10
 8009d5e:	d00b      	beq.n	8009d78 <prvDetermineSocketSize+0x34>
 8009d60:	2300      	movs	r3, #0
            configASSERT( ( xDomain == FREERTOS_AF_INET ) || ( xDomain == FREERTOS_AF_INET6 ) );
 8009d62:	2c0a      	cmp	r4, #10
 8009d64:	d00b      	beq.n	8009d7e <prvDetermineSocketSize+0x3a>
 8009d66:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009d6a:	f383 8811 	msr	BASEPRI, r3
 8009d6e:	f3bf 8f6f 	isb	sy
 8009d72:	f3bf 8f4f 	dsb	sy
 8009d76:	e7fe      	b.n	8009d76 <prvDetermineSocketSize+0x32>
    BaseType_t xReturn = pdPASS;
 8009d78:	2301      	movs	r3, #1
 8009d7a:	e7f2      	b.n	8009d62 <prvDetermineSocketSize+0x1e>
 8009d7c:	2301      	movs	r3, #1
        configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
 8009d7e:	4a23      	ldr	r2, [pc, #140]	@ (8009e0c <prvDetermineSocketSize+0xc8>)
 8009d80:	6892      	ldr	r2, [r2, #8]
 8009d82:	f1b2 3fff 	cmp.w	r2, #4294967295
 8009d86:	d008      	beq.n	8009d9a <prvDetermineSocketSize+0x56>
 8009d88:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009d8c:	f383 8811 	msr	BASEPRI, r3
 8009d90:	f3bf 8f6f 	isb	sy
 8009d94:	f3bf 8f4f 	dsb	sy
 8009d98:	e7fe      	b.n	8009d98 <prvDetermineSocketSize+0x54>
            configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
 8009d9a:	4a1d      	ldr	r2, [pc, #116]	@ (8009e10 <prvDetermineSocketSize+0xcc>)
 8009d9c:	6892      	ldr	r2, [r2, #8]
 8009d9e:	f1b2 3fff 	cmp.w	r2, #4294967295
 8009da2:	d008      	beq.n	8009db6 <prvDetermineSocketSize+0x72>
 8009da4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009da8:	f383 8811 	msr	BASEPRI, r3
 8009dac:	f3bf 8f6f 	isb	sy
 8009db0:	f3bf 8f4f 	dsb	sy
 8009db4:	e7fe      	b.n	8009db4 <prvDetermineSocketSize+0x70>
        if( xProtocol == FREERTOS_IPPROTO_UDP )
 8009db6:	2e11      	cmp	r6, #17
 8009db8:	d00a      	beq.n	8009dd0 <prvDetermineSocketSize+0x8c>
            else if( xProtocol == FREERTOS_IPPROTO_TCP )
 8009dba:	2e06      	cmp	r6, #6
 8009dbc:	d017      	beq.n	8009dee <prvDetermineSocketSize+0xaa>
 8009dbe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009dc2:	f383 8811 	msr	BASEPRI, r3
 8009dc6:	f3bf 8f6f 	isb	sy
 8009dca:	f3bf 8f4f 	dsb	sy
            configASSERT( xReturn == pdPASS ); /* LCOV_EXCL_BR_LINE Exclude this line from branch coverage as the not-taken condition will never happen. */
 8009dce:	e7fe      	b.n	8009dce <prvDetermineSocketSize+0x8a>
            if( xType != FREERTOS_SOCK_DGRAM )
 8009dd0:	2f02      	cmp	r7, #2
 8009dd2:	d008      	beq.n	8009de6 <prvDetermineSocketSize+0xa2>
 8009dd4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009dd8:	f383 8811 	msr	BASEPRI, r3
 8009ddc:	f3bf 8f6f 	isb	sy
 8009de0:	f3bf 8f4f 	dsb	sy
                configASSERT( xReturn == pdPASS ); /* LCOV_EXCL_BR_LINE Exclude this line from branch coverage as the not-taken condition will never happen. */
 8009de4:	e7fe      	b.n	8009de4 <prvDetermineSocketSize+0xa0>
            *pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
 8009de6:	2268      	movs	r2, #104	@ 0x68
 8009de8:	602a      	str	r2, [r5, #0]
}
 8009dea:	4618      	mov	r0, r3
 8009dec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                if( xType != FREERTOS_SOCK_STREAM )
 8009dee:	2f01      	cmp	r7, #1
 8009df0:	d008      	beq.n	8009e04 <prvDetermineSocketSize+0xc0>
 8009df2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8009df6:	f383 8811 	msr	BASEPRI, r3
 8009dfa:	f3bf 8f6f 	isb	sy
 8009dfe:	f3bf 8f4f 	dsb	sy
                    configASSERT( xReturn == pdPASS ); /* LCOV_EXCL_BR_LINE Exclude this line from branch coverage as the not-taken condition will never happen. */
 8009e02:	e7fe      	b.n	8009e02 <prvDetermineSocketSize+0xbe>
                *pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
 8009e04:	f44f 72ea 	mov.w	r2, #468	@ 0x1d4
 8009e08:	602a      	str	r2, [r5, #0]
 8009e0a:	e7ee      	b.n	8009dea <prvDetermineSocketSize+0xa6>
 8009e0c:	20013794 	.word	0x20013794
 8009e10:	20013780 	.word	0x20013780

08009e14 <pxListFindListItemWithValue>:
{
 8009e14:	b538      	push	{r3, r4, r5, lr}
 8009e16:	4604      	mov	r4, r0
 8009e18:	460d      	mov	r5, r1
    if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
 8009e1a:	f7fd fa5d 	bl	80072d8 <xIPIsNetworkTaskReady>
 8009e1e:	b160      	cbz	r0, 8009e3a <pxListFindListItemWithValue+0x26>
 8009e20:	b16c      	cbz	r4, 8009e3e <pxListFindListItemWithValue+0x2a>
        const ListItem_t * pxEnd = ( ( const ListItem_t * ) &( pxList->xListEnd ) );
 8009e22:	f104 0208 	add.w	r2, r4, #8
        for( pxIterator = listGET_NEXT( pxEnd );
 8009e26:	68e0      	ldr	r0, [r4, #12]
             pxIterator != pxEnd;
 8009e28:	4290      	cmp	r0, r2
 8009e2a:	d004      	beq.n	8009e36 <pxListFindListItemWithValue+0x22>
            if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 8009e2c:	6803      	ldr	r3, [r0, #0]
 8009e2e:	42ab      	cmp	r3, r5
 8009e30:	d002      	beq.n	8009e38 <pxListFindListItemWithValue+0x24>
             pxIterator = listGET_NEXT( pxIterator ) )
 8009e32:	6840      	ldr	r0, [r0, #4]
 8009e34:	e7f8      	b.n	8009e28 <pxListFindListItemWithValue+0x14>
    const ListItem_t * pxResult = NULL;
 8009e36:	2000      	movs	r0, #0
} /* Tested */
 8009e38:	bd38      	pop	{r3, r4, r5, pc}
    const ListItem_t * pxResult = NULL;
 8009e3a:	2000      	movs	r0, #0
 8009e3c:	e7fc      	b.n	8009e38 <pxListFindListItemWithValue+0x24>
 8009e3e:	4620      	mov	r0, r4
    return pxResult;
 8009e40:	e7fa      	b.n	8009e38 <pxListFindListItemWithValue+0x24>

08009e42 <prvSockopt_so_buffer>:
        if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009e42:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 8009e46:	2b06      	cmp	r3, #6
 8009e48:	d122      	bne.n	8009e90 <prvSockopt_so_buffer+0x4e>
    {
 8009e4a:	b510      	push	{r4, lr}
 8009e4c:	4604      	mov	r4, r0
        else if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 8009e4e:	2904      	cmp	r1, #4
 8009e50:	d008      	beq.n	8009e64 <prvSockopt_so_buffer+0x22>
 8009e52:	2905      	cmp	r1, #5
 8009e54:	d00d      	beq.n	8009e72 <prvSockopt_so_buffer+0x30>
            ulNewValue = *( ( const uint32_t * ) pvOptionValue );
 8009e56:	6810      	ldr	r0, [r2, #0]
            if( lOptionName == FREERTOS_SO_SNDBUF )
 8009e58:	2904      	cmp	r1, #4
 8009e5a:	d011      	beq.n	8009e80 <prvSockopt_so_buffer+0x3e>
                pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
 8009e5c:	f8c4 0094 	str.w	r0, [r4, #148]	@ 0x94
            xReturn = 0;
 8009e60:	2000      	movs	r0, #0
    }
 8009e62:	bd10      	pop	{r4, pc}
        else if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 8009e64:	f8d0 30a0 	ldr.w	r3, [r0, #160]	@ 0xa0
 8009e68:	2b00      	cmp	r3, #0
 8009e6a:	d0f2      	beq.n	8009e52 <prvSockopt_so_buffer+0x10>
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009e6c:	f06f 0015 	mvn.w	r0, #21
 8009e70:	e7f7      	b.n	8009e62 <prvSockopt_so_buffer+0x20>
                 ( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 8009e72:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
 8009e76:	2b00      	cmp	r3, #0
 8009e78:	d0ed      	beq.n	8009e56 <prvSockopt_so_buffer+0x14>
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009e7a:	f06f 0015 	mvn.w	r0, #21
        return xReturn;
 8009e7e:	e7f0      	b.n	8009e62 <prvSockopt_so_buffer+0x20>
                ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usMSS );
 8009e80:	f8b4 1072 	ldrh.w	r1, [r4, #114]	@ 0x72
 8009e84:	f7fe f9da 	bl	800823c <FreeRTOS_round_up>
                pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 8009e88:	f8c4 0098 	str.w	r0, [r4, #152]	@ 0x98
            xReturn = 0;
 8009e8c:	2000      	movs	r0, #0
 8009e8e:	e7e8      	b.n	8009e62 <prvSockopt_so_buffer+0x20>
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009e90:	f06f 0015 	mvn.w	r0, #21
    }
 8009e94:	4770      	bx	lr

08009e96 <prvSetOptionTCPWindows>:
    {
 8009e96:	b538      	push	{r3, r4, r5, lr}
            if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009e98:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 8009e9c:	2b06      	cmp	r3, #6
 8009e9e:	d125      	bne.n	8009eec <prvSetOptionTCPWindows+0x56>
 8009ea0:	4604      	mov	r4, r0
 8009ea2:	460d      	mov	r5, r1
            xReturn = prvSockopt_so_buffer( pxSocket, FREERTOS_SO_SNDBUF, &( pxProps->lTxBufSize ) );
 8009ea4:	460a      	mov	r2, r1
 8009ea6:	2104      	movs	r1, #4
 8009ea8:	f7ff ffcb 	bl	8009e42 <prvSockopt_so_buffer>
            if( xReturn != 0 )
 8009eac:	b100      	cbz	r0, 8009eb0 <prvSetOptionTCPWindows+0x1a>
    }
 8009eae:	bd38      	pop	{r3, r4, r5, pc}
            xReturn = prvSockopt_so_buffer( pxSocket, FREERTOS_SO_RCVBUF, &( pxProps->lRxBufSize ) );
 8009eb0:	f105 0208 	add.w	r2, r5, #8
 8009eb4:	2105      	movs	r1, #5
 8009eb6:	4620      	mov	r0, r4
 8009eb8:	f7ff ffc3 	bl	8009e42 <prvSockopt_so_buffer>
            if( xReturn != 0 )
 8009ebc:	2800      	cmp	r0, #0
 8009ebe:	d1f6      	bne.n	8009eae <prvSetOptionTCPWindows+0x18>
                pxTCP->uxRxWinSize = ( uint32_t ) pxProps->lRxWinSize; /* Fixed value: size of the TCP reception window */
 8009ec0:	68ea      	ldr	r2, [r5, #12]
 8009ec2:	f8c4 210c 	str.w	r2, [r4, #268]	@ 0x10c
                pxTCP->uxTxWinSize = ( uint32_t ) pxProps->lTxWinSize; /* Fixed value: size of the TCP transmit window */
 8009ec6:	686b      	ldr	r3, [r5, #4]
 8009ec8:	f8c4 3110 	str.w	r3, [r4, #272]	@ 0x110
            if( pxTCP->xTCPWindow.u.bits.bHasInit != pdFALSE_UNSIGNED )
 8009ecc:	f894 1114 	ldrb.w	r1, [r4, #276]	@ 0x114
 8009ed0:	f011 0f01 	tst.w	r1, #1
 8009ed4:	d0eb      	beq.n	8009eae <prvSetOptionTCPWindows+0x18>
                pxTCP->xTCPWindow.xSize.ulRxWindowLength = ( uint32_t ) ( pxTCP->uxRxWinSize * pxTCP->usMSS );
 8009ed6:	f8b4 1072 	ldrh.w	r1, [r4, #114]	@ 0x72
 8009eda:	fb01 f202 	mul.w	r2, r1, r2
 8009ede:	f8c4 2118 	str.w	r2, [r4, #280]	@ 0x118
                pxTCP->xTCPWindow.xSize.ulTxWindowLength = ( uint32_t ) ( pxTCP->uxTxWinSize * pxTCP->usMSS );
 8009ee2:	fb01 f303 	mul.w	r3, r1, r3
 8009ee6:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
 8009eea:	e7e0      	b.n	8009eae <prvSetOptionTCPWindows+0x18>
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009eec:	f06f 0015 	mvn.w	r0, #21
        return xReturn;
 8009ef0:	e7dd      	b.n	8009eae <prvSetOptionTCPWindows+0x18>
	...

08009ef4 <prvInitialiseTCPFields>:
    {
 8009ef4:	b538      	push	{r3, r4, r5, lr}
 8009ef6:	4604      	mov	r4, r0
        pxSocket->u.xTCP.usMSS = ( uint16_t ) ipconfigTCP_MSS;
 8009ef8:	f240 53b4 	movw	r3, #1460	@ 0x5b4
 8009efc:	f8a0 3072 	strh.w	r3, [r0, #114]	@ 0x72
            if( pxSocket->bits.bIsIPv6 != 0U )
 8009f00:	7a03      	ldrb	r3, [r0, #8]
 8009f02:	f013 0f01 	tst.w	r3, #1
 8009f06:	d003      	beq.n	8009f10 <prvInitialiseTCPFields+0x1c>
                pxSocket->u.xTCP.usMSS = ( uint16_t ) ( pxSocket->u.xTCP.usMSS - usDifference );
 8009f08:	f44f 63b4 	mov.w	r3, #1440	@ 0x5a0
 8009f0c:	f8a0 3072 	strh.w	r3, [r0, #114]	@ 0x72
        pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 8009f10:	f242 7010 	movw	r0, #10000	@ 0x2710
 8009f14:	f8c4 0094 	str.w	r0, [r4, #148]	@ 0x94
        pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH, ipconfigTCP_MSS );
 8009f18:	f240 51b4 	movw	r1, #1460	@ 0x5b4
 8009f1c:	f7fe f98e 	bl	800823c <FreeRTOS_round_up>
 8009f20:	f8c4 0098 	str.w	r0, [r4, #152]	@ 0x98
            pxSocket->u.xTCP.uxRxWinSize = FreeRTOS_max_size_t( 1U, ( pxSocket->u.xTCP.uxRxStreamSize / 2U ) / ipconfigTCP_MSS );
 8009f24:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
 8009f28:	08c9      	lsrs	r1, r1, #3
 8009f2a:	4d0a      	ldr	r5, [pc, #40]	@ (8009f54 <prvInitialiseTCPFields+0x60>)
 8009f2c:	fba5 3101 	umull	r3, r1, r5, r1
 8009f30:	0989      	lsrs	r1, r1, #6
 8009f32:	2001      	movs	r0, #1
 8009f34:	f7fe f972 	bl	800821c <FreeRTOS_max_size_t>
 8009f38:	f8c4 010c 	str.w	r0, [r4, #268]	@ 0x10c
            pxSocket->u.xTCP.uxTxWinSize = FreeRTOS_max_size_t( 1U, ( pxSocket->u.xTCP.uxTxStreamSize / 2U ) / ipconfigTCP_MSS );
 8009f3c:	f8d4 1098 	ldr.w	r1, [r4, #152]	@ 0x98
 8009f40:	08c9      	lsrs	r1, r1, #3
 8009f42:	fba5 5101 	umull	r5, r1, r5, r1
 8009f46:	0989      	lsrs	r1, r1, #6
 8009f48:	2001      	movs	r0, #1
 8009f4a:	f7fe f967 	bl	800821c <FreeRTOS_max_size_t>
 8009f4e:	f8c4 0110 	str.w	r0, [r4, #272]	@ 0x110
    }
 8009f52:	bd38      	pop	{r3, r4, r5, pc}
 8009f54:	2ce33e6d 	.word	0x2ce33e6d

08009f58 <prvRecvFromWaitForPacket>:
{
 8009f58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009f5c:	b087      	sub	sp, #28
 8009f5e:	4606      	mov	r6, r0
 8009f60:	4688      	mov	r8, r1
 8009f62:	4691      	mov	r9, r2
    TickType_t xRemainingTime = pxSocket->xReceiveBlockTime;
 8009f64:	6a03      	ldr	r3, [r0, #32]
 8009f66:	9305      	str	r3, [sp, #20]
    lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8009f68:	6d44      	ldr	r4, [r0, #84]	@ 0x54
    EventBits_t xEventBits = ( EventBits_t ) 0;
 8009f6a:	2500      	movs	r5, #0
    BaseType_t xTimed = pdFALSE;
 8009f6c:	462f      	mov	r7, r5
    while( lPacketCount == 0 )
 8009f6e:	e013      	b.n	8009f98 <prvRecvFromWaitForPacket+0x40>
            vTaskSetTimeOutState( &xTimeOut );
 8009f70:	a803      	add	r0, sp, #12
 8009f72:	f7fb f8c7 	bl	8005104 <vTaskSetTimeOutState>
            xTimed = pdTRUE;
 8009f76:	2701      	movs	r7, #1
        xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, ( ( EventBits_t ) eSOCKET_RECEIVE ) | ( ( EventBits_t ) eSOCKET_INTR ),
 8009f78:	9b05      	ldr	r3, [sp, #20]
 8009f7a:	9300      	str	r3, [sp, #0]
 8009f7c:	2300      	movs	r3, #0
 8009f7e:	2201      	movs	r2, #1
 8009f80:	2141      	movs	r1, #65	@ 0x41
 8009f82:	6870      	ldr	r0, [r6, #4]
 8009f84:	f7f9 fdff 	bl	8003b86 <xEventGroupWaitBits>
 8009f88:	4605      	mov	r5, r0
        lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8009f8a:	6d74      	ldr	r4, [r6, #84]	@ 0x54
        if( lPacketCount != 0 )
 8009f8c:	b964      	cbnz	r4, 8009fa8 <prvRecvFromWaitForPacket+0x50>
        if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8009f8e:	a905      	add	r1, sp, #20
 8009f90:	a803      	add	r0, sp, #12
 8009f92:	f7fb f8df 	bl	8005154 <xTaskCheckForTimeOut>
 8009f96:	b938      	cbnz	r0, 8009fa8 <prvRecvFromWaitForPacket+0x50>
    while( lPacketCount == 0 )
 8009f98:	b934      	cbnz	r4, 8009fa8 <prvRecvFromWaitForPacket+0x50>
        if( xTimed == pdFALSE )
 8009f9a:	2f00      	cmp	r7, #0
 8009f9c:	d1ec      	bne.n	8009f78 <prvRecvFromWaitForPacket+0x20>
            if( xRemainingTime == ( TickType_t ) 0 )
 8009f9e:	9b05      	ldr	r3, [sp, #20]
 8009fa0:	b113      	cbz	r3, 8009fa8 <prvRecvFromWaitForPacket+0x50>
            if( ( ( ( UBaseType_t ) xFlags ) & ( ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) ) != 0U )
 8009fa2:	f018 0f10 	tst.w	r8, #16
 8009fa6:	d0e3      	beq.n	8009f70 <prvRecvFromWaitForPacket+0x18>
    if( lPacketCount > 0 )
 8009fa8:	2c00      	cmp	r4, #0
 8009faa:	dd12      	ble.n	8009fd2 <prvRecvFromWaitForPacket+0x7a>
        vTaskSuspendAll();
 8009fac:	f7fa fe32 	bl	8004c14 <vTaskSuspendAll>
            pxNetworkBuffer = ( ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) );
 8009fb0:	6e33      	ldr	r3, [r6, #96]	@ 0x60
 8009fb2:	68dc      	ldr	r4, [r3, #12]
            if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_PEEK ) == 0U )
 8009fb4:	f018 0f04 	tst.w	r8, #4
 8009fb8:	d007      	beq.n	8009fca <prvRecvFromWaitForPacket+0x72>
        ( void ) xTaskResumeAll();
 8009fba:	f7fa fec5 	bl	8004d48 <xTaskResumeAll>
    *pxEventBits = xEventBits;
 8009fbe:	f8c9 5000 	str.w	r5, [r9]
}
 8009fc2:	4620      	mov	r0, r4
 8009fc4:	b007      	add	sp, #28
 8009fc6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                ( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 8009fca:	4620      	mov	r0, r4
 8009fcc:	f7f9 ff1e 	bl	8003e0c <uxListRemove>
 8009fd0:	e7f3      	b.n	8009fba <prvRecvFromWaitForPacket+0x62>
    NetworkBufferDescriptor_t * pxNetworkBuffer = NULL;
 8009fd2:	2400      	movs	r4, #0
 8009fd4:	e7f3      	b.n	8009fbe <prvRecvFromWaitForPacket+0x66>

08009fd6 <prvRecvFrom_CopyPacket>:
{
 8009fd6:	b538      	push	{r3, r4, r5, lr}
 8009fd8:	4604      	mov	r4, r0
 8009fda:	4608      	mov	r0, r1
    if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 8009fdc:	f013 0f01 	tst.w	r3, #1
 8009fe0:	d10a      	bne.n	8009ff8 <prvRecvFrom_CopyPacket+0x22>
        if( lReturn > ( int32_t ) uxBufferLength )
 8009fe2:	4615      	mov	r5, r2
 8009fe4:	9b04      	ldr	r3, [sp, #16]
 8009fe6:	429a      	cmp	r2, r3
 8009fe8:	db00      	blt.n	8009fec <prvRecvFrom_CopyPacket+0x16>
    int32_t lReturn = lDataLength;
 8009fea:	461d      	mov	r5, r3
        ( void ) memcpy( pvBuffer, pvCopySource, ( size_t ) lReturn );
 8009fec:	462a      	mov	r2, r5
 8009fee:	4621      	mov	r1, r4
 8009ff0:	f004 ff39 	bl	800ee66 <memcpy>
}
 8009ff4:	4628      	mov	r0, r5
 8009ff6:	bd38      	pop	{r3, r4, r5, pc}
        *( ( void ** ) pvBuffer ) = ( void * ) pucEthernetBuffer;
 8009ff8:	600c      	str	r4, [r1, #0]
    int32_t lReturn = lDataLength;
 8009ffa:	9d04      	ldr	r5, [sp, #16]
    return lReturn;
 8009ffc:	e7fa      	b.n	8009ff4 <prvRecvFrom_CopyPacket+0x1e>

08009ffe <prvSendUDPPacket>:
{
 8009ffe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a002:	b082      	sub	sp, #8
 800a004:	4605      	mov	r5, r0
 800a006:	460c      	mov	r4, r1
 800a008:	4616      	mov	r6, r2
 800a00a:	461f      	mov	r7, r3
 800a00c:	f8dd 8020 	ldr.w	r8, [sp, #32]
    IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 800a010:	2304      	movs	r3, #4
 800a012:	f88d 3000 	strb.w	r3, [sp]
 800a016:	2300      	movs	r3, #0
 800a018:	9301      	str	r3, [sp, #4]
    switch( pxDestinationAddress->sin_family ) /* LCOV_EXCL_BR_LINE Exclude this line because default case is checked before calling. */
 800a01a:	f898 3001 	ldrb.w	r3, [r8, #1]
 800a01e:	2b02      	cmp	r3, #2
 800a020:	d020      	beq.n	800a064 <prvSendUDPPacket+0x66>
 800a022:	2b0a      	cmp	r3, #10
 800a024:	d103      	bne.n	800a02e <prvSendUDPPacket+0x30>
                ( void ) xSend_UDP_Update_IPv6( pxNetworkBuffer, pxDestinationAddress );
 800a026:	4641      	mov	r1, r8
 800a028:	4620      	mov	r0, r4
 800a02a:	f7fe fc53 	bl	80088d4 <xSend_UDP_Update_IPv6>
    pxNetworkBuffer->xDataLength = uxTotalDataLength + uxPayloadOffset;
 800a02e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800a030:	4433      	add	r3, r6
 800a032:	62a3      	str	r3, [r4, #40]	@ 0x28
    pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
 800a034:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 800a038:	86a3      	strh	r3, [r4, #52]	@ 0x34
    pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
 800a03a:	89ab      	ldrh	r3, [r5, #12]
 800a03c:	86e3      	strh	r3, [r4, #54]	@ 0x36
    pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
 800a03e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800a040:	f895 203a 	ldrb.w	r2, [r5, #58]	@ 0x3a
 800a044:	719a      	strb	r2, [r3, #6]
    xStackTxEvent.pvData = pxNetworkBuffer;
 800a046:	9401      	str	r4, [sp, #4]
    if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
 800a048:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800a04a:	4668      	mov	r0, sp
 800a04c:	f7fd f94a 	bl	80072e4 <xSendEventStructToIPTask>
 800a050:	2801      	cmp	r0, #1
 800a052:	d003      	beq.n	800a05c <prvSendUDPPacket+0x5e>
        if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 800a054:	f017 0601 	ands.w	r6, r7, #1
 800a058:	d009      	beq.n	800a06e <prvSendUDPPacket+0x70>
    int32_t lReturn = 0;
 800a05a:	2600      	movs	r6, #0
}
 800a05c:	4630      	mov	r0, r6
 800a05e:	b002      	add	sp, #8
 800a060:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                ( void ) xSend_UDP_Update_IPv4( pxNetworkBuffer, pxDestinationAddress );
 800a064:	4641      	mov	r1, r8
 800a066:	4620      	mov	r0, r4
 800a068:	f7fe fa0f 	bl	800848a <xSend_UDP_Update_IPv4>
                break;
 800a06c:	e7df      	b.n	800a02e <prvSendUDPPacket+0x30>
            vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800a06e:	4620      	mov	r0, r4
 800a070:	f004 fb16 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 800a074:	e7f2      	b.n	800a05c <prvSendUDPPacket+0x5e>

0800a076 <prvSendTo_ActualSend>:
{
 800a076:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800a07a:	b088      	sub	sp, #32
 800a07c:	4607      	mov	r7, r0
 800a07e:	4689      	mov	r9, r1
 800a080:	4690      	mov	r8, r2
 800a082:	461c      	mov	r4, r3
 800a084:	f8dd a044 	ldr.w	sl, [sp, #68]	@ 0x44
    TickType_t xTicksToWait = pxSocket->xSendBlockTime;
 800a088:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 800a08a:	9307      	str	r3, [sp, #28]
    if( ( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) != 0U ) ||
 800a08c:	f014 0f10 	tst.w	r4, #16
 800a090:	d01d      	beq.n	800a0ce <prvSendTo_ActualSend+0x58>
        xTicksToWait = ( TickType_t ) 0U;
 800a092:	2300      	movs	r3, #0
 800a094:	9307      	str	r3, [sp, #28]
    if( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_ZERO_COPY ) == 0U )
 800a096:	f014 0501 	ands.w	r5, r4, #1
 800a09a:	d11d      	bne.n	800a0d8 <prvSendTo_ActualSend+0x62>
        vTaskSetTimeOutState( &xTimeOut );
 800a09c:	a805      	add	r0, sp, #20
 800a09e:	f7fb f831 	bl	8005104 <vTaskSetTimeOutState>
        pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxPayloadOffset + uxTotalDataLength, xTicksToWait );
 800a0a2:	9907      	ldr	r1, [sp, #28]
 800a0a4:	eb0a 0008 	add.w	r0, sl, r8
 800a0a8:	f004 fb20 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
        if( pxNetworkBuffer != NULL )
 800a0ac:	4606      	mov	r6, r0
 800a0ae:	b338      	cbz	r0, 800a100 <prvSendTo_ActualSend+0x8a>
            void * pvCopyDest = ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ uxPayloadOffset ] );
 800a0b0:	6a40      	ldr	r0, [r0, #36]	@ 0x24
            ( void ) memcpy( pvCopyDest, pvBuffer, uxTotalDataLength );
 800a0b2:	4642      	mov	r2, r8
 800a0b4:	4649      	mov	r1, r9
 800a0b6:	4450      	add	r0, sl
 800a0b8:	f004 fed5 	bl	800ee66 <memcpy>
            if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
 800a0bc:	a907      	add	r1, sp, #28
 800a0be:	a805      	add	r0, sp, #20
 800a0c0:	f7fb f848 	bl	8005154 <xTaskCheckForTimeOut>
 800a0c4:	2801      	cmp	r0, #1
 800a0c6:	d10c      	bne.n	800a0e2 <prvSendTo_ActualSend+0x6c>
                xTicksToWait = ( TickType_t ) 0;
 800a0c8:	2300      	movs	r3, #0
 800a0ca:	9307      	str	r3, [sp, #28]
    if( pxNetworkBuffer != NULL )
 800a0cc:	e009      	b.n	800a0e2 <prvSendTo_ActualSend+0x6c>
        ( xIsCallingFromIPTask() != pdFALSE ) )
 800a0ce:	f7fd fe7a 	bl	8007dc6 <xIsCallingFromIPTask>
    if( ( ( ( UBaseType_t ) xFlags & ( UBaseType_t ) FREERTOS_MSG_DONTWAIT ) != 0U ) ||
 800a0d2:	2800      	cmp	r0, #0
 800a0d4:	d0df      	beq.n	800a096 <prvSendTo_ActualSend+0x20>
 800a0d6:	e7dc      	b.n	800a092 <prvSendTo_ActualSend+0x1c>
        pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pvBuffer );
 800a0d8:	4648      	mov	r0, r9
 800a0da:	f7fd fe51 	bl	8007d80 <pxUDPPayloadBuffer_to_NetworkBuffer>
    if( pxNetworkBuffer != NULL )
 800a0de:	4606      	mov	r6, r0
 800a0e0:	b190      	cbz	r0, 800a108 <prvSendTo_ActualSend+0x92>
        pxNetworkBuffer->pxEndPoint = pxSocket->pxEndPoint;
 800a0e2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800a0e4:	6333      	str	r3, [r6, #48]	@ 0x30
        lReturn = prvSendUDPPacket( pxSocket,
 800a0e6:	f8cd a008 	str.w	sl, [sp, #8]
 800a0ea:	9b07      	ldr	r3, [sp, #28]
 800a0ec:	9301      	str	r3, [sp, #4]
 800a0ee:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 800a0f0:	9300      	str	r3, [sp, #0]
 800a0f2:	4623      	mov	r3, r4
 800a0f4:	4642      	mov	r2, r8
 800a0f6:	4631      	mov	r1, r6
 800a0f8:	4638      	mov	r0, r7
 800a0fa:	f7ff ff80 	bl	8009ffe <prvSendUDPPacket>
 800a0fe:	4605      	mov	r5, r0
}
 800a100:	4628      	mov	r0, r5
 800a102:	b008      	add	sp, #32
 800a104:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    int32_t lReturn = 0;
 800a108:	2500      	movs	r5, #0
    return lReturn;
 800a10a:	e7f9      	b.n	800a100 <prvSendTo_ActualSend+0x8a>

0800a10c <prvGetPrivatePortNumber>:
{
 800a10c:	b570      	push	{r4, r5, r6, lr}
 800a10e:	b082      	sub	sp, #8
    uint32_t ulRandomSeed = 0;
 800a110:	2300      	movs	r3, #0
 800a112:	9301      	str	r3, [sp, #4]
        if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
 800a114:	2806      	cmp	r0, #6
 800a116:	d024      	beq.n	800a162 <prvGetPrivatePortNumber+0x56>
        pxList = &xBoundUDPSocketsList;
 800a118:	4e15      	ldr	r6, [pc, #84]	@ (800a170 <prvGetPrivatePortNumber+0x64>)
 800a11a:	f44f 457c 	mov.w	r5, #64512	@ 0xfc00
        if( xApplicationGetRandomNumber( &( ulRandomSeed ) ) == pdFALSE )
 800a11e:	a801      	add	r0, sp, #4
 800a120:	f7f7 f9ec 	bl	80014fc <xApplicationGetRandomNumber>
 800a124:	b1f8      	cbz	r0, 800a166 <prvGetPrivatePortNumber+0x5a>
                                  ( ( ( uint16_t ) ulRandomSeed ) % usEphemeralPortCount ) );
 800a126:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        usResult = ( uint16_t ) ( socketAUTO_PORT_ALLOCATION_START_NUMBER +
 800a12a:	0a9a      	lsrs	r2, r3, #10
 800a12c:	4911      	ldr	r1, [pc, #68]	@ (800a174 <prvGetPrivatePortNumber+0x68>)
 800a12e:	fba1 1202 	umull	r1, r2, r1, r2
 800a132:	ebc2 1282 	rsb	r2, r2, r2, lsl #6
 800a136:	eba3 2382 	sub.w	r3, r3, r2, lsl #10
 800a13a:	b29b      	uxth	r3, r3
 800a13c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 800a140:	b29a      	uxth	r2, r3
                ( TickType_t ) FreeRTOS_htons( usResult ) ) )
 800a142:	f3c3 2407 	ubfx	r4, r3, #8, #8
 800a146:	ea44 2402 	orr.w	r4, r4, r2, lsl #8
 800a14a:	b2a4      	uxth	r4, r4
        if( NULL == pxListFindListItemWithValue(
 800a14c:	4621      	mov	r1, r4
 800a14e:	4630      	mov	r0, r6
 800a150:	f7ff fe60 	bl	8009e14 <pxListFindListItemWithValue>
 800a154:	b140      	cbz	r0, 800a168 <prvGetPrivatePortNumber+0x5c>
        usIterations--;
 800a156:	3d01      	subs	r5, #1
 800a158:	b2ad      	uxth	r5, r5
    while( usIterations > 0U );
 800a15a:	2d00      	cmp	r5, #0
 800a15c:	d1df      	bne.n	800a11e <prvGetPrivatePortNumber+0x12>
            usResult = 0;
 800a15e:	462c      	mov	r4, r5
 800a160:	e002      	b.n	800a168 <prvGetPrivatePortNumber+0x5c>
            pxList = &xBoundTCPSocketsList;
 800a162:	4e05      	ldr	r6, [pc, #20]	@ (800a178 <prvGetPrivatePortNumber+0x6c>)
 800a164:	e7d9      	b.n	800a11a <prvGetPrivatePortNumber+0xe>
 800a166:	2400      	movs	r4, #0
}
 800a168:	4620      	mov	r0, r4
 800a16a:	b002      	add	sp, #8
 800a16c:	bd70      	pop	{r4, r5, r6, pc}
 800a16e:	bf00      	nop
 800a170:	20013794 	.word	0x20013794
 800a174:	04104114 	.word	0x04104114
 800a178:	20013780 	.word	0x20013780

0800a17c <prvSocketBindAdd>:
{
 800a17c:	b570      	push	{r4, r5, r6, lr}
 800a17e:	4604      	mov	r4, r0
 800a180:	460d      	mov	r5, r1
 800a182:	4616      	mov	r6, r2
    if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 800a184:	b11b      	cbz	r3, 800a18e <prvSocketBindAdd+0x12>
 800a186:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800a18a:	2b06      	cmp	r3, #6
 800a18c:	d005      	beq.n	800a19a <prvSocketBindAdd+0x1e>
        ( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 800a18e:	8869      	ldrh	r1, [r5, #2]
 800a190:	4630      	mov	r0, r6
 800a192:	f7ff fe3f 	bl	8009e14 <pxListFindListItemWithValue>
    if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 800a196:	2800      	cmp	r0, #0
 800a198:	d138      	bne.n	800a20c <prvSocketBindAdd+0x90>
        socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
 800a19a:	886b      	ldrh	r3, [r5, #2]
 800a19c:	60e3      	str	r3, [r4, #12]
        pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 800a19e:	886a      	ldrh	r2, [r5, #2]
 800a1a0:	0213      	lsls	r3, r2, #8
 800a1a2:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800a1a6:	8723      	strh	r3, [r4, #56]	@ 0x38
            if( pxAddress->sin_family == ( uint8_t ) FREERTOS_AF_INET6 )
 800a1a8:	786b      	ldrb	r3, [r5, #1]
 800a1aa:	2b0a      	cmp	r3, #10
 800a1ac:	d017      	beq.n	800a1de <prvSocketBindAdd+0x62>
                if( pxAddress->sin_address.ulIP_IPv4 != FREERTOS_INADDR_ANY )
 800a1ae:	68a8      	ldr	r0, [r5, #8]
 800a1b0:	b9f0      	cbnz	r0, 800a1f0 <prvSocketBindAdd+0x74>
            if( pxSocket->pxEndPoint != NULL )
 800a1b2:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800a1b4:	b30b      	cbz	r3, 800a1fa <prvSocketBindAdd+0x7e>
                pxSocket->xLocalAddress.ulIP_IPv4 = FreeRTOS_ntohl( pxSocket->pxEndPoint->ipv4_settings.ulIPAddress );
 800a1b6:	681a      	ldr	r2, [r3, #0]
 800a1b8:	0213      	lsls	r3, r2, #8
 800a1ba:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800a1be:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a1c2:	0a11      	lsrs	r1, r2, #8
 800a1c4:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800a1c8:	430b      	orrs	r3, r1
 800a1ca:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800a1ce:	62a3      	str	r3, [r4, #40]	@ 0x28
            vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
 800a1d0:	f104 010c 	add.w	r1, r4, #12
 800a1d4:	4630      	mov	r0, r6
 800a1d6:	f7f9 fdf5 	bl	8003dc4 <vListInsertEnd>
    BaseType_t xReturn = 0;
 800a1da:	2000      	movs	r0, #0
}
 800a1dc:	bd70      	pop	{r4, r5, r6, pc}
                ( void ) memcpy( pxSocket->xLocalAddress.xIP_IPv6.ucBytes, pxAddress->sin_address.xIP_IPv6.ucBytes, sizeof( pxSocket->xLocalAddress.xIP_IPv6.ucBytes ) );
 800a1de:	68a8      	ldr	r0, [r5, #8]
 800a1e0:	68e9      	ldr	r1, [r5, #12]
 800a1e2:	692a      	ldr	r2, [r5, #16]
 800a1e4:	696b      	ldr	r3, [r5, #20]
 800a1e6:	62a0      	str	r0, [r4, #40]	@ 0x28
 800a1e8:	62e1      	str	r1, [r4, #44]	@ 0x2c
 800a1ea:	6322      	str	r2, [r4, #48]	@ 0x30
 800a1ec:	6363      	str	r3, [r4, #52]	@ 0x34
 800a1ee:	e7e0      	b.n	800a1b2 <prvSocketBindAdd+0x36>
                    pxSocket->pxEndPoint = FreeRTOS_FindEndPointOnIP_IPv4( pxAddress->sin_address.ulIP_IPv4, 7 );
 800a1f0:	2107      	movs	r1, #7
 800a1f2:	f7ff fc3b 	bl	8009a6c <FreeRTOS_FindEndPointOnIP_IPv4>
 800a1f6:	64e0      	str	r0, [r4, #76]	@ 0x4c
 800a1f8:	e7db      	b.n	800a1b2 <prvSocketBindAdd+0x36>
            if( pxAddress->sin_family == ( uint8_t ) FREERTOS_AF_INET6 )
 800a1fa:	786b      	ldrb	r3, [r5, #1]
 800a1fc:	2b0a      	cmp	r3, #10
 800a1fe:	d0e7      	beq.n	800a1d0 <prvSocketBindAdd+0x54>
            ( void ) memset( pxSocket->xLocalAddress.xIP_IPv6.ucBytes, 0, sizeof( pxSocket->xLocalAddress.xIP_IPv6.ucBytes ) );
 800a200:	2300      	movs	r3, #0
 800a202:	62a3      	str	r3, [r4, #40]	@ 0x28
 800a204:	62e3      	str	r3, [r4, #44]	@ 0x2c
 800a206:	6323      	str	r3, [r4, #48]	@ 0x30
 800a208:	6363      	str	r3, [r4, #52]	@ 0x34
 800a20a:	e7e1      	b.n	800a1d0 <prvSocketBindAdd+0x54>
        xReturn = -pdFREERTOS_ERRNO_EADDRINUSE;
 800a20c:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
    return xReturn;
 800a210:	e7e4      	b.n	800a1dc <prvSocketBindAdd+0x60>

0800a212 <prvSetOptionStopRX>:
    {
 800a212:	b508      	push	{r3, lr}
        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800a214:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800a218:	2b06      	cmp	r3, #6
 800a21a:	d11c      	bne.n	800a256 <prvSetOptionStopRX+0x44>
            if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 800a21c:	680b      	ldr	r3, [r1, #0]
 800a21e:	b19b      	cbz	r3, 800a248 <prvSetOptionStopRX+0x36>
                pxSocket->u.xTCP.bits.bRxStopped = pdTRUE_UNSIGNED;
 800a220:	f890 306a 	ldrb.w	r3, [r0, #106]	@ 0x6a
 800a224:	f043 0304 	orr.w	r3, r3, #4
 800a228:	f880 306a 	strb.w	r3, [r0, #106]	@ 0x6a
            pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800a22c:	f890 3069 	ldrb.w	r3, [r0, #105]	@ 0x69
 800a230:	f043 0301 	orr.w	r3, r3, #1
 800a234:	f880 3069 	strb.w	r3, [r0, #105]	@ 0x69
            pxSocket->u.xTCP.usTimeout = 1U; /* to set/clear bRxStopped */
 800a238:	2301      	movs	r3, #1
 800a23a:	f8a0 3070 	strh.w	r3, [r0, #112]	@ 0x70
            ( void ) xSendEventToIPTask( eTCPTimerEvent );
 800a23e:	2006      	movs	r0, #6
 800a240:	f7fd f8ba 	bl	80073b8 <xSendEventToIPTask>
            xReturn = 0;
 800a244:	2000      	movs	r0, #0
    }
 800a246:	bd08      	pop	{r3, pc}
                pxSocket->u.xTCP.bits.bRxStopped = pdFALSE_UNSIGNED;
 800a248:	f890 306a 	ldrb.w	r3, [r0, #106]	@ 0x6a
 800a24c:	f023 0304 	bic.w	r3, r3, #4
 800a250:	f880 306a 	strb.w	r3, [r0, #106]	@ 0x6a
 800a254:	e7ea      	b.n	800a22c <prvSetOptionStopRX+0x1a>
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800a256:	f06f 0015 	mvn.w	r0, #21
        return xReturn;
 800a25a:	e7f4      	b.n	800a246 <prvSetOptionStopRX+0x34>

0800a25c <prvTCPCreateStream>:
 *
 * @return The stream buffer.
 */
    static StreamBuffer_t * prvTCPCreateStream( FreeRTOS_Socket_t * pxSocket,
                                                BaseType_t xIsInputStream )
    {
 800a25c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a25e:	4605      	mov	r5, r0
        size_t uxLength;
        size_t uxSize;

        /* Now that a stream is created, the maximum size is fixed before
         * creation, it could still be changed with setsockopt(). */
        if( xIsInputStream != pdFALSE )
 800a260:	460f      	mov	r7, r1
 800a262:	b341      	cbz	r1, 800a2b6 <prvTCPCreateStream+0x5a>
        {
            size_t uxLittlePerc = sock20_PERCENT;
            size_t uxEnoughPerc = sock80_PERCENT;
            size_t uxSegmentCount = pxSocket->u.xTCP.uxRxStreamSize / pxSocket->u.xTCP.usMSS;
 800a264:	f8d0 3094 	ldr.w	r3, [r0, #148]	@ 0x94
 800a268:	f8b0 2072 	ldrh.w	r2, [r0, #114]	@ 0x72
 800a26c:	fbb3 f2f2 	udiv	r2, r3, r2
                { 50U, 100U }, /* 2 segments. */
                { 34U, 100U }, /* 3 segments. */
                { 25U, 100U }, /* 4 segments. */
            };

            if( ( uxSegmentCount > 0U ) &&
 800a270:	3a01      	subs	r2, #1
 800a272:	2a03      	cmp	r2, #3
 800a274:	d806      	bhi.n	800a284 <prvTCPCreateStream+0x28>
                ( uxSegmentCount <= ARRAY_USIZE( xPercTable ) ) )
            {
                uxLittlePerc = xPercTable[ uxSegmentCount - 1U ].uxPercLittle;
 800a276:	4822      	ldr	r0, [pc, #136]	@ (800a300 <prvTCPCreateStream+0xa4>)
 800a278:	f850 1032 	ldr.w	r1, [r0, r2, lsl #3]
                uxEnoughPerc = xPercTable[ uxSegmentCount - 1U ].uxPercEnough;
 800a27c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 800a280:	6842      	ldr	r2, [r0, #4]
 800a282:	e001      	b.n	800a288 <prvTCPCreateStream+0x2c>
            size_t uxEnoughPerc = sock80_PERCENT;
 800a284:	2250      	movs	r2, #80	@ 0x50
            size_t uxLittlePerc = sock20_PERCENT;
 800a286:	2114      	movs	r1, #20
            }

            uxLength = pxSocket->u.xTCP.uxRxStreamSize;

            if( pxSocket->u.xTCP.uxLittleSpace == 0U )
 800a288:	f8d5 008c 	ldr.w	r0, [r5, #140]	@ 0x8c
 800a28c:	b938      	cbnz	r0, 800a29e <prvTCPCreateStream+0x42>
            {
                pxSocket->u.xTCP.uxLittleSpace = ( uxLittlePerc * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
 800a28e:	fb03 f101 	mul.w	r1, r3, r1
 800a292:	481c      	ldr	r0, [pc, #112]	@ (800a304 <prvTCPCreateStream+0xa8>)
 800a294:	fba0 0101 	umull	r0, r1, r0, r1
 800a298:	0949      	lsrs	r1, r1, #5
 800a29a:	f8c5 108c 	str.w	r1, [r5, #140]	@ 0x8c
            }

            if( pxSocket->u.xTCP.uxEnoughSpace == 0U )
 800a29e:	f8d5 1090 	ldr.w	r1, [r5, #144]	@ 0x90
 800a2a2:	b951      	cbnz	r1, 800a2ba <prvTCPCreateStream+0x5e>
            {
                pxSocket->u.xTCP.uxEnoughSpace = ( uxEnoughPerc * pxSocket->u.xTCP.uxRxStreamSize ) / sock100_PERCENT;
 800a2a4:	fb03 f202 	mul.w	r2, r3, r2
 800a2a8:	4916      	ldr	r1, [pc, #88]	@ (800a304 <prvTCPCreateStream+0xa8>)
 800a2aa:	fba1 1202 	umull	r1, r2, r1, r2
 800a2ae:	0952      	lsrs	r2, r2, #5
 800a2b0:	f8c5 2090 	str.w	r2, [r5, #144]	@ 0x90
 800a2b4:	e001      	b.n	800a2ba <prvTCPCreateStream+0x5e>
            }
        }
        else
        {
            uxLength = pxSocket->u.xTCP.uxTxStreamSize;
 800a2b6:	f8d0 3098 	ldr.w	r3, [r0, #152]	@ 0x98
        }

        /* Add an extra 4 (or 8) bytes. */
        uxLength += sizeof( size_t );
 800a2ba:	3304      	adds	r3, #4

        /* And make the length a multiple of sizeof( size_t ). */
        uxLength &= ~( sizeof( size_t ) - 1U );
 800a2bc:	f023 0403 	bic.w	r4, r3, #3
        uxSize = ( sizeof( *pxBuffer ) + uxLength ) - sizeof( pxBuffer->ucArray );

        /* MISRA Ref 4.12.1 [Use of dynamic memory]. */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#directive-412. */
        /* coverity[misra_c_2012_directive_4_12_violation] */
        pxBuffer = ( ( StreamBuffer_t * ) pvPortMallocLarge( uxSize ) );
 800a2c0:	f104 0014 	add.w	r0, r4, #20
 800a2c4:	f7fb fcee 	bl	8005ca4 <pvPortMalloc>

        if( pxBuffer == NULL )
 800a2c8:	4606      	mov	r6, r0
 800a2ca:	b158      	cbz	r0, 800a2e4 <prvTCPCreateStream+0x88>
            vTCPStateChange( pxSocket, eCLOSE_WAIT );
        }
        else
        {
            /* Clear the markers of the stream */
            ( void ) memset( pxBuffer, 0, sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 800a2cc:	2300      	movs	r3, #0
 800a2ce:	6003      	str	r3, [r0, #0]
 800a2d0:	6043      	str	r3, [r0, #4]
 800a2d2:	6083      	str	r3, [r0, #8]
 800a2d4:	60c3      	str	r3, [r0, #12]
 800a2d6:	6103      	str	r3, [r0, #16]
            pxBuffer->LENGTH = ( size_t ) uxLength;
 800a2d8:	6104      	str	r4, [r0, #16]
            if( xTCPWindowLoggingLevel != 0 )
            {
                FreeRTOS_debug_printf( ( "prvTCPCreateStream: %cxStream created %u bytes (total %u)\n", ( xIsInputStream != 0 ) ? 'R' : 'T', ( unsigned ) uxLength, ( unsigned ) uxSize ) );
            }

            if( xIsInputStream != 0 )
 800a2da:	b177      	cbz	r7, 800a2fa <prvTCPCreateStream+0x9e>
            {
                iptraceMEM_STATS_CREATE( tcpRX_STREAM_BUFFER, pxBuffer, uxSize );
                pxSocket->u.xTCP.rxStream = pxBuffer;
 800a2dc:	f8c5 009c 	str.w	r0, [r5, #156]	@ 0x9c
                pxSocket->u.xTCP.txStream = pxBuffer;
            }
        }

        return pxBuffer;
    }
 800a2e0:	4630      	mov	r0, r6
 800a2e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
 800a2e4:	f895 306a 	ldrb.w	r3, [r5, #106]	@ 0x6a
 800a2e8:	f043 0308 	orr.w	r3, r3, #8
 800a2ec:	f885 306a 	strb.w	r3, [r5, #106]	@ 0x6a
            vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800a2f0:	2108      	movs	r1, #8
 800a2f2:	4628      	mov	r0, r5
 800a2f4:	f001 f9e2 	bl	800b6bc <vTCPStateChange>
 800a2f8:	e7f2      	b.n	800a2e0 <prvTCPCreateStream+0x84>
                pxSocket->u.xTCP.txStream = pxBuffer;
 800a2fa:	f8c5 00a0 	str.w	r0, [r5, #160]	@ 0xa0
        return pxBuffer;
 800a2fe:	e7ef      	b.n	800a2e0 <prvTCPCreateStream+0x84>
 800a300:	0801031c 	.word	0x0801031c
 800a304:	51eb851f 	.word	0x51eb851f

0800a308 <prvRecvWait>:
    {
 800a308:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a30c:	b087      	sub	sp, #28
 800a30e:	4604      	mov	r4, r0
 800a310:	4688      	mov	r8, r1
 800a312:	4617      	mov	r7, r2
        if( pxSocket->u.xTCP.rxStream != NULL )
 800a314:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
 800a318:	2800      	cmp	r0, #0
 800a31a:	d03d      	beq.n	800a398 <prvRecvWait+0x90>
            xByteCount = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
 800a31c:	f001 f889 	bl	800b432 <uxStreamBufferGetSize>
 800a320:	4606      	mov	r6, r0
        BaseType_t xByteCount = 0;
 800a322:	2500      	movs	r5, #0
 800a324:	46a9      	mov	r9, r5
        while( xByteCount == 0 )
 800a326:	bb8e      	cbnz	r6, 800a38c <prvRecvWait+0x84>
            eIPTCPState_t eType = ( eIPTCPState_t ) pxSocket->u.xTCP.eTCPState;
 800a328:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
            if( ( eType == eCLOSED ) ||
 800a32c:	b33b      	cbz	r3, 800a37e <prvRecvWait+0x76>
 800a32e:	2b08      	cmp	r3, #8
 800a330:	d025      	beq.n	800a37e <prvRecvWait+0x76>
                ( eType == eCLOSE_WAIT ) || /* (server + client) waiting for a connection termination request from the local user. */
 800a332:	2b09      	cmp	r3, #9
 800a334:	d023      	beq.n	800a37e <prvRecvWait+0x76>
            if( xTimed == pdFALSE )
 800a336:	f1b9 0f00 	cmp.w	r9, #0
 800a33a:	d10a      	bne.n	800a352 <prvRecvWait+0x4a>
                xRemainingTime = pxSocket->xReceiveBlockTime;
 800a33c:	6a23      	ldr	r3, [r4, #32]
 800a33e:	9305      	str	r3, [sp, #20]
                if( xRemainingTime == ( TickType_t ) 0U )
 800a340:	b323      	cbz	r3, 800a38c <prvRecvWait+0x84>
                if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 800a342:	f017 0f10 	tst.w	r7, #16
 800a346:	d121      	bne.n	800a38c <prvRecvWait+0x84>
                vTaskSetTimeOutState( &xTimeOut );
 800a348:	a803      	add	r0, sp, #12
 800a34a:	f7fa fedb 	bl	8005104 <vTaskSetTimeOutState>
                xTimed = pdTRUE;
 800a34e:	f04f 0901 	mov.w	r9, #1
            if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 800a352:	a905      	add	r1, sp, #20
 800a354:	a803      	add	r0, sp, #12
 800a356:	f7fa fefd 	bl	8005154 <xTaskCheckForTimeOut>
 800a35a:	b9b8      	cbnz	r0, 800a38c <prvRecvWait+0x84>
            xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup,
 800a35c:	9b05      	ldr	r3, [sp, #20]
 800a35e:	9300      	str	r3, [sp, #0]
 800a360:	2300      	movs	r3, #0
 800a362:	2201      	movs	r2, #1
 800a364:	2161      	movs	r1, #97	@ 0x61
 800a366:	6860      	ldr	r0, [r4, #4]
 800a368:	f7f9 fc0d 	bl	8003b86 <xEventGroupWaitBits>
 800a36c:	4605      	mov	r5, r0
            if( pxSocket->u.xTCP.rxStream != NULL )
 800a36e:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 800a372:	2800      	cmp	r0, #0
 800a374:	d0d7      	beq.n	800a326 <prvRecvWait+0x1e>
                xByteCount = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
 800a376:	f001 f85c 	bl	800b432 <uxStreamBufferGetSize>
 800a37a:	4606      	mov	r6, r0
 800a37c:	e7d3      	b.n	800a326 <prvRecvWait+0x1e>
                if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 800a37e:	f894 306a 	ldrb.w	r3, [r4, #106]	@ 0x6a
 800a382:	f013 0f08 	tst.w	r3, #8
 800a386:	d109      	bne.n	800a39c <prvRecvWait+0x94>
                xByteCount = -pdFREERTOS_ERRNO_ENOTCONN;
 800a388:	f06f 067f 	mvn.w	r6, #127	@ 0x7f
        *( pxEventBits ) = xEventBits;
 800a38c:	f8c8 5000 	str.w	r5, [r8]
    }
 800a390:	4630      	mov	r0, r6
 800a392:	b007      	add	sp, #28
 800a394:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        BaseType_t xByteCount = 0;
 800a398:	2600      	movs	r6, #0
 800a39a:	e7c2      	b.n	800a322 <prvRecvWait+0x1a>
                    xByteCount = -pdFREERTOS_ERRNO_ENOMEM;
 800a39c:	f06f 060b 	mvn.w	r6, #11
 800a3a0:	e7f4      	b.n	800a38c <prvRecvWait+0x84>

0800a3a2 <vTCPAddRxdata_Stored>:
 *        RX-stream. When the space is dropped below a threshold, it may set the
 *        bit field 'bLowWater'. Also the socket's events bits for READ will be set.
 * @param[in] pxSocket the socket that has received new data.
 */
    static void vTCPAddRxdata_Stored( FreeRTOS_Socket_t * pxSocket )
    {
 800a3a2:	b510      	push	{r4, lr}
 800a3a4:	4604      	mov	r4, r0
        /* See if running out of space. */
        if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
 800a3a6:	f990 3068 	ldrsb.w	r3, [r0, #104]	@ 0x68
 800a3aa:	2b00      	cmp	r3, #0
 800a3ac:	da0d      	bge.n	800a3ca <vTCPAddRxdata_Stored+0x28>
            }
        }

        /* New incoming data is available, wake up the user.   User's
         * semaphores will be set just before the IP-task goes asleep. */
        pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_RECEIVE;
 800a3ae:	6823      	ldr	r3, [r4, #0]
 800a3b0:	f043 0201 	orr.w	r2, r3, #1
 800a3b4:	6022      	str	r2, [r4, #0]

        #if ipconfigSUPPORT_SELECT_FUNCTION == 1
        {
            if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U )
 800a3b6:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 800a3b8:	f012 0f01 	tst.w	r2, #1
 800a3bc:	d004      	beq.n	800a3c8 <vTCPAddRxdata_Stored+0x26>
            {
                pxSocket->xEventBits |= ( ( ( EventBits_t ) eSELECT_READ ) << SOCKET_EVENT_BIT_COUNT );
 800a3be:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800a3c2:	f043 0301 	orr.w	r3, r3, #1
 800a3c6:	6023      	str	r3, [r4, #0]
            }
        }
        #endif
    }
 800a3c8:	bd10      	pop	{r4, pc}
            size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800a3ca:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
 800a3ce:	f001 f82a 	bl	800b426 <uxStreamBufferFrontSpace>
            if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace )
 800a3d2:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
 800a3d6:	4283      	cmp	r3, r0
 800a3d8:	d3e9      	bcc.n	800a3ae <vTCPAddRxdata_Stored+0xc>
                pxSocket->u.xTCP.bits.bLowWater = pdTRUE_UNSIGNED;
 800a3da:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800a3de:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800a3e2:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
                pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800a3e6:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800a3ea:	f043 0301 	orr.w	r3, r3, #1
 800a3ee:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                pxSocket->u.xTCP.usTimeout = 1U;
 800a3f2:	2301      	movs	r3, #1
 800a3f4:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                ( void ) xSendEventToIPTask( eTCPTimerEvent );
 800a3f8:	2006      	movs	r0, #6
 800a3fa:	f7fc ffdd 	bl	80073b8 <xSendEventToIPTask>
 800a3fe:	e7d6      	b.n	800a3ae <vTCPAddRxdata_Stored+0xc>

0800a400 <prvRecvData>:
    {
 800a400:	b530      	push	{r4, r5, lr}
 800a402:	b083      	sub	sp, #12
 800a404:	4604      	mov	r4, r0
        if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) == 0U )
 800a406:	f013 0f01 	tst.w	r3, #1
 800a40a:	d129      	bne.n	800a460 <prvRecvData+0x60>
            BaseType_t xIsPeek = ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_PEEK ) != 0U ) ? 1L : 0L;
 800a40c:	f3c3 0380 	ubfx	r3, r3, #2, #1
                         uxStreamBufferGet( pxSocket->u.xTCP.rxStream,
 800a410:	9300      	str	r3, [sp, #0]
 800a412:	4613      	mov	r3, r2
 800a414:	460a      	mov	r2, r1
 800a416:	2100      	movs	r1, #0
 800a418:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
 800a41c:	f001 f88d 	bl	800b53a <uxStreamBufferGet>
 800a420:	4605      	mov	r5, r0
            if( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED )
 800a422:	f994 3068 	ldrsb.w	r3, [r4, #104]	@ 0x68
 800a426:	2b00      	cmp	r3, #0
 800a428:	da1f      	bge.n	800a46a <prvRecvData+0x6a>
                size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800a42a:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 800a42e:	f000 fffa 	bl	800b426 <uxStreamBufferFrontSpace>
                if( uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace )
 800a432:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 800a436:	4283      	cmp	r3, r0
 800a438:	d817      	bhi.n	800a46a <prvRecvData+0x6a>
                    pxSocket->u.xTCP.bits.bLowWater = pdFALSE_UNSIGNED;
 800a43a:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800a43e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800a442:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
                    pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800a446:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800a44a:	f043 0301 	orr.w	r3, r3, #1
 800a44e:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                    pxSocket->u.xTCP.usTimeout = 1U; /* because bLowWater is cleared. */
 800a452:	2301      	movs	r3, #1
 800a454:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                    ( void ) xSendEventToIPTask( eTCPTimerEvent );
 800a458:	2006      	movs	r0, #6
 800a45a:	f7fc ffad 	bl	80073b8 <xSendEventToIPTask>
 800a45e:	e004      	b.n	800a46a <prvRecvData+0x6a>
            xByteCount = ( BaseType_t ) uxStreamBufferGetPtr( pxSocket->u.xTCP.rxStream, ( uint8_t ** ) pvBuffer );
 800a460:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
 800a464:	f001 f810 	bl	800b488 <uxStreamBufferGetPtr>
 800a468:	4605      	mov	r5, r0
    }
 800a46a:	4628      	mov	r0, r5
 800a46c:	b003      	add	sp, #12
 800a46e:	bd30      	pop	{r4, r5, pc}

0800a470 <vTCPNetStat_TCPSocket>:
 * @brief A helper function of vTCPNetStat(), see below.
 *
 * @param[in] pxSocket The socket that needs logging.
 */
    static void vTCPNetStat_TCPSocket( const FreeRTOS_Socket_t * pxSocket )
    {
 800a470:	b510      	push	{r4, lr}
 800a472:	b090      	sub	sp, #64	@ 0x40
 800a474:	4604      	mov	r4, r0
        char pcRemoteIp[ 40 ];
        int xIPWidth = 32;

        #if ( ipconfigTCP_KEEP_ALIVE == 1 )
            TickType_t age = xTaskGetTickCount() - pxSocket->u.xTCP.xLastAliveTime;
 800a476:	f7fa fbd5 	bl	8004c24 <xTaskGetTickCount>
        #else
            TickType_t age = 0U;
        #endif

        char ucChildText[ 16 ] = "";
 800a47a:	2300      	movs	r3, #0
 800a47c:	9302      	str	r3, [sp, #8]
 800a47e:	9303      	str	r3, [sp, #12]
 800a480:	9304      	str	r3, [sp, #16]
 800a482:	9305      	str	r3, [sp, #20]

        if( pxSocket->u.xTCP.eTCPState == ( uint8_t ) eTCP_LISTEN )
 800a484:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800a488:	2b01      	cmp	r3, #1
 800a48a:	d00c      	beq.n	800a4a6 <vTCPNetStat_TCPSocket+0x36>
        if( age > 999999U )
        {
            age = 999999U;
        }

        switch( pxSocket->bits.bIsIPv6 ) /* LCOV_EXCL_BR_LINE Exclude this line because default case is not counted. */
 800a48c:	7a23      	ldrb	r3, [r4, #8]
 800a48e:	f013 0301 	ands.w	r3, r3, #1
 800a492:	d028      	beq.n	800a4e6 <vTCPNetStat_TCPSocket+0x76>
 800a494:	b36b      	cbz	r3, 800a4f2 <vTCPNetStat_TCPSocket+0x82>
                    break;
            #endif /* ( ipconfigUSE_IPv4 != 0 ) */

            #if ( ipconfigUSE_IPv6 != 0 )
                case pdTRUE_UNSIGNED:
                    ( void ) snprintf( pcRemoteIp,
 800a496:	f104 0354 	add.w	r3, r4, #84	@ 0x54
 800a49a:	4a17      	ldr	r2, [pc, #92]	@ (800a4f8 <vTCPNetStat_TCPSocket+0x88>)
 800a49c:	2128      	movs	r1, #40	@ 0x28
 800a49e:	a806      	add	r0, sp, #24
 800a4a0:	f004 fad0 	bl	800ea44 <sniprintf>
                           ( pxSocket->u.xTCP.txStream != NULL ) ? 1 : 0,
                           FreeRTOS_GetTCPStateName( pxSocket->u.xTCP.eTCPState ),
                           ( unsigned ) ( ( age > 999999U ) ? 999999U : age ), /* Format 'age' for printing */
                           pxSocket->u.xTCP.usTimeout,
                           ucChildText ) );
    }
 800a4a4:	e025      	b.n	800a4f2 <vTCPNetStat_TCPSocket+0x82>
                                                 pxSocket->u.xTCP.usBacklog );
 800a4a6:	f8b4 3076 	ldrh.w	r3, [r4, #118]	@ 0x76
            const int32_t copied_len = snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
 800a4aa:	9300      	str	r3, [sp, #0]
 800a4ac:	f8b4 3074 	ldrh.w	r3, [r4, #116]	@ 0x74
 800a4b0:	4a12      	ldr	r2, [pc, #72]	@ (800a4fc <vTCPNetStat_TCPSocket+0x8c>)
 800a4b2:	2110      	movs	r1, #16
 800a4b4:	a802      	add	r0, sp, #8
 800a4b6:	f004 fac5 	bl	800ea44 <sniprintf>
            configASSERT( copied_len >= 0 );                                /* LCOV_EXCL_BR_LINE the 'taken' branch will never execute. See the above comment. */
 800a4ba:	2800      	cmp	r0, #0
 800a4bc:	db0a      	blt.n	800a4d4 <vTCPNetStat_TCPSocket+0x64>
            configASSERT( copied_len < ( int32_t ) sizeof( ucChildText ) ); /* LCOV_EXCL_BR_LINE the 'taken' branch will never execute. See the above comment. */
 800a4be:	280f      	cmp	r0, #15
 800a4c0:	dde4      	ble.n	800a48c <vTCPNetStat_TCPSocket+0x1c>
 800a4c2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800a4c6:	f383 8811 	msr	BASEPRI, r3
 800a4ca:	f3bf 8f6f 	isb	sy
 800a4ce:	f3bf 8f4f 	dsb	sy
 800a4d2:	e7fe      	b.n	800a4d2 <vTCPNetStat_TCPSocket+0x62>
 800a4d4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800a4d8:	f383 8811 	msr	BASEPRI, r3
 800a4dc:	f3bf 8f6f 	isb	sy
 800a4e0:	f3bf 8f4f 	dsb	sy
            configASSERT( copied_len >= 0 );                                /* LCOV_EXCL_BR_LINE the 'taken' branch will never execute. See the above comment. */
 800a4e4:	e7fe      	b.n	800a4e4 <vTCPNetStat_TCPSocket+0x74>
                    ( void ) snprintf( pcRemoteIp, sizeof( pcRemoteIp ), "%xip", ( unsigned ) pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 );
 800a4e6:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 800a4e8:	4a05      	ldr	r2, [pc, #20]	@ (800a500 <vTCPNetStat_TCPSocket+0x90>)
 800a4ea:	2128      	movs	r1, #40	@ 0x28
 800a4ec:	a806      	add	r0, sp, #24
 800a4ee:	f004 faa9 	bl	800ea44 <sniprintf>
    }
 800a4f2:	b010      	add	sp, #64	@ 0x40
 800a4f4:	bd10      	pop	{r4, pc}
 800a4f6:	bf00      	nop
 800a4f8:	080101f8 	.word	0x080101f8
 800a4fc:	080101e8 	.word	0x080101e8
 800a500:	080101f0 	.word	0x080101f0

0800a504 <vNetworkSocketsInit>:
{
 800a504:	b508      	push	{r3, lr}
    vListInitialise( &xBoundUDPSocketsList );
 800a506:	4803      	ldr	r0, [pc, #12]	@ (800a514 <vNetworkSocketsInit+0x10>)
 800a508:	f7f9 fc4e 	bl	8003da8 <vListInitialise>
        vListInitialise( &xBoundTCPSocketsList );
 800a50c:	4802      	ldr	r0, [pc, #8]	@ (800a518 <vNetworkSocketsInit+0x14>)
 800a50e:	f7f9 fc4b 	bl	8003da8 <vListInitialise>
}
 800a512:	bd08      	pop	{r3, pc}
 800a514:	20013794 	.word	0x20013794
 800a518:	20013780 	.word	0x20013780

0800a51c <FreeRTOS_socket>:
{
 800a51c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a51e:	b083      	sub	sp, #12
 800a520:	4604      	mov	r4, r0
 800a522:	4615      	mov	r5, r2
    size_t uxSocketSize = 1;
 800a524:	2301      	movs	r3, #1
 800a526:	9301      	str	r3, [sp, #4]
    configASSERT( ( xDomain == FREERTOS_AF_INET6 ) || ( xDomain == FREERTOS_AF_INET ) );
 800a528:	280a      	cmp	r0, #10
 800a52a:	d00a      	beq.n	800a542 <FreeRTOS_socket+0x26>
 800a52c:	2802      	cmp	r0, #2
 800a52e:	d008      	beq.n	800a542 <FreeRTOS_socket+0x26>
 800a530:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800a534:	f383 8811 	msr	BASEPRI, r3
 800a538:	f3bf 8f6f 	isb	sy
 800a53c:	f3bf 8f4f 	dsb	sy
 800a540:	e7fe      	b.n	800a540 <FreeRTOS_socket+0x24>
        if( xProtocol == FREERTOS_SOCK_DEPENDENT_PROTO )
 800a542:	b925      	cbnz	r5, 800a54e <FreeRTOS_socket+0x32>
            switch( xType )
 800a544:	2901      	cmp	r1, #1
 800a546:	d00d      	beq.n	800a564 <FreeRTOS_socket+0x48>
 800a548:	2902      	cmp	r1, #2
 800a54a:	d100      	bne.n	800a54e <FreeRTOS_socket+0x32>
                    xProtocolCpy = FREERTOS_IPPROTO_UDP;
 800a54c:	2511      	movs	r5, #17
        if( prvDetermineSocketSize( xDomain, xType, xProtocolCpy, &uxSocketSize ) == pdFAIL )
 800a54e:	ab01      	add	r3, sp, #4
 800a550:	462a      	mov	r2, r5
 800a552:	4620      	mov	r0, r4
 800a554:	f7ff fbf6 	bl	8009d44 <prvDetermineSocketSize>
 800a558:	b930      	cbnz	r0, 800a568 <FreeRTOS_socket+0x4c>
            xReturn = FREERTOS_INVALID_SOCKET;
 800a55a:	f04f 36ff 	mov.w	r6, #4294967295
}
 800a55e:	4630      	mov	r0, r6
 800a560:	b003      	add	sp, #12
 800a562:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    xProtocolCpy = FREERTOS_IPPROTO_TCP;
 800a564:	2506      	movs	r5, #6
 800a566:	e7f2      	b.n	800a54e <FreeRTOS_socket+0x32>
        pxSocket = ( ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize ) );
 800a568:	9801      	ldr	r0, [sp, #4]
 800a56a:	f7fb fb9b 	bl	8005ca4 <pvPortMalloc>
        if( pxSocket == NULL )
 800a56e:	4606      	mov	r6, r0
 800a570:	2800      	cmp	r0, #0
 800a572:	d039      	beq.n	800a5e8 <FreeRTOS_socket+0xcc>
        xEventGroup = xEventGroupCreate();
 800a574:	f7f9 faf9 	bl	8003b6a <xEventGroupCreate>
        if( xEventGroup == NULL )
 800a578:	4607      	mov	r7, r0
 800a57a:	b300      	cbz	r0, 800a5be <FreeRTOS_socket+0xa2>
            ( void ) memset( pxSocket, 0, uxSocketSize );
 800a57c:	9a01      	ldr	r2, [sp, #4]
 800a57e:	2100      	movs	r1, #0
 800a580:	4630      	mov	r0, r6
 800a582:	f004 fb97 	bl	800ecb4 <memset>
            pxSocket->xEventGroup = xEventGroup;
 800a586:	6077      	str	r7, [r6, #4]
            switch( xDomain ) /* LCOV_EXCL_BR_LINE Exclude this because domain is checked at the begin of this function. */
 800a588:	2c02      	cmp	r4, #2
 800a58a:	d01e      	beq.n	800a5ca <FreeRTOS_socket+0xae>
 800a58c:	2c0a      	cmp	r4, #10
 800a58e:	d103      	bne.n	800a598 <FreeRTOS_socket+0x7c>
                        pxSocket->bits.bIsIPv6 = pdTRUE_UNSIGNED;
 800a590:	7a33      	ldrb	r3, [r6, #8]
 800a592:	f043 0301 	orr.w	r3, r3, #1
 800a596:	7233      	strb	r3, [r6, #8]
            if( xProtocolCpy == FREERTOS_IPPROTO_UDP )
 800a598:	2d11      	cmp	r5, #17
 800a59a:	d01b      	beq.n	800a5d4 <FreeRTOS_socket+0xb8>
                else if( xProtocolCpy == FREERTOS_IPPROTO_TCP ) /* LCOV_EXCL_BR_LINE Exclude else case because protocol is checked in prvDetermineSocketSize */
 800a59c:	2d06      	cmp	r5, #6
 800a59e:	d01e      	beq.n	800a5de <FreeRTOS_socket+0xc2>
            vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 800a5a0:	f106 000c 	add.w	r0, r6, #12
 800a5a4:	f7f9 fc0b 	bl	8003dbe <vListInitialiseItem>
            listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
 800a5a8:	61b6      	str	r6, [r6, #24]
            pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 800a5aa:	f241 3388 	movw	r3, #5000	@ 0x1388
 800a5ae:	6233      	str	r3, [r6, #32]
            pxSocket->xSendBlockTime = ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 800a5b0:	6273      	str	r3, [r6, #36]	@ 0x24
            pxSocket->ucSocketOptions = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 800a5b2:	2302      	movs	r3, #2
 800a5b4:	f886 303a 	strb.w	r3, [r6, #58]	@ 0x3a
            pxSocket->ucProtocol = ( uint8_t ) xProtocolCpy; /* protocol: UDP or TCP */
 800a5b8:	f886 503b 	strb.w	r5, [r6, #59]	@ 0x3b
            xReturn = pxSocket;
 800a5bc:	e7cf      	b.n	800a55e <FreeRTOS_socket+0x42>
            vPortFreeSocket( pxSocket );
 800a5be:	4630      	mov	r0, r6
 800a5c0:	f7fb fbf2 	bl	8005da8 <vPortFree>
            xReturn = FREERTOS_INVALID_SOCKET;
 800a5c4:	f04f 36ff 	mov.w	r6, #4294967295
 800a5c8:	e7c9      	b.n	800a55e <FreeRTOS_socket+0x42>
                        pxSocket->bits.bIsIPv6 = pdFALSE_UNSIGNED;
 800a5ca:	7a33      	ldrb	r3, [r6, #8]
 800a5cc:	f023 0301 	bic.w	r3, r3, #1
 800a5d0:	7233      	strb	r3, [r6, #8]
                        break;
 800a5d2:	e7e1      	b.n	800a598 <FreeRTOS_socket+0x7c>
                vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 800a5d4:	f106 0054 	add.w	r0, r6, #84	@ 0x54
 800a5d8:	f7f9 fbe6 	bl	8003da8 <vListInitialise>
 800a5dc:	e7e0      	b.n	800a5a0 <FreeRTOS_socket+0x84>
                    prvInitialiseTCPFields( pxSocket, uxSocketSize );
 800a5de:	9901      	ldr	r1, [sp, #4]
 800a5e0:	4630      	mov	r0, r6
 800a5e2:	f7ff fc87 	bl	8009ef4 <prvInitialiseTCPFields>
 800a5e6:	e7db      	b.n	800a5a0 <FreeRTOS_socket+0x84>
            xReturn = FREERTOS_INVALID_SOCKET;
 800a5e8:	f04f 36ff 	mov.w	r6, #4294967295
    return xReturn;
 800a5ec:	e7b7      	b.n	800a55e <FreeRTOS_socket+0x42>

0800a5ee <vSocketClose>:
{
 800a5ee:	b538      	push	{r3, r4, r5, lr}
 800a5f0:	4604      	mov	r4, r0
        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800a5f2:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800a5f6:	2b06      	cmp	r3, #6
 800a5f8:	d012      	beq.n	800a620 <vSocketClose+0x32>
    if( socketSOCKET_IS_BOUND( pxSocket ) )
 800a5fa:	69e3      	ldr	r3, [r4, #28]
 800a5fc:	b11b      	cbz	r3, 800a606 <vSocketClose+0x18>
        ( void ) uxListRemove( &( pxSocket->xBoundSocketListItem ) );
 800a5fe:	f104 000c 	add.w	r0, r4, #12
 800a602:	f7f9 fc03 	bl	8003e0c <uxListRemove>
    if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 800a606:	f894 303b 	ldrb.w	r3, [r4, #59]	@ 0x3b
 800a60a:	2b11      	cmp	r3, #17
 800a60c:	d027      	beq.n	800a65e <vSocketClose+0x70>
    if( pxSocket->xEventGroup != NULL )
 800a60e:	6860      	ldr	r0, [r4, #4]
 800a610:	b108      	cbz	r0, 800a616 <vSocketClose+0x28>
        vEventGroupDelete( pxSocket->xEventGroup );
 800a612:	f7f9 fba7 	bl	8003d64 <vEventGroupDelete>
    vPortFreeSocket( pxSocket );
 800a616:	4620      	mov	r0, r4
 800a618:	f7fb fbc6 	bl	8005da8 <vPortFree>
} /* Tested */
 800a61c:	2000      	movs	r0, #0
 800a61e:	bd38      	pop	{r3, r4, r5, pc}
                if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800a620:	f8d0 00a4 	ldr.w	r0, [r0, #164]	@ 0xa4
 800a624:	b108      	cbz	r0, 800a62a <vSocketClose+0x3c>
                    vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800a626:	f004 f83b 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
                vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
 800a62a:	f504 708a 	add.w	r0, r4, #276	@ 0x114
 800a62e:	f003 fbc5 	bl	800ddbc <vTCPWindowDestroy>
            if( pxSocket->u.xTCP.rxStream != NULL )
 800a632:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 800a636:	b108      	cbz	r0, 800a63c <vSocketClose+0x4e>
                vPortFreeLarge( pxSocket->u.xTCP.rxStream );
 800a638:	f7fb fbb6 	bl	8005da8 <vPortFree>
            if( pxSocket->u.xTCP.txStream != NULL )
 800a63c:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
 800a640:	b108      	cbz	r0, 800a646 <vSocketClose+0x58>
                vPortFreeLarge( pxSocket->u.xTCP.txStream );
 800a642:	f7fb fbb1 	bl	8005da8 <vPortFree>
            prvTCPSetSocketCount( pxSocket );
 800a646:	4620      	mov	r0, r4
 800a648:	f000 f80e 	bl	800a668 <prvTCPSetSocketCount>
 800a64c:	e7d5      	b.n	800a5fa <vSocketClose+0xc>
            pxNetworkBuffer = ( ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) );
 800a64e:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 800a650:	68dd      	ldr	r5, [r3, #12]
            ( void ) uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 800a652:	4628      	mov	r0, r5
 800a654:	f7f9 fbda 	bl	8003e0c <uxListRemove>
            vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800a658:	4628      	mov	r0, r5
 800a65a:	f004 f821 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
        while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 800a65e:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 800a660:	2b00      	cmp	r3, #0
 800a662:	d1f4      	bne.n	800a64e <vSocketClose+0x60>
 800a664:	e7d3      	b.n	800a60e <vSocketClose+0x20>
	...

0800a668 <prvTCPSetSocketCount>:
    {
 800a668:	b538      	push	{r3, r4, r5, lr}
        uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
 800a66a:	8f05      	ldrh	r5, [r0, #56]	@ 0x38
        if( pxSocketToDelete->u.xTCP.eTCPState == eTCP_LISTEN )
 800a66c:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79
 800a670:	2b01      	cmp	r3, #1
 800a672:	d002      	beq.n	800a67a <prvTCPSetSocketCount+0x12>
            for( pxIterator = listGET_NEXT( pxEnd );
 800a674:	4b16      	ldr	r3, [pc, #88]	@ (800a6d0 <prvTCPSetSocketCount+0x68>)
 800a676:	68db      	ldr	r3, [r3, #12]
 800a678:	e016      	b.n	800a6a8 <prvTCPSetSocketCount+0x40>
            pxIterator = listGET_NEXT( pxEnd );
 800a67a:	4b15      	ldr	r3, [pc, #84]	@ (800a6d0 <prvTCPSetSocketCount+0x68>)
 800a67c:	68dc      	ldr	r4, [r3, #12]
            while( pxIterator != pxEnd )
 800a67e:	4b15      	ldr	r3, [pc, #84]	@ (800a6d4 <prvTCPSetSocketCount+0x6c>)
 800a680:	429c      	cmp	r4, r3
 800a682:	d023      	beq.n	800a6cc <prvTCPSetSocketCount+0x64>
                pxOtherSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800a684:	68e0      	ldr	r0, [r4, #12]
                pxIterator = listGET_NEXT( pxIterator );
 800a686:	6864      	ldr	r4, [r4, #4]
                if( ( pxOtherSocket->u.xTCP.eTCPState != eTCP_LISTEN ) &&
 800a688:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79
 800a68c:	2b01      	cmp	r3, #1
 800a68e:	d0f6      	beq.n	800a67e <prvTCPSetSocketCount+0x16>
                    ( pxOtherSocket->usLocalPort == usLocalPort ) &&
 800a690:	8f03      	ldrh	r3, [r0, #56]	@ 0x38
                if( ( pxOtherSocket->u.xTCP.eTCPState != eTCP_LISTEN ) &&
 800a692:	42ab      	cmp	r3, r5
 800a694:	d1f3      	bne.n	800a67e <prvTCPSetSocketCount+0x16>
                    ( ( pxOtherSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 800a696:	f890 3068 	ldrb.w	r3, [r0, #104]	@ 0x68
                    ( pxOtherSocket->usLocalPort == usLocalPort ) &&
 800a69a:	f013 0f06 	tst.w	r3, #6
 800a69e:	d0ee      	beq.n	800a67e <prvTCPSetSocketCount+0x16>
                    ( void ) vSocketClose( pxOtherSocket );
 800a6a0:	f7ff ffa5 	bl	800a5ee <vSocketClose>
 800a6a4:	e7eb      	b.n	800a67e <prvTCPSetSocketCount+0x16>
                 pxIterator = listGET_NEXT( pxIterator ) )
 800a6a6:	685b      	ldr	r3, [r3, #4]
                 pxIterator != pxEnd;
 800a6a8:	4a0a      	ldr	r2, [pc, #40]	@ (800a6d4 <prvTCPSetSocketCount+0x6c>)
 800a6aa:	4293      	cmp	r3, r2
 800a6ac:	d00e      	beq.n	800a6cc <prvTCPSetSocketCount+0x64>
                pxOtherSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800a6ae:	68da      	ldr	r2, [r3, #12]
                if( ( pxOtherSocket->u.xTCP.eTCPState == eTCP_LISTEN ) &&
 800a6b0:	f892 1079 	ldrb.w	r1, [r2, #121]	@ 0x79
 800a6b4:	2901      	cmp	r1, #1
 800a6b6:	d1f6      	bne.n	800a6a6 <prvTCPSetSocketCount+0x3e>
                    ( pxOtherSocket->usLocalPort == usLocalPort ) &&
 800a6b8:	8f11      	ldrh	r1, [r2, #56]	@ 0x38
                if( ( pxOtherSocket->u.xTCP.eTCPState == eTCP_LISTEN ) &&
 800a6ba:	42a9      	cmp	r1, r5
 800a6bc:	d1f3      	bne.n	800a6a6 <prvTCPSetSocketCount+0x3e>
                    ( pxOtherSocket->u.xTCP.usChildCount != 0U ) )
 800a6be:	f8b2 1074 	ldrh.w	r1, [r2, #116]	@ 0x74
                    ( pxOtherSocket->usLocalPort == usLocalPort ) &&
 800a6c2:	2900      	cmp	r1, #0
 800a6c4:	d0ef      	beq.n	800a6a6 <prvTCPSetSocketCount+0x3e>
                    pxOtherSocket->u.xTCP.usChildCount--;
 800a6c6:	3901      	subs	r1, #1
 800a6c8:	f8a2 1074 	strh.w	r1, [r2, #116]	@ 0x74
    }
 800a6cc:	bd38      	pop	{r3, r4, r5, pc}
 800a6ce:	bf00      	nop
 800a6d0:	20013780 	.word	0x20013780
 800a6d4:	20013788 	.word	0x20013788

0800a6d8 <pxUDPSocketLookup>:
{
 800a6d8:	b508      	push	{r3, lr}
 800a6da:	4601      	mov	r1, r0
    pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
 800a6dc:	4808      	ldr	r0, [pc, #32]	@ (800a700 <pxUDPSocketLookup+0x28>)
 800a6de:	f7ff fb99 	bl	8009e14 <pxListFindListItemWithValue>
    if( pxListItem != NULL )
 800a6e2:	4603      	mov	r3, r0
 800a6e4:	b108      	cbz	r0, 800a6ea <pxUDPSocketLookup+0x12>
        pxSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxListItem ) );
 800a6e6:	68c3      	ldr	r3, [r0, #12]
        configASSERT( pxSocket != NULL );
 800a6e8:	b10b      	cbz	r3, 800a6ee <pxUDPSocketLookup+0x16>
}
 800a6ea:	4618      	mov	r0, r3
 800a6ec:	bd08      	pop	{r3, pc}
 800a6ee:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800a6f2:	f383 8811 	msr	BASEPRI, r3
 800a6f6:	f3bf 8f6f 	isb	sy
 800a6fa:	f3bf 8f4f 	dsb	sy
        configASSERT( pxSocket != NULL );
 800a6fe:	e7fe      	b.n	800a6fe <pxUDPSocketLookup+0x26>
 800a700:	20013794 	.word	0x20013794

0800a704 <FreeRTOS_inet_ntoa>:
{
 800a704:	b530      	push	{r4, r5, lr}
 800a706:	b085      	sub	sp, #20
 800a708:	9001      	str	r0, [sp, #4]
 800a70a:	4608      	mov	r0, r1
    socklen_t uxIndex = 0;
 800a70c:	2200      	movs	r2, #0
    for( uxNibble = 0; uxNibble < ipSIZE_OF_IPv4_ADDRESS; uxNibble++ )
 800a70e:	4615      	mov	r5, r2
 800a710:	e020      	b.n	800a754 <FreeRTOS_inet_ntoa+0x50>
        pucDigits[ 0 ] = ucValue;
 800a712:	f88d c00c 	strb.w	ip, [sp, #12]
        for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 800a716:	2300      	movs	r3, #0
 800a718:	2b01      	cmp	r3, #1
 800a71a:	d813      	bhi.n	800a744 <FreeRTOS_inet_ntoa+0x40>
            if( pucDigits[ uxSource ] != 0U )
 800a71c:	f103 0110 	add.w	r1, r3, #16
 800a720:	4469      	add	r1, sp
 800a722:	f811 1c04 	ldrb.w	r1, [r1, #-4]
 800a726:	b969      	cbnz	r1, 800a744 <FreeRTOS_inet_ntoa+0x40>
        for( uxSource = 0; uxSource < ( ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U ); uxSource++ )
 800a728:	3301      	adds	r3, #1
 800a72a:	e7f5      	b.n	800a718 <FreeRTOS_inet_ntoa+0x14>
            pcBuffer[ uxIndex ] = ( char ) ( pucDigits[ uxSource ] + ( char ) '0' );
 800a72c:	f103 0110 	add.w	r1, r3, #16
 800a730:	eb0d 0401 	add.w	r4, sp, r1
 800a734:	f814 cc04 	ldrb.w	ip, [r4, #-4]
 800a738:	f10c 0c30 	add.w	ip, ip, #48	@ 0x30
 800a73c:	f800 c002 	strb.w	ip, [r0, r2]
            uxIndex++;
 800a740:	3201      	adds	r2, #1
        for( ; uxSource < ( socklen_t ) sockDIGIT_COUNT; uxSource++ )
 800a742:	3301      	adds	r3, #1
 800a744:	2b02      	cmp	r3, #2
 800a746:	d9f1      	bls.n	800a72c <FreeRTOS_inet_ntoa+0x28>
        if( uxNibble < ( ipSIZE_OF_IPv4_ADDRESS - 1U ) )
 800a748:	2d02      	cmp	r5, #2
 800a74a:	d81d      	bhi.n	800a788 <FreeRTOS_inet_ntoa+0x84>
            pcBuffer[ uxIndex ] = '.';
 800a74c:	232e      	movs	r3, #46	@ 0x2e
 800a74e:	5483      	strb	r3, [r0, r2]
        uxIndex++;
 800a750:	3201      	adds	r2, #1
    for( uxNibble = 0; uxNibble < ipSIZE_OF_IPv4_ADDRESS; uxNibble++ )
 800a752:	3501      	adds	r5, #1
 800a754:	2d03      	cmp	r5, #3
 800a756:	d81a      	bhi.n	800a78e <FreeRTOS_inet_ntoa+0x8a>
        uint8_t ucValue = pucAddress[ uxNibble ];
 800a758:	ab01      	add	r3, sp, #4
 800a75a:	f813 c005 	ldrb.w	ip, [r3, r5]
        socklen_t uxSource = ( socklen_t ) sockDIGIT_COUNT - ( socklen_t ) 1U;
 800a75e:	2402      	movs	r4, #2
            pucDigits[ uxSource ] = ucValue % ( uint8_t ) 10U;
 800a760:	4b0c      	ldr	r3, [pc, #48]	@ (800a794 <FreeRTOS_inet_ntoa+0x90>)
 800a762:	fba3 130c 	umull	r1, r3, r3, ip
 800a766:	08db      	lsrs	r3, r3, #3
 800a768:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800a76c:	ebac 0c41 	sub.w	ip, ip, r1, lsl #1
 800a770:	f104 0110 	add.w	r1, r4, #16
 800a774:	eb0d 0e01 	add.w	lr, sp, r1
 800a778:	f80e cc04 	strb.w	ip, [lr, #-4]
            ucValue /= ( uint8_t ) 10U;
 800a77c:	fa5f fc83 	uxtb.w	ip, r3
            if( uxSource == 1U )
 800a780:	2c01      	cmp	r4, #1
 800a782:	d0c6      	beq.n	800a712 <FreeRTOS_inet_ntoa+0xe>
            uxSource--;
 800a784:	3c01      	subs	r4, #1
            pucDigits[ uxSource ] = ucValue % ( uint8_t ) 10U;
 800a786:	e7eb      	b.n	800a760 <FreeRTOS_inet_ntoa+0x5c>
            pcBuffer[ uxIndex ] = '\0';
 800a788:	2300      	movs	r3, #0
 800a78a:	5483      	strb	r3, [r0, r2]
 800a78c:	e7e0      	b.n	800a750 <FreeRTOS_inet_ntoa+0x4c>
}
 800a78e:	b005      	add	sp, #20
 800a790:	bd30      	pop	{r4, r5, pc}
 800a792:	bf00      	nop
 800a794:	cccccccd 	.word	0xcccccccd

0800a798 <FreeRTOS_inet_ntop>:
{
 800a798:	b508      	push	{r3, lr}
 800a79a:	4684      	mov	ip, r0
 800a79c:	4608      	mov	r0, r1
 800a79e:	4611      	mov	r1, r2
 800a7a0:	461a      	mov	r2, r3
    switch( xAddressFamily )
 800a7a2:	f1bc 0f02 	cmp.w	ip, #2
 800a7a6:	d004      	beq.n	800a7b2 <FreeRTOS_inet_ntop+0x1a>
 800a7a8:	f1bc 0f0a 	cmp.w	ip, #10
 800a7ac:	d004      	beq.n	800a7b8 <FreeRTOS_inet_ntop+0x20>
 800a7ae:	2000      	movs	r0, #0
 800a7b0:	e001      	b.n	800a7b6 <FreeRTOS_inet_ntop+0x1e>
                pcResult = FreeRTOS_inet_ntop4( pvSource, pcDestination, uxSize );
 800a7b2:	f7fd fe5f 	bl	8008474 <FreeRTOS_inet_ntop4>
}
 800a7b6:	bd08      	pop	{r3, pc}
                pcResult = FreeRTOS_inet_ntop6( pvSource, pcDestination, uxSize );
 800a7b8:	f7fe f963 	bl	8008a82 <FreeRTOS_inet_ntop6>
    return pcResult;
 800a7bc:	e7fb      	b.n	800a7b6 <FreeRTOS_inet_ntop+0x1e>

0800a7be <FreeRTOS_GetLocalAddress>:
    switch( pxSocket->bits.bIsIPv6 ) /* LCOV_EXCL_BR_LINE Exclude this line because default case is not counted. */
 800a7be:	7a03      	ldrb	r3, [r0, #8]
 800a7c0:	f013 0301 	ands.w	r3, r3, #1
 800a7c4:	d017      	beq.n	800a7f6 <FreeRTOS_GetLocalAddress+0x38>
 800a7c6:	b373      	cbz	r3, 800a826 <FreeRTOS_GetLocalAddress+0x68>
{
 800a7c8:	b500      	push	{lr}
                pxAddress->sin_family = FREERTOS_AF_INET6;
 800a7ca:	230a      	movs	r3, #10
 800a7cc:	704b      	strb	r3, [r1, #1]
                ( void ) memcpy( pxAddress->sin_address.xIP_IPv6.ucBytes, pxSocket->xLocalAddress.xIP_IPv6.ucBytes, sizeof( pxAddress->sin_address.xIP_IPv6.ucBytes ) );
 800a7ce:	f8d0 e028 	ldr.w	lr, [r0, #40]	@ 0x28
 800a7d2:	f8d0 c02c 	ldr.w	ip, [r0, #44]	@ 0x2c
 800a7d6:	6b02      	ldr	r2, [r0, #48]	@ 0x30
 800a7d8:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 800a7da:	f8c1 e008 	str.w	lr, [r1, #8]
 800a7de:	f8c1 c00c 	str.w	ip, [r1, #12]
 800a7e2:	610a      	str	r2, [r1, #16]
 800a7e4:	614b      	str	r3, [r1, #20]
                pxAddress->sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 800a7e6:	8f02      	ldrh	r2, [r0, #56]	@ 0x38
 800a7e8:	0213      	lsls	r3, r2, #8
 800a7ea:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800a7ee:	804b      	strh	r3, [r1, #2]
}
 800a7f0:	2018      	movs	r0, #24
 800a7f2:	f85d fb04 	ldr.w	pc, [sp], #4
                pxAddress->sin_family = FREERTOS_AF_INET;
 800a7f6:	2302      	movs	r3, #2
 800a7f8:	704b      	strb	r3, [r1, #1]
                pxAddress->sin_len = ( uint8_t ) sizeof( *pxAddress );
 800a7fa:	2318      	movs	r3, #24
 800a7fc:	700b      	strb	r3, [r1, #0]
                pxAddress->sin_address.ulIP_IPv4 = FreeRTOS_htonl( pxSocket->xLocalAddress.ulIP_IPv4 );
 800a7fe:	6a82      	ldr	r2, [r0, #40]	@ 0x28
 800a800:	0213      	lsls	r3, r2, #8
 800a802:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800a806:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a80a:	ea4f 2c12 	mov.w	ip, r2, lsr #8
 800a80e:	f40c 4c7f 	and.w	ip, ip, #65280	@ 0xff00
 800a812:	ea43 030c 	orr.w	r3, r3, ip
 800a816:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800a81a:	608b      	str	r3, [r1, #8]
                pxAddress->sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 800a81c:	8f02      	ldrh	r2, [r0, #56]	@ 0x38
 800a81e:	0213      	lsls	r3, r2, #8
 800a820:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800a824:	804b      	strh	r3, [r1, #2]
}
 800a826:	2018      	movs	r0, #24
 800a828:	4770      	bx	lr

0800a82a <vSocketWakeUpUser>:
{
 800a82a:	b510      	push	{r4, lr}
 800a82c:	4604      	mov	r4, r0
        if( pxSocket->pxUserWakeCallback != NULL )
 800a82e:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
 800a830:	b103      	cbz	r3, 800a834 <vSocketWakeUpUser+0xa>
            pxSocket->pxUserWakeCallback( pxSocket );
 800a832:	4798      	blx	r3
        if( pxSocket->pxSocketSet != NULL )
 800a834:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 800a836:	b12b      	cbz	r3, 800a844 <vSocketWakeUpUser+0x1a>
            EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & ( ( EventBits_t ) eSELECT_ALL );
 800a838:	6822      	ldr	r2, [r4, #0]
 800a83a:	f3c2 2103 	ubfx	r1, r2, #8, #4
            if( xSelectBits != 0U )
 800a83e:	f412 6f70 	tst.w	r2, #3840	@ 0xf00
 800a842:	d109      	bne.n	800a858 <vSocketWakeUpUser+0x2e>
        pxSocket->xEventBits &= ( EventBits_t ) eSOCKET_ALL;
 800a844:	6821      	ldr	r1, [r4, #0]
 800a846:	f001 017f 	and.w	r1, r1, #127	@ 0x7f
 800a84a:	6021      	str	r1, [r4, #0]
    if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0U ) )
 800a84c:	6860      	ldr	r0, [r4, #4]
 800a84e:	b100      	cbz	r0, 800a852 <vSocketWakeUpUser+0x28>
 800a850:	b949      	cbnz	r1, 800a866 <vSocketWakeUpUser+0x3c>
    pxSocket->xEventBits = 0U;
 800a852:	2300      	movs	r3, #0
 800a854:	6023      	str	r3, [r4, #0]
}
 800a856:	bd10      	pop	{r4, pc}
                pxSocket->xSocketBits |= xSelectBits;
 800a858:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 800a85a:	430a      	orrs	r2, r1
 800a85c:	64a2      	str	r2, [r4, #72]	@ 0x48
                ( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
 800a85e:	6818      	ldr	r0, [r3, #0]
 800a860:	f7f9 fa39 	bl	8003cd6 <xEventGroupSetBits>
 800a864:	e7ee      	b.n	800a844 <vSocketWakeUpUser+0x1a>
        ( void ) xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
 800a866:	f7f9 fa36 	bl	8003cd6 <xEventGroupSetBits>
 800a86a:	e7f2      	b.n	800a852 <vSocketWakeUpUser+0x28>

0800a86c <xTCPTimerCheck>:
    {
 800a86c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a870:	4680      	mov	r8, r0
        TickType_t xNow = xTaskGetTickCount();
 800a872:	f7fa f9d7 	bl	8004c24 <xTaskGetTickCount>
        TickType_t xDelta = xNow - xLastTime;
 800a876:	4a1b      	ldr	r2, [pc, #108]	@ (800a8e4 <xTCPTimerCheck+0x78>)
 800a878:	6816      	ldr	r6, [r2, #0]
        const ListItem_t * pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800a87a:	491b      	ldr	r1, [pc, #108]	@ (800a8e8 <xTCPTimerCheck+0x7c>)
 800a87c:	68cc      	ldr	r4, [r1, #12]
        xLastTime = xNow;
 800a87e:	6010      	str	r0, [r2, #0]
        if( xDelta == 0U )
 800a880:	1b86      	subs	r6, r0, r6
 800a882:	d02a      	beq.n	800a8da <xTCPTimerCheck+0x6e>
                xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 800a884:	f44f 777a 	mov.w	r7, #1000	@ 0x3e8
        while( pxIterator != pxEnd )
 800a888:	4b18      	ldr	r3, [pc, #96]	@ (800a8ec <xTCPTimerCheck+0x80>)
 800a88a:	429c      	cmp	r4, r3
 800a88c:	d027      	beq.n	800a8de <xTCPTimerCheck+0x72>
            pxSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800a88e:	68e5      	ldr	r5, [r4, #12]
            pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 800a890:	6864      	ldr	r4, [r4, #4]
            if( pxSocket->u.xTCP.usTimeout == 0U )
 800a892:	f8b5 3070 	ldrh.w	r3, [r5, #112]	@ 0x70
 800a896:	2b00      	cmp	r3, #0
 800a898:	d0f6      	beq.n	800a888 <xTCPTimerCheck+0x1c>
            if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
 800a89a:	42b3      	cmp	r3, r6
 800a89c:	d910      	bls.n	800a8c0 <xTCPTimerCheck+0x54>
                pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDelta );
 800a89e:	1b9b      	subs	r3, r3, r6
 800a8a0:	f8a5 3070 	strh.w	r3, [r5, #112]	@ 0x70
            if( pxSocket->xEventBits != 0U )
 800a8a4:	682b      	ldr	r3, [r5, #0]
 800a8a6:	b11b      	cbz	r3, 800a8b0 <xTCPTimerCheck+0x44>
                if( xWillSleep != pdFALSE )
 800a8a8:	f1b8 0f00 	cmp.w	r8, #0
 800a8ac:	d111      	bne.n	800a8d2 <xTCPTimerCheck+0x66>
                    xShortest = ( TickType_t ) 0;
 800a8ae:	2700      	movs	r7, #0
            if( ( pxSocket->u.xTCP.usTimeout != 0U ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTimeout ) )
 800a8b0:	f8b5 3070 	ldrh.w	r3, [r5, #112]	@ 0x70
 800a8b4:	2b00      	cmp	r3, #0
 800a8b6:	d0e7      	beq.n	800a888 <xTCPTimerCheck+0x1c>
 800a8b8:	42bb      	cmp	r3, r7
 800a8ba:	d2e5      	bcs.n	800a888 <xTCPTimerCheck+0x1c>
                xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 800a8bc:	461f      	mov	r7, r3
 800a8be:	e7e3      	b.n	800a888 <xTCPTimerCheck+0x1c>
                pxSocket->u.xTCP.usTimeout = 0U;
 800a8c0:	2300      	movs	r3, #0
 800a8c2:	f8a5 3070 	strh.w	r3, [r5, #112]	@ 0x70
                xRc = xTCPSocketCheck( pxSocket );
 800a8c6:	4628      	mov	r0, r5
 800a8c8:	f001 f84e 	bl	800b968 <xTCPSocketCheck>
                if( xRc < 0 )
 800a8cc:	2800      	cmp	r0, #0
 800a8ce:	dae9      	bge.n	800a8a4 <xTCPTimerCheck+0x38>
 800a8d0:	e7da      	b.n	800a888 <xTCPTimerCheck+0x1c>
                    vSocketWakeUpUser( pxSocket );
 800a8d2:	4628      	mov	r0, r5
 800a8d4:	f7ff ffa9 	bl	800a82a <vSocketWakeUpUser>
 800a8d8:	e7ea      	b.n	800a8b0 <xTCPTimerCheck+0x44>
            xDelta = 1U;
 800a8da:	2601      	movs	r6, #1
 800a8dc:	e7d2      	b.n	800a884 <xTCPTimerCheck+0x18>
    }
 800a8de:	4638      	mov	r0, r7
 800a8e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a8e4:	2001377c 	.word	0x2001377c
 800a8e8:	20013780 	.word	0x20013780
 800a8ec:	20013788 	.word	0x20013788

0800a8f0 <pxTCPSocketLookup>:
    {
 800a8f0:	b082      	sub	sp, #8
 800a8f2:	b570      	push	{r4, r5, r6, lr}
 800a8f4:	460d      	mov	r5, r1
 800a8f6:	a904      	add	r1, sp, #16
 800a8f8:	e881 000c 	stmia.w	r1, {r2, r3}
        for( pxIterator = listGET_NEXT( pxEnd );
 800a8fc:	4b18      	ldr	r3, [pc, #96]	@ (800a960 <pxTCPSocketLookup+0x70>)
 800a8fe:	68dc      	ldr	r4, [r3, #12]
        FreeRTOS_Socket_t * pxResult = NULL, * pxListenSocket = NULL;
 800a900:	2600      	movs	r6, #0
 800a902:	4630      	mov	r0, r6
        for( pxIterator = listGET_NEXT( pxEnd );
 800a904:	e006      	b.n	800a914 <pxTCPSocketLookup+0x24>
                            pxResult = pxTCPSocketLookup_IPv6( pxSocket, &xRemoteIP );
 800a906:	a904      	add	r1, sp, #16
 800a908:	4618      	mov	r0, r3
 800a90a:	f7fd ffc2 	bl	8008892 <pxTCPSocketLookup_IPv6>
 800a90e:	e01b      	b.n	800a948 <pxTCPSocketLookup+0x58>
                    pxListenSocket = pxSocket;
 800a910:	461e      	mov	r6, r3
             pxIterator = listGET_NEXT( pxIterator ) )
 800a912:	6864      	ldr	r4, [r4, #4]
             pxIterator != pxEnd;
 800a914:	4b13      	ldr	r3, [pc, #76]	@ (800a964 <pxTCPSocketLookup+0x74>)
 800a916:	429c      	cmp	r4, r3
 800a918:	d018      	beq.n	800a94c <pxTCPSocketLookup+0x5c>
            FreeRTOS_Socket_t * pxSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800a91a:	68e3      	ldr	r3, [r4, #12]
            if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 800a91c:	f8b3 c038 	ldrh.w	ip, [r3, #56]	@ 0x38
 800a920:	b2aa      	uxth	r2, r5
 800a922:	4594      	cmp	ip, r2
 800a924:	d1f5      	bne.n	800a912 <pxTCPSocketLookup+0x22>
                if( pxSocket->u.xTCP.eTCPState == eTCP_LISTEN )
 800a926:	f893 2079 	ldrb.w	r2, [r3, #121]	@ 0x79
 800a92a:	2a01      	cmp	r2, #1
 800a92c:	d0f0      	beq.n	800a910 <pxTCPSocketLookup+0x20>
                else if( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort )
 800a92e:	f8b3 1064 	ldrh.w	r1, [r3, #100]	@ 0x64
 800a932:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800a934:	b292      	uxth	r2, r2
 800a936:	4291      	cmp	r1, r2
 800a938:	d1eb      	bne.n	800a912 <pxTCPSocketLookup+0x22>
                    if( xRemoteIP.xIs_IPv6 != pdFALSE )
 800a93a:	9a08      	ldr	r2, [sp, #32]
 800a93c:	2a00      	cmp	r2, #0
 800a93e:	d1e2      	bne.n	800a906 <pxTCPSocketLookup+0x16>
                        if( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 == xRemoteIP.xIPAddress.ulIP_IPv4 )
 800a940:	6d59      	ldr	r1, [r3, #84]	@ 0x54
 800a942:	9a04      	ldr	r2, [sp, #16]
 800a944:	4291      	cmp	r1, r2
 800a946:	d006      	beq.n	800a956 <pxTCPSocketLookup+0x66>
                    if( pxResult != NULL )
 800a948:	2800      	cmp	r0, #0
 800a94a:	d0e2      	beq.n	800a912 <pxTCPSocketLookup+0x22>
        if( pxResult == NULL )
 800a94c:	b128      	cbz	r0, 800a95a <pxTCPSocketLookup+0x6a>
    }
 800a94e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800a952:	b002      	add	sp, #8
 800a954:	4770      	bx	lr
                            pxResult = pxSocket;
 800a956:	4618      	mov	r0, r3
 800a958:	e7f8      	b.n	800a94c <pxTCPSocketLookup+0x5c>
            pxResult = pxListenSocket;
 800a95a:	4630      	mov	r0, r6
        return pxResult;
 800a95c:	e7f7      	b.n	800a94e <pxTCPSocketLookup+0x5e>
 800a95e:	bf00      	nop
 800a960:	20013780 	.word	0x20013780
 800a964:	20013788 	.word	0x20013788

0800a968 <lTCPAddRxdata>:
    {
 800a968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a96a:	4605      	mov	r5, r0
 800a96c:	460c      	mov	r4, r1
 800a96e:	4616      	mov	r6, r2
 800a970:	461f      	mov	r7, r3
        StreamBuffer_t * pxStream = pxSocket->u.xTCP.rxStream;
 800a972:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
        if( pxStream == NULL )
 800a976:	b140      	cbz	r0, 800a98a <lTCPAddRxdata+0x22>
            xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
 800a978:	463b      	mov	r3, r7
 800a97a:	4632      	mov	r2, r6
 800a97c:	4621      	mov	r1, r4
 800a97e:	f000 fd92 	bl	800b4a6 <uxStreamBufferAdd>
 800a982:	4606      	mov	r6, r0
            if( uxOffset == 0U )
 800a984:	b154      	cbz	r4, 800a99c <lTCPAddRxdata+0x34>
    }
 800a986:	4630      	mov	r0, r6
 800a988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            pxStream = prvTCPCreateStream( pxSocket, pdTRUE );
 800a98a:	2101      	movs	r1, #1
 800a98c:	4628      	mov	r0, r5
 800a98e:	f7ff fc65 	bl	800a25c <prvTCPCreateStream>
            if( pxStream == NULL )
 800a992:	2800      	cmp	r0, #0
 800a994:	d1f0      	bne.n	800a978 <lTCPAddRxdata+0x10>
                xResult = -1;
 800a996:	f04f 36ff 	mov.w	r6, #4294967295
        return xResult;
 800a99a:	e7f4      	b.n	800a986 <lTCPAddRxdata+0x1e>
                    vTCPAddRxdata_Stored( pxSocket );
 800a99c:	4628      	mov	r0, r5
 800a99e:	f7ff fd00 	bl	800a3a2 <vTCPAddRxdata_Stored>
 800a9a2:	e7f0      	b.n	800a986 <lTCPAddRxdata+0x1e>

0800a9a4 <FreeRTOS_tx_space>:
        if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800a9a4:	f890 203b 	ldrb.w	r2, [r0, #59]	@ 0x3b
 800a9a8:	2a06      	cmp	r2, #6
 800a9aa:	d10a      	bne.n	800a9c2 <FreeRTOS_tx_space+0x1e>
    {
 800a9ac:	b508      	push	{r3, lr}
 800a9ae:	4603      	mov	r3, r0
            if( pxSocket->u.xTCP.txStream != NULL )
 800a9b0:	f8d0 00a0 	ldr.w	r0, [r0, #160]	@ 0xa0
 800a9b4:	b110      	cbz	r0, 800a9bc <FreeRTOS_tx_space+0x18>
                xReturn = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 800a9b6:	f000 fd30 	bl	800b41a <uxStreamBufferGetSpace>
    }
 800a9ba:	bd08      	pop	{r3, pc}
                xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 800a9bc:	f8d3 0098 	ldr.w	r0, [r3, #152]	@ 0x98
 800a9c0:	e7fb      	b.n	800a9ba <FreeRTOS_tx_space+0x16>
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800a9c2:	f06f 0015 	mvn.w	r0, #21
    }
 800a9c6:	4770      	bx	lr

0800a9c8 <FreeRTOS_tx_size>:
    {
 800a9c8:	b508      	push	{r3, lr}
        if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800a9ca:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800a9ce:	2b06      	cmp	r3, #6
 800a9d0:	d105      	bne.n	800a9de <FreeRTOS_tx_size+0x16>
            if( pxSocket->u.xTCP.txStream != NULL )
 800a9d2:	f8d0 00a0 	ldr.w	r0, [r0, #160]	@ 0xa0
 800a9d6:	b128      	cbz	r0, 800a9e4 <FreeRTOS_tx_size+0x1c>
                xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.txStream );
 800a9d8:	f000 fd2b 	bl	800b432 <uxStreamBufferGetSize>
    }
 800a9dc:	bd08      	pop	{r3, pc}
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800a9de:	f06f 0015 	mvn.w	r0, #21
 800a9e2:	e7fb      	b.n	800a9dc <FreeRTOS_tx_size+0x14>
                xReturn = 0;
 800a9e4:	2000      	movs	r0, #0
        return xReturn;
 800a9e6:	e7f9      	b.n	800a9dc <FreeRTOS_tx_size+0x14>

0800a9e8 <prvSetOptionSetFullSize>:
        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800a9e8:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800a9ec:	2b06      	cmp	r3, #6
 800a9ee:	d123      	bne.n	800aa38 <prvSetOptionSetFullSize+0x50>
    {
 800a9f0:	b510      	push	{r4, lr}
 800a9f2:	4604      	mov	r4, r0
            if( *( ( const BaseType_t * ) pvOptionValue ) != 0 )
 800a9f4:	680b      	ldr	r3, [r1, #0]
 800a9f6:	b15b      	cbz	r3, 800aa10 <prvSetOptionSetFullSize+0x28>
                pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdTRUE_UNSIGNED;
 800a9f8:	f890 3114 	ldrb.w	r3, [r0, #276]	@ 0x114
 800a9fc:	f043 0302 	orr.w	r3, r3, #2
 800aa00:	f880 3114 	strb.w	r3, [r0, #276]	@ 0x114
            if( ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) &&
 800aa04:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800aa08:	2b04      	cmp	r3, #4
 800aa0a:	d808      	bhi.n	800aa1e <prvSetOptionSetFullSize+0x36>
            xReturn = 0;
 800aa0c:	2000      	movs	r0, #0
    }
 800aa0e:	bd10      	pop	{r4, pc}
                pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE_UNSIGNED;
 800aa10:	f890 3114 	ldrb.w	r3, [r0, #276]	@ 0x114
 800aa14:	f023 0302 	bic.w	r3, r3, #2
 800aa18:	f880 3114 	strb.w	r3, [r0, #276]	@ 0x114
 800aa1c:	e7f2      	b.n	800aa04 <prvSetOptionSetFullSize+0x1c>
                ( FreeRTOS_outstanding( pxSocket ) != 0 ) )
 800aa1e:	4620      	mov	r0, r4
 800aa20:	f7ff ffd2 	bl	800a9c8 <FreeRTOS_tx_size>
            if( ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) &&
 800aa24:	2800      	cmp	r0, #0
 800aa26:	d0f2      	beq.n	800aa0e <prvSetOptionSetFullSize+0x26>
                pxSocket->u.xTCP.usTimeout = 1U;
 800aa28:	2301      	movs	r3, #1
 800aa2a:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                ( void ) xSendEventToIPTask( eTCPTimerEvent );
 800aa2e:	2006      	movs	r0, #6
 800aa30:	f7fc fcc2 	bl	80073b8 <xSendEventToIPTask>
            xReturn = 0;
 800aa34:	2000      	movs	r0, #0
 800aa36:	e7ea      	b.n	800aa0e <prvSetOptionSetFullSize+0x26>
        BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800aa38:	f06f 0015 	mvn.w	r0, #21
    }
 800aa3c:	4770      	bx	lr

0800aa3e <FreeRTOS_issocketconnected>:
        if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800aa3e:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800aa42:	2b06      	cmp	r3, #6
 800aa44:	d107      	bne.n	800aa56 <FreeRTOS_issocketconnected+0x18>
            if( pxSocket->u.xTCP.eTCPState >= eESTABLISHED )
 800aa46:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79
 800aa4a:	2b04      	cmp	r3, #4
 800aa4c:	d906      	bls.n	800aa5c <FreeRTOS_issocketconnected+0x1e>
                if( pxSocket->u.xTCP.eTCPState < eCLOSE_WAIT )
 800aa4e:	2b07      	cmp	r3, #7
 800aa50:	d906      	bls.n	800aa60 <FreeRTOS_issocketconnected+0x22>
        BaseType_t xReturn = pdFALSE;
 800aa52:	2000      	movs	r0, #0
 800aa54:	4770      	bx	lr
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800aa56:	f06f 0015 	mvn.w	r0, #21
 800aa5a:	4770      	bx	lr
        BaseType_t xReturn = pdFALSE;
 800aa5c:	2000      	movs	r0, #0
 800aa5e:	4770      	bx	lr
                    xReturn = pdTRUE;
 800aa60:	2001      	movs	r0, #1
    }
 800aa62:	4770      	bx	lr

0800aa64 <FreeRTOS_rx_size>:
    {
 800aa64:	b508      	push	{r3, lr}
        if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800aa66:	f890 303b 	ldrb.w	r3, [r0, #59]	@ 0x3b
 800aa6a:	2b06      	cmp	r3, #6
 800aa6c:	d105      	bne.n	800aa7a <FreeRTOS_rx_size+0x16>
        else if( pxSocket->u.xTCP.rxStream != NULL )
 800aa6e:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
 800aa72:	b128      	cbz	r0, 800aa80 <FreeRTOS_rx_size+0x1c>
            xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
 800aa74:	f000 fcdd 	bl	800b432 <uxStreamBufferGetSize>
    }
 800aa78:	bd08      	pop	{r3, pc}
            xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800aa7a:	f06f 0015 	mvn.w	r0, #21
 800aa7e:	e7fb      	b.n	800aa78 <FreeRTOS_rx_size+0x14>
            xReturn = 0;
 800aa80:	2000      	movs	r0, #0
        return xReturn;
 800aa82:	e7f9      	b.n	800aa78 <FreeRTOS_rx_size+0x14>

0800aa84 <vSocketSelectTCP>:
 *
 * @param[in] pxSocket The socket which needs to be checked.
 * @return An event mask of events that are active for this socket.
 */
        static EventBits_t vSocketSelectTCP( FreeRTOS_Socket_t * pxSocket )
        {
 800aa84:	b570      	push	{r4, r5, r6, lr}
 800aa86:	4604      	mov	r4, r0
             * the owner.  If not, it is useless to return it from a
             * select(). */
            BaseType_t bAccepted = pdFALSE;
            EventBits_t xSocketBits = 0U;

            if( pxSocket->u.xTCP.bits.bPassQueued == pdFALSE_UNSIGNED )
 800aa88:	f890 3068 	ldrb.w	r3, [r0, #104]	@ 0x68
 800aa8c:	f013 0f04 	tst.w	r3, #4
 800aa90:	d104      	bne.n	800aa9c <vSocketSelectTCP+0x18>
            {
                if( pxSocket->u.xTCP.bits.bPassAccept == pdFALSE_UNSIGNED )
 800aa92:	f013 0f02 	tst.w	r3, #2
 800aa96:	d030      	beq.n	800aafa <vSocketSelectTCP+0x76>
            BaseType_t bAccepted = pdFALSE;
 800aa98:	2600      	movs	r6, #0
 800aa9a:	e000      	b.n	800aa9e <vSocketSelectTCP+0x1a>
 800aa9c:	2600      	movs	r6, #0
                    bAccepted = pdTRUE;
                }
            }

            /* Is the set owner interested in READ events? */
            if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != ( EventBits_t ) 0U )
 800aa9e:	6c65      	ldr	r5, [r4, #68]	@ 0x44
 800aaa0:	f015 0501 	ands.w	r5, r5, #1
 800aaa4:	d009      	beq.n	800aaba <vSocketSelectTCP+0x36>
            {
                if( pxSocket->u.xTCP.eTCPState == eTCP_LISTEN )
 800aaa6:	f894 2079 	ldrb.w	r2, [r4, #121]	@ 0x79
 800aaaa:	2a01      	cmp	r2, #1
 800aaac:	d027      	beq.n	800aafe <vSocketSelectTCP+0x7a>
                    if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
                    {
                        xSocketBits |= ( EventBits_t ) eSELECT_READ;
                    }
                }
                else if( ( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800aaae:	f003 030a 	and.w	r3, r3, #10
 800aab2:	2b0a      	cmp	r3, #10
 800aab4:	d039      	beq.n	800ab2a <vSocketSelectTCP+0xa6>
                {
                    /* This socket has the re-use flag. After connecting it turns into
                     * a connected socket. Set the READ event, so that accept() will be called. */
                    xSocketBits |= ( EventBits_t ) eSELECT_READ;
                }
                else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 800aab6:	bb5e      	cbnz	r6, 800ab10 <vSocketSelectTCP+0x8c>
            EventBits_t xSocketBits = 0U;
 800aab8:	2500      	movs	r5, #0
                    /* Nothing. */
                }
            }

            /* Is the set owner interested in EXCEPTION events? */
            if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_EXCEPT ) != 0U )
 800aaba:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 800aabc:	f013 0f04 	tst.w	r3, #4
 800aac0:	d006      	beq.n	800aad0 <vSocketSelectTCP+0x4c>
            {
                if( ( pxSocket->u.xTCP.eTCPState == eCLOSE_WAIT ) || ( pxSocket->u.xTCP.eTCPState == eCLOSED ) )
 800aac2:	f894 2079 	ldrb.w	r2, [r4, #121]	@ 0x79
 800aac6:	2a08      	cmp	r2, #8
 800aac8:	d000      	beq.n	800aacc <vSocketSelectTCP+0x48>
 800aaca:	b90a      	cbnz	r2, 800aad0 <vSocketSelectTCP+0x4c>
                {
                    xSocketBits |= ( EventBits_t ) eSELECT_EXCEPT;
 800aacc:	f045 0504 	orr.w	r5, r5, #4
                }
            }

            /* Is the set owner interested in WRITE events? */
            if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_WRITE ) != 0U )
 800aad0:	f013 0f02 	tst.w	r3, #2
 800aad4:	d032      	beq.n	800ab3c <vSocketSelectTCP+0xb8>
            {
                BaseType_t bMatch = pdFALSE;

                if( bAccepted != 0 )
 800aad6:	bb56      	cbnz	r6, 800ab2e <vSocketSelectTCP+0xaa>
                    }
                }

                if( bMatch == pdFALSE )
                {
                    if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 800aad8:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800aadc:	f013 0f08 	tst.w	r3, #8
 800aae0:	d02c      	beq.n	800ab3c <vSocketSelectTCP+0xb8>
                        ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) &&
 800aae2:	f894 2079 	ldrb.w	r2, [r4, #121]	@ 0x79
                    if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 800aae6:	2a04      	cmp	r2, #4
 800aae8:	d928      	bls.n	800ab3c <vSocketSelectTCP+0xb8>
                        ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) &&
 800aaea:	f013 0f10 	tst.w	r3, #16
 800aaee:	d125      	bne.n	800ab3c <vSocketSelectTCP+0xb8>
                        ( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
                    {
                        pxSocket->u.xTCP.bits.bConnPassed = pdTRUE_UNSIGNED;
 800aaf0:	f043 0310 	orr.w	r3, r3, #16
 800aaf4:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                        bMatch = pdTRUE;
                    }
                }

                if( bMatch != pdFALSE )
 800aaf8:	e01e      	b.n	800ab38 <vSocketSelectTCP+0xb4>
                    bAccepted = pdTRUE;
 800aafa:	2601      	movs	r6, #1
 800aafc:	e7cf      	b.n	800aa9e <vSocketSelectTCP+0x1a>
                    if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800aafe:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800ab00:	b17b      	cbz	r3, 800ab22 <vSocketSelectTCP+0x9e>
 800ab02:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
 800ab06:	f013 0f02 	tst.w	r3, #2
 800ab0a:	d10c      	bne.n	800ab26 <vSocketSelectTCP+0xa2>
            EventBits_t xSocketBits = 0U;
 800ab0c:	2500      	movs	r5, #0
 800ab0e:	e7d4      	b.n	800aaba <vSocketSelectTCP+0x36>
                else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 800ab10:	4620      	mov	r0, r4
 800ab12:	f7ff ffa7 	bl	800aa64 <FreeRTOS_rx_size>
 800ab16:	2800      	cmp	r0, #0
 800ab18:	dd01      	ble.n	800ab1e <vSocketSelectTCP+0x9a>
                    xSocketBits |= ( EventBits_t ) eSELECT_READ;
 800ab1a:	2501      	movs	r5, #1
 800ab1c:	e7cd      	b.n	800aaba <vSocketSelectTCP+0x36>
            EventBits_t xSocketBits = 0U;
 800ab1e:	2500      	movs	r5, #0
 800ab20:	e7cb      	b.n	800aaba <vSocketSelectTCP+0x36>
 800ab22:	2500      	movs	r5, #0
 800ab24:	e7c9      	b.n	800aaba <vSocketSelectTCP+0x36>
                        xSocketBits |= ( EventBits_t ) eSELECT_READ;
 800ab26:	2501      	movs	r5, #1
 800ab28:	e7c7      	b.n	800aaba <vSocketSelectTCP+0x36>
                    xSocketBits |= ( EventBits_t ) eSELECT_READ;
 800ab2a:	2501      	movs	r5, #1
 800ab2c:	e7c5      	b.n	800aaba <vSocketSelectTCP+0x36>
                    if( FreeRTOS_tx_space( pxSocket ) > 0 )
 800ab2e:	4620      	mov	r0, r4
 800ab30:	f7ff ff38 	bl	800a9a4 <FreeRTOS_tx_space>
 800ab34:	2800      	cmp	r0, #0
 800ab36:	ddcf      	ble.n	800aad8 <vSocketSelectTCP+0x54>
                {
                    xSocketBits |= ( EventBits_t ) eSELECT_WRITE;
 800ab38:	f045 0502 	orr.w	r5, r5, #2
                }
            }

            return xSocketBits;
        }
 800ab3c:	4628      	mov	r0, r5
 800ab3e:	bd70      	pop	{r4, r5, r6, pc}

0800ab40 <xSocketValid>:
    if( ( xSocket != FREERTOS_INVALID_SOCKET ) && ( xSocket != NULL ) )
 800ab40:	3801      	subs	r0, #1
 800ab42:	f110 0f03 	cmn.w	r0, #3
 800ab46:	d901      	bls.n	800ab4c <xSocketValid+0xc>
    BaseType_t xReturnValue = pdFALSE;
 800ab48:	2000      	movs	r0, #0
 800ab4a:	4770      	bx	lr
        xReturnValue = pdTRUE;
 800ab4c:	2001      	movs	r0, #1
}
 800ab4e:	4770      	bx	lr

0800ab50 <prvValidSocket>:
{
 800ab50:	b570      	push	{r4, r5, r6, lr}
 800ab52:	4605      	mov	r5, r0
 800ab54:	460c      	mov	r4, r1
 800ab56:	4616      	mov	r6, r2
    if( xSocketValid( pxSocket ) == pdFALSE )
 800ab58:	f7ff fff2 	bl	800ab40 <xSocketValid>
 800ab5c:	b140      	cbz	r0, 800ab70 <prvValidSocket+0x20>
    else if( ( xIsBound != pdFALSE ) && !socketSOCKET_IS_BOUND( pxSocket ) )
 800ab5e:	b10e      	cbz	r6, 800ab64 <prvValidSocket+0x14>
 800ab60:	69eb      	ldr	r3, [r5, #28]
 800ab62:	b133      	cbz	r3, 800ab72 <prvValidSocket+0x22>
    else if( pxSocket->ucProtocol != ( uint8_t ) xProtocol )
 800ab64:	f895 303b 	ldrb.w	r3, [r5, #59]	@ 0x3b
 800ab68:	b2e1      	uxtb	r1, r4
 800ab6a:	428b      	cmp	r3, r1
 800ab6c:	d003      	beq.n	800ab76 <prvValidSocket+0x26>
        xReturn = pdFALSE;
 800ab6e:	2000      	movs	r0, #0
}
 800ab70:	bd70      	pop	{r4, r5, r6, pc}
        xReturn = pdFALSE;
 800ab72:	2000      	movs	r0, #0
 800ab74:	e7fc      	b.n	800ab70 <prvValidSocket+0x20>
        xReturn = pdTRUE;
 800ab76:	2001      	movs	r0, #1
    return xReturn;
 800ab78:	e7fa      	b.n	800ab70 <prvValidSocket+0x20>

0800ab7a <FreeRTOS_recvfrom>:
{
 800ab7a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ab7e:	b084      	sub	sp, #16
 800ab80:	4606      	mov	r6, r0
 800ab82:	460f      	mov	r7, r1
 800ab84:	4690      	mov	r8, r2
 800ab86:	461c      	mov	r4, r3
 800ab88:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
    EventBits_t xEventBits = ( EventBits_t ) 0;
 800ab8a:	2300      	movs	r3, #0
 800ab8c:	9303      	str	r3, [sp, #12]
    if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE )
 800ab8e:	2201      	movs	r2, #1
 800ab90:	2111      	movs	r1, #17
 800ab92:	f7ff ffdd 	bl	800ab50 <prvValidSocket>
 800ab96:	b390      	cbz	r0, 800abfe <FreeRTOS_recvfrom+0x84>
        pxNetworkBuffer = prvRecvFromWaitForPacket( pxSocket, xFlags, &( xEventBits ) );
 800ab98:	aa03      	add	r2, sp, #12
 800ab9a:	4621      	mov	r1, r4
 800ab9c:	4630      	mov	r0, r6
 800ab9e:	f7ff f9db 	bl	8009f58 <prvRecvFromWaitForPacket>
        if( pxNetworkBuffer != NULL )
 800aba2:	4606      	mov	r6, r0
 800aba4:	b370      	cbz	r0, 800ac04 <FreeRTOS_recvfrom+0x8a>
                switch( uxIPHeaderSizePacket( pxNetworkBuffer ) )
 800aba6:	f7fc fc97 	bl	80074d8 <uxIPHeaderSizePacket>
 800abaa:	2814      	cmp	r0, #20
 800abac:	d004      	beq.n	800abb8 <FreeRTOS_recvfrom+0x3e>
 800abae:	2828      	cmp	r0, #40	@ 0x28
 800abb0:	d020      	beq.n	800abf4 <FreeRTOS_recvfrom+0x7a>
 800abb2:	f06f 0515 	mvn.w	r5, #21
 800abb6:	e011      	b.n	800abdc <FreeRTOS_recvfrom+0x62>
                            uxPayloadOffset = xRecv_Update_IPv4( pxNetworkBuffer, pxSourceAddress );
 800abb8:	990a      	ldr	r1, [sp, #40]	@ 0x28
 800abba:	4630      	mov	r0, r6
 800abbc:	f7fd fc70 	bl	80084a0 <xRecv_Update_IPv4>
                if( pxSourceAddressLength != NULL )
 800abc0:	b10d      	cbz	r5, 800abc6 <FreeRTOS_recvfrom+0x4c>
                    *pxSourceAddressLength = xAddressLength;
 800abc2:	2318      	movs	r3, #24
 800abc4:	602b      	str	r3, [r5, #0]
                uxPayloadLength = pxNetworkBuffer->xDataLength - uxPayloadOffset;
 800abc6:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 800abc8:	1a1b      	subs	r3, r3, r0
                lReturn = prvRecvFrom_CopyPacket( &( pxNetworkBuffer->pucEthernetBuffer[ uxPayloadOffset ] ), pvBuffer, uxBufferLength, xFlags, lReturn );
 800abca:	6a75      	ldr	r5, [r6, #36]	@ 0x24
 800abcc:	9300      	str	r3, [sp, #0]
 800abce:	4623      	mov	r3, r4
 800abd0:	4642      	mov	r2, r8
 800abd2:	4639      	mov	r1, r7
 800abd4:	4428      	add	r0, r5
 800abd6:	f7ff f9fe 	bl	8009fd6 <prvRecvFrom_CopyPacket>
 800abda:	4605      	mov	r5, r0
            if( ( ( ( UBaseType_t ) xFlags & ( ( ( UBaseType_t ) FREERTOS_MSG_PEEK ) | ( ( UBaseType_t ) FREERTOS_ZERO_COPY ) ) ) == 0U ) ||
 800abdc:	f014 0f05 	tst.w	r4, #5
 800abe0:	d001      	beq.n	800abe6 <FreeRTOS_recvfrom+0x6c>
 800abe2:	2d00      	cmp	r5, #0
 800abe4:	da02      	bge.n	800abec <FreeRTOS_recvfrom+0x72>
                vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800abe6:	4630      	mov	r0, r6
 800abe8:	f003 fd5a 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
}
 800abec:	4628      	mov	r0, r5
 800abee:	b004      	add	sp, #16
 800abf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                            uxPayloadOffset = xRecv_Update_IPv6( pxNetworkBuffer, pxSourceAddress );
 800abf4:	990a      	ldr	r1, [sp, #40]	@ 0x28
 800abf6:	4630      	mov	r0, r6
 800abf8:	f7fd fe9d 	bl	8008936 <xRecv_Update_IPv6>
                if( lReturn < 0 )
 800abfc:	e7e0      	b.n	800abc0 <FreeRTOS_recvfrom+0x46>
        lReturn = -pdFREERTOS_ERRNO_EINVAL;
 800abfe:	f06f 0515 	mvn.w	r5, #21
 800ac02:	e7f3      	b.n	800abec <FreeRTOS_recvfrom+0x72>
            lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 800ac04:	f06f 050a 	mvn.w	r5, #10
    return lReturn;
 800ac08:	e7f0      	b.n	800abec <FreeRTOS_recvfrom+0x72>

0800ac0a <FreeRTOS_recv>:
    {
 800ac0a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ac0c:	b083      	sub	sp, #12
 800ac0e:	4605      	mov	r5, r0
 800ac10:	460e      	mov	r6, r1
 800ac12:	4617      	mov	r7, r2
 800ac14:	461c      	mov	r4, r3
        EventBits_t xEventBits = ( EventBits_t ) 0U;
 800ac16:	2300      	movs	r3, #0
 800ac18:	9301      	str	r3, [sp, #4]
        if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800ac1a:	2201      	movs	r2, #1
 800ac1c:	2106      	movs	r1, #6
 800ac1e:	f7ff ff97 	bl	800ab50 <prvValidSocket>
 800ac22:	b198      	cbz	r0, 800ac4c <FreeRTOS_recv+0x42>
        else if( ( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_ZERO_COPY ) != 0U ) &&
 800ac24:	f014 0f01 	tst.w	r4, #1
 800ac28:	d000      	beq.n	800ac2c <FreeRTOS_recv+0x22>
 800ac2a:	b196      	cbz	r6, 800ac52 <FreeRTOS_recv+0x48>
            xByteCount = prvRecvWait( pxSocket, &( xEventBits ), xFlags );
 800ac2c:	4622      	mov	r2, r4
 800ac2e:	a901      	add	r1, sp, #4
 800ac30:	4628      	mov	r0, r5
 800ac32:	f7ff fb69 	bl	800a308 <prvRecvWait>
            if( xByteCount > 0 )
 800ac36:	2800      	cmp	r0, #0
 800ac38:	dc01      	bgt.n	800ac3e <FreeRTOS_recv+0x34>
    }
 800ac3a:	b003      	add	sp, #12
 800ac3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                xByteCount = prvRecvData( pxSocket, pvBuffer, uxBufferLength, xFlags );
 800ac3e:	4623      	mov	r3, r4
 800ac40:	463a      	mov	r2, r7
 800ac42:	4631      	mov	r1, r6
 800ac44:	4628      	mov	r0, r5
 800ac46:	f7ff fbdb 	bl	800a400 <prvRecvData>
 800ac4a:	e7f6      	b.n	800ac3a <FreeRTOS_recv+0x30>
            xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 800ac4c:	f06f 0015 	mvn.w	r0, #21
 800ac50:	e7f3      	b.n	800ac3a <FreeRTOS_recv+0x30>
            xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 800ac52:	f06f 0015 	mvn.w	r0, #21
        return xByteCount;
 800ac56:	e7f0      	b.n	800ac3a <FreeRTOS_recv+0x30>

0800ac58 <prvTCPSendCheck>:
    {
 800ac58:	b538      	push	{r3, r4, r5, lr}
 800ac5a:	4604      	mov	r4, r0
 800ac5c:	460d      	mov	r5, r1
        if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800ac5e:	2201      	movs	r2, #1
 800ac60:	2106      	movs	r1, #6
 800ac62:	f7ff ff75 	bl	800ab50 <prvValidSocket>
 800ac66:	b1f8      	cbz	r0, 800aca8 <prvTCPSendCheck+0x50>
        else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 800ac68:	f894 306a 	ldrb.w	r3, [r4, #106]	@ 0x6a
 800ac6c:	f013 0f08 	tst.w	r3, #8
 800ac70:	d11d      	bne.n	800acae <prvTCPSendCheck+0x56>
        else if( ( pxSocket->u.xTCP.eTCPState == eCLOSED ) ||
 800ac72:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800ac76:	b1eb      	cbz	r3, 800acb4 <prvTCPSendCheck+0x5c>
 800ac78:	3b08      	subs	r3, #8
 800ac7a:	b2db      	uxtb	r3, r3
 800ac7c:	2b01      	cmp	r3, #1
 800ac7e:	d91c      	bls.n	800acba <prvTCPSendCheck+0x62>
        else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 800ac80:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800ac84:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800ac88:	d11a      	bne.n	800acc0 <prvTCPSendCheck+0x68>
        else if( uxDataLength == 0U )
 800ac8a:	b1dd      	cbz	r5, 800acc4 <prvTCPSendCheck+0x6c>
        else if( pxSocket->u.xTCP.txStream == NULL )
 800ac8c:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800ac90:	b10b      	cbz	r3, 800ac96 <prvTCPSendCheck+0x3e>
        int32_t xResult = 1;
 800ac92:	2001      	movs	r0, #1
 800ac94:	e015      	b.n	800acc2 <prvTCPSendCheck+0x6a>
            ( void ) prvTCPCreateStream( pxSocket, pdFALSE );
 800ac96:	2100      	movs	r1, #0
 800ac98:	4620      	mov	r0, r4
 800ac9a:	f7ff fadf 	bl	800a25c <prvTCPCreateStream>
            if( pxSocket->u.xTCP.txStream == NULL )
 800ac9e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800aca2:	b18b      	cbz	r3, 800acc8 <prvTCPSendCheck+0x70>
        int32_t xResult = 1;
 800aca4:	2001      	movs	r0, #1
 800aca6:	e00c      	b.n	800acc2 <prvTCPSendCheck+0x6a>
            xResult = -pdFREERTOS_ERRNO_EINVAL;
 800aca8:	f06f 0015 	mvn.w	r0, #21
 800acac:	e009      	b.n	800acc2 <prvTCPSendCheck+0x6a>
            xResult = -pdFREERTOS_ERRNO_ENOMEM;
 800acae:	f06f 000b 	mvn.w	r0, #11
 800acb2:	e006      	b.n	800acc2 <prvTCPSendCheck+0x6a>
        else if( ( pxSocket->u.xTCP.eTCPState == eCLOSED ) ||
 800acb4:	f06f 007f 	mvn.w	r0, #127	@ 0x7f
 800acb8:	e003      	b.n	800acc2 <prvTCPSendCheck+0x6a>
 800acba:	f06f 007f 	mvn.w	r0, #127	@ 0x7f
 800acbe:	e000      	b.n	800acc2 <prvTCPSendCheck+0x6a>
            xResult = 0;
 800acc0:	2000      	movs	r0, #0
    }
 800acc2:	bd38      	pop	{r3, r4, r5, pc}
            xResult = 0;
 800acc4:	2000      	movs	r0, #0
 800acc6:	e7fc      	b.n	800acc2 <prvTCPSendCheck+0x6a>
                xResult = -pdFREERTOS_ERRNO_ENOMEM;
 800acc8:	f06f 000b 	mvn.w	r0, #11
        return xResult;
 800accc:	e7f9      	b.n	800acc2 <prvTCPSendCheck+0x6a>

0800acce <prvTCPSendLoop>:
    {
 800acce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800acd2:	b089      	sub	sp, #36	@ 0x24
 800acd4:	4605      	mov	r5, r0
 800acd6:	460f      	mov	r7, r1
 800acd8:	9102      	str	r1, [sp, #8]
 800acda:	4692      	mov	sl, r2
 800acdc:	9303      	str	r3, [sp, #12]
        BaseType_t xBytesLeft = ( BaseType_t ) uxDataLength;
 800acde:	4616      	mov	r6, r2
        BaseType_t xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 800ace0:	f8d0 00a0 	ldr.w	r0, [r0, #160]	@ 0xa0
 800ace4:	f000 fb99 	bl	800b41a <uxStreamBufferGetSpace>
 800ace8:	4604      	mov	r4, r0
        BaseType_t xTimed = pdFALSE;
 800acea:	f04f 0800 	mov.w	r8, #0
        BaseType_t xBytesSent = 0;
 800acee:	46c1      	mov	r9, r8
        while( xBytesLeft > 0 )
 800acf0:	e05a      	b.n	800ada8 <prvTCPSendLoop+0xda>
                    vTaskSuspendAll();
 800acf2:	f7f9 ff8f 	bl	8004c14 <vTaskSuspendAll>
                    pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE_UNSIGNED;
 800acf6:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 800acfa:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800acfe:	f885 3068 	strb.w	r3, [r5, #104]	@ 0x68
                    xCloseAfterSend = pdTRUE;
 800ad02:	f04f 0b01 	mov.w	fp, #1
 800ad06:	e001      	b.n	800ad0c <prvTCPSendLoop+0x3e>
                BaseType_t xCloseAfterSend = pdFALSE;
 800ad08:	f04f 0b00 	mov.w	fp, #0
                xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0U, pucSource, ( size_t ) xByteCount );
 800ad0c:	4623      	mov	r3, r4
 800ad0e:	463a      	mov	r2, r7
 800ad10:	2100      	movs	r1, #0
 800ad12:	f8d5 00a0 	ldr.w	r0, [r5, #160]	@ 0xa0
 800ad16:	f000 fbc6 	bl	800b4a6 <uxStreamBufferAdd>
 800ad1a:	4604      	mov	r4, r0
                if( xCloseAfterSend == pdTRUE )
 800ad1c:	f1bb 0f00 	cmp.w	fp, #0
 800ad20:	d123      	bne.n	800ad6a <prvTCPSendLoop+0x9c>
                pxSocket->u.xTCP.usTimeout = 1U;
 800ad22:	2301      	movs	r3, #1
 800ad24:	f8a5 3070 	strh.w	r3, [r5, #112]	@ 0x70
                if( xIsCallingFromIPTask() == pdFALSE )
 800ad28:	f7fd f84d 	bl	8007dc6 <xIsCallingFromIPTask>
 800ad2c:	b300      	cbz	r0, 800ad70 <prvTCPSendLoop+0xa2>
                xBytesSent += xByteCount;
 800ad2e:	44a1      	add	r9, r4
                if( ( xBytesLeft == 0 ) || ( pvBuffer == NULL ) )
 800ad30:	1b36      	subs	r6, r6, r4
 800ad32:	d04a      	beq.n	800adca <prvTCPSendLoop+0xfc>
 800ad34:	9b02      	ldr	r3, [sp, #8]
 800ad36:	2b00      	cmp	r3, #0
 800ad38:	d047      	beq.n	800adca <prvTCPSendLoop+0xfc>
                pucSource = &( pucSource[ xByteCount ] );
 800ad3a:	4427      	add	r7, r4
            if( xTimed == pdFALSE )
 800ad3c:	f1b8 0f00 	cmp.w	r8, #0
 800ad40:	d11a      	bne.n	800ad78 <prvTCPSendLoop+0xaa>
                xRemainingTime = pxSocket->xSendBlockTime;
 800ad42:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800ad44:	9307      	str	r3, [sp, #28]
                if( xIsCallingFromIPTask() != pdFALSE )
 800ad46:	f7fd f83e 	bl	8007dc6 <xIsCallingFromIPTask>
 800ad4a:	b108      	cbz	r0, 800ad50 <prvTCPSendLoop+0x82>
                    xRemainingTime = ( TickType_t ) 0U;
 800ad4c:	2300      	movs	r3, #0
 800ad4e:	9307      	str	r3, [sp, #28]
                if( xRemainingTime == ( TickType_t ) 0U )
 800ad50:	9b07      	ldr	r3, [sp, #28]
 800ad52:	2b00      	cmp	r3, #0
 800ad54:	d039      	beq.n	800adca <prvTCPSendLoop+0xfc>
                if( ( ( uint32_t ) xFlags & ( uint32_t ) FREERTOS_MSG_DONTWAIT ) != 0U )
 800ad56:	9b03      	ldr	r3, [sp, #12]
 800ad58:	f013 0f10 	tst.w	r3, #16
 800ad5c:	d135      	bne.n	800adca <prvTCPSendLoop+0xfc>
                vTaskSetTimeOutState( &xTimeOut );
 800ad5e:	a805      	add	r0, sp, #20
 800ad60:	f7fa f9d0 	bl	8005104 <vTaskSetTimeOutState>
                xTimed = pdTRUE;
 800ad64:	f04f 0801 	mov.w	r8, #1
 800ad68:	e00b      	b.n	800ad82 <prvTCPSendLoop+0xb4>
                    ( void ) xTaskResumeAll();
 800ad6a:	f7f9 ffed 	bl	8004d48 <xTaskResumeAll>
 800ad6e:	e7d8      	b.n	800ad22 <prvTCPSendLoop+0x54>
                    ( void ) xSendEventToIPTask( eTCPTimerEvent );
 800ad70:	2006      	movs	r0, #6
 800ad72:	f7fc fb21 	bl	80073b8 <xSendEventToIPTask>
 800ad76:	e7da      	b.n	800ad2e <prvTCPSendLoop+0x60>
                if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 800ad78:	a907      	add	r1, sp, #28
 800ad7a:	a805      	add	r0, sp, #20
 800ad7c:	f7fa f9ea 	bl	8005154 <xTaskCheckForTimeOut>
 800ad80:	bb18      	cbnz	r0, 800adca <prvTCPSendLoop+0xfc>
            ( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_SEND | ( EventBits_t ) eSOCKET_CLOSED,
 800ad82:	9b07      	ldr	r3, [sp, #28]
 800ad84:	9300      	str	r3, [sp, #0]
 800ad86:	2300      	movs	r3, #0
 800ad88:	2201      	movs	r2, #1
 800ad8a:	2122      	movs	r1, #34	@ 0x22
 800ad8c:	6868      	ldr	r0, [r5, #4]
 800ad8e:	f7f8 fefa 	bl	8003b86 <xEventGroupWaitBits>
            xByteCount = ( BaseType_t ) prvTCPSendCheck( pxSocket, uxDataLength );
 800ad92:	4651      	mov	r1, sl
 800ad94:	4628      	mov	r0, r5
 800ad96:	f7ff ff5f 	bl	800ac58 <prvTCPSendCheck>
            if( xByteCount < 0 )
 800ad9a:	2800      	cmp	r0, #0
 800ad9c:	db15      	blt.n	800adca <prvTCPSendLoop+0xfc>
            xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 800ad9e:	f8d5 00a0 	ldr.w	r0, [r5, #160]	@ 0xa0
 800ada2:	f000 fb3a 	bl	800b41a <uxStreamBufferGetSpace>
 800ada6:	4604      	mov	r4, r0
        while( xBytesLeft > 0 )
 800ada8:	2e00      	cmp	r6, #0
 800adaa:	dd0e      	ble.n	800adca <prvTCPSendLoop+0xfc>
            if( xByteCount > 0 )
 800adac:	2c00      	cmp	r4, #0
 800adae:	ddc5      	ble.n	800ad3c <prvTCPSendLoop+0x6e>
                if( xByteCount > xBytesLeft )
 800adb0:	42a6      	cmp	r6, r4
 800adb2:	da00      	bge.n	800adb6 <prvTCPSendLoop+0xe8>
                    xByteCount = xBytesLeft;
 800adb4:	4634      	mov	r4, r6
                if( ( pxSocket->u.xTCP.bits.bCloseAfterSend != pdFALSE_UNSIGNED ) &&
 800adb6:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 800adba:	f013 0f10 	tst.w	r3, #16
 800adbe:	d0a3      	beq.n	800ad08 <prvTCPSendLoop+0x3a>
 800adc0:	42a6      	cmp	r6, r4
 800adc2:	d096      	beq.n	800acf2 <prvTCPSendLoop+0x24>
                BaseType_t xCloseAfterSend = pdFALSE;
 800adc4:	f04f 0b00 	mov.w	fp, #0
 800adc8:	e7a0      	b.n	800ad0c <prvTCPSendLoop+0x3e>
    }
 800adca:	4648      	mov	r0, r9
 800adcc:	b009      	add	sp, #36	@ 0x24
 800adce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800add2 <FreeRTOS_send>:
    {
 800add2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800add4:	4605      	mov	r5, r0
 800add6:	460e      	mov	r6, r1
 800add8:	4614      	mov	r4, r2
 800adda:	461f      	mov	r7, r3
        xByteCount = ( BaseType_t ) prvTCPSendCheck( pxSocket, uxDataLength );
 800addc:	4611      	mov	r1, r2
 800adde:	f7ff ff3b 	bl	800ac58 <prvTCPSendCheck>
        if( xByteCount > 0 )
 800ade2:	2800      	cmp	r0, #0
 800ade4:	dc00      	bgt.n	800ade8 <FreeRTOS_send+0x16>
    }
 800ade6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            xByteCount = prvTCPSendLoop( pxSocket, pvBuffer, uxDataLength, xFlags );
 800ade8:	463b      	mov	r3, r7
 800adea:	4622      	mov	r2, r4
 800adec:	4631      	mov	r1, r6
 800adee:	4628      	mov	r0, r5
 800adf0:	f7ff ff6d 	bl	800acce <prvTCPSendLoop>
            if( xByteCount == 0 )
 800adf4:	2800      	cmp	r0, #0
 800adf6:	d1f6      	bne.n	800ade6 <FreeRTOS_send+0x14>
                if( pxSocket->u.xTCP.eTCPState > eESTABLISHED )
 800adf8:	f895 3079 	ldrb.w	r3, [r5, #121]	@ 0x79
 800adfc:	2b05      	cmp	r3, #5
 800adfe:	d902      	bls.n	800ae06 <FreeRTOS_send+0x34>
                    xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOTCONN;
 800ae00:	f06f 007f 	mvn.w	r0, #127	@ 0x7f
 800ae04:	e7ef      	b.n	800ade6 <FreeRTOS_send+0x14>
                    xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOSPC;
 800ae06:	f06f 001b 	mvn.w	r0, #27
        return xByteCount;
 800ae0a:	e7ec      	b.n	800ade6 <FreeRTOS_send+0x14>

0800ae0c <FreeRTOS_listen>:
    {
 800ae0c:	b538      	push	{r3, r4, r5, lr}
 800ae0e:	4604      	mov	r4, r0
 800ae10:	460d      	mov	r5, r1
        if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800ae12:	2201      	movs	r2, #1
 800ae14:	2106      	movs	r1, #6
 800ae16:	f7ff fe9b 	bl	800ab50 <prvValidSocket>
 800ae1a:	b3a0      	cbz	r0, 800ae86 <FreeRTOS_listen+0x7a>
        else if( ( pxSocket->u.xTCP.eTCPState != eCLOSED ) && ( pxSocket->u.xTCP.eTCPState != eCLOSE_WAIT ) )
 800ae1c:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800ae20:	b10b      	cbz	r3, 800ae26 <FreeRTOS_listen+0x1a>
 800ae22:	2b08      	cmp	r3, #8
 800ae24:	d132      	bne.n	800ae8c <FreeRTOS_listen+0x80>
            pxSocket->u.xTCP.usBacklog = ( uint16_t ) FreeRTOS_min_int32( ( int32_t ) 0xffff, ( int32_t ) xBacklog );
 800ae26:	4629      	mov	r1, r5
 800ae28:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 800ae2c:	f7fd f9fa 	bl	8008224 <FreeRTOS_min_int32>
 800ae30:	f8a4 0076 	strh.w	r0, [r4, #118]	@ 0x76
            if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800ae34:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800ae38:	f013 0f08 	tst.w	r3, #8
 800ae3c:	d01d      	beq.n	800ae7a <FreeRTOS_listen+0x6e>
                if( pxSocket->u.xTCP.rxStream != NULL )
 800ae3e:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 800ae42:	b108      	cbz	r0, 800ae48 <FreeRTOS_listen+0x3c>
                    vStreamBufferClear( pxSocket->u.xTCP.rxStream );
 800ae44:	f000 fb01 	bl	800b44a <vStreamBufferClear>
                if( pxSocket->u.xTCP.txStream != NULL )
 800ae48:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
 800ae4c:	b108      	cbz	r0, 800ae52 <FreeRTOS_listen+0x46>
                    vStreamBufferClear( pxSocket->u.xTCP.txStream );
 800ae4e:	f000 fafc 	bl	800b44a <vStreamBufferClear>
                ( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800ae52:	225a      	movs	r2, #90	@ 0x5a
 800ae54:	2100      	movs	r1, #0
 800ae56:	f104 00aa 	add.w	r0, r4, #170	@ 0xaa
 800ae5a:	f003 ff2b 	bl	800ecb4 <memset>
                ( void ) memset( &pxSocket->u.xTCP.xTCPWindow, 0, sizeof( pxSocket->u.xTCP.xTCPWindow ) );
 800ae5e:	22c0      	movs	r2, #192	@ 0xc0
 800ae60:	2100      	movs	r1, #0
 800ae62:	f504 708a 	add.w	r0, r4, #276	@ 0x114
 800ae66:	f003 ff25 	bl	800ecb4 <memset>
                ( void ) memset( &pxSocket->u.xTCP.bits, 0, sizeof( pxSocket->u.xTCP.bits ) );
 800ae6a:	2300      	movs	r3, #0
 800ae6c:	66a3      	str	r3, [r4, #104]	@ 0x68
                pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE;
 800ae6e:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800ae72:	f043 0308 	orr.w	r3, r3, #8
 800ae76:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
            vTCPStateChange( pxSocket, eTCP_LISTEN );
 800ae7a:	2101      	movs	r1, #1
 800ae7c:	4620      	mov	r0, r4
 800ae7e:	f000 fc1d 	bl	800b6bc <vTCPStateChange>
        BaseType_t xResult = 0;
 800ae82:	2000      	movs	r0, #0
    }
 800ae84:	bd38      	pop	{r3, r4, r5, pc}
            xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 800ae86:	f06f 005e 	mvn.w	r0, #94	@ 0x5e
 800ae8a:	e7fb      	b.n	800ae84 <FreeRTOS_listen+0x78>
            xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 800ae8c:	f06f 005e 	mvn.w	r0, #94	@ 0x5e
        return xResult;
 800ae90:	e7f8      	b.n	800ae84 <FreeRTOS_listen+0x78>

0800ae92 <FreeRTOS_shutdown>:
    {
 800ae92:	b510      	push	{r4, lr}
 800ae94:	4604      	mov	r4, r0
        if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800ae96:	2201      	movs	r2, #1
 800ae98:	2106      	movs	r1, #6
 800ae9a:	f7ff fe59 	bl	800ab50 <prvValidSocket>
 800ae9e:	b188      	cbz	r0, 800aec4 <FreeRTOS_shutdown+0x32>
        else if( pxSocket->u.xTCP.eTCPState != eESTABLISHED )
 800aea0:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800aea4:	2b05      	cmp	r3, #5
 800aea6:	d110      	bne.n	800aeca <FreeRTOS_shutdown+0x38>
            pxSocket->u.xTCP.bits.bUserShutdown = pdTRUE_UNSIGNED;
 800aea8:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800aeac:	f043 0320 	orr.w	r3, r3, #32
 800aeb0:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
            pxSocket->u.xTCP.usTimeout = 1U;
 800aeb4:	2301      	movs	r3, #1
 800aeb6:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
            ( void ) xSendEventToIPTask( eTCPTimerEvent );
 800aeba:	2006      	movs	r0, #6
 800aebc:	f7fc fa7c 	bl	80073b8 <xSendEventToIPTask>
            xResult = 0;
 800aec0:	2000      	movs	r0, #0
    }
 800aec2:	bd10      	pop	{r4, pc}
            xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 800aec4:	f06f 005e 	mvn.w	r0, #94	@ 0x5e
 800aec8:	e7fb      	b.n	800aec2 <FreeRTOS_shutdown+0x30>
            xResult = -pdFREERTOS_ERRNO_ENOTCONN;
 800aeca:	f06f 007f 	mvn.w	r0, #127	@ 0x7f
        return xResult;
 800aece:	e7f8      	b.n	800aec2 <FreeRTOS_shutdown+0x30>

0800aed0 <FreeRTOS_bind>:
{
 800aed0:	b570      	push	{r4, r5, r6, lr}
 800aed2:	b084      	sub	sp, #16
 800aed4:	4604      	mov	r4, r0
 800aed6:	460d      	mov	r5, r1
    configASSERT( xIsCallingFromIPTask() == pdFALSE );
 800aed8:	f7fc ff75 	bl	8007dc6 <xIsCallingFromIPTask>
 800aedc:	b140      	cbz	r0, 800aef0 <FreeRTOS_bind+0x20>
 800aede:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800aee2:	f383 8811 	msr	BASEPRI, r3
 800aee6:	f3bf 8f6f 	isb	sy
 800aeea:	f3bf 8f4f 	dsb	sy
 800aeee:	e7fe      	b.n	800aeee <FreeRTOS_bind+0x1e>
 800aef0:	4606      	mov	r6, r0
    if( xSocketValid( pxSocket ) == pdFALSE )
 800aef2:	4620      	mov	r0, r4
 800aef4:	f7ff fe24 	bl	800ab40 <xSocketValid>
 800aef8:	2800      	cmp	r0, #0
 800aefa:	d04b      	beq.n	800af94 <FreeRTOS_bind+0xc4>
    else if( socketSOCKET_IS_BOUND( pxSocket ) )
 800aefc:	69e3      	ldr	r3, [r4, #28]
 800aefe:	2b00      	cmp	r3, #0
 800af00:	d14b      	bne.n	800af9a <FreeRTOS_bind+0xca>
        xBindEvent.eEventType = eSocketBindEvent;
 800af02:	2309      	movs	r3, #9
 800af04:	f88d 3008 	strb.w	r3, [sp, #8]
        xBindEvent.pvData = xSocket;
 800af08:	9403      	str	r4, [sp, #12]
        if( pxAddress != NULL )
 800af0a:	2d00      	cmp	r5, #0
 800af0c:	d03b      	beq.n	800af86 <FreeRTOS_bind+0xb6>
            switch( pxAddress->sin_family )
 800af0e:	786b      	ldrb	r3, [r5, #1]
 800af10:	2b02      	cmp	r3, #2
 800af12:	d026      	beq.n	800af62 <FreeRTOS_bind+0x92>
 800af14:	2b0a      	cmp	r3, #10
 800af16:	d10b      	bne.n	800af30 <FreeRTOS_bind+0x60>
                        ( void ) memcpy( pxSocket->xLocalAddress.xIP_IPv6.ucBytes, pxAddress->sin_address.xIP_IPv6.ucBytes, sizeof( pxSocket->xLocalAddress.xIP_IPv6.ucBytes ) );
 800af18:	68a8      	ldr	r0, [r5, #8]
 800af1a:	68e9      	ldr	r1, [r5, #12]
 800af1c:	692a      	ldr	r2, [r5, #16]
 800af1e:	696b      	ldr	r3, [r5, #20]
 800af20:	62a0      	str	r0, [r4, #40]	@ 0x28
 800af22:	62e1      	str	r1, [r4, #44]	@ 0x2c
 800af24:	6322      	str	r2, [r4, #48]	@ 0x30
 800af26:	6363      	str	r3, [r4, #52]	@ 0x34
                        pxSocket->bits.bIsIPv6 = pdTRUE_UNSIGNED;
 800af28:	7a23      	ldrb	r3, [r4, #8]
 800af2a:	f043 0301 	orr.w	r3, r3, #1
 800af2e:	7223      	strb	r3, [r4, #8]
            pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 800af30:	886a      	ldrh	r2, [r5, #2]
 800af32:	0213      	lsls	r3, r2, #8
 800af34:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800af38:	8723      	strh	r3, [r4, #56]	@ 0x38
        if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 800af3a:	f04f 31ff 	mov.w	r1, #4294967295
 800af3e:	a802      	add	r0, sp, #8
 800af40:	f7fc f9d0 	bl	80072e4 <xSendEventStructToIPTask>
 800af44:	b360      	cbz	r0, 800afa0 <FreeRTOS_bind+0xd0>
            ( void ) xEventGroupWaitBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_BOUND, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, portMAX_DELAY );
 800af46:	f04f 33ff 	mov.w	r3, #4294967295
 800af4a:	9300      	str	r3, [sp, #0]
 800af4c:	2300      	movs	r3, #0
 800af4e:	2201      	movs	r2, #1
 800af50:	2110      	movs	r1, #16
 800af52:	6860      	ldr	r0, [r4, #4]
 800af54:	f7f8 fe17 	bl	8003b86 <xEventGroupWaitBits>
            if( !socketSOCKET_IS_BOUND( pxSocket ) )
 800af58:	69e3      	ldr	r3, [r4, #28]
 800af5a:	b323      	cbz	r3, 800afa6 <FreeRTOS_bind+0xd6>
}
 800af5c:	4630      	mov	r0, r6
 800af5e:	b004      	add	sp, #16
 800af60:	bd70      	pop	{r4, r5, r6, pc}
                        pxSocket->xLocalAddress.ulIP_IPv4 = FreeRTOS_ntohl( pxAddress->sin_address.ulIP_IPv4 );
 800af62:	68aa      	ldr	r2, [r5, #8]
 800af64:	0213      	lsls	r3, r2, #8
 800af66:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800af6a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800af6e:	0a11      	lsrs	r1, r2, #8
 800af70:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800af74:	430b      	orrs	r3, r1
 800af76:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800af7a:	62a3      	str	r3, [r4, #40]	@ 0x28
                        pxSocket->bits.bIsIPv6 = pdFALSE_UNSIGNED;
 800af7c:	7a23      	ldrb	r3, [r4, #8]
 800af7e:	f023 0301 	bic.w	r3, r3, #1
 800af82:	7223      	strb	r3, [r4, #8]
                        break;
 800af84:	e7d4      	b.n	800af30 <FreeRTOS_bind+0x60>
            pxSocket->usLocalPort = 0U;
 800af86:	2300      	movs	r3, #0
 800af88:	8723      	strh	r3, [r4, #56]	@ 0x38
            ( void ) memset( pxSocket->xLocalAddress.xIP_IPv6.ucBytes, 0, sizeof( pxSocket->xLocalAddress.xIP_IPv6.ucBytes ) );
 800af8a:	62a3      	str	r3, [r4, #40]	@ 0x28
 800af8c:	62e3      	str	r3, [r4, #44]	@ 0x2c
 800af8e:	6323      	str	r3, [r4, #48]	@ 0x30
 800af90:	6363      	str	r3, [r4, #52]	@ 0x34
 800af92:	e7d2      	b.n	800af3a <FreeRTOS_bind+0x6a>
        xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800af94:	f06f 0615 	mvn.w	r6, #21
 800af98:	e7e0      	b.n	800af5c <FreeRTOS_bind+0x8c>
        xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800af9a:	f06f 0615 	mvn.w	r6, #21
 800af9e:	e7dd      	b.n	800af5c <FreeRTOS_bind+0x8c>
            xReturn = -pdFREERTOS_ERRNO_ECANCELED;
 800afa0:	f06f 068b 	mvn.w	r6, #139	@ 0x8b
 800afa4:	e7da      	b.n	800af5c <FreeRTOS_bind+0x8c>
                xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800afa6:	f06f 0615 	mvn.w	r6, #21
    return xReturn;
 800afaa:	e7d7      	b.n	800af5c <FreeRTOS_bind+0x8c>

0800afac <prvMakeSureSocketIsBound>:
{
 800afac:	b538      	push	{r3, r4, r5, lr}
 800afae:	4605      	mov	r5, r0
    BaseType_t xReturn = prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdFALSE );
 800afb0:	2200      	movs	r2, #0
 800afb2:	2111      	movs	r1, #17
 800afb4:	f7ff fdcc 	bl	800ab50 <prvValidSocket>
 800afb8:	4604      	mov	r4, r0
    if( ( xReturn == pdTRUE ) && ( !socketSOCKET_IS_BOUND( pxSocket ) ) )
 800afba:	2801      	cmp	r0, #1
 800afbc:	d001      	beq.n	800afc2 <prvMakeSureSocketIsBound+0x16>
}
 800afbe:	4620      	mov	r0, r4
 800afc0:	bd38      	pop	{r3, r4, r5, pc}
    if( ( xReturn == pdTRUE ) && ( !socketSOCKET_IS_BOUND( pxSocket ) ) )
 800afc2:	69eb      	ldr	r3, [r5, #28]
 800afc4:	2b00      	cmp	r3, #0
 800afc6:	d1fa      	bne.n	800afbe <prvMakeSureSocketIsBound+0x12>
        if( FreeRTOS_bind( pxSocket, NULL, 0U ) != 0 )
 800afc8:	2200      	movs	r2, #0
 800afca:	4611      	mov	r1, r2
 800afcc:	4628      	mov	r0, r5
 800afce:	f7ff ff7f 	bl	800aed0 <FreeRTOS_bind>
 800afd2:	2800      	cmp	r0, #0
 800afd4:	d0f3      	beq.n	800afbe <prvMakeSureSocketIsBound+0x12>
            xReturn = pdFALSE;
 800afd6:	2400      	movs	r4, #0
    return xReturn;
 800afd8:	e7f1      	b.n	800afbe <prvMakeSureSocketIsBound+0x12>

0800afda <FreeRTOS_sendto>:
{
 800afda:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800afde:	b083      	sub	sp, #12
 800afe0:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
    configASSERT( pxDestinationAddress != NULL );
 800afe2:	b19d      	cbz	r5, 800b00c <FreeRTOS_sendto+0x32>
 800afe4:	4680      	mov	r8, r0
 800afe6:	460f      	mov	r7, r1
 800afe8:	4616      	mov	r6, r2
 800afea:	461c      	mov	r4, r3
    configASSERT( pvBuffer != NULL );
 800afec:	b1b9      	cbz	r1, 800b01e <FreeRTOS_sendto+0x44>
    switch( pxDestinationAddress->sin_family )
 800afee:	786b      	ldrb	r3, [r5, #1]
 800aff0:	2b02      	cmp	r3, #2
 800aff2:	d01d      	beq.n	800b030 <FreeRTOS_sendto+0x56>
 800aff4:	2b0a      	cmp	r3, #10
 800aff6:	d131      	bne.n	800b05c <FreeRTOS_sendto+0x82>
 800aff8:	f04f 093e 	mov.w	r9, #62	@ 0x3e
 800affc:	f240 53ac 	movw	r3, #1452	@ 0x5ac
        if( uxTotalDataLength <= ( size_t ) uxMaxPayloadLength )
 800b000:	42b3      	cmp	r3, r6
 800b002:	d21a      	bcs.n	800b03a <FreeRTOS_sendto+0x60>
 800b004:	2000      	movs	r0, #0
} /* Tested */
 800b006:	b003      	add	sp, #12
 800b008:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800b00c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800b010:	f383 8811 	msr	BASEPRI, r3
 800b014:	f3bf 8f6f 	isb	sy
 800b018:	f3bf 8f4f 	dsb	sy
    configASSERT( pxDestinationAddress != NULL );
 800b01c:	e7fe      	b.n	800b01c <FreeRTOS_sendto+0x42>
 800b01e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800b022:	f383 8811 	msr	BASEPRI, r3
 800b026:	f3bf 8f6f 	isb	sy
 800b02a:	f3bf 8f4f 	dsb	sy
    configASSERT( pvBuffer != NULL );
 800b02e:	e7fe      	b.n	800b02e <FreeRTOS_sendto+0x54>
                uxPayloadOffset = ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER;
 800b030:	f04f 092a 	mov.w	r9, #42	@ 0x2a
                uxMaxPayloadLength = ipconfigNETWORK_MTU - ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER );
 800b034:	f44f 63b8 	mov.w	r3, #1472	@ 0x5c0
 800b038:	e7e2      	b.n	800b000 <FreeRTOS_sendto+0x26>
            if( prvMakeSureSocketIsBound( pxSocket ) == pdTRUE )
 800b03a:	4640      	mov	r0, r8
 800b03c:	f7ff ffb6 	bl	800afac <prvMakeSureSocketIsBound>
 800b040:	2801      	cmp	r0, #1
 800b042:	d001      	beq.n	800b048 <FreeRTOS_sendto+0x6e>
 800b044:	2000      	movs	r0, #0
    return lReturn;
 800b046:	e7de      	b.n	800b006 <FreeRTOS_sendto+0x2c>
                lReturn = prvSendTo_ActualSend( pxSocket, pvBuffer, uxTotalDataLength, xFlags, pxDestinationAddress, uxPayloadOffset );
 800b048:	f8cd 9004 	str.w	r9, [sp, #4]
 800b04c:	9500      	str	r5, [sp, #0]
 800b04e:	4623      	mov	r3, r4
 800b050:	4632      	mov	r2, r6
 800b052:	4639      	mov	r1, r7
 800b054:	4640      	mov	r0, r8
 800b056:	f7ff f80e 	bl	800a076 <prvSendTo_ActualSend>
 800b05a:	e7d4      	b.n	800b006 <FreeRTOS_sendto+0x2c>
    switch( pxDestinationAddress->sin_family )
 800b05c:	f06f 0015 	mvn.w	r0, #21
 800b060:	e7d1      	b.n	800b006 <FreeRTOS_sendto+0x2c>

0800b062 <prvTCPConnectStart>:
    {
 800b062:	b570      	push	{r4, r5, r6, lr}
        if( pxAddress == NULL )
 800b064:	2900      	cmp	r1, #0
 800b066:	d05c      	beq.n	800b122 <prvTCPConnectStart+0xc0>
 800b068:	4604      	mov	r4, r0
 800b06a:	460d      	mov	r5, r1
        else if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdFALSE )
 800b06c:	2200      	movs	r2, #0
 800b06e:	2106      	movs	r1, #6
 800b070:	f7ff fd6e 	bl	800ab50 <prvValidSocket>
 800b074:	2800      	cmp	r0, #0
 800b076:	d057      	beq.n	800b128 <prvTCPConnectStart+0xc6>
        else if( FreeRTOS_issocketconnected( pxSocket ) > 0 )
 800b078:	4620      	mov	r0, r4
 800b07a:	f7ff fce0 	bl	800aa3e <FreeRTOS_issocketconnected>
 800b07e:	2800      	cmp	r0, #0
 800b080:	dc55      	bgt.n	800b12e <prvTCPConnectStart+0xcc>
        else if( !socketSOCKET_IS_BOUND( pxSocket ) )
 800b082:	69e3      	ldr	r3, [r4, #28]
 800b084:	b393      	cbz	r3, 800b0ec <prvTCPConnectStart+0x8a>
            xResult = bMayConnect( pxSocket ); /* -EINPROGRESS, -EAGAIN, or 0 for OK */
 800b086:	4620      	mov	r0, r4
 800b088:	f7fe fe4a 	bl	8009d20 <bMayConnect>
            if( xResult == 0 )
 800b08c:	4606      	mov	r6, r0
 800b08e:	bb58      	cbnz	r0, 800b0e8 <prvTCPConnectStart+0x86>
                pxSocket->u.xTCP.bits.bConnPrepared = pdFALSE;
 800b090:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800b094:	f023 0308 	bic.w	r3, r3, #8
 800b098:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                pxSocket->u.xTCP.ucRepCount = 0U;
 800b09c:	2300      	movs	r3, #0
 800b09e:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
                switch( pxAddress->sin_family )
 800b0a2:	786b      	ldrb	r3, [r5, #1]
 800b0a4:	2b02      	cmp	r3, #2
 800b0a6:	d02a      	beq.n	800b0fe <prvTCPConnectStart+0x9c>
 800b0a8:	2b0a      	cmp	r3, #10
 800b0aa:	d10b      	bne.n	800b0c4 <prvTCPConnectStart+0x62>
                            pxSocket->bits.bIsIPv6 = pdTRUE_UNSIGNED;
 800b0ac:	7a23      	ldrb	r3, [r4, #8]
 800b0ae:	f043 0301 	orr.w	r3, r3, #1
 800b0b2:	7223      	strb	r3, [r4, #8]
                            ( void ) memcpy( pxSocket->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, pxAddress->sin_address.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800b0b4:	68a8      	ldr	r0, [r5, #8]
 800b0b6:	68e9      	ldr	r1, [r5, #12]
 800b0b8:	692a      	ldr	r2, [r5, #16]
 800b0ba:	696b      	ldr	r3, [r5, #20]
 800b0bc:	6560      	str	r0, [r4, #84]	@ 0x54
 800b0be:	65a1      	str	r1, [r4, #88]	@ 0x58
 800b0c0:	65e2      	str	r2, [r4, #92]	@ 0x5c
 800b0c2:	6623      	str	r3, [r4, #96]	@ 0x60
                pxSocket->u.xTCP.usRemotePort = FreeRTOS_ntohs( pxAddress->sin_port );
 800b0c4:	886a      	ldrh	r2, [r5, #2]
 800b0c6:	0213      	lsls	r3, r2, #8
 800b0c8:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800b0cc:	f8a4 3064 	strh.w	r3, [r4, #100]	@ 0x64
                vTCPStateChange( pxSocket, eCONNECT_SYN );
 800b0d0:	2102      	movs	r1, #2
 800b0d2:	4620      	mov	r0, r4
 800b0d4:	f000 faf2 	bl	800b6bc <vTCPStateChange>
                pxSocket->u.xTCP.usTimeout = 1U;
 800b0d8:	2301      	movs	r3, #1
 800b0da:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                if( xSendEventToIPTask( eTCPTimerEvent ) != pdPASS )
 800b0de:	2006      	movs	r0, #6
 800b0e0:	f7fc f96a 	bl	80073b8 <xSendEventToIPTask>
 800b0e4:	2801      	cmp	r0, #1
 800b0e6:	d125      	bne.n	800b134 <prvTCPConnectStart+0xd2>
    }
 800b0e8:	4630      	mov	r0, r6
 800b0ea:	bd70      	pop	{r4, r5, r6, pc}
            xResult = FreeRTOS_bind( pxSocket, NULL, 0U );
 800b0ec:	2200      	movs	r2, #0
 800b0ee:	4611      	mov	r1, r2
 800b0f0:	4620      	mov	r0, r4
 800b0f2:	f7ff feed 	bl	800aed0 <FreeRTOS_bind>
        if( xResult == 0 )
 800b0f6:	4606      	mov	r6, r0
 800b0f8:	2800      	cmp	r0, #0
 800b0fa:	d1f5      	bne.n	800b0e8 <prvTCPConnectStart+0x86>
 800b0fc:	e7c3      	b.n	800b086 <prvTCPConnectStart+0x24>
                            pxSocket->bits.bIsIPv6 = pdFALSE_UNSIGNED;
 800b0fe:	7a23      	ldrb	r3, [r4, #8]
 800b100:	f023 0301 	bic.w	r3, r3, #1
 800b104:	7223      	strb	r3, [r4, #8]
                            pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 = FreeRTOS_ntohl( pxAddress->sin_address.ulIP_IPv4 );
 800b106:	68aa      	ldr	r2, [r5, #8]
 800b108:	0213      	lsls	r3, r2, #8
 800b10a:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800b10e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800b112:	0a11      	lsrs	r1, r2, #8
 800b114:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800b118:	430b      	orrs	r3, r1
 800b11a:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800b11e:	6563      	str	r3, [r4, #84]	@ 0x54
                            break;
 800b120:	e7d0      	b.n	800b0c4 <prvTCPConnectStart+0x62>
            xResult = -pdFREERTOS_ERRNO_EINVAL;
 800b122:	f06f 0615 	mvn.w	r6, #21
 800b126:	e7df      	b.n	800b0e8 <prvTCPConnectStart+0x86>
            xResult = -pdFREERTOS_ERRNO_EBADF;
 800b128:	f06f 0608 	mvn.w	r6, #8
 800b12c:	e7dc      	b.n	800b0e8 <prvTCPConnectStart+0x86>
            xResult = -pdFREERTOS_ERRNO_EISCONN;
 800b12e:	f06f 067e 	mvn.w	r6, #126	@ 0x7e
 800b132:	e7d9      	b.n	800b0e8 <prvTCPConnectStart+0x86>
                    xResult = -pdFREERTOS_ERRNO_ECANCELED;
 800b134:	f06f 068b 	mvn.w	r6, #139	@ 0x8b
        return xResult;
 800b138:	e7d6      	b.n	800b0e8 <prvTCPConnectStart+0x86>

0800b13a <FreeRTOS_connect>:
    {
 800b13a:	b570      	push	{r4, r5, r6, lr}
 800b13c:	b086      	sub	sp, #24
 800b13e:	4604      	mov	r4, r0
        xResult = prvTCPConnectStart( pxSocket, pxAddress );
 800b140:	f7ff ff8f 	bl	800b062 <prvTCPConnectStart>
        if( xResult == 0 )
 800b144:	4606      	mov	r6, r0
 800b146:	bb40      	cbnz	r0, 800b19a <FreeRTOS_connect+0x60>
        BaseType_t xTimed = pdFALSE;
 800b148:	4605      	mov	r5, r0
 800b14a:	e015      	b.n	800b178 <FreeRTOS_connect+0x3e>
                xResult = FreeRTOS_issocketconnected( pxSocket );
 800b14c:	4620      	mov	r0, r4
 800b14e:	f7ff fc76 	bl	800aa3e <FreeRTOS_issocketconnected>
                if( xResult < 0 )
 800b152:	2800      	cmp	r0, #0
 800b154:	db20      	blt.n	800b198 <FreeRTOS_connect+0x5e>
                if( xResult > 0 )
 800b156:	dc20      	bgt.n	800b19a <FreeRTOS_connect+0x60>
                if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 800b158:	a905      	add	r1, sp, #20
 800b15a:	a803      	add	r0, sp, #12
 800b15c:	f7f9 fffa 	bl	8005154 <xTaskCheckForTimeOut>
 800b160:	b9f0      	cbnz	r0, 800b1a0 <FreeRTOS_connect+0x66>
                uxEvents = xEventGroupWaitBits( pxSocket->xEventGroup,
 800b162:	9b05      	ldr	r3, [sp, #20]
 800b164:	9300      	str	r3, [sp, #0]
 800b166:	2300      	movs	r3, #0
 800b168:	2201      	movs	r2, #1
 800b16a:	2128      	movs	r1, #40	@ 0x28
 800b16c:	6860      	ldr	r0, [r4, #4]
 800b16e:	f7f8 fd0a 	bl	8003b86 <xEventGroupWaitBits>
                if( ( uxEvents & ( EventBits_t ) eSOCKET_CLOSED ) != 0U )
 800b172:	f010 0f20 	tst.w	r0, #32
 800b176:	d109      	bne.n	800b18c <FreeRTOS_connect+0x52>
                if( xTimed == pdFALSE )
 800b178:	2d00      	cmp	r5, #0
 800b17a:	d1e7      	bne.n	800b14c <FreeRTOS_connect+0x12>
                    xRemainingTime = pxSocket->xReceiveBlockTime;
 800b17c:	6a23      	ldr	r3, [r4, #32]
 800b17e:	9305      	str	r3, [sp, #20]
                    if( xRemainingTime == ( TickType_t ) 0 )
 800b180:	b13b      	cbz	r3, 800b192 <FreeRTOS_connect+0x58>
                    vTaskSetTimeOutState( &xTimeOut );
 800b182:	a803      	add	r0, sp, #12
 800b184:	f7f9 ffbe 	bl	8005104 <vTaskSetTimeOutState>
                    xTimed = pdTRUE;
 800b188:	2501      	movs	r5, #1
 800b18a:	e7df      	b.n	800b14c <FreeRTOS_connect+0x12>
                    xResult = -pdFREERTOS_ERRNO_ENOTCONN;
 800b18c:	f06f 067f 	mvn.w	r6, #127	@ 0x7f
 800b190:	e003      	b.n	800b19a <FreeRTOS_connect+0x60>
                        xResult = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 800b192:	f06f 060a 	mvn.w	r6, #10
 800b196:	e000      	b.n	800b19a <FreeRTOS_connect+0x60>
                xResult = FreeRTOS_issocketconnected( pxSocket );
 800b198:	4606      	mov	r6, r0
    }
 800b19a:	4630      	mov	r0, r6
 800b19c:	b006      	add	sp, #24
 800b19e:	bd70      	pop	{r4, r5, r6, pc}
                    xResult = -pdFREERTOS_ERRNO_ETIMEDOUT;
 800b1a0:	f06f 0673 	mvn.w	r6, #115	@ 0x73
        return xResult;
 800b1a4:	e7f9      	b.n	800b19a <FreeRTOS_connect+0x60>
	...

0800b1a8 <vSocketBind>:
{
 800b1a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b1aa:	b087      	sub	sp, #28
 800b1ac:	4606      	mov	r6, r0
 800b1ae:	460c      	mov	r4, r1
 800b1b0:	461d      	mov	r5, r3
    configASSERT( xSocketValid( pxSocket ) == pdTRUE );
 800b1b2:	f7ff fcc5 	bl	800ab40 <xSocketValid>
 800b1b6:	2801      	cmp	r0, #1
 800b1b8:	d008      	beq.n	800b1cc <vSocketBind+0x24>
 800b1ba:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800b1be:	f383 8811 	msr	BASEPRI, r3
 800b1c2:	f3bf 8f6f 	isb	sy
 800b1c6:	f3bf 8f4f 	dsb	sy
 800b1ca:	e7fe      	b.n	800b1ca <vSocketBind+0x22>
        if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800b1cc:	f896 003b 	ldrb.w	r0, [r6, #59]	@ 0x3b
 800b1d0:	2806      	cmp	r0, #6
 800b1d2:	d00f      	beq.n	800b1f4 <vSocketBind+0x4c>
        pxSocketList = &xBoundUDPSocketsList;
 800b1d4:	4f14      	ldr	r7, [pc, #80]	@ (800b228 <vSocketBind+0x80>)
        if( pxAddress == NULL )
 800b1d6:	b17c      	cbz	r4, 800b1f8 <vSocketBind+0x50>
            if( pxAddress->sin_port == 0U )
 800b1d8:	8863      	ldrh	r3, [r4, #2]
 800b1da:	b91b      	cbnz	r3, 800b1e4 <vSocketBind+0x3c>
                pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
 800b1dc:	f7fe ff96 	bl	800a10c <prvGetPrivatePortNumber>
 800b1e0:	8060      	strh	r0, [r4, #2]
                if( pxAddress->sin_port == ( uint16_t ) 0U )
 800b1e2:	b1f0      	cbz	r0, 800b222 <vSocketBind+0x7a>
            xReturn = prvSocketBindAdd( pxSocket, pxAddress, pxSocketList, xInternal );
 800b1e4:	462b      	mov	r3, r5
 800b1e6:	463a      	mov	r2, r7
 800b1e8:	4621      	mov	r1, r4
 800b1ea:	4630      	mov	r0, r6
 800b1ec:	f7fe ffc6 	bl	800a17c <prvSocketBindAdd>
} /* Tested */
 800b1f0:	b007      	add	sp, #28
 800b1f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            pxSocketList = &xBoundTCPSocketsList;
 800b1f4:	4f0d      	ldr	r7, [pc, #52]	@ (800b22c <vSocketBind+0x84>)
 800b1f6:	e7ee      	b.n	800b1d6 <vSocketBind+0x2e>
            ( void ) memset( pxAddress, 0, sizeof( struct freertos_sockaddr ) );
 800b1f8:	2300      	movs	r3, #0
 800b1fa:	9300      	str	r3, [sp, #0]
 800b1fc:	9301      	str	r3, [sp, #4]
 800b1fe:	9302      	str	r3, [sp, #8]
 800b200:	9303      	str	r3, [sp, #12]
 800b202:	9304      	str	r3, [sp, #16]
 800b204:	9305      	str	r3, [sp, #20]
            if( pxSocket->bits.bIsIPv6 != pdFALSE_UNSIGNED )
 800b206:	7a33      	ldrb	r3, [r6, #8]
 800b208:	f013 0f01 	tst.w	r3, #1
 800b20c:	d004      	beq.n	800b218 <vSocketBind+0x70>
                pxAddress->sin_family = FREERTOS_AF_INET6;
 800b20e:	230a      	movs	r3, #10
 800b210:	f88d 3001 	strb.w	r3, [sp, #1]
            pxAddress = &xAddress;
 800b214:	466c      	mov	r4, sp
 800b216:	e7df      	b.n	800b1d8 <vSocketBind+0x30>
                pxAddress->sin_family = FREERTOS_AF_INET;
 800b218:	2302      	movs	r3, #2
 800b21a:	f88d 3001 	strb.w	r3, [sp, #1]
            pxAddress = &xAddress;
 800b21e:	466c      	mov	r4, sp
 800b220:	e7da      	b.n	800b1d8 <vSocketBind+0x30>
                    xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
 800b222:	f06f 007c 	mvn.w	r0, #124	@ 0x7c
    return xReturn;
 800b226:	e7e3      	b.n	800b1f0 <vSocketBind+0x48>
 800b228:	20013794 	.word	0x20013794
 800b22c:	20013780 	.word	0x20013780

0800b230 <FreeRTOS_closesocket>:
{
 800b230:	b500      	push	{lr}
 800b232:	b083      	sub	sp, #12
    xCloseEvent.eEventType = eSocketCloseEvent;
 800b234:	230a      	movs	r3, #10
 800b236:	f88d 3000 	strb.w	r3, [sp]
    xCloseEvent.pvData = xSocket;
 800b23a:	9001      	str	r0, [sp, #4]
    if( xSocketValid( xSocket ) == pdFALSE )
 800b23c:	f7ff fc80 	bl	800ab40 <xSocketValid>
 800b240:	b910      	cbnz	r0, 800b248 <FreeRTOS_closesocket+0x18>
}
 800b242:	b003      	add	sp, #12
 800b244:	f85d fb04 	ldr.w	pc, [sp], #4
        if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 800b248:	f04f 31ff 	mov.w	r1, #4294967295
 800b24c:	4668      	mov	r0, sp
 800b24e:	f7fc f849 	bl	80072e4 <xSendEventStructToIPTask>
 800b252:	b910      	cbnz	r0, 800b25a <FreeRTOS_closesocket+0x2a>
            xResult = -1;
 800b254:	f04f 30ff 	mov.w	r0, #4294967295
 800b258:	e7f3      	b.n	800b242 <FreeRTOS_closesocket+0x12>
            xResult = 1;
 800b25a:	2001      	movs	r0, #1
    return xResult;
 800b25c:	e7f1      	b.n	800b242 <FreeRTOS_closesocket+0x12>

0800b25e <FreeRTOS_setsockopt>:
{
 800b25e:	b570      	push	{r4, r5, r6, lr}
 800b260:	4606      	mov	r6, r0
 800b262:	4614      	mov	r4, r2
 800b264:	461d      	mov	r5, r3
    if( xSocketValid( pxSocket ) == pdTRUE )
 800b266:	f7ff fc6b 	bl	800ab40 <xSocketValid>
 800b26a:	2801      	cmp	r0, #1
 800b26c:	d153      	bne.n	800b316 <FreeRTOS_setsockopt+0xb8>
        switch( lOptionName )
 800b26e:	2c12      	cmp	r4, #18
 800b270:	d854      	bhi.n	800b31c <FreeRTOS_setsockopt+0xbe>
 800b272:	e8df f004 	tbb	[pc, r4]
 800b276:	110a      	.short	0x110a
 800b278:	31315318 	.word	0x31315318
 800b27c:	53535353 	.word	0x53535353
 800b280:	37413c53 	.word	0x37413c53
 800b284:	29534b46 	.word	0x29534b46
 800b288:	2c          	.byte	0x2c
 800b289:	00          	.byte	0x00
                prvSetOptionTimeout( pxSocket, pvOptionValue, pdFALSE );
 800b28a:	2200      	movs	r2, #0
 800b28c:	4629      	mov	r1, r5
 800b28e:	4630      	mov	r0, r6
 800b290:	f7fe fd03 	bl	8009c9a <prvSetOptionTimeout>
                xReturn = 0;
 800b294:	4620      	mov	r0, r4
                break;
 800b296:	e043      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                prvSetOptionTimeout( pxSocket, pvOptionValue, pdTRUE );
 800b298:	2201      	movs	r2, #1
 800b29a:	4629      	mov	r1, r5
 800b29c:	4630      	mov	r0, r6
 800b29e:	f7fe fcfc 	bl	8009c9a <prvSetOptionTimeout>
                xReturn = 0;
 800b2a2:	2000      	movs	r0, #0
                break;
 800b2a4:	e03c      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                if( pvOptionValue == NULL )
 800b2a6:	b13d      	cbz	r5, 800b2b8 <FreeRTOS_setsockopt+0x5a>
                    pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 800b2a8:	f896 303a 	ldrb.w	r3, [r6, #58]	@ 0x3a
 800b2ac:	f043 0302 	orr.w	r3, r3, #2
 800b2b0:	f886 303a 	strb.w	r3, [r6, #58]	@ 0x3a
                xReturn = 0;
 800b2b4:	2000      	movs	r0, #0
 800b2b6:	e033      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                    pxSocket->ucSocketOptions &= ( ( uint8_t ) ~( ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT ) );
 800b2b8:	f896 303a 	ldrb.w	r3, [r6, #58]	@ 0x3a
 800b2bc:	f023 0302 	bic.w	r3, r3, #2
 800b2c0:	f886 303a 	strb.w	r3, [r6, #58]	@ 0x3a
                xReturn = 0;
 800b2c4:	2000      	movs	r0, #0
 800b2c6:	e02b      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        pxSocket->pxUserWakeCallback = ( SocketWakeupCallback_t ) pvOptionValue;
 800b2c8:	63f5      	str	r5, [r6, #60]	@ 0x3c
                        xReturn = 0;
 800b2ca:	2000      	movs	r0, #0
                        break;
 800b2cc:	e028      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSetOptionLowHighWater( pxSocket, pvOptionValue );
 800b2ce:	4629      	mov	r1, r5
 800b2d0:	4630      	mov	r0, r6
 800b2d2:	f7fe fcc3 	bl	8009c5c <prvSetOptionLowHighWater>
                        break;
 800b2d6:	e023      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSockopt_so_buffer( pxSocket, lOptionName, pvOptionValue );
 800b2d8:	462a      	mov	r2, r5
 800b2da:	4621      	mov	r1, r4
 800b2dc:	4630      	mov	r0, r6
 800b2de:	f7fe fdb0 	bl	8009e42 <prvSockopt_so_buffer>
                        break;
 800b2e2:	e01d      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSetOptionTCPWindows( pxSocket, pvOptionValue );
 800b2e4:	4629      	mov	r1, r5
 800b2e6:	4630      	mov	r0, r6
 800b2e8:	f7fe fdd5 	bl	8009e96 <prvSetOptionTCPWindows>
                        break;
 800b2ec:	e018      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSetOptionReuseListenSocket( pxSocket, pvOptionValue );
 800b2ee:	4629      	mov	r1, r5
 800b2f0:	4630      	mov	r0, r6
 800b2f2:	f7fe fce3 	bl	8009cbc <prvSetOptionReuseListenSocket>
                        break;
 800b2f6:	e013      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSetOptionCloseAfterSend( pxSocket, pvOptionValue );
 800b2f8:	4629      	mov	r1, r5
 800b2fa:	4630      	mov	r0, r6
 800b2fc:	f7fe fcf7 	bl	8009cee <prvSetOptionCloseAfterSend>
                        break;
 800b300:	e00e      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSetOptionSetFullSize( pxSocket, pvOptionValue );
 800b302:	4629      	mov	r1, r5
 800b304:	4630      	mov	r0, r6
 800b306:	f7ff fb6f 	bl	800a9e8 <prvSetOptionSetFullSize>
                        break;
 800b30a:	e009      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
                        xReturn = prvSetOptionStopRX( pxSocket, pvOptionValue );
 800b30c:	4629      	mov	r1, r5
 800b30e:	4630      	mov	r0, r6
 800b310:	f7fe ff7f 	bl	800a212 <prvSetOptionStopRX>
                        break;
 800b314:	e004      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
        xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800b316:	f06f 0015 	mvn.w	r0, #21
 800b31a:	e001      	b.n	800b320 <FreeRTOS_setsockopt+0xc2>
        switch( lOptionName )
 800b31c:	f06f 006c 	mvn.w	r0, #108	@ 0x6c
} /* Tested */
 800b320:	bd70      	pop	{r4, r5, r6, pc}
	...

0800b324 <vTCPNetStat>:
    {
 800b324:	b510      	push	{r4, lr}
        size_t uxMinimum = uxGetMinimumFreeNetworkBuffers();
 800b326:	f003 fa55 	bl	800e7d4 <uxGetMinimumFreeNetworkBuffers>
        size_t uxCurrent = uxGetNumberOfFreeNetworkBuffers();
 800b32a:	f003 fa4d 	bl	800e7c8 <uxGetNumberOfFreeNetworkBuffers>
        if( !listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) )
 800b32e:	4b0c      	ldr	r3, [pc, #48]	@ (800b360 <vTCPNetStat+0x3c>)
 800b330:	689b      	ldr	r3, [r3, #8]
 800b332:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b336:	d000      	beq.n	800b33a <vTCPNetStat+0x16>
    }
 800b338:	bd10      	pop	{r4, pc}
            for( pxIterator = listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800b33a:	4b09      	ldr	r3, [pc, #36]	@ (800b360 <vTCPNetStat+0x3c>)
 800b33c:	68dc      	ldr	r4, [r3, #12]
 800b33e:	e003      	b.n	800b348 <vTCPNetStat+0x24>
                vTCPNetStat_TCPSocket( pxSocket );
 800b340:	68e0      	ldr	r0, [r4, #12]
 800b342:	f7ff f895 	bl	800a470 <vTCPNetStat_TCPSocket>
                 pxIterator = listGET_NEXT( pxIterator ) )
 800b346:	6864      	ldr	r4, [r4, #4]
                 pxIterator != pxEndTCP;
 800b348:	4b06      	ldr	r3, [pc, #24]	@ (800b364 <vTCPNetStat+0x40>)
 800b34a:	429c      	cmp	r4, r3
 800b34c:	d1f8      	bne.n	800b340 <vTCPNetStat+0x1c>
            for( pxIterator = listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 800b34e:	4b06      	ldr	r3, [pc, #24]	@ (800b368 <vTCPNetStat+0x44>)
 800b350:	68db      	ldr	r3, [r3, #12]
 800b352:	e000      	b.n	800b356 <vTCPNetStat+0x32>
                 pxIterator = listGET_NEXT( pxIterator ) )
 800b354:	685b      	ldr	r3, [r3, #4]
                 pxIterator != pxEndUDP;
 800b356:	4a05      	ldr	r2, [pc, #20]	@ (800b36c <vTCPNetStat+0x48>)
 800b358:	4293      	cmp	r3, r2
 800b35a:	d1fb      	bne.n	800b354 <vTCPNetStat+0x30>
 800b35c:	e7ec      	b.n	800b338 <vTCPNetStat+0x14>
 800b35e:	bf00      	nop
 800b360:	20013780 	.word	0x20013780
 800b364:	20013788 	.word	0x20013788
 800b368:	20013794 	.word	0x20013794
 800b36c:	2001379c 	.word	0x2001379c

0800b370 <vSocketSelect>:
 *        event has occurred.
 *
 * @param[in] pxSocketSet The socket-set which is to be waited on for change.
 */
    void vSocketSelect( const SocketSelect_t * pxSocketSet )
    {
 800b370:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b374:	4607      	mov	r7, r0
        #else
            BaseType_t xLastRound = 0;
        #endif

        /* These flags will be switched on after checking the socket status. */
        EventBits_t xGroupBits = 0;
 800b376:	f04f 0800 	mov.w	r8, #0

        for( xRound = 0; xRound <= xLastRound; xRound++ )
 800b37a:	46c1      	mov	r9, r8
 800b37c:	e01d      	b.n	800b3ba <vSocketSelect+0x4a>
            if( xRound == 0 )
            {
                /* MISRA Ref 11.3.1 [Misaligned access] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
                /* coverity[misra_c_2012_rule_11_3_violation] */
                pxEnd = ( ( const ListItem_t * ) &( xBoundUDPSocketsList.xListEnd ) );
 800b37e:	4e1d      	ldr	r6, [pc, #116]	@ (800b3f4 <vSocketSelect+0x84>)
 800b380:	e022      	b.n	800b3c8 <vSocketSelect+0x58>
                xSocketBits = 0;

                #if ( ipconfigUSE_TCP == 1 )
                    if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
                    {
                        xSocketBits |= vSocketSelectTCP( pxSocket );
 800b382:	4628      	mov	r0, r5
 800b384:	f7ff fb7e 	bl	800aa84 <vSocketSelectTCP>
                    /* The WRITE and EXCEPT bits are not used for UDP */
                } /* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */

                /* Each socket keeps its own event flags, which are looked-up
                 * by FreeRTOS_FD_ISSSET() */
                pxSocket->xSocketBits = xSocketBits;
 800b388:	64a8      	str	r0, [r5, #72]	@ 0x48

                /* The ORed value will be used to set the bits in the event
                 * group. */
                xGroupBits |= xSocketBits;
 800b38a:	ea48 0800 	orr.w	r8, r8, r0
                 pxIterator = listGET_NEXT( pxIterator ) )
 800b38e:	6864      	ldr	r4, [r4, #4]
                 pxIterator != pxEnd;
 800b390:	42b4      	cmp	r4, r6
 800b392:	d010      	beq.n	800b3b6 <vSocketSelect+0x46>
                FreeRTOS_Socket_t * pxSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800b394:	68e5      	ldr	r5, [r4, #12]
                if( pxSocket->pxSocketSet != pxSocketSet )
 800b396:	6c2b      	ldr	r3, [r5, #64]	@ 0x40
 800b398:	42bb      	cmp	r3, r7
 800b39a:	d1f8      	bne.n	800b38e <vSocketSelect+0x1e>
                    if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800b39c:	f895 303b 	ldrb.w	r3, [r5, #59]	@ 0x3b
 800b3a0:	2b06      	cmp	r3, #6
 800b3a2:	d0ee      	beq.n	800b382 <vSocketSelect+0x12>
                    if( ( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U ) &&
 800b3a4:	6c68      	ldr	r0, [r5, #68]	@ 0x44
 800b3a6:	f010 0001 	ands.w	r0, r0, #1
 800b3aa:	d0ed      	beq.n	800b388 <vSocketSelect+0x18>
                        ( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
 800b3ac:	6d68      	ldr	r0, [r5, #84]	@ 0x54
                    if( ( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_READ ) != 0U ) &&
 800b3ae:	2800      	cmp	r0, #0
 800b3b0:	d0ea      	beq.n	800b388 <vSocketSelect+0x18>
                        xSocketBits |= ( EventBits_t ) eSELECT_READ;
 800b3b2:	2001      	movs	r0, #1
 800b3b4:	e7e8      	b.n	800b388 <vSocketSelect+0x18>
        for( xRound = 0; xRound <= xLastRound; xRound++ )
 800b3b6:	f109 0901 	add.w	r9, r9, #1
 800b3ba:	f1b9 0f01 	cmp.w	r9, #1
 800b3be:	dc05      	bgt.n	800b3cc <vSocketSelect+0x5c>
            if( xRound == 0 )
 800b3c0:	f1b9 0f00 	cmp.w	r9, #0
 800b3c4:	d0db      	beq.n	800b37e <vSocketSelect+0xe>
                    pxEnd = ( ( const ListItem_t * ) &( xBoundTCPSocketsList.xListEnd ) );
 800b3c6:	4e0c      	ldr	r6, [pc, #48]	@ (800b3f8 <vSocketSelect+0x88>)
            for( pxIterator = listGET_NEXT( pxEnd );
 800b3c8:	6874      	ldr	r4, [r6, #4]
 800b3ca:	e7e1      	b.n	800b390 <vSocketSelect+0x20>
            } /* for( pxIterator ... ) */
        }     /* for( xRound = 0; xRound <= xLastRound; xRound++ ) */

        xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 800b3cc:	2100      	movs	r1, #0
 800b3ce:	6838      	ldr	r0, [r7, #0]
 800b3d0:	f7f8 fc5e 	bl	8003c90 <xEventGroupClearBits>

        /* Now set the necessary bits. */
        xBitsToClear = ( xBitsToClear & ~xGroupBits ) & ( ( EventBits_t ) eSELECT_ALL );
 800b3d4:	ea20 0008 	bic.w	r0, r0, r8
             * and cleared in FreeRTOS_select(). */
            xBitsToClear &= ~( ( EventBits_t ) eSELECT_INTR );
        }
        #endif /* ipconfigSUPPORT_SIGNALS */

        if( xBitsToClear != 0U )
 800b3d8:	f010 010f 	ands.w	r1, r0, #15
 800b3dc:	d106      	bne.n	800b3ec <vSocketSelect+0x7c>
        {
            ( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
        }

        /* Now include eSELECT_CALL_IP to wakeup the caller. */
        ( void ) xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | ( EventBits_t ) eSELECT_CALL_IP );
 800b3de:	f048 0110 	orr.w	r1, r8, #16
 800b3e2:	6838      	ldr	r0, [r7, #0]
 800b3e4:	f7f8 fc77 	bl	8003cd6 <xEventGroupSetBits>
    }
 800b3e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            ( void ) xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
 800b3ec:	6838      	ldr	r0, [r7, #0]
 800b3ee:	f7f8 fc4f 	bl	8003c90 <xEventGroupClearBits>
 800b3f2:	e7f4      	b.n	800b3de <vSocketSelect+0x6e>
 800b3f4:	2001379c 	.word	0x2001379c
 800b3f8:	20013788 	.word	0x20013788

0800b3fc <uxStreamBufferSpace>:
 */
size_t uxStreamBufferSpace( const StreamBuffer_t * const pxBuffer,
                            size_t uxLower,
                            size_t uxUpper )
{
    const size_t uxLength = pxBuffer->LENGTH;
 800b3fc:	6903      	ldr	r3, [r0, #16]
    size_t uxCount = uxLength + uxUpper - uxLower - 1U;
 800b3fe:	441a      	add	r2, r3
 800b400:	1a52      	subs	r2, r2, r1
 800b402:	1e50      	subs	r0, r2, #1

    if( uxCount >= uxLength )
 800b404:	4283      	cmp	r3, r0
 800b406:	d800      	bhi.n	800b40a <uxStreamBufferSpace+0xe>
    {
        uxCount -= uxLength;
 800b408:	1ac0      	subs	r0, r0, r3
    }

    return uxCount;
}
 800b40a:	4770      	bx	lr

0800b40c <uxStreamBufferDistance>:
 */
size_t uxStreamBufferDistance( const StreamBuffer_t * const pxBuffer,
                               size_t uxLower,
                               size_t uxUpper )
{
    const size_t uxLength = pxBuffer->LENGTH;
 800b40c:	6903      	ldr	r3, [r0, #16]
    size_t uxCount = uxLength + uxUpper - uxLower;
 800b40e:	1898      	adds	r0, r3, r2
 800b410:	1a40      	subs	r0, r0, r1

    if( uxCount >= uxLength )
 800b412:	4283      	cmp	r3, r0
 800b414:	d800      	bhi.n	800b418 <uxStreamBufferDistance+0xc>
    {
        uxCount -= uxLength;
 800b416:	1ac0      	subs	r0, r0, r3
    }

    return uxCount;
}
 800b418:	4770      	bx	lr

0800b41a <uxStreamBufferGetSpace>:
 * @param[in] pxBuffer The circular stream buffer.
 * @return The number of items which can still be added to uxHead
 *         before hitting on uxTail
 */
size_t uxStreamBufferGetSpace( const StreamBuffer_t * const pxBuffer )
{
 800b41a:	b508      	push	{r3, lr}
    return uxStreamBufferSpace( pxBuffer, pxBuffer->uxHead, pxBuffer->uxTail );
 800b41c:	6881      	ldr	r1, [r0, #8]
 800b41e:	6802      	ldr	r2, [r0, #0]
 800b420:	f7ff ffec 	bl	800b3fc <uxStreamBufferSpace>
}
 800b424:	bd08      	pop	{r3, pc}

0800b426 <uxStreamBufferFrontSpace>:
 * @param[in] pxBuffer The circular stream buffer.
 * @return Distance between uxFront and uxTail or the number of items
 *         which can still be added to uxFront, before hitting on uxTail.
 */
size_t uxStreamBufferFrontSpace( const StreamBuffer_t * const pxBuffer )
{
 800b426:	b508      	push	{r3, lr}
    return uxStreamBufferSpace( pxBuffer, pxBuffer->uxFront, pxBuffer->uxTail );
 800b428:	68c1      	ldr	r1, [r0, #12]
 800b42a:	6802      	ldr	r2, [r0, #0]
 800b42c:	f7ff ffe6 	bl	800b3fc <uxStreamBufferSpace>
}
 800b430:	bd08      	pop	{r3, pc}

0800b432 <uxStreamBufferGetSize>:
 * @param[in] pxBuffer The circular stream buffer.
 * @return The number of items which can be read from the tail before
 *        reaching the head.
 */
size_t uxStreamBufferGetSize( const StreamBuffer_t * const pxBuffer )
{
 800b432:	b508      	push	{r3, lr}
    return uxStreamBufferDistance( pxBuffer, pxBuffer->uxTail, pxBuffer->uxHead );
 800b434:	6801      	ldr	r1, [r0, #0]
 800b436:	6882      	ldr	r2, [r0, #8]
 800b438:	f7ff ffe8 	bl	800b40c <uxStreamBufferDistance>
}
 800b43c:	bd08      	pop	{r3, pc}

0800b43e <uxStreamBufferMidSpace>:
 *        buffer.
 * @param[in] pxBuffer The circular stream buffer.
 * @return The space between the mid pointer and the head.
 */
size_t uxStreamBufferMidSpace( const StreamBuffer_t * const pxBuffer )
{
 800b43e:	b508      	push	{r3, lr}
    return uxStreamBufferDistance( pxBuffer, pxBuffer->uxMid, pxBuffer->uxHead );
 800b440:	6841      	ldr	r1, [r0, #4]
 800b442:	6882      	ldr	r2, [r0, #8]
 800b444:	f7ff ffe2 	bl	800b40c <uxStreamBufferDistance>
}
 800b448:	bd08      	pop	{r3, pc}

0800b44a <vStreamBufferClear>:
 * @param[in] pxBuffer The circular stream buffer.
 */
void vStreamBufferClear( StreamBuffer_t * const pxBuffer )
{
    /* Make the circular buffer empty */
    pxBuffer->uxHead = 0U;
 800b44a:	2300      	movs	r3, #0
 800b44c:	6083      	str	r3, [r0, #8]
    pxBuffer->uxTail = 0U;
 800b44e:	6003      	str	r3, [r0, #0]
    pxBuffer->uxFront = 0U;
 800b450:	60c3      	str	r3, [r0, #12]
    pxBuffer->uxMid = 0U;
 800b452:	6043      	str	r3, [r0, #4]
}
 800b454:	4770      	bx	lr

0800b456 <vStreamBufferMoveMid>:
 * @param[in] pxBuffer The circular stream buffer.
 * @param[in] uxCount The byte count by which the mid pointer is to be moved.
 */
void vStreamBufferMoveMid( StreamBuffer_t * const pxBuffer,
                           const size_t uxCount )
{
 800b456:	b570      	push	{r4, r5, r6, lr}
 800b458:	4604      	mov	r4, r0
 800b45a:	460d      	mov	r5, r1
    /* Increment uxMid, but no further than uxHead */
    const size_t uxLength = pxBuffer->LENGTH;
 800b45c:	6906      	ldr	r6, [r0, #16]
    const size_t uxSize = uxStreamBufferMidSpace( pxBuffer );
 800b45e:	f7ff ffee 	bl	800b43e <uxStreamBufferMidSpace>
    size_t uxMid = pxBuffer->uxMid;
 800b462:	6863      	ldr	r3, [r4, #4]
    size_t uxMoveCount = uxCount;

    if( uxMoveCount > uxSize )
 800b464:	42a8      	cmp	r0, r5
 800b466:	d300      	bcc.n	800b46a <vStreamBufferMoveMid+0x14>
    size_t uxMoveCount = uxCount;
 800b468:	4628      	mov	r0, r5
    {
        uxMoveCount = uxSize;
    }

    uxMid += uxMoveCount;
 800b46a:	4403      	add	r3, r0

    if( uxMid >= uxLength )
 800b46c:	429e      	cmp	r6, r3
 800b46e:	d800      	bhi.n	800b472 <vStreamBufferMoveMid+0x1c>
    {
        uxMid -= uxLength;
 800b470:	1b9b      	subs	r3, r3, r6
    }

    pxBuffer->uxMid = uxMid;
 800b472:	6063      	str	r3, [r4, #4]
}
 800b474:	bd70      	pop	{r4, r5, r6, pc}

0800b476 <xStreamBufferLessThenEqual>:
BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t * const pxBuffer,
                                       size_t uxLeft,
                                       size_t uxRight )
{
    BaseType_t xReturn = pdFALSE;
    const size_t uxTail = pxBuffer->uxTail;
 800b476:	6803      	ldr	r3, [r0, #0]

    if( ( uxLeft - uxTail ) <= ( uxRight - uxTail ) )
 800b478:	1ac9      	subs	r1, r1, r3
 800b47a:	1ad2      	subs	r2, r2, r3
 800b47c:	4291      	cmp	r1, r2
 800b47e:	d901      	bls.n	800b484 <xStreamBufferLessThenEqual+0xe>
    BaseType_t xReturn = pdFALSE;
 800b480:	2000      	movs	r0, #0
 800b482:	4770      	bx	lr
    {
        xReturn = pdTRUE;
 800b484:	2001      	movs	r0, #1
    }

    return xReturn;
}
 800b486:	4770      	bx	lr

0800b488 <uxStreamBufferGetPtr>:
 *         actual number of available bytes since this is a circular buffer and tail
 *         can loop back to the start of the buffer).
 */
size_t uxStreamBufferGetPtr( StreamBuffer_t * const pxBuffer,
                             uint8_t ** const ppucData )
{
 800b488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b48a:	4605      	mov	r5, r0
 800b48c:	460e      	mov	r6, r1
    const size_t uxNextTail = pxBuffer->uxTail;
 800b48e:	4604      	mov	r4, r0
 800b490:	f854 7b14 	ldr.w	r7, [r4], #20
    const size_t uxSize = uxStreamBufferGetSize( pxBuffer );
 800b494:	f7ff ffcd 	bl	800b432 <uxStreamBufferGetSize>

    /* MISRA Ref 18.4.1 [Usage of +, -, += and -= operators on expression of pointer type]. */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-184. */
    /* coverity[misra_c_2012_rule_18_4_violation] */
    *ppucData = pxBuffer->ucArray + uxNextTail;
 800b498:	443c      	add	r4, r7
 800b49a:	6034      	str	r4, [r6, #0]

    return FreeRTOS_min_size_t( uxSize, pxBuffer->LENGTH - uxNextTail );
 800b49c:	6929      	ldr	r1, [r5, #16]
 800b49e:	1bc9      	subs	r1, r1, r7
 800b4a0:	f7fc fec8 	bl	8008234 <FreeRTOS_min_size_t>
}
 800b4a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800b4a6 <uxStreamBufferAdd>:
 */
size_t uxStreamBufferAdd( StreamBuffer_t * const pxBuffer,
                          size_t uxOffset,
                          const uint8_t * const pucData,
                          size_t uxByteCount )
{
 800b4a6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b4aa:	4604      	mov	r4, r0
 800b4ac:	460d      	mov	r5, r1
 800b4ae:	4617      	mov	r7, r2
 800b4b0:	461e      	mov	r6, r3
    size_t uxCount;
    size_t uxSpace = uxStreamBufferGetSpace( pxBuffer );
 800b4b2:	f7ff ffb2 	bl	800b41a <uxStreamBufferGetSpace>

    /* If uxOffset > 0, items can be placed in front of uxHead */
    if( uxSpace > uxOffset )
 800b4b6:	42a8      	cmp	r0, r5
 800b4b8:	d934      	bls.n	800b524 <uxStreamBufferAdd+0x7e>
    {
        uxSpace -= uxOffset;
 800b4ba:	1b40      	subs	r0, r0, r5
        uxSpace = 0U;
    }

    /* The number of bytes that can be written is the minimum of the number of
     * bytes requested and the number available. */
    uxCount = FreeRTOS_min_size_t( uxSpace, uxByteCount );
 800b4bc:	4631      	mov	r1, r6
 800b4be:	f7fc feb9 	bl	8008234 <FreeRTOS_min_size_t>

    if( uxCount != 0U )
 800b4c2:	4680      	mov	r8, r0
 800b4c4:	b358      	cbz	r0, 800b51e <uxStreamBufferAdd+0x78>
    {
        const size_t uxLength = pxBuffer->LENGTH;
 800b4c6:	f8d4 9010 	ldr.w	r9, [r4, #16]
        size_t uxNextHead = pxBuffer->uxHead;
 800b4ca:	68a6      	ldr	r6, [r4, #8]

        if( uxOffset != 0U )
 800b4cc:	b125      	cbz	r5, 800b4d8 <uxStreamBufferAdd+0x32>
        {
            /* ( uxOffset > 0 ) means: write in front if the uxHead marker */
            uxNextHead += uxOffset;
 800b4ce:	442e      	add	r6, r5

            if( uxNextHead >= uxLength )
 800b4d0:	45b1      	cmp	r9, r6
 800b4d2:	d801      	bhi.n	800b4d8 <uxStreamBufferAdd+0x32>
            {
                uxNextHead -= uxLength;
 800b4d4:	eba6 0609 	sub.w	r6, r6, r9
            }
        }

        if( pucData != NULL )
 800b4d8:	b17f      	cbz	r7, 800b4fa <uxStreamBufferAdd+0x54>
        {
            /* Calculate the number of bytes that can be added in the first
            * write - which may be less than the total number of bytes that need
            * to be added if the buffer will wrap back to the beginning. */
            const size_t uxFirst = FreeRTOS_min_size_t( uxLength - uxNextHead, uxCount );
 800b4da:	4641      	mov	r1, r8
 800b4dc:	eba9 0006 	sub.w	r0, r9, r6
 800b4e0:	f7fc fea8 	bl	8008234 <FreeRTOS_min_size_t>
 800b4e4:	4682      	mov	sl, r0

            /* Write as many bytes as can be written in the first write. */
            ( void ) memcpy( &( pxBuffer->ucArray[ uxNextHead ] ), pucData, uxFirst );
 800b4e6:	f106 0010 	add.w	r0, r6, #16
 800b4ea:	4420      	add	r0, r4
 800b4ec:	4652      	mov	r2, sl
 800b4ee:	4639      	mov	r1, r7
 800b4f0:	3004      	adds	r0, #4
 800b4f2:	f003 fcb8 	bl	800ee66 <memcpy>

            /* If the number of bytes written was less than the number that
             * could be written in the first write... */
            if( uxCount > uxFirst )
 800b4f6:	45d0      	cmp	r8, sl
 800b4f8:	d816      	bhi.n	800b528 <uxStreamBufferAdd+0x82>
            }
        }

        /* The below update to the stream buffer members must happen
         * atomically. */
        vTaskSuspendAll();
 800b4fa:	f7f9 fb8b 	bl	8004c14 <vTaskSuspendAll>
        {
            if( uxOffset == 0U )
 800b4fe:	b92d      	cbnz	r5, 800b50c <uxStreamBufferAdd+0x66>
            {
                /* ( uxOffset == 0 ) means: write at uxHead position */
                uxNextHead += uxCount;
 800b500:	4446      	add	r6, r8

                if( uxNextHead >= uxLength )
 800b502:	45b1      	cmp	r9, r6
 800b504:	d801      	bhi.n	800b50a <uxStreamBufferAdd+0x64>
                {
                    uxNextHead -= uxLength;
 800b506:	eba6 0609 	sub.w	r6, r6, r9
                }

                pxBuffer->uxHead = uxNextHead;
 800b50a:	60a6      	str	r6, [r4, #8]
            }

            if( xStreamBufferLessThenEqual( pxBuffer, pxBuffer->uxFront, uxNextHead ) != pdFALSE )
 800b50c:	68e1      	ldr	r1, [r4, #12]
 800b50e:	4632      	mov	r2, r6
 800b510:	4620      	mov	r0, r4
 800b512:	f7ff ffb0 	bl	800b476 <xStreamBufferLessThenEqual>
 800b516:	b100      	cbz	r0, 800b51a <uxStreamBufferAdd+0x74>
            {
                /* Advance the front pointer */
                pxBuffer->uxFront = uxNextHead;
 800b518:	60e6      	str	r6, [r4, #12]
            }
        }
        ( void ) xTaskResumeAll();
 800b51a:	f7f9 fc15 	bl	8004d48 <xTaskResumeAll>
    }

    return uxCount;
}
 800b51e:	4640      	mov	r0, r8
 800b520:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        uxSpace = 0U;
 800b524:	2000      	movs	r0, #0
 800b526:	e7c9      	b.n	800b4bc <uxStreamBufferAdd+0x16>
                ( void ) memcpy( pxBuffer->ucArray, &( pucData[ uxFirst ] ), uxCount - uxFirst );
 800b528:	eba8 020a 	sub.w	r2, r8, sl
 800b52c:	eb07 010a 	add.w	r1, r7, sl
 800b530:	f104 0014 	add.w	r0, r4, #20
 800b534:	f003 fc97 	bl	800ee66 <memcpy>
 800b538:	e7df      	b.n	800b4fa <uxStreamBufferAdd+0x54>

0800b53a <uxStreamBufferGet>:
size_t uxStreamBufferGet( StreamBuffer_t * const pxBuffer,
                          size_t uxOffset,
                          uint8_t * const pucData,
                          size_t uxMaxCount,
                          BaseType_t xPeek )
{
 800b53a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b53e:	4605      	mov	r5, r0
 800b540:	460c      	mov	r4, r1
 800b542:	4617      	mov	r7, r2
 800b544:	461e      	mov	r6, r3
    size_t uxCount;

    /* How much data is available? */
    size_t uxSize = uxStreamBufferGetSize( pxBuffer );
 800b546:	f7ff ff74 	bl	800b432 <uxStreamBufferGetSize>

    if( uxSize > uxOffset )
 800b54a:	42a0      	cmp	r0, r4
 800b54c:	d92d      	bls.n	800b5aa <uxStreamBufferGet+0x70>
    {
        uxSize -= uxOffset;
 800b54e:	1b00      	subs	r0, r0, r4
    {
        uxSize = 0U;
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    uxCount = FreeRTOS_min_size_t( uxSize, uxMaxCount );
 800b550:	4631      	mov	r1, r6
 800b552:	f7fc fe6f 	bl	8008234 <FreeRTOS_min_size_t>

    if( uxCount != 0U )
 800b556:	4606      	mov	r6, r0
 800b558:	b320      	cbz	r0, 800b5a4 <uxStreamBufferGet+0x6a>
    {
        const size_t uxLength = pxBuffer->LENGTH;
 800b55a:	f8d5 a010 	ldr.w	sl, [r5, #16]
        size_t uxNextTail = pxBuffer->uxTail;
 800b55e:	f8d5 8000 	ldr.w	r8, [r5]

        if( uxOffset != 0U )
 800b562:	b124      	cbz	r4, 800b56e <uxStreamBufferGet+0x34>
        {
            uxNextTail += uxOffset;
 800b564:	44a0      	add	r8, r4

            if( uxNextTail >= uxLength )
 800b566:	45c2      	cmp	sl, r8
 800b568:	d801      	bhi.n	800b56e <uxStreamBufferGet+0x34>
            {
                uxNextTail -= uxLength;
 800b56a:	eba8 080a 	sub.w	r8, r8, sl
            }
        }

        if( pucData != NULL )
 800b56e:	b17f      	cbz	r7, 800b590 <uxStreamBufferGet+0x56>
        {
            /* Calculate the number of bytes that can be read - which may be
             * less than the number wanted if the data wraps around to the start of
             * the buffer. */
            const size_t uxFirst = FreeRTOS_min_size_t( uxLength - uxNextTail, uxCount );
 800b570:	4631      	mov	r1, r6
 800b572:	ebaa 0008 	sub.w	r0, sl, r8
 800b576:	f7fc fe5d 	bl	8008234 <FreeRTOS_min_size_t>
 800b57a:	4681      	mov	r9, r0

            /* Obtain the number of bytes it is possible to obtain in the first
             * read. */
            ( void ) memcpy( pucData, &( pxBuffer->ucArray[ uxNextTail ] ), uxFirst );
 800b57c:	f108 0110 	add.w	r1, r8, #16
 800b580:	4429      	add	r1, r5
 800b582:	4602      	mov	r2, r0
 800b584:	3104      	adds	r1, #4
 800b586:	4638      	mov	r0, r7
 800b588:	f003 fc6d 	bl	800ee66 <memcpy>

            /* If the total number of wanted bytes is greater than the number
             * that could be read in the first read... */
            if( uxCount > uxFirst )
 800b58c:	454e      	cmp	r6, r9
 800b58e:	d80e      	bhi.n	800b5ae <uxStreamBufferGet+0x74>
                /* ...then read the remaining bytes from the start of the buffer. */
                ( void ) memcpy( &( pucData[ uxFirst ] ), pxBuffer->ucArray, uxCount - uxFirst );
            }
        }

        if( ( xPeek == pdFALSE ) && ( uxOffset == 0U ) )
 800b590:	9b08      	ldr	r3, [sp, #32]
 800b592:	b93b      	cbnz	r3, 800b5a4 <uxStreamBufferGet+0x6a>
 800b594:	b934      	cbnz	r4, 800b5a4 <uxStreamBufferGet+0x6a>
        {
            /* Move the tail pointer to effectively remove the data read from
             * the buffer. */
            uxNextTail += uxCount;
 800b596:	eb08 0306 	add.w	r3, r8, r6

            if( uxNextTail >= uxLength )
 800b59a:	459a      	cmp	sl, r3
 800b59c:	d801      	bhi.n	800b5a2 <uxStreamBufferGet+0x68>
            {
                uxNextTail -= uxLength;
 800b59e:	eba3 030a 	sub.w	r3, r3, sl
            }

            pxBuffer->uxTail = uxNextTail;
 800b5a2:	602b      	str	r3, [r5, #0]
        }
    }

    return uxCount;
}
 800b5a4:	4630      	mov	r0, r6
 800b5a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        uxSize = 0U;
 800b5aa:	2000      	movs	r0, #0
 800b5ac:	e7d0      	b.n	800b550 <uxStreamBufferGet+0x16>
                ( void ) memcpy( &( pucData[ uxFirst ] ), pxBuffer->ucArray, uxCount - uxFirst );
 800b5ae:	eba6 0209 	sub.w	r2, r6, r9
 800b5b2:	f105 0114 	add.w	r1, r5, #20
 800b5b6:	eb07 0009 	add.w	r0, r7, r9
 800b5ba:	f003 fc54 	bl	800ee66 <memcpy>
 800b5be:	e7e7      	b.n	800b590 <uxStreamBufferGet+0x56>

0800b5c0 <vTCPRemoveTCPChild>:
        const ListItem_t * pxEnd = ( ( const ListItem_t * ) &( xBoundTCPSocketsList.xListEnd ) );

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const ListItem_t * pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800b5c0:	4b0b      	ldr	r3, [pc, #44]	@ (800b5f0 <vTCPRemoveTCPChild+0x30>)
 800b5c2:	68db      	ldr	r3, [r3, #12]

        while( pxIterator != pxEnd )
 800b5c4:	4a0b      	ldr	r2, [pc, #44]	@ (800b5f4 <vTCPRemoveTCPChild+0x34>)
 800b5c6:	4293      	cmp	r3, r2
 800b5c8:	d00f      	beq.n	800b5ea <vTCPRemoveTCPChild+0x2a>
        {
            FreeRTOS_Socket_t * pxSocket;
            pxSocket = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800b5ca:	68da      	ldr	r2, [r3, #12]
            pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 800b5cc:	685b      	ldr	r3, [r3, #4]

            if( ( pxSocket != pxChildSocket ) && ( pxSocket->usLocalPort == pxChildSocket->usLocalPort ) )
 800b5ce:	4282      	cmp	r2, r0
 800b5d0:	d0f8      	beq.n	800b5c4 <vTCPRemoveTCPChild+0x4>
 800b5d2:	f8b2 c038 	ldrh.w	ip, [r2, #56]	@ 0x38
 800b5d6:	8f01      	ldrh	r1, [r0, #56]	@ 0x38
 800b5d8:	458c      	cmp	ip, r1
 800b5da:	d1f3      	bne.n	800b5c4 <vTCPRemoveTCPChild+0x4>
            {
                if( pxSocket->u.xTCP.pxPeerSocket == pxChildSocket ) /**< for server socket: child, for child socket: parent */
 800b5dc:	6fd1      	ldr	r1, [r2, #124]	@ 0x7c
 800b5de:	4281      	cmp	r1, r0
 800b5e0:	d1f0      	bne.n	800b5c4 <vTCPRemoveTCPChild+0x4>
                {
                    pxSocket->u.xTCP.pxPeerSocket = NULL;
 800b5e2:	2300      	movs	r3, #0
 800b5e4:	67d3      	str	r3, [r2, #124]	@ 0x7c
                    xReturn = pdTRUE;
 800b5e6:	2001      	movs	r0, #1
                    break;
 800b5e8:	4770      	bx	lr
        BaseType_t xReturn = pdFALSE;
 800b5ea:	2000      	movs	r0, #0
                }
            }
        }

        return xReturn;
    }
 800b5ec:	4770      	bx	lr
 800b5ee:	bf00      	nop
 800b5f0:	20013780 	.word	0x20013780
 800b5f4:	20013788 	.word	0x20013788

0800b5f8 <xGetSourceAddrFromBuffer>:
 * @param[in] pucEthernetBuffer The Ethernet buffer from which the source address will be retrieved.
 *
 * @return IPv46_Address_t struct containing the source IP address.
 */
    static IPv46_Address_t xGetSourceAddrFromBuffer( const uint8_t * const pucEthernetBuffer )
    {
 800b5f8:	4684      	mov	ip, r0
 800b5fa:	460b      	mov	r3, r1
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const EthernetHeader_t * pxHeader = ( ( const EthernetHeader_t * ) pucEthernetBuffer );

        if( pxHeader->usFrameType == ( uint16_t ) ipIPv6_FRAME_TYPE )
 800b5fc:	8989      	ldrh	r1, [r1, #12]
 800b5fe:	f64d 5286 	movw	r2, #56710	@ 0xdd86
 800b602:	4291      	cmp	r1, r2
 800b604:	d010      	beq.n	800b628 <xGetSourceAddrFromBuffer+0x30>
            /* Map the ethernet buffer onto the IPHeader_t struct for easy access to the fields. */
            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            const IPHeader_t * const pxIPHeader = ( ( const IPHeader_t * ) &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
            xSourceAddr.xIs_IPv6 = pdFALSE;
 800b606:	2200      	movs	r2, #0
 800b608:	6102      	str	r2, [r0, #16]
            xSourceAddr.xIPAddress.ulIP_IPv4 = FreeRTOS_htonl( pxIPHeader->ulSourceIPAddress );
 800b60a:	f8d3 201a 	ldr.w	r2, [r3, #26]
 800b60e:	0213      	lsls	r3, r2, #8
 800b610:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800b614:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800b618:	0a11      	lsrs	r1, r2, #8
 800b61a:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800b61e:	430b      	orrs	r3, r1
 800b620:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800b624:	6003      	str	r3, [r0, #0]
        }

        return xSourceAddr;
    }
 800b626:	4770      	bx	lr
    {
 800b628:	b500      	push	{lr}
            xSourceAddr.xIs_IPv6 = pdTRUE;
 800b62a:	2201      	movs	r2, #1
 800b62c:	6102      	str	r2, [r0, #16]
            ( void ) memcpy( xSourceAddr.xIPAddress.xIP_IPv6.ucBytes, pxIPHeader_IPv6->xSourceAddress.ucBytes, sizeof( IPv6_Address_t ) );
 800b62e:	4686      	mov	lr, r0
 800b630:	f8d3 0016 	ldr.w	r0, [r3, #22]
 800b634:	f8d3 101a 	ldr.w	r1, [r3, #26]
 800b638:	f8d3 201e 	ldr.w	r2, [r3, #30]
 800b63c:	f8d3 3022 	ldr.w	r3, [r3, #34]	@ 0x22
 800b640:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    }
 800b644:	4660      	mov	r0, ip
 800b646:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800b64c <vSocketCloseNextTime>:
    {
 800b64c:	b510      	push	{r4, lr}
 800b64e:	4604      	mov	r4, r0
        if( ( xSocketToClose != NULL ) && ( xSocketToClose != pxSocket ) )
 800b650:	4b04      	ldr	r3, [pc, #16]	@ (800b664 <vSocketCloseNextTime+0x18>)
 800b652:	6818      	ldr	r0, [r3, #0]
 800b654:	b118      	cbz	r0, 800b65e <vSocketCloseNextTime+0x12>
 800b656:	42a0      	cmp	r0, r4
 800b658:	d001      	beq.n	800b65e <vSocketCloseNextTime+0x12>
            ( void ) vSocketClose( xSocketToClose );
 800b65a:	f7fe ffc8 	bl	800a5ee <vSocketClose>
        xSocketToClose = pxSocket;
 800b65e:	4b01      	ldr	r3, [pc, #4]	@ (800b664 <vSocketCloseNextTime+0x18>)
 800b660:	601c      	str	r4, [r3, #0]
    }
 800b662:	bd10      	pop	{r4, pc}
 800b664:	200137ac 	.word	0x200137ac

0800b668 <vSocketListenNextTime>:
    {
 800b668:	b510      	push	{r4, lr}
 800b66a:	4604      	mov	r4, r0
        if( ( xSocketToListen != NULL ) && ( xSocketToListen != pxSocket ) )
 800b66c:	4b05      	ldr	r3, [pc, #20]	@ (800b684 <vSocketListenNextTime+0x1c>)
 800b66e:	6818      	ldr	r0, [r3, #0]
 800b670:	b128      	cbz	r0, 800b67e <vSocketListenNextTime+0x16>
 800b672:	42a0      	cmp	r0, r4
 800b674:	d003      	beq.n	800b67e <vSocketListenNextTime+0x16>
            ( void ) FreeRTOS_listen( ( Socket_t ) xSocketToListen, ( BaseType_t ) ( xSocketToListen->u.xTCP.usBacklog ) );
 800b676:	f8b0 1076 	ldrh.w	r1, [r0, #118]	@ 0x76
 800b67a:	f7ff fbc7 	bl	800ae0c <FreeRTOS_listen>
        xSocketToListen = pxSocket;
 800b67e:	4b01      	ldr	r3, [pc, #4]	@ (800b684 <vSocketListenNextTime+0x1c>)
 800b680:	601c      	str	r4, [r3, #0]
    }
 800b682:	bd10      	pop	{r4, pc}
 800b684:	200137a8 	.word	0x200137a8

0800b688 <prvTCPTouchSocket>:
    {
 800b688:	b510      	push	{r4, lr}
 800b68a:	4604      	mov	r4, r0
            pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount();
 800b68c:	f7f9 faca 	bl	8004c24 <xTaskGetTickCount>
 800b690:	f8c4 0088 	str.w	r0, [r4, #136]	@ 0x88
            pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 800b694:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800b698:	f023 0304 	bic.w	r3, r3, #4
 800b69c:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
            pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800b6a0:	b2db      	uxtb	r3, r3
 800b6a2:	f023 0302 	bic.w	r3, r3, #2
 800b6a6:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
            pxSocket->u.xTCP.ucKeepRepCount = 0U;
 800b6aa:	2300      	movs	r3, #0
 800b6ac:	f884 3080 	strb.w	r3, [r4, #128]	@ 0x80
            pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 800b6b0:	f7f9 fab8 	bl	8004c24 <xTaskGetTickCount>
 800b6b4:	f8c4 0084 	str.w	r0, [r4, #132]	@ 0x84
    }
 800b6b8:	bd10      	pop	{r4, pc}
	...

0800b6bc <vTCPStateChange>:
    {
 800b6bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b6be:	b08d      	sub	sp, #52	@ 0x34
 800b6c0:	4604      	mov	r4, r0
 800b6c2:	460d      	mov	r5, r1
        BaseType_t bBefore = tcpNOW_CONNECTED( ( BaseType_t ) pxSocket->u.xTCP.eTCPState ); /* Was it connected ? */
 800b6c4:	f890 7079 	ldrb.w	r7, [r0, #121]	@ 0x79
 800b6c8:	2f04      	cmp	r7, #4
 800b6ca:	d905      	bls.n	800b6d8 <vTCPStateChange+0x1c>
 800b6cc:	2f08      	cmp	r7, #8
 800b6ce:	d001      	beq.n	800b6d4 <vTCPStateChange+0x18>
 800b6d0:	2101      	movs	r1, #1
 800b6d2:	e002      	b.n	800b6da <vTCPStateChange+0x1e>
 800b6d4:	2100      	movs	r1, #0
 800b6d6:	e000      	b.n	800b6da <vTCPStateChange+0x1e>
 800b6d8:	2100      	movs	r1, #0
        BaseType_t bAfter = tcpNOW_CONNECTED( ( BaseType_t ) eTCPState );                   /* Is it connected now ? */
 800b6da:	2d04      	cmp	r5, #4
 800b6dc:	d905      	bls.n	800b6ea <vTCPStateChange+0x2e>
 800b6de:	2d08      	cmp	r5, #8
 800b6e0:	d001      	beq.n	800b6e6 <vTCPStateChange+0x2a>
 800b6e2:	2201      	movs	r2, #1
 800b6e4:	e002      	b.n	800b6ec <vTCPStateChange+0x30>
 800b6e6:	2200      	movs	r2, #0
 800b6e8:	e000      	b.n	800b6ec <vTCPStateChange+0x30>
 800b6ea:	2200      	movs	r2, #0
              ( xPreviousState == eSYN_FIRST ) ||
 800b6ec:	1ebb      	subs	r3, r7, #2
 800b6ee:	b2db      	uxtb	r3, r3
        if( ( ( xPreviousState == eCONNECT_SYN ) ||
 800b6f0:	2b02      	cmp	r3, #2
 800b6f2:	d801      	bhi.n	800b6f8 <vTCPStateChange+0x3c>
              ( xPreviousState == eSYN_RECEIVED ) ) &&
 800b6f4:	2d08      	cmp	r5, #8
 800b6f6:	d014      	beq.n	800b722 <vTCPStateChange+0x66>
        if( bBefore != bAfter )
 800b6f8:	4291      	cmp	r1, r2
 800b6fa:	d058      	beq.n	800b7ae <vTCPStateChange+0xf2>
            if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 800b6fc:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800b700:	f013 0104 	ands.w	r1, r3, #4
 800b704:	d00f      	beq.n	800b726 <vTCPStateChange+0x6a>
                if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 800b706:	f013 0f08 	tst.w	r3, #8
 800b70a:	d134      	bne.n	800b776 <vTCPStateChange+0xba>
                    xParent = pxSocket->u.xTCP.pxPeerSocket;
 800b70c:	6fe6      	ldr	r6, [r4, #124]	@ 0x7c
                    configASSERT( xParent != NULL );
 800b70e:	b95e      	cbnz	r6, 800b728 <vTCPStateChange+0x6c>
 800b710:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800b714:	f383 8811 	msr	BASEPRI, r3
 800b718:	f3bf 8f6f 	isb	sy
 800b71c:	f3bf 8f4f 	dsb	sy
 800b720:	e7fe      	b.n	800b720 <vTCPStateChange+0x64>
            bBefore = pdTRUE;
 800b722:	2101      	movs	r1, #1
 800b724:	e7e8      	b.n	800b6f8 <vTCPStateChange+0x3c>
        FreeRTOS_Socket_t * xParent = pxSocket;
 800b726:	4626      	mov	r6, r4
            if( bAfter != pdFALSE )
 800b728:	2a00      	cmp	r2, #0
 800b72a:	d034      	beq.n	800b796 <vTCPStateChange+0xda>
                if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 800b72c:	b339      	cbz	r1, 800b77e <vTCPStateChange+0xc2>
                    if( xParent != NULL )
 800b72e:	b166      	cbz	r6, 800b74a <vTCPStateChange+0x8e>
                        if( xParent->u.xTCP.pxPeerSocket == NULL )
 800b730:	6ff3      	ldr	r3, [r6, #124]	@ 0x7c
 800b732:	b313      	cbz	r3, 800b77a <vTCPStateChange+0xbe>
                        xParent->xEventBits |= ( EventBits_t ) eSOCKET_ACCEPT;
 800b734:	6833      	ldr	r3, [r6, #0]
 800b736:	f043 0204 	orr.w	r2, r3, #4
 800b73a:	6032      	str	r2, [r6, #0]
                            if( ( xParent->xSelectBits & ( ( EventBits_t ) eSELECT_READ ) ) != 0U )
 800b73c:	6c72      	ldr	r2, [r6, #68]	@ 0x44
 800b73e:	f012 0f01 	tst.w	r2, #1
 800b742:	d002      	beq.n	800b74a <vTCPStateChange+0x8e>
                                xParent->xEventBits |= ( ( EventBits_t ) eSELECT_READ ) << SOCKET_EVENT_BIT_COUNT;
 800b744:	f443 7382 	orr.w	r3, r3, #260	@ 0x104
 800b748:	6033      	str	r3, [r6, #0]
                    pxSocket->u.xTCP.pxPeerSocket = NULL;
 800b74a:	2200      	movs	r2, #0
 800b74c:	67e2      	str	r2, [r4, #124]	@ 0x7c
                    pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 800b74e:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800b752:	f362 0382 	bfi	r3, r2, #2, #1
 800b756:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
                    pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
 800b75a:	b2db      	uxtb	r3, r3
 800b75c:	f043 0302 	orr.w	r3, r3, #2
 800b760:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
            if( prvTCPSocketIsActive( pxSocket->u.xTCP.eTCPState ) == 0 )
 800b764:	f894 0079 	ldrb.w	r0, [r4, #121]	@ 0x79
 800b768:	f000 fe00 	bl	800c36c <prvTCPSocketIsActive>
 800b76c:	bb00      	cbnz	r0, 800b7b0 <vTCPStateChange+0xf4>
                pxSocket->u.xTCP.usTimeout = 0U;
 800b76e:	2300      	movs	r3, #0
 800b770:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
 800b774:	e01c      	b.n	800b7b0 <vTCPStateChange+0xf4>
        FreeRTOS_Socket_t * xParent = pxSocket;
 800b776:	4626      	mov	r6, r4
 800b778:	e7d6      	b.n	800b728 <vTCPStateChange+0x6c>
                            xParent->u.xTCP.pxPeerSocket = pxSocket;
 800b77a:	67f4      	str	r4, [r6, #124]	@ 0x7c
 800b77c:	e7da      	b.n	800b734 <vTCPStateChange+0x78>
                    pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_CONNECT;
 800b77e:	6823      	ldr	r3, [r4, #0]
 800b780:	f043 0208 	orr.w	r2, r3, #8
 800b784:	6022      	str	r2, [r4, #0]
                        if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_WRITE ) ) != 0U )
 800b786:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 800b788:	f012 0f02 	tst.w	r2, #2
 800b78c:	d0ea      	beq.n	800b764 <vTCPStateChange+0xa8>
                            pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
 800b78e:	f443 7302 	orr.w	r3, r3, #520	@ 0x208
 800b792:	6023      	str	r3, [r4, #0]
 800b794:	e7e6      	b.n	800b764 <vTCPStateChange+0xa8>
                xParent->xEventBits |= ( EventBits_t ) eSOCKET_CLOSED;
 800b796:	6833      	ldr	r3, [r6, #0]
 800b798:	f043 0220 	orr.w	r2, r3, #32
 800b79c:	6032      	str	r2, [r6, #0]
                    if( ( xParent->xSelectBits & ( EventBits_t ) eSELECT_EXCEPT ) != 0U )
 800b79e:	6c72      	ldr	r2, [r6, #68]	@ 0x44
 800b7a0:	f012 0f04 	tst.w	r2, #4
 800b7a4:	d0de      	beq.n	800b764 <vTCPStateChange+0xa8>
                        xParent->xEventBits |= ( ( EventBits_t ) eSELECT_EXCEPT ) << SOCKET_EVENT_BIT_COUNT;
 800b7a6:	f443 6384 	orr.w	r3, r3, #1056	@ 0x420
 800b7aa:	6033      	str	r3, [r6, #0]
 800b7ac:	e7da      	b.n	800b764 <vTCPStateChange+0xa8>
        FreeRTOS_Socket_t * xParent = pxSocket;
 800b7ae:	4626      	mov	r6, r4
        pxSocket->u.xTCP.eTCPState = eTCPState;
 800b7b0:	f884 5079 	strb.w	r5, [r4, #121]	@ 0x79
        if( ( eTCPState == eCLOSED ) ||
 800b7b4:	b10d      	cbz	r5, 800b7ba <vTCPStateChange+0xfe>
 800b7b6:	2d08      	cmp	r5, #8
 800b7b8:	d10f      	bne.n	800b7da <vTCPStateChange+0x11e>
            if( ( xParent == pxSocket ) && ( pxSocket->u.xTCP.pxPeerSocket != NULL ) )
 800b7ba:	42a6      	cmp	r6, r4
 800b7bc:	d023      	beq.n	800b806 <vTCPStateChange+0x14a>
            vTaskSuspendAll();
 800b7be:	f7f9 fa29 	bl	8004c14 <vTaskSuspendAll>
                if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 800b7c2:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800b7c6:	f013 0f06 	tst.w	r3, #6
 800b7ca:	d002      	beq.n	800b7d2 <vTCPStateChange+0x116>
                    if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 800b7cc:	f013 0f08 	tst.w	r3, #8
 800b7d0:	d01e      	beq.n	800b810 <vTCPStateChange+0x154>
            ( void ) xTaskResumeAll();
 800b7d2:	f7f9 fab9 	bl	8004d48 <xTaskResumeAll>
        if( ( eTCPState == eCLOSE_WAIT ) && ( pxSocket->u.xTCP.bits.bReuseSocket == pdTRUE_UNSIGNED ) )
 800b7d6:	2d08      	cmp	r5, #8
 800b7d8:	d038      	beq.n	800b84c <vTCPStateChange+0x190>
        prvTCPTouchSocket( pxSocket );
 800b7da:	4620      	mov	r0, r4
 800b7dc:	f7ff ff54 	bl	800b688 <prvTCPTouchSocket>
            if( ( xTCPWindowLoggingLevel >= 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) ) )
 800b7e0:	4b30      	ldr	r3, [pc, #192]	@ (800b8a4 <vTCPStateChange+0x1e8>)
 800b7e2:	681b      	ldr	r3, [r3, #0]
 800b7e4:	2b00      	cmp	r3, #0
 800b7e6:	db08      	blt.n	800b7fa <vTCPStateChange+0x13e>
 800b7e8:	8f23      	ldrh	r3, [r4, #56]	@ 0x38
 800b7ea:	2b17      	cmp	r3, #23
 800b7ec:	d005      	beq.n	800b7fa <vTCPStateChange+0x13e>
                switch( pxSocket->bits.bIsIPv6 ) /* LCOV_EXCL_BR_LINE */
 800b7ee:	7a23      	ldrb	r3, [r4, #8]
 800b7f0:	f013 0301 	ands.w	r3, r3, #1
 800b7f4:	d039      	beq.n	800b86a <vTCPStateChange+0x1ae>
 800b7f6:	2b00      	cmp	r3, #0
 800b7f8:	d14b      	bne.n	800b892 <vTCPStateChange+0x1d6>
        if( xParent != NULL )
 800b7fa:	b116      	cbz	r6, 800b802 <vTCPStateChange+0x146>
            vSocketWakeUpUser( xParent );
 800b7fc:	4630      	mov	r0, r6
 800b7fe:	f7ff f814 	bl	800a82a <vSocketWakeUpUser>
    }
 800b802:	b00d      	add	sp, #52	@ 0x34
 800b804:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( xParent == pxSocket ) && ( pxSocket->u.xTCP.pxPeerSocket != NULL ) )
 800b806:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800b808:	2b00      	cmp	r3, #0
 800b80a:	d0d8      	beq.n	800b7be <vTCPStateChange+0x102>
                xParent = pxSocket->u.xTCP.pxPeerSocket;
 800b80c:	461e      	mov	r6, r3
 800b80e:	e7d6      	b.n	800b7be <vTCPStateChange+0x102>
                        xHasCleared = vTCPRemoveTCPChild( pxSocket );
 800b810:	4620      	mov	r0, r4
 800b812:	f7ff fed5 	bl	800b5c0 <vTCPRemoveTCPChild>
                        pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 800b816:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800b81a:	f023 0304 	bic.w	r3, r3, #4
 800b81e:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
                        pxSocket->u.xTCP.bits.bPassAccept = pdFALSE_UNSIGNED;
 800b822:	b2db      	uxtb	r3, r3
 800b824:	f023 0302 	bic.w	r3, r3, #2
 800b828:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
                        configASSERT( xIsCallingFromIPTask() != pdFALSE );
 800b82c:	f7fc facb 	bl	8007dc6 <xIsCallingFromIPTask>
 800b830:	b940      	cbnz	r0, 800b844 <vTCPStateChange+0x188>
 800b832:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800b836:	f383 8811 	msr	BASEPRI, r3
 800b83a:	f3bf 8f6f 	isb	sy
 800b83e:	f3bf 8f4f 	dsb	sy
 800b842:	e7fe      	b.n	800b842 <vTCPStateChange+0x186>
                        vSocketCloseNextTime( pxSocket );
 800b844:	4620      	mov	r0, r4
 800b846:	f7ff ff01 	bl	800b64c <vSocketCloseNextTime>
 800b84a:	e7c2      	b.n	800b7d2 <vTCPStateChange+0x116>
        if( ( eTCPState == eCLOSE_WAIT ) && ( pxSocket->u.xTCP.bits.bReuseSocket == pdTRUE_UNSIGNED ) )
 800b84c:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800b850:	f013 0f08 	tst.w	r3, #8
 800b854:	d0c1      	beq.n	800b7da <vTCPStateChange+0x11e>
            switch( xPreviousState )
 800b856:	3f03      	subs	r7, #3
 800b858:	2f01      	cmp	r7, #1
 800b85a:	d8be      	bhi.n	800b7da <vTCPStateChange+0x11e>
                    pxSocket->u.xTCP.eTCPState = eCLOSED;
 800b85c:	2300      	movs	r3, #0
 800b85e:	f884 3079 	strb.w	r3, [r4, #121]	@ 0x79
                    vSocketListenNextTime( pxSocket );
 800b862:	4620      	mov	r0, r4
 800b864:	f7ff ff00 	bl	800b668 <vSocketListenNextTime>
                    break;
 800b868:	e7b7      	b.n	800b7da <vTCPStateChange+0x11e>
                               uint32_t ulIPAddress = FreeRTOS_ntohl( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 );
 800b86a:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800b86c:	0213      	lsls	r3, r2, #8
 800b86e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800b872:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800b876:	0a11      	lsrs	r1, r2, #8
 800b878:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800b87c:	430b      	orrs	r3, r1
 800b87e:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800b882:	9301      	str	r3, [sp, #4]
                               FreeRTOS_inet_ntop( FREERTOS_AF_INET4,
 800b884:	2328      	movs	r3, #40	@ 0x28
 800b886:	aa02      	add	r2, sp, #8
 800b888:	a901      	add	r1, sp, #4
 800b88a:	2002      	movs	r0, #2
 800b88c:	f7fe ff84 	bl	800a798 <FreeRTOS_inet_ntop>
                           break;
 800b890:	e7b3      	b.n	800b7fa <vTCPStateChange+0x13e>
                            FreeRTOS_inet_ntop( FREERTOS_AF_INET6,
 800b892:	2328      	movs	r3, #40	@ 0x28
 800b894:	aa02      	add	r2, sp, #8
 800b896:	f104 0154 	add.w	r1, r4, #84	@ 0x54
 800b89a:	200a      	movs	r0, #10
 800b89c:	f7fe ff7c 	bl	800a798 <FreeRTOS_inet_ntop>
                            break;
 800b8a0:	e7ab      	b.n	800b7fa <vTCPStateChange+0x13e>
 800b8a2:	bf00      	nop
 800b8a4:	200137b0 	.word	0x200137b0

0800b8a8 <prvTCPNextTimeout>:
    {
 800b8a8:	b510      	push	{r4, lr}
 800b8aa:	b082      	sub	sp, #8
 800b8ac:	4604      	mov	r4, r0
        TickType_t ulDelayMs = ( TickType_t ) tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
 800b8ae:	f644 6320 	movw	r3, #20000	@ 0x4e20
 800b8b2:	9301      	str	r3, [sp, #4]
        if( pxSocket->u.xTCP.eTCPState == eCONNECT_SYN )
 800b8b4:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79
 800b8b8:	2b02      	cmp	r3, #2
 800b8ba:	d006      	beq.n	800b8ca <prvTCPNextTimeout+0x22>
        else if( pxSocket->u.xTCP.usTimeout == 0U )
 800b8bc:	f8b0 3070 	ldrh.w	r3, [r0, #112]	@ 0x70
 800b8c0:	b373      	cbz	r3, 800b920 <prvTCPNextTimeout+0x78>
    }
 800b8c2:	f8b4 0070 	ldrh.w	r0, [r4, #112]	@ 0x70
 800b8c6:	b002      	add	sp, #8
 800b8c8:	bd10      	pop	{r4, pc}
            if( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED )
 800b8ca:	f890 3069 	ldrb.w	r3, [r0, #105]	@ 0x69
 800b8ce:	f013 0f08 	tst.w	r3, #8
 800b8d2:	d011      	beq.n	800b8f8 <prvTCPNextTimeout+0x50>
                if( pxSocket->u.xTCP.ucRepCount < 3U )
 800b8d4:	f890 3078 	ldrb.w	r3, [r0, #120]	@ 0x78
 800b8d8:	2b02      	cmp	r3, #2
 800b8da:	d809      	bhi.n	800b8f0 <prvTCPNextTimeout+0x48>
                    if( pxSocket->u.xTCP.ucRepCount == 0U )
 800b8dc:	b90b      	cbnz	r3, 800b8e2 <prvTCPNextTimeout+0x3a>
                        ulDelayMs = 0U;
 800b8de:	9301      	str	r3, [sp, #4]
 800b8e0:	e00d      	b.n	800b8fe <prvTCPNextTimeout+0x56>
                        ulDelayMs = ( ( uint32_t ) 3000U ) << ( pxSocket->u.xTCP.ucRepCount - 1U );
 800b8e2:	3b01      	subs	r3, #1
 800b8e4:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 800b8e8:	fa02 f303 	lsl.w	r3, r2, r3
 800b8ec:	9301      	str	r3, [sp, #4]
 800b8ee:	e006      	b.n	800b8fe <prvTCPNextTimeout+0x56>
                    ulDelayMs = 11000U;
 800b8f0:	f642 23f8 	movw	r3, #11000	@ 0x2af8
 800b8f4:	9301      	str	r3, [sp, #4]
 800b8f6:	e002      	b.n	800b8fe <prvTCPNextTimeout+0x56>
                ulDelayMs = 500U;
 800b8f8:	f44f 73fa 	mov.w	r3, #500	@ 0x1f4
 800b8fc:	9301      	str	r3, [sp, #4]
            pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( ulDelayMs );
 800b8fe:	9b01      	ldr	r3, [sp, #4]
 800b900:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800b904:	fb02 f303 	mul.w	r3, r2, r3
 800b908:	4293      	cmp	r3, r2
 800b90a:	d307      	bcc.n	800b91c <prvTCPNextTimeout+0x74>
 800b90c:	4a15      	ldr	r2, [pc, #84]	@ (800b964 <prvTCPNextTimeout+0xbc>)
 800b90e:	fba2 2303 	umull	r2, r3, r2, r3
 800b912:	f3c3 138f 	ubfx	r3, r3, #6, #16
 800b916:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
 800b91a:	e7d2      	b.n	800b8c2 <prvTCPNextTimeout+0x1a>
 800b91c:	2301      	movs	r3, #1
 800b91e:	e7fa      	b.n	800b916 <prvTCPNextTimeout+0x6e>
            BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs );
 800b920:	aa01      	add	r2, sp, #4
 800b922:	f8d0 1108 	ldr.w	r1, [r0, #264]	@ 0x108
 800b926:	f500 708a 	add.w	r0, r0, #276	@ 0x114
 800b92a:	f002 fb5a 	bl	800dfe2 <xTCPWindowTxHasData>
            if( ulDelayMs == 0U )
 800b92e:	9b01      	ldr	r3, [sp, #4]
 800b930:	b913      	cbnz	r3, 800b938 <prvTCPNextTimeout+0x90>
                if( xResult != ( BaseType_t ) 0 )
 800b932:	b170      	cbz	r0, 800b952 <prvTCPNextTimeout+0xaa>
                    ulDelayMs = 1U;
 800b934:	2301      	movs	r3, #1
 800b936:	9301      	str	r3, [sp, #4]
            pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( ulDelayMs ); /* LCOV_EXCL_BR_LINE ulDelayMs will not be smaller than 1 */
 800b938:	9b01      	ldr	r3, [sp, #4]
 800b93a:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800b93e:	fb02 f303 	mul.w	r3, r2, r3
 800b942:	4293      	cmp	r3, r2
 800b944:	d309      	bcc.n	800b95a <prvTCPNextTimeout+0xb2>
 800b946:	4a07      	ldr	r2, [pc, #28]	@ (800b964 <prvTCPNextTimeout+0xbc>)
 800b948:	fba2 2303 	umull	r2, r3, r2, r3
 800b94c:	f3c3 138f 	ubfx	r3, r3, #6, #16
 800b950:	e004      	b.n	800b95c <prvTCPNextTimeout+0xb4>
                    ulDelayMs = tcpMAXIMUM_TCP_WAKEUP_TIME_MS;
 800b952:	f644 6320 	movw	r3, #20000	@ 0x4e20
 800b956:	9301      	str	r3, [sp, #4]
 800b958:	e7ee      	b.n	800b938 <prvTCPNextTimeout+0x90>
            pxSocket->u.xTCP.usTimeout = ( uint16_t ) ipMS_TO_MIN_TICKS( ulDelayMs ); /* LCOV_EXCL_BR_LINE ulDelayMs will not be smaller than 1 */
 800b95a:	2301      	movs	r3, #1
 800b95c:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
 800b960:	e7af      	b.n	800b8c2 <prvTCPNextTimeout+0x1a>
 800b962:	bf00      	nop
 800b964:	10624dd3 	.word	0x10624dd3

0800b968 <xTCPSocketCheck>:
    {
 800b968:	b538      	push	{r3, r4, r5, lr}
 800b96a:	4604      	mov	r4, r0
        if( ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != NULL ) )
 800b96c:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79
 800b970:	2b04      	cmp	r3, #4
 800b972:	d904      	bls.n	800b97e <xTCPSocketCheck+0x16>
 800b974:	f8d0 30a0 	ldr.w	r3, [r0, #160]	@ 0xa0
 800b978:	b10b      	cbz	r3, 800b97e <xTCPSocketCheck+0x16>
            prvTCPAddTxData( pxSocket );
 800b97a:	f001 fab4 	bl	800cee6 <prvTCPAddTxData>
            if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800b97e:	f8d4 50a4 	ldr.w	r5, [r4, #164]	@ 0xa4
 800b982:	b32d      	cbz	r5, 800b9d0 <xTCPSocketCheck+0x68>
                if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
 800b984:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800b988:	f013 0f20 	tst.w	r3, #32
 800b98c:	d116      	bne.n	800b9bc <xTCPSocketCheck+0x54>
                    if( pxSocket->u.xTCP.eTCPState != eCLOSED )
 800b98e:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800b992:	b933      	cbnz	r3, 800b9a2 <xTCPSocketCheck+0x3a>
                    if( prvTCPNextTimeout( pxSocket ) > 1U )
 800b994:	4620      	mov	r0, r4
 800b996:	f7ff ff87 	bl	800b8a8 <prvTCPNextTimeout>
 800b99a:	2801      	cmp	r0, #1
 800b99c:	d90c      	bls.n	800b9b8 <xTCPSocketCheck+0x50>
                        xReady = pdTRUE;
 800b99e:	2501      	movs	r5, #1
 800b9a0:	e00d      	b.n	800b9be <xTCPSocketCheck+0x56>
                        prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ( uint32_t ) ( uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER ), ipconfigZERO_COPY_TX_DRIVER );
 800b9a2:	4620      	mov	r0, r4
 800b9a4:	f7fb ff80 	bl	80078a8 <uxIPHeaderSizeSocket>
 800b9a8:	2300      	movs	r3, #0
 800b9aa:	f100 0214 	add.w	r2, r0, #20
 800b9ae:	4629      	mov	r1, r5
 800b9b0:	4620      	mov	r0, r4
 800b9b2:	f000 ffd1 	bl	800c958 <prvTCPReturnPacket>
 800b9b6:	e7ed      	b.n	800b994 <xTCPSocketCheck+0x2c>
        BaseType_t xReady = pdFALSE;
 800b9b8:	2500      	movs	r5, #0
 800b9ba:	e000      	b.n	800b9be <xTCPSocketCheck+0x56>
 800b9bc:	2500      	movs	r5, #0
                if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800b9be:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
 800b9c2:	b120      	cbz	r0, 800b9ce <xTCPSocketCheck+0x66>
                    vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800b9c4:	f002 fe6c 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
                    pxSocket->u.xTCP.pxAckMessage = NULL;
 800b9c8:	2300      	movs	r3, #0
 800b9ca:	f8c4 30a4 	str.w	r3, [r4, #164]	@ 0xa4
        if( xReady == pdFALSE )
 800b9ce:	b97d      	cbnz	r5, 800b9f0 <xTCPSocketCheck+0x88>
            if( ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) ||
 800b9d0:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800b9d4:	2b04      	cmp	r3, #4
 800b9d6:	d801      	bhi.n	800b9dc <xTCPSocketCheck+0x74>
 800b9d8:	2b02      	cmp	r3, #2
 800b9da:	d102      	bne.n	800b9e2 <xTCPSocketCheck+0x7a>
                ( void ) prvTCPSendPacket( pxSocket );
 800b9dc:	4620      	mov	r0, r4
 800b9de:	f001 fa3d 	bl	800ce5c <prvTCPSendPacket>
            ( void ) prvTCPNextTimeout( pxSocket );
 800b9e2:	4620      	mov	r0, r4
 800b9e4:	f7ff ff60 	bl	800b8a8 <prvTCPNextTimeout>
                xResult = prvTCPStatusAgeCheck( pxSocket );
 800b9e8:	4620      	mov	r0, r4
 800b9ea:	f000 fccd 	bl	800c388 <prvTCPStatusAgeCheck>
    }
 800b9ee:	bd38      	pop	{r3, r4, r5, pc}
        BaseType_t xResult = 0;
 800b9f0:	2000      	movs	r0, #0
        return xResult;
 800b9f2:	e7fc      	b.n	800b9ee <xTCPSocketCheck+0x86>

0800b9f4 <xProcessReceivedTCPPacket>:
        BaseType_t xResult = pdPASS;
        /* Function might modify the parameter. */
        NetworkBufferDescriptor_t * pxNetworkBuffer;
        size_t uxIPHeaderOffset;

        configASSERT( pxDescriptor != NULL );
 800b9f4:	b198      	cbz	r0, 800ba1e <xProcessReceivedTCPPacket+0x2a>
        configASSERT( pxDescriptor->pucEthernetBuffer != NULL );
 800b9f6:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 800b9f8:	b1d2      	cbz	r2, 800ba30 <xProcessReceivedTCPPacket+0x3c>
    {
 800b9fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b9fe:	b08a      	sub	sp, #40	@ 0x28

        pxNetworkBuffer = pxDescriptor;
 800ba00:	9009      	str	r0, [sp, #36]	@ 0x24
        uxIPHeaderOffset = ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer );
 800ba02:	f7fb fd69 	bl	80074d8 <uxIPHeaderSizePacket>
 800ba06:	f100 050e 	add.w	r5, r0, #14

        /* Check for a minimum packet size. */
        if( pxNetworkBuffer->xDataLength < ( uxIPHeaderOffset + ipSIZE_OF_TCP_HEADER ) )
 800ba0a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800ba0c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800ba0e:	3022      	adds	r0, #34	@ 0x22
 800ba10:	4282      	cmp	r2, r0
 800ba12:	d216      	bcs.n	800ba42 <xProcessReceivedTCPPacket+0x4e>
        {
            xResult = pdFAIL;
 800ba14:	2400      	movs	r4, #0
            }
        }

        /* pdPASS being returned means the buffer has been consumed. */
        return xResult;
    }
 800ba16:	4620      	mov	r0, r4
 800ba18:	b00a      	add	sp, #40	@ 0x28
 800ba1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ba1e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ba22:	f383 8811 	msr	BASEPRI, r3
 800ba26:	f3bf 8f6f 	isb	sy
 800ba2a:	f3bf 8f4f 	dsb	sy
        configASSERT( pxDescriptor != NULL );
 800ba2e:	e7fe      	b.n	800ba2e <xProcessReceivedTCPPacket+0x3a>
 800ba30:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ba34:	f383 8811 	msr	BASEPRI, r3
 800ba38:	f3bf 8f6f 	isb	sy
 800ba3c:	f3bf 8f4f 	dsb	sy
        configASSERT( pxDescriptor->pucEthernetBuffer != NULL );
 800ba40:	e7fe      	b.n	800ba40 <xProcessReceivedTCPPacket+0x4c>
                                                &( pxNetworkBuffer->pucEthernetBuffer[ uxIPHeaderOffset ] ) );
 800ba42:	6a59      	ldr	r1, [r3, #36]	@ 0x24
            const TCPHeader_t * pxTCPHeader = ( ( const TCPHeader_t * )
 800ba44:	194e      	adds	r6, r1, r5
            const uint16_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800ba46:	7b77      	ldrb	r7, [r6, #13]
            const uint16_t usLocalPort = FreeRTOS_htons( pxTCPHeader->usDestinationPort );
 800ba48:	8873      	ldrh	r3, [r6, #2]
 800ba4a:	021c      	lsls	r4, r3, #8
 800ba4c:	ea44 2413 	orr.w	r4, r4, r3, lsr #8
 800ba50:	b2a4      	uxth	r4, r4
            const uint16_t usRemotePort = FreeRTOS_htons( pxTCPHeader->usSourcePort );
 800ba52:	5b4b      	ldrh	r3, [r1, r5]
 800ba54:	021d      	lsls	r5, r3, #8
 800ba56:	ea45 2513 	orr.w	r5, r5, r3, lsr #8
 800ba5a:	b2ad      	uxth	r5, r5
            const IPv46_Address_t xRemoteIP = xGetSourceAddrFromBuffer( pxNetworkBuffer->pucEthernetBuffer );
 800ba5c:	f10d 0810 	add.w	r8, sp, #16
 800ba60:	4640      	mov	r0, r8
 800ba62:	f7ff fdc9 	bl	800b5f8 <xGetSourceAddrFromBuffer>
            FreeRTOS_Socket_t * pxSocket = pxTCPSocketLookup( 0U, usLocalPort, xRemoteIP, usRemotePort );
 800ba66:	9503      	str	r5, [sp, #12]
 800ba68:	ab06      	add	r3, sp, #24
 800ba6a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ba6e:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800ba72:	e898 000c 	ldmia.w	r8, {r2, r3}
 800ba76:	4621      	mov	r1, r4
 800ba78:	2000      	movs	r0, #0
 800ba7a:	f7fe ff39 	bl	800a8f0 <pxTCPSocketLookup>
            if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( pxSocket->u.xTCP.eTCPState ) == pdFALSE ) )
 800ba7e:	4605      	mov	r5, r0
 800ba80:	b120      	cbz	r0, 800ba8c <xProcessReceivedTCPPacket+0x98>
 800ba82:	f890 0079 	ldrb.w	r0, [r0, #121]	@ 0x79
 800ba86:	f000 fc71 	bl	800c36c <prvTCPSocketIsActive>
 800ba8a:	b970      	cbnz	r0, 800baaa <xProcessReceivedTCPPacket+0xb6>
                if( ( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) != tcpTCP_FLAG_ACK ) &&
 800ba8c:	f007 031f 	and.w	r3, r7, #31
 800ba90:	2b10      	cmp	r3, #16
 800ba92:	f000 80d9 	beq.w	800bc48 <xProcessReceivedTCPPacket+0x254>
 800ba96:	f017 0f04 	tst.w	r7, #4
 800ba9a:	d001      	beq.n	800baa0 <xProcessReceivedTCPPacket+0xac>
                xResult = pdFAIL;
 800ba9c:	2400      	movs	r4, #0
 800ba9e:	e7ba      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                    ( void ) prvTCPSendReset( pxNetworkBuffer );
 800baa0:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800baa2:	f001 fae0 	bl	800d066 <prvTCPSendReset>
                xResult = pdFAIL;
 800baa6:	2400      	movs	r4, #0
 800baa8:	e7b5      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                pxSocket->u.xTCP.ucRepCount = 0U;
 800baaa:	2300      	movs	r3, #0
 800baac:	f885 3078 	strb.w	r3, [r5, #120]	@ 0x78
                if( pxSocket->u.xTCP.eTCPState == eTCP_LISTEN )
 800bab0:	f895 3079 	ldrb.w	r3, [r5, #121]	@ 0x79
 800bab4:	2b01      	cmp	r3, #1
 800bab6:	d02a      	beq.n	800bb0e <xProcessReceivedTCPPacket+0x11a>
                    if( ( ucTCPFlags & tcpTCP_FLAG_RST ) != 0U )
 800bab8:	f017 0f04 	tst.w	r7, #4
 800babc:	d05d      	beq.n	800bb7a <xProcessReceivedTCPPacket+0x186>
                        if( pxSocket->u.xTCP.eTCPState == eCONNECT_SYN )
 800babe:	2b02      	cmp	r3, #2
 800bac0:	d03c      	beq.n	800bb3c <xProcessReceivedTCPPacket+0x148>
                            const uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800bac2:	6873      	ldr	r3, [r6, #4]
 800bac4:	021e      	lsls	r6, r3, #8
 800bac6:	f406 067f 	and.w	r6, r6, #16711680	@ 0xff0000
 800baca:	ea46 6603 	orr.w	r6, r6, r3, lsl #24
 800bace:	0a1a      	lsrs	r2, r3, #8
 800bad0:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800bad4:	4316      	orrs	r6, r2
 800bad6:	ea46 6613 	orr.w	r6, r6, r3, lsr #24
                            if( ulSequenceNumber == pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber )
 800bada:	f8d5 1124 	ldr.w	r1, [r5, #292]	@ 0x124
 800bade:	42b1      	cmp	r1, r6
 800bae0:	d045      	beq.n	800bb6e <xProcessReceivedTCPPacket+0x17a>
                            else if( ( xSequenceGreaterThan( ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber ) != pdFALSE ) &&
 800bae2:	4630      	mov	r0, r6
 800bae4:	f002 f8fa 	bl	800dcdc <xSequenceGreaterThan>
 800bae8:	4604      	mov	r4, r0
 800baea:	2800      	cmp	r0, #0
 800baec:	d093      	beq.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                                     ( xSequenceLessThan( ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
 800baee:	f8d5 1124 	ldr.w	r1, [r5, #292]	@ 0x124
                                                          pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength ) != pdFALSE ) )
 800baf2:	f8d5 3118 	ldr.w	r3, [r5, #280]	@ 0x118
                                     ( xSequenceLessThan( ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber +
 800baf6:	4419      	add	r1, r3
 800baf8:	4630      	mov	r0, r6
 800bafa:	f002 f860 	bl	800dbbe <xSequenceLessThan>
                            else if( ( xSequenceGreaterThan( ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber ) != pdFALSE ) &&
 800bafe:	4604      	mov	r4, r0
 800bb00:	2800      	cmp	r0, #0
 800bb02:	d088      	beq.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                                ( void ) prvTCPSendChallengeAck( pxNetworkBuffer );
 800bb04:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800bb06:	f001 faa9 	bl	800d05c <prvTCPSendChallengeAck>
                        xResult = pdFAIL;
 800bb0a:	2400      	movs	r4, #0
 800bb0c:	e783      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                    if( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) != tcpTCP_FLAG_SYN )
 800bb0e:	f007 031f 	and.w	r3, r7, #31
 800bb12:	2b02      	cmp	r3, #2
 800bb14:	d009      	beq.n	800bb2a <xProcessReceivedTCPPacket+0x136>
                        if( ( ucTCPFlags & tcpTCP_FLAG_RST ) == 0U )
 800bb16:	f017 0f04 	tst.w	r7, #4
 800bb1a:	d001      	beq.n	800bb20 <xProcessReceivedTCPPacket+0x12c>
                        xResult = pdFAIL;
 800bb1c:	2400      	movs	r4, #0
 800bb1e:	e77a      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                            ( void ) prvTCPSendReset( pxNetworkBuffer );
 800bb20:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800bb22:	f001 faa0 	bl	800d066 <prvTCPSendReset>
                        xResult = pdFAIL;
 800bb26:	2400      	movs	r4, #0
 800bb28:	e775      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                        pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
 800bb2a:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800bb2c:	4628      	mov	r0, r5
 800bb2e:	f000 fd1b 	bl	800c568 <prvHandleListen>
                        if( pxSocket == NULL )
 800bb32:	4605      	mov	r5, r0
 800bb34:	2800      	cmp	r0, #0
 800bb36:	d147      	bne.n	800bbc8 <xProcessReceivedTCPPacket+0x1d4>
                            xResult = pdFAIL;
 800bb38:	2400      	movs	r4, #0
 800bb3a:	e76c      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                            const uint32_t ulAckNumber = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 800bb3c:	68b2      	ldr	r2, [r6, #8]
 800bb3e:	0213      	lsls	r3, r2, #8
 800bb40:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800bb44:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800bb48:	0a11      	lsrs	r1, r2, #8
 800bb4a:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800bb4e:	430b      	orrs	r3, r1
 800bb50:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
                            if( ulAckNumber == ( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber + 1U ) )
 800bb54:	f8d5 2140 	ldr.w	r2, [r5, #320]	@ 0x140
 800bb58:	3201      	adds	r2, #1
 800bb5a:	429a      	cmp	r2, r3
 800bb5c:	d001      	beq.n	800bb62 <xProcessReceivedTCPPacket+0x16e>
                        xResult = pdFAIL;
 800bb5e:	2400      	movs	r4, #0
 800bb60:	e759      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                                vTCPStateChange( pxSocket, eCLOSED );
 800bb62:	2100      	movs	r1, #0
 800bb64:	4628      	mov	r0, r5
 800bb66:	f7ff fda9 	bl	800b6bc <vTCPStateChange>
                        xResult = pdFAIL;
 800bb6a:	2400      	movs	r4, #0
 800bb6c:	e753      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                                vTCPStateChange( pxSocket, eCLOSED );
 800bb6e:	2100      	movs	r1, #0
 800bb70:	4628      	mov	r0, r5
 800bb72:	f7ff fda3 	bl	800b6bc <vTCPStateChange>
                        xResult = pdFAIL;
 800bb76:	2400      	movs	r4, #0
 800bb78:	e74d      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                    else if( ( ( ucTCPFlags & tcpTCP_FLAG_CTRL ) == tcpTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) )
 800bb7a:	f007 021f 	and.w	r2, r7, #31
 800bb7e:	2a02      	cmp	r2, #2
 800bb80:	d101      	bne.n	800bb86 <xProcessReceivedTCPPacket+0x192>
 800bb82:	2b04      	cmp	r3, #4
 800bb84:	d862      	bhi.n	800bc4c <xProcessReceivedTCPPacket+0x258>
                        const size_t uxOffset = ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket );
 800bb86:	4628      	mov	r0, r5
 800bb88:	f7fb fe8e 	bl	80078a8 <uxIPHeaderSizeSocket>
 800bb8c:	4603      	mov	r3, r0
 800bb8e:	300e      	adds	r0, #14
                        ( void ) memcpy( ( void * ) ( &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ uxOffset ] ) ),
 800bb90:	f103 02ae 	add.w	r2, r3, #174	@ 0xae
 800bb94:	442a      	add	r2, r5
                                         ( const void * ) ( &( pxNetworkBuffer->pucEthernetBuffer[ uxOffset ] ) ),
 800bb96:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800bb98:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
 800bb9a:	1821      	adds	r1, r4, r0
                        ( void ) memcpy( ( void * ) ( &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ uxOffset ] ) ),
 800bb9c:	5820      	ldr	r0, [r4, r0]
 800bb9e:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800bba2:	f8d1 c008 	ldr.w	ip, [r1, #8]
 800bba6:	68cc      	ldr	r4, [r1, #12]
 800bba8:	f8c2 000a 	str.w	r0, [r2, #10]
 800bbac:	f8c2 e00e 	str.w	lr, [r2, #14]
 800bbb0:	f8c2 c012 	str.w	ip, [r2, #18]
 800bbb4:	f8c2 4016 	str.w	r4, [r2, #22]
 800bbb8:	6908      	ldr	r0, [r1, #16]
 800bbba:	f8c2 001a 	str.w	r0, [r2, #26]
                        pxSocket->u.xTCP.xPacket.u.ucLastPacket[ uxOffset + ipTCP_FLAGS_OFFSET ] = tcpTCP_FLAG_ACK;
 800bbbe:	331b      	adds	r3, #27
 800bbc0:	442b      	add	r3, r5
 800bbc2:	2210      	movs	r2, #16
 800bbc4:	f883 20aa 	strb.w	r2, [r3, #170]	@ 0xaa
                configASSERT( pxSocket != NULL ); /* LCOV_EXCL_LINE ,this branch will not be hit*/
 800bbc8:	b355      	cbz	r5, 800bc20 <xProcessReceivedTCPPacket+0x22c>
                prvTCPTouchSocket( pxSocket );
 800bbca:	4628      	mov	r0, r5
 800bbcc:	f7ff fd5c 	bl	800b688 <prvTCPTouchSocket>
                if( ( pxTCPHeader->ucTCPOffset & tcpTCP_OFFSET_LENGTH_BITS ) > tcpTCP_OFFSET_STANDARD_LENGTH )
 800bbd0:	7b33      	ldrb	r3, [r6, #12]
 800bbd2:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800bbd6:	2b50      	cmp	r3, #80	@ 0x50
 800bbd8:	d82b      	bhi.n	800bc32 <xProcessReceivedTCPPacket+0x23e>
 800bbda:	2401      	movs	r4, #1
                if( xResult != pdFAIL )
 800bbdc:	2c00      	cmp	r4, #0
 800bbde:	f43f af1a 	beq.w	800ba16 <xProcessReceivedTCPPacket+0x22>
                    usWindow = FreeRTOS_ntohs( pxTCPHeader->usWindow );
 800bbe2:	89f2      	ldrh	r2, [r6, #14]
 800bbe4:	0213      	lsls	r3, r2, #8
 800bbe6:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800bbea:	b29b      	uxth	r3, r3
                    pxSocket->u.xTCP.ulWindowSize = ( uint32_t ) usWindow;
 800bbec:	f8c5 3108 	str.w	r3, [r5, #264]	@ 0x108
                        if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_SYN ) == 0U )
 800bbf0:	f017 0f02 	tst.w	r7, #2
 800bbf4:	d104      	bne.n	800bc00 <xProcessReceivedTCPPacket+0x20c>
                                ( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 800bbf6:	f895 2106 	ldrb.w	r2, [r5, #262]	@ 0x106
 800bbfa:	4093      	lsls	r3, r2
                            pxSocket->u.xTCP.ulWindowSize =
 800bbfc:	f8c5 3108 	str.w	r3, [r5, #264]	@ 0x108
                    if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
 800bc00:	a909      	add	r1, sp, #36	@ 0x24
 800bc02:	4628      	mov	r0, r5
 800bc04:	f000 fbe7 	bl	800c3d6 <prvTCPHandleState>
 800bc08:	2800      	cmp	r0, #0
 800bc0a:	dc18      	bgt.n	800bc3e <xProcessReceivedTCPPacket+0x24a>
                    if( pxNetworkBuffer != NULL )
 800bc0c:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800bc0e:	b118      	cbz	r0, 800bc18 <xProcessReceivedTCPPacket+0x224>
                        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800bc10:	f002 fd46 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
                            pxNetworkBuffer = NULL;
 800bc14:	2300      	movs	r3, #0
 800bc16:	9309      	str	r3, [sp, #36]	@ 0x24
                    ( void ) prvTCPNextTimeout( pxSocket );
 800bc18:	4628      	mov	r0, r5
 800bc1a:	f7ff fe45 	bl	800b8a8 <prvTCPNextTimeout>
 800bc1e:	e6fa      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
 800bc20:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800bc24:	f383 8811 	msr	BASEPRI, r3
 800bc28:	f3bf 8f6f 	isb	sy
 800bc2c:	f3bf 8f4f 	dsb	sy
                configASSERT( pxSocket != NULL ); /* LCOV_EXCL_LINE ,this branch will not be hit*/
 800bc30:	e7fe      	b.n	800bc30 <xProcessReceivedTCPPacket+0x23c>
                    xResult = prvCheckOptions( pxSocket, pxNetworkBuffer );
 800bc32:	9909      	ldr	r1, [sp, #36]	@ 0x24
 800bc34:	4628      	mov	r0, r5
 800bc36:	f000 f8e4 	bl	800be02 <prvCheckOptions>
 800bc3a:	4604      	mov	r4, r0
 800bc3c:	e7ce      	b.n	800bbdc <xProcessReceivedTCPPacket+0x1e8>
                            ( void ) prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 800bc3e:	a909      	add	r1, sp, #36	@ 0x24
 800bc40:	4628      	mov	r0, r5
 800bc42:	f001 f8ef 	bl	800ce24 <prvTCPSendRepeated>
 800bc46:	e7e1      	b.n	800bc0c <xProcessReceivedTCPPacket+0x218>
                xResult = pdFAIL;
 800bc48:	2400      	movs	r4, #0
 800bc4a:	e6e4      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>
                        xResult = pdFAIL;
 800bc4c:	2400      	movs	r4, #0
 800bc4e:	e6e2      	b.n	800ba16 <xProcessReceivedTCPPacket+0x22>

0800bc50 <xTCPCheckNewClient>:
 *
 * @return if there is a new client, then pdTRUE is returned or else, pdFALSE.
 */
    BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t * pxSocket )
    {
        TickType_t uxLocalPort = ( TickType_t ) FreeRTOS_htons( pxSocket->usLocalPort );
 800bc50:	8f03      	ldrh	r3, [r0, #56]	@ 0x38
 800bc52:	0219      	lsls	r1, r3, #8
 800bc54:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
 800bc58:	b289      	uxth	r1, r1
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const ListItem_t * pxEndTCP = ( ( const ListItem_t * ) &( xBoundTCPSocketsList.xListEnd ) );

        /* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
         * who has access. */
        for( pxIterator = ( const ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800bc5a:	4b0d      	ldr	r3, [pc, #52]	@ (800bc90 <xTCPCheckNewClient+0x40>)
 800bc5c:	68db      	ldr	r3, [r3, #12]
 800bc5e:	e000      	b.n	800bc62 <xTCPCheckNewClient+0x12>
             pxIterator != pxEndTCP;
             pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 800bc60:	685b      	ldr	r3, [r3, #4]
             pxIterator != pxEndTCP;
 800bc62:	4a0c      	ldr	r2, [pc, #48]	@ (800bc94 <xTCPCheckNewClient+0x44>)
 800bc64:	4293      	cmp	r3, r2
 800bc66:	d010      	beq.n	800bc8a <xTCPCheckNewClient+0x3a>
        {
            if( listGET_LIST_ITEM_VALUE( pxIterator ) == ( configLIST_VOLATILE TickType_t ) uxLocalPort )
 800bc68:	681a      	ldr	r2, [r3, #0]
 800bc6a:	428a      	cmp	r2, r1
 800bc6c:	d1f8      	bne.n	800bc60 <xTCPCheckNewClient+0x10>
            {
                pxFound = ( ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800bc6e:	68da      	ldr	r2, [r3, #12]

                if( ( pxFound->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800bc70:	f892 c03b 	ldrb.w	ip, [r2, #59]	@ 0x3b
 800bc74:	f1bc 0f06 	cmp.w	ip, #6
 800bc78:	d1f2      	bne.n	800bc60 <xTCPCheckNewClient+0x10>
 800bc7a:	f892 c068 	ldrb.w	ip, [r2, #104]	@ 0x68
 800bc7e:	f01c 0f02 	tst.w	ip, #2
 800bc82:	d0ed      	beq.n	800bc60 <xTCPCheckNewClient+0x10>
                {
                    pxSocket->u.xTCP.pxPeerSocket = pxFound;
 800bc84:	67c2      	str	r2, [r0, #124]	@ 0x7c
                    FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) );
                    xResult = pdTRUE;
 800bc86:	2001      	movs	r0, #1
                    break;
 800bc88:	4770      	bx	lr
        BaseType_t xResult = pdFALSE;
 800bc8a:	2000      	movs	r0, #0
                }
            }
        }

        return xResult;
    }
 800bc8c:	4770      	bx	lr
 800bc8e:	bf00      	nop
 800bc90:	20013780 	.word	0x20013780
 800bc94:	20013788 	.word	0x20013788

0800bc98 <prvReadSackOption>:
 * @param[in] pxSocket Socket handling the TCP connection.
 */
        static void prvReadSackOption( const uint8_t * const pucPtr,
                                       size_t uxIndex,
                                       FreeRTOS_Socket_t * const pxSocket )
        {
 800bc98:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bc9a:	b083      	sub	sp, #12
 800bc9c:	4606      	mov	r6, r0
 800bc9e:	460c      	mov	r4, r1
 800bca0:	4615      	mov	r5, r2
            uint32_t ulFirst = ulChar2u32( &( pucPtr[ uxIndex ] ) );
 800bca2:	4408      	add	r0, r1
 800bca4:	f7fc fadb 	bl	800825e <ulChar2u32>
 800bca8:	4607      	mov	r7, r0
            uint32_t ulLast = ulChar2u32( &( pucPtr[ uxIndex + 4U ] ) );
 800bcaa:	3404      	adds	r4, #4
 800bcac:	1930      	adds	r0, r6, r4
 800bcae:	f7fc fad6 	bl	800825e <ulChar2u32>
 800bcb2:	4602      	mov	r2, r0
            uint32_t ulCount = ulTCPWindowTxSack( &( pxSocket->u.xTCP.xTCPWindow ), ulFirst, ulLast );
 800bcb4:	4639      	mov	r1, r7
 800bcb6:	f505 708a 	add.w	r0, r5, #276	@ 0x114
 800bcba:	f002 fa23 	bl	800e104 <ulTCPWindowTxSack>

            /* ulTCPWindowTxSack( ) returns the number of bytes which have been acked
             * starting from the head position.  Advance the tail pointer in txStream.
             */
            if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0U ) )
 800bcbe:	f8d5 40a0 	ldr.w	r4, [r5, #160]	@ 0xa0
 800bcc2:	b104      	cbz	r4, 800bcc6 <prvReadSackOption+0x2e>
 800bcc4:	b908      	cbnz	r0, 800bcca <prvReadSackOption+0x32>
                        pxSocket->u.xTCP.pxHandleSent( pxSocket, ulCount );
                    }
                }
                #endif /* ipconfigUSE_CALLBACKS == 1  */
            }
        }
 800bcc6:	b003      	add	sp, #12
 800bcc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                ( void ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 800bcca:	2100      	movs	r1, #0
 800bccc:	9100      	str	r1, [sp, #0]
 800bcce:	4603      	mov	r3, r0
 800bcd0:	460a      	mov	r2, r1
 800bcd2:	4620      	mov	r0, r4
 800bcd4:	f7ff fc31 	bl	800b53a <uxStreamBufferGet>
                pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
 800bcd8:	682b      	ldr	r3, [r5, #0]
 800bcda:	f043 0202 	orr.w	r2, r3, #2
 800bcde:	602a      	str	r2, [r5, #0]
                    if( ( pxSocket->xSelectBits & ( EventBits_t ) eSELECT_WRITE ) != 0U )
 800bce0:	6c6a      	ldr	r2, [r5, #68]	@ 0x44
 800bce2:	f012 0f02 	tst.w	r2, #2
 800bce6:	d0ee      	beq.n	800bcc6 <prvReadSackOption+0x2e>
                        pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
 800bce8:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800bcec:	f043 0302 	orr.w	r3, r3, #2
 800bcf0:	602b      	str	r3, [r5, #0]
        }
 800bcf2:	e7e8      	b.n	800bcc6 <prvReadSackOption+0x2e>

0800bcf4 <prvSingleStepTCPHeaderOptions>:
    {
 800bcf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bcf6:	4616      	mov	r6, r2
        if( pucPtr[ 0U ] == tcpTCP_OPT_END )
 800bcf8:	7802      	ldrb	r2, [r0, #0]
 800bcfa:	2a00      	cmp	r2, #0
 800bcfc:	d061      	beq.n	800bdc2 <prvSingleStepTCPHeaderOptions+0xce>
 800bcfe:	4604      	mov	r4, r0
        else if( pucPtr[ 0U ] == tcpTCP_OPT_NOOP )
 800bd00:	2a01      	cmp	r2, #1
 800bd02:	d060      	beq.n	800bdc6 <prvSingleStepTCPHeaderOptions+0xd2>
        else if( uxRemainingOptionsBytes < 2U )
 800bd04:	2901      	cmp	r1, #1
 800bd06:	d960      	bls.n	800bdca <prvSingleStepTCPHeaderOptions+0xd6>
            else if( pucPtr[ 0 ] == tcpTCP_OPT_WSOPT )
 800bd08:	2a03      	cmp	r2, #3
 800bd0a:	d00b      	beq.n	800bd24 <prvSingleStepTCPHeaderOptions+0x30>
        else if( pucPtr[ 0 ] == tcpTCP_OPT_MSS )
 800bd0c:	2a02      	cmp	r2, #2
 800bd0e:	d01b      	beq.n	800bd48 <prvSingleStepTCPHeaderOptions+0x54>
            ucLen = pucPtr[ 1 ];
 800bd10:	7845      	ldrb	r5, [r0, #1]
            if( ( ucLen < ( uint8_t ) 2U ) || ( uxRemainingOptionsBytes < ( size_t ) ucLen ) )
 800bd12:	2d01      	cmp	r5, #1
 800bd14:	d96f      	bls.n	800bdf6 <prvSingleStepTCPHeaderOptions+0x102>
 800bd16:	428d      	cmp	r5, r1
 800bd18:	d870      	bhi.n	800bdfc <prvSingleStepTCPHeaderOptions+0x108>
                    if( pucPtr[ 0U ] == tcpTCP_OPT_SACK_A )
 800bd1a:	2a05      	cmp	r2, #5
 800bd1c:	d041      	beq.n	800bda2 <prvSingleStepTCPHeaderOptions+0xae>
            lIndex = 0;
 800bd1e:	2700      	movs	r7, #0
                lIndex += ( int32_t ) ucLen;
 800bd20:	19e8      	adds	r0, r5, r7
 800bd22:	e04f      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                if( ( uxRemainingOptionsBytes < tcpTCP_OPT_WSOPT_LEN ) || ( pucPtr[ 1 ] != tcpTCP_OPT_WSOPT_LEN ) )
 800bd24:	2902      	cmp	r1, #2
 800bd26:	d953      	bls.n	800bdd0 <prvSingleStepTCPHeaderOptions+0xdc>
 800bd28:	7842      	ldrb	r2, [r0, #1]
 800bd2a:	2a03      	cmp	r2, #3
 800bd2c:	d153      	bne.n	800bdd6 <prvSingleStepTCPHeaderOptions+0xe2>
                    if( xHasSYNFlag != 0 )
 800bd2e:	2b00      	cmp	r3, #0
 800bd30:	d054      	beq.n	800bddc <prvSingleStepTCPHeaderOptions+0xe8>
                        pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
 800bd32:	7883      	ldrb	r3, [r0, #2]
 800bd34:	f886 3106 	strb.w	r3, [r6, #262]	@ 0x106
                        pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
 800bd38:	f896 306a 	ldrb.w	r3, [r6, #106]	@ 0x6a
 800bd3c:	f043 0310 	orr.w	r3, r3, #16
 800bd40:	f886 306a 	strb.w	r3, [r6, #106]	@ 0x6a
                    lIndex = ( int32_t ) tcpTCP_OPT_WSOPT_LEN;
 800bd44:	2003      	movs	r0, #3
 800bd46:	e03d      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
            if( ( uxRemainingOptionsBytes < tcpTCP_OPT_MSS_LEN ) || ( pucPtr[ 1 ] != tcpTCP_OPT_MSS_LEN ) )
 800bd48:	2903      	cmp	r1, #3
 800bd4a:	d949      	bls.n	800bde0 <prvSingleStepTCPHeaderOptions+0xec>
 800bd4c:	7843      	ldrb	r3, [r0, #1]
 800bd4e:	2b04      	cmp	r3, #4
 800bd50:	d149      	bne.n	800bde6 <prvSingleStepTCPHeaderOptions+0xf2>
                uxNewMSS = usChar2u16( &( pucPtr[ 2 ] ) );
 800bd52:	3002      	adds	r0, #2
 800bd54:	f7fc fa8e 	bl	8008274 <usChar2u16>
 800bd58:	4603      	mov	r3, r0
                if( pxSocket->u.xTCP.usMSS != uxNewMSS )
 800bd5a:	f8b6 2072 	ldrh.w	r2, [r6, #114]	@ 0x72
 800bd5e:	4290      	cmp	r0, r2
 800bd60:	d001      	beq.n	800bd66 <prvSingleStepTCPHeaderOptions+0x72>
                    if( uxNewMSS == 0U )
 800bd62:	2800      	cmp	r0, #0
 800bd64:	d042      	beq.n	800bdec <prvSingleStepTCPHeaderOptions+0xf8>
                    if( uxNewMSS < tcpMINIMUM_SEGMENT_LENGTH )
 800bd66:	f5b0 7f06 	cmp.w	r0, #536	@ 0x218
 800bd6a:	d201      	bcs.n	800bd70 <prvSingleStepTCPHeaderOptions+0x7c>
                        uxNewMSS = tcpMINIMUM_SEGMENT_LENGTH;
 800bd6c:	f44f 7306 	mov.w	r3, #536	@ 0x218
                    if( pxSocket->u.xTCP.usMSS > uxNewMSS )
 800bd70:	429a      	cmp	r2, r3
 800bd72:	d93e      	bls.n	800bdf2 <prvSingleStepTCPHeaderOptions+0xfe>
                        pxSocket->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
 800bd74:	f896 2068 	ldrb.w	r2, [r6, #104]	@ 0x68
 800bd78:	f042 0201 	orr.w	r2, r2, #1
 800bd7c:	f886 2068 	strb.w	r2, [r6, #104]	@ 0x68
                        pxTCPWindow->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( pxTCPWindow->xSize.ulRxWindowLength / ( ( uint32_t ) uxNewMSS ) );
 800bd80:	f8d6 2118 	ldr.w	r2, [r6, #280]	@ 0x118
 800bd84:	fbb2 f2f3 	udiv	r2, r2, r3
 800bd88:	fb03 f202 	mul.w	r2, r3, r2
 800bd8c:	f8c6 2118 	str.w	r2, [r6, #280]	@ 0x118
                        pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
 800bd90:	b29b      	uxth	r3, r3
 800bd92:	f8a6 31d2 	strh.w	r3, [r6, #466]	@ 0x1d2
                        pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
 800bd96:	f8a6 31d0 	strh.w	r3, [r6, #464]	@ 0x1d0
                        pxSocket->u.xTCP.usMSS = ( uint16_t ) uxNewMSS;
 800bd9a:	f8a6 3072 	strh.w	r3, [r6, #114]	@ 0x72
                    lIndex = ( int32_t ) tcpTCP_OPT_MSS_LEN;
 800bd9e:	2004      	movs	r0, #4
 800bda0:	e010      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                        ucLen = ( uint8_t ) ( ucLen - 2U );
 800bda2:	1ea8      	subs	r0, r5, #2
 800bda4:	b2c5      	uxtb	r5, r0
                        lIndex += 2;
 800bda6:	2702      	movs	r7, #2
                        while( ucLen >= ( uint8_t ) 8U )
 800bda8:	e008      	b.n	800bdbc <prvSingleStepTCPHeaderOptions+0xc8>
                            prvReadSackOption( pucPtr, ( size_t ) lIndex, pxSocket );
 800bdaa:	4632      	mov	r2, r6
 800bdac:	4639      	mov	r1, r7
 800bdae:	4620      	mov	r0, r4
 800bdb0:	f7ff ff72 	bl	800bc98 <prvReadSackOption>
                            lIndex += 8;
 800bdb4:	3708      	adds	r7, #8
                            ucLen = ( uint8_t ) ( ucLen - 8U );
 800bdb6:	f1a5 0008 	sub.w	r0, r5, #8
 800bdba:	b2c5      	uxtb	r5, r0
                        while( ucLen >= ( uint8_t ) 8U )
 800bdbc:	2d07      	cmp	r5, #7
 800bdbe:	d8f4      	bhi.n	800bdaa <prvSingleStepTCPHeaderOptions+0xb6>
 800bdc0:	e7ae      	b.n	800bd20 <prvSingleStepTCPHeaderOptions+0x2c>
            lIndex = 0;
 800bdc2:	2000      	movs	r0, #0
    }
 800bdc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            lIndex = 1;
 800bdc6:	2001      	movs	r0, #1
 800bdc8:	e7fc      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
            lIndex = -1;
 800bdca:	f04f 30ff 	mov.w	r0, #4294967295
 800bdce:	e7f9      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                    lIndex = -1;
 800bdd0:	f04f 30ff 	mov.w	r0, #4294967295
 800bdd4:	e7f6      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
 800bdd6:	f04f 30ff 	mov.w	r0, #4294967295
 800bdda:	e7f3      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                    lIndex = ( int32_t ) tcpTCP_OPT_WSOPT_LEN;
 800bddc:	2003      	movs	r0, #3
 800bdde:	e7f1      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                lIndex = -1;
 800bde0:	f04f 30ff 	mov.w	r0, #4294967295
 800bde4:	e7ee      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
 800bde6:	f04f 30ff 	mov.w	r0, #4294967295
 800bdea:	e7eb      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                        lIndex = -1;
 800bdec:	f04f 30ff 	mov.w	r0, #4294967295
 800bdf0:	e7e8      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                    lIndex = ( int32_t ) tcpTCP_OPT_MSS_LEN;
 800bdf2:	2004      	movs	r0, #4
 800bdf4:	e7e6      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
                lIndex = -1;
 800bdf6:	f04f 30ff 	mov.w	r0, #4294967295
 800bdfa:	e7e3      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>
 800bdfc:	f04f 30ff 	mov.w	r0, #4294967295
        return lIndex;
 800be00:	e7e0      	b.n	800bdc4 <prvSingleStepTCPHeaderOptions+0xd0>

0800be02 <prvCheckOptions>:
    {
 800be02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800be04:	4605      	mov	r5, r0
 800be06:	460e      	mov	r6, r1
        size_t uxTCPHeaderOffset = ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer );
 800be08:	4608      	mov	r0, r1
 800be0a:	f7fb fb65 	bl	80074d8 <uxIPHeaderSizePacket>
 800be0e:	f100 030e 	add.w	r3, r0, #14
                                                        &( pxNetworkBuffer->pucEthernetBuffer[ uxTCPHeaderOffset ] ) );
 800be12:	6a72      	ldr	r2, [r6, #36]	@ 0x24
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800be14:	441a      	add	r2, r3
        if( pxTCPHeader->ucTCPOffset <= ( 5U << 4U ) )
 800be16:	7b14      	ldrb	r4, [r2, #12]
 800be18:	2c50      	cmp	r4, #80	@ 0x50
 800be1a:	d925      	bls.n	800be68 <prvCheckOptions+0x66>
 800be1c:	f100 0322 	add.w	r3, r0, #34	@ 0x22
 800be20:	f102 0714 	add.w	r7, r2, #20
            ucLength = ( uint8_t ) ( ( ( pxTCPHeader->ucTCPOffset >> 4U ) - 5U ) << 2U );
 800be24:	0924      	lsrs	r4, r4, #4
 800be26:	3c05      	subs	r4, #5
 800be28:	b2e4      	uxtb	r4, r4
 800be2a:	00a4      	lsls	r4, r4, #2
 800be2c:	b2e4      	uxtb	r4, r4
            if( pxNetworkBuffer->xDataLength > uxOptionOffset )
 800be2e:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 800be30:	4299      	cmp	r1, r3
 800be32:	d91b      	bls.n	800be6c <prvCheckOptions+0x6a>
                if( uxOptionsLength <= ( pxNetworkBuffer->xDataLength - uxOptionOffset ) )
 800be34:	1ac9      	subs	r1, r1, r3
 800be36:	42a1      	cmp	r1, r4
 800be38:	d31a      	bcc.n	800be70 <prvCheckOptions+0x6e>
                    if( ( pxTCPHeader->ucTCPFlags & tcpTCP_FLAG_SYN ) != ( uint8_t ) 0U )
 800be3a:	7b53      	ldrb	r3, [r2, #13]
 800be3c:	f013 0f02 	tst.w	r3, #2
 800be40:	d001      	beq.n	800be46 <prvCheckOptions+0x44>
                        xHasSYNFlag = pdTRUE;
 800be42:	2601      	movs	r6, #1
 800be44:	e003      	b.n	800be4e <prvCheckOptions+0x4c>
                        xHasSYNFlag = pdFALSE;
 800be46:	2600      	movs	r6, #0
 800be48:	e001      	b.n	800be4e <prvCheckOptions+0x4c>
                        uxOptionsLength -= ( size_t ) lResult;
 800be4a:	1a24      	subs	r4, r4, r0
                        pucPtr = &( pucPtr[ lResult ] );
 800be4c:	4407      	add	r7, r0
                        if( uxOptionsLength == 0U )
 800be4e:	b18c      	cbz	r4, 800be74 <prvCheckOptions+0x72>
                        lResult = prvSingleStepTCPHeaderOptions( pucPtr, uxOptionsLength, pxSocket, xHasSYNFlag );
 800be50:	4633      	mov	r3, r6
 800be52:	462a      	mov	r2, r5
 800be54:	4621      	mov	r1, r4
 800be56:	4638      	mov	r0, r7
 800be58:	f7ff ff4c 	bl	800bcf4 <prvSingleStepTCPHeaderOptions>
                        if( lResult < 0 )
 800be5c:	2800      	cmp	r0, #0
 800be5e:	db0b      	blt.n	800be78 <prvCheckOptions+0x76>
                        if( lResult == 0 )
 800be60:	2800      	cmp	r0, #0
 800be62:	d1f2      	bne.n	800be4a <prvCheckOptions+0x48>
        BaseType_t xReturn = pdPASS;
 800be64:	2001      	movs	r0, #1
        return xReturn;
 800be66:	e000      	b.n	800be6a <prvCheckOptions+0x68>
        BaseType_t xReturn = pdPASS;
 800be68:	2001      	movs	r0, #1
    }
 800be6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        BaseType_t xReturn = pdPASS;
 800be6c:	2001      	movs	r0, #1
 800be6e:	e7fc      	b.n	800be6a <prvCheckOptions+0x68>
 800be70:	2001      	movs	r0, #1
 800be72:	e7fa      	b.n	800be6a <prvCheckOptions+0x68>
 800be74:	2001      	movs	r0, #1
 800be76:	e7f8      	b.n	800be6a <prvCheckOptions+0x68>
                            xReturn = pdFAIL;
 800be78:	2000      	movs	r0, #0
 800be7a:	e7f6      	b.n	800be6a <prvCheckOptions+0x68>

0800be7c <prvCheckRxData>:
 *
 * @return Length of the received buffer.
 */
    BaseType_t prvCheckRxData( const NetworkBufferDescriptor_t * pxNetworkBuffer,
                               uint8_t ** ppucRecvData )
    {
 800be7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800be7e:	4604      	mov	r4, r0
 800be80:	460e      	mov	r6, r1

        /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                        &( pxNetworkBuffer->pucEthernetBuffer[ ( size_t ) ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer ) ] ) );
 800be82:	6a45      	ldr	r5, [r0, #36]	@ 0x24
 800be84:	f7fb fb28 	bl	80074d8 <uxIPHeaderSizePacket>
 800be88:	300e      	adds	r0, #14
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800be8a:	4405      	add	r5, r0
        const TCPHeader_t * pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
        int32_t lLength, lTCPHeaderLength, lReceiveLength, lUrgentLength;

        /* Map the buffer onto an IPHeader_t struct for easy access to fields. */

        const size_t xIPHeaderLength = uxIPHeaderSizePacket( pxNetworkBuffer );
 800be8c:	4620      	mov	r0, r4
 800be8e:	f7fb fb23 	bl	80074d8 <uxIPHeaderSizePacket>
         * node.
         *
         * The size of the TCP header is given in a multiple of 4-byte words (single
         * byte, needs no ntoh() translation).  A shift-right 2: is the same as
         * (offset >> 4) * 4. */
        ucIntermediateResult = ( pxTCPHeader->ucTCPOffset & tcpVALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2;
 800be92:	7b2a      	ldrb	r2, [r5, #12]
 800be94:	0892      	lsrs	r2, r2, #2
 800be96:	f002 023c 	and.w	r2, r2, #60	@ 0x3c
        lTCPHeaderLength = ( int32_t ) ucIntermediateResult;

        /* Let pucRecvData point to the first byte received. */
        *ppucRecvData = &( pxNetworkBuffer->pucEthernetBuffer[ ( size_t ) ipSIZE_OF_ETH_HEADER + xIPHeaderLength + ( size_t ) lTCPHeaderLength ] );
 800be9a:	6a67      	ldr	r7, [r4, #36]	@ 0x24
 800be9c:	1813      	adds	r3, r2, r0
 800be9e:	330e      	adds	r3, #14
 800bea0:	441f      	add	r7, r3
 800bea2:	6037      	str	r7, [r6, #0]

        /* Calculate lReceiveLength - the length of the TCP data received.  This is
         * equal to the total packet length minus:
         * ( LinkLayer length (14) + IP header length (20) + size of TCP header(20 +) ).*/
        lReceiveLength = ( int32_t ) pxNetworkBuffer->xDataLength;
 800bea4:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
        lReceiveLength -= ( int32_t ) ipSIZE_OF_ETH_HEADER;
 800bea6:	390e      	subs	r1, #14

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        switch( ( ( EthernetHeader_t * ) pxNetworkBuffer->pucEthernetBuffer )->usFrameType )
 800bea8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800beaa:	899c      	ldrh	r4, [r3, #12]
 800beac:	2c08      	cmp	r4, #8
 800beae:	d005      	beq.n	800bebc <prvCheckRxData+0x40>
 800beb0:	f64d 5c86 	movw	ip, #56710	@ 0xdd86
 800beb4:	4564      	cmp	r4, ip
 800beb6:	d013      	beq.n	800bee0 <prvCheckRxData+0x64>
 800beb8:	2300      	movs	r3, #0
 800beba:	e004      	b.n	800bec6 <prvCheckRxData+0x4a>
                       /* MISRA Ref 11.3.1 [Misaligned access] */
                       /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
                       /* coverity[misra_c_2012_rule_11_3_violation] */
                       const IPHeader_t * pxIPHeader = ( ( IPHeader_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );

                       usLength = FreeRTOS_htons( pxIPHeader->usLength );
 800bebc:	8a1c      	ldrh	r4, [r3, #16]
 800bebe:	0223      	lsls	r3, r4, #8
 800bec0:	ea43 2314 	orr.w	r3, r3, r4, lsr #8
 800bec4:	b29b      	uxth	r3, r3
                /* Shouldn't reach here */
                lLength = 0;
                break;
        }

        if( lReceiveLength > lLength )
 800bec6:	428b      	cmp	r3, r1
 800bec8:	db00      	blt.n	800becc <prvCheckRxData+0x50>
        lReceiveLength -= ( int32_t ) ipSIZE_OF_ETH_HEADER;
 800beca:	460b      	mov	r3, r1
            lReceiveLength = lLength;
        }

        /* Subtract the size of the TCP and IP headers and the actual data size is
         * known. */
        if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) xIPHeaderLength ) )
 800becc:	4410      	add	r0, r2
 800bece:	4298      	cmp	r0, r3
 800bed0:	da0d      	bge.n	800beee <prvCheckRxData+0x72>
        {
            lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) xIPHeaderLength );
 800bed2:	1a1c      	subs	r4, r3, r0
         * This field communicates the current value of the urgent pointer as a
         * positive offset from the sequence number in this segment.  The urgent
         * pointer points to the sequence number of the octet following the urgent
         * data.  This field is only be interpreted in segments with the URG control
         * bit set. */
        if( ( pxTCPHeader->ucTCPFlags & tcpTCP_FLAG_URG ) != 0U )
 800bed4:	7b6b      	ldrb	r3, [r5, #13]
 800bed6:	f013 0f20 	tst.w	r3, #32
 800beda:	d10a      	bne.n	800bef2 <prvCheckRxData+0x76>
            *ppucRecvData += lUrgentLength;
            lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
        }

        return ( BaseType_t ) lReceiveLength;
    }
 800bedc:	4620      	mov	r0, r4
 800bede:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                       usLength = FreeRTOS_htons( pxIPHeader->usPayloadLength );
 800bee0:	8a5c      	ldrh	r4, [r3, #18]
 800bee2:	0223      	lsls	r3, r4, #8
 800bee4:	ea43 2314 	orr.w	r3, r3, r4, lsr #8
 800bee8:	b29b      	uxth	r3, r3
                       lLength += ( int32_t ) sizeof( IPHeader_IPv6_t );
 800beea:	3328      	adds	r3, #40	@ 0x28
                   break;
 800beec:	e7eb      	b.n	800bec6 <prvCheckRxData+0x4a>
            lReceiveLength = 0;
 800beee:	2400      	movs	r4, #0
 800bef0:	e7f0      	b.n	800bed4 <prvCheckRxData+0x58>
            lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
 800bef2:	8a6b      	ldrh	r3, [r5, #18]
 800bef4:	0219      	lsls	r1, r3, #8
 800bef6:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
 800befa:	b289      	uxth	r1, r1
            *ppucRecvData += lUrgentLength;
 800befc:	440f      	add	r7, r1
 800befe:	6037      	str	r7, [r6, #0]
            lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
 800bf00:	4620      	mov	r0, r4
 800bf02:	f7fc f98f 	bl	8008224 <FreeRTOS_min_int32>
 800bf06:	1a24      	subs	r4, r4, r0
        return ( BaseType_t ) lReceiveLength;
 800bf08:	e7e8      	b.n	800bedc <prvCheckRxData+0x60>

0800bf0a <prvStoreRxData>:
 */
    BaseType_t prvStoreRxData( FreeRTOS_Socket_t * pxSocket,
                               const uint8_t * pucRecvData,
                               NetworkBufferDescriptor_t * pxNetworkBuffer,
                               uint32_t ulReceiveLength )
    {
 800bf0a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bf0e:	b085      	sub	sp, #20
 800bf10:	4604      	mov	r4, r0
 800bf12:	460f      	mov	r7, r1
 800bf14:	4615      	mov	r5, r2
 800bf16:	461e      	mov	r6, r3
        /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */
        size_t uxIPOffset = uxIPHeaderSizePacket( pxNetworkBuffer );
 800bf18:	4610      	mov	r0, r2
 800bf1a:	f7fb fadd 	bl	80074d8 <uxIPHeaderSizePacket>
        /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( const ProtocolHeaders_t * )
                                                        &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPOffset ] ) );
 800bf1e:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800bf20:	300e      	adds	r0, #14
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( const ProtocolHeaders_t * )
 800bf22:	4403      	add	r3, r0
        int32_t lOffset, lStored;
        BaseType_t xResult = 0;
        uint32_t ulRxLength = ulReceiveLength;
        const uint8_t * pucRxBuffer = &( pucRecvData[ 0 ] );

        ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800bf24:	685b      	ldr	r3, [r3, #4]
 800bf26:	ea4f 2c03 	mov.w	ip, r3, lsl #8
 800bf2a:	f40c 0c7f 	and.w	ip, ip, #16711680	@ 0xff0000
 800bf2e:	ea4c 6c03 	orr.w	ip, ip, r3, lsl #24
 800bf32:	0a1a      	lsrs	r2, r3, #8
 800bf34:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800bf38:	ea4c 0c02 	orr.w	ip, ip, r2
 800bf3c:	ea4c 6913 	orr.w	r9, ip, r3, lsr #24

        if( ( ulRxLength > 0U ) && ( pxSocket->u.xTCP.eTCPState >= eSYN_RECEIVED ) )
 800bf40:	b3c6      	cbz	r6, 800bfb4 <prvStoreRxData+0xaa>
 800bf42:	f504 788a 	add.w	r8, r4, #276	@ 0x114
 800bf46:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800bf4a:	2b03      	cmp	r3, #3
 800bf4c:	d932      	bls.n	800bfb4 <prvStoreRxData+0xaa>
        {
            uint32_t ulSkipCount = 0;
 800bf4e:	2300      	movs	r3, #0
 800bf50:	9303      	str	r3, [sp, #12]
             *
             * If it can't be "accept"ed it may have to be stored and send a selective
             * ack (SACK) option to confirm it.  In that case, lTCPAddRxdata() will be
             * called later to store an out-of-order packet (in case lOffset is
             * negative). */
            if( pxSocket->u.xTCP.rxStream != NULL )
 800bf52:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 800bf56:	b1d8      	cbz	r0, 800bf90 <prvStoreRxData+0x86>
            {
                ulSpace = ( uint32_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.rxStream );
 800bf58:	f7ff fa5f 	bl	800b41a <uxStreamBufferGetSpace>
 800bf5c:	4603      	mov	r3, r0
            else
            {
                ulSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
            }

            lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulRxLength, ulSpace, &( ulSkipCount ) );
 800bf5e:	aa03      	add	r2, sp, #12
 800bf60:	9200      	str	r2, [sp, #0]
 800bf62:	4632      	mov	r2, r6
 800bf64:	4649      	mov	r1, r9
 800bf66:	4640      	mov	r0, r8
 800bf68:	f001 ff9e 	bl	800dea8 <lTCPWindowRxCheck>

            if( lOffset >= 0 )
 800bf6c:	1e01      	subs	r1, r0, #0
 800bf6e:	db0a      	blt.n	800bf86 <prvStoreRxData+0x7c>
            {
                /* New data has arrived and may be made available to the user.  See
                 * if the head marker in rxStream may be advanced, only if lOffset == 0.
                 * In case the low-water mark is reached, bLowWater will be set
                 * "low-water" here stands for "little space". */
                if( ulSkipCount != 0U )
 800bf70:	9b03      	ldr	r3, [sp, #12]
 800bf72:	b10b      	cbz	r3, 800bf78 <prvStoreRxData+0x6e>
                {
                    /* A packet was received that starts before 'ulCurrentSequenceNumber',
                     * and that ends after it.  The first 'ulSkipCount' bytes shall be
                     * skipped. */
                    ulRxLength -= ulSkipCount;
 800bf74:	1af6      	subs	r6, r6, r3
                    pucRxBuffer = &( pucRecvData[ ulSkipCount ] );
 800bf76:	441f      	add	r7, r3
                }

                lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRxBuffer, ulRxLength );
 800bf78:	4633      	mov	r3, r6
 800bf7a:	463a      	mov	r2, r7
 800bf7c:	4620      	mov	r0, r4
 800bf7e:	f7fe fcf3 	bl	800a968 <lTCPAddRxdata>

                if( lStored != ( int32_t ) ulRxLength )
 800bf82:	4286      	cmp	r6, r0
 800bf84:	d107      	bne.n	800bf96 <prvStoreRxData+0x8c>
            #if ( ipconfigUSE_TCP_WIN == 1 )
            {
                /* Now lTCPAddRxdata() will move the rxHead pointer forward
                 * so data becomes available to the user immediately
                 * In case the low-water mark is reached, bLowWater will be set. */
                if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0U ) )
 800bf86:	f8d4 3144 	ldr.w	r3, [r4, #324]	@ 0x144
 800bf8a:	b953      	cbnz	r3, 800bfa2 <prvStoreRxData+0x98>
 800bf8c:	2000      	movs	r0, #0
        {
 800bf8e:	e014      	b.n	800bfba <prvStoreRxData+0xb0>
                ulSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 800bf90:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
 800bf94:	e7e3      	b.n	800bf5e <prvStoreRxData+0x54>
                    ( void ) prvTCPSendReset( pxNetworkBuffer );
 800bf96:	4628      	mov	r0, r5
 800bf98:	f001 f865 	bl	800d066 <prvTCPSendReset>
                    xResult = -1;
 800bf9c:	f04f 30ff 	mov.w	r0, #4294967295
 800bfa0:	e00b      	b.n	800bfba <prvStoreRxData+0xb0>
                {
                    ( void ) lTCPAddRxdata( pxSocket, 0U, NULL, pxTCPWindow->ulUserDataLength );
 800bfa2:	2200      	movs	r2, #0
 800bfa4:	4611      	mov	r1, r2
 800bfa6:	4620      	mov	r0, r4
 800bfa8:	f7fe fcde 	bl	800a968 <lTCPAddRxdata>
                    pxTCPWindow->ulUserDataLength = 0;
 800bfac:	2000      	movs	r0, #0
 800bfae:	f8c4 0144 	str.w	r0, [r4, #324]	@ 0x144
 800bfb2:	e002      	b.n	800bfba <prvStoreRxData+0xb0>
            }
            #endif /* ipconfigUSE_TCP_WIN */
        }
        else
        {
            pxTCPWindow->ucOptionLength = 0U;
 800bfb4:	2000      	movs	r0, #0
 800bfb6:	f884 0150 	strb.w	r0, [r4, #336]	@ 0x150
        }

        return xResult;
    }
 800bfba:	b005      	add	sp, #20
 800bfbc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800bfc0 <prvTCPHandleFin>:
 *
 * @return Length of the packet to be sent.
 */
    static BaseType_t prvTCPHandleFin( FreeRTOS_Socket_t * pxSocket,
                                       const NetworkBufferDescriptor_t * pxNetworkBuffer )
    {
 800bfc0:	b538      	push	{r3, r4, r5, lr}
 800bfc2:	4604      	mov	r4, r0
 800bfc4:	4608      	mov	r0, r1

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                  &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer ) ] ) );
 800bfc6:	6a4d      	ldr	r5, [r1, #36]	@ 0x24
 800bfc8:	f7fb fa86 	bl	80074d8 <uxIPHeaderSizePacket>
 800bfcc:	300e      	adds	r0, #14
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800bfce:	4405      	add	r5, r0
        TCPHeader_t * pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
        uint8_t ucIntermediateResult = 0, ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800bfd0:	7b68      	ldrb	r0, [r5, #13]
        TCPWindow_t * pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
        BaseType_t xSendLength = 0;
        uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 800bfd2:	68aa      	ldr	r2, [r5, #8]
 800bfd4:	0213      	lsls	r3, r2, #8
 800bfd6:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800bfda:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800bfde:	0a11      	lsrs	r1, r2, #8
 800bfe0:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800bfe4:	430b      	orrs	r3, r1
 800bfe6:	ea43 6312 	orr.w	r3, r3, r2, lsr #24

        if( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U )
 800bfea:	f010 0f01 	tst.w	r0, #1
 800bfee:	d004      	beq.n	800bffa <prvTCPHandleFin+0x3a>
        {
            pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1U;
 800bff0:	f8d4 2128 	ldr.w	r2, [r4, #296]	@ 0x128
 800bff4:	3201      	adds	r2, #1
 800bff6:	f8c4 2124 	str.w	r2, [r4, #292]	@ 0x124
        }

        if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800bffa:	f894 2069 	ldrb.w	r2, [r4, #105]	@ 0x69
 800bffe:	f012 0f40 	tst.w	r2, #64	@ 0x40
 800c002:	d125      	bne.n	800c050 <prvTCPHandleFin+0x90>
        {
            /* We haven't yet replied with a FIN, do so now. */
            pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800c004:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
 800c008:	f8c4 3138 	str.w	r3, [r4, #312]	@ 0x138
            pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800c00c:	f042 0340 	orr.w	r3, r2, #64	@ 0x40
 800c010:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
            {
                pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
            }
        }

        if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
 800c014:	f894 206a 	ldrb.w	r2, [r4, #106]	@ 0x6a
 800c018:	f012 0f01 	tst.w	r2, #1
 800c01c:	d024      	beq.n	800c068 <prvTCPHandleFin+0xa8>
            vTCPStateChange( pxSocket, eLAST_ACK );
        }
        else
        {
            /* Our FIN has been ACK'd, the outgoing sequence number is now fixed. */
            pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1U;
 800c01e:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
 800c022:	3301      	adds	r3, #1
 800c024:	f8c4 3134 	str.w	r3, [r4, #308]	@ 0x134

            if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
 800c028:	f994 3069 	ldrsb.w	r3, [r4, #105]	@ 0x69
 800c02c:	2b00      	cmp	r3, #0
 800c02e:	db26      	blt.n	800c07e <prvTCPHandleFin+0xbe>
            {
                /* We have sent out a FIN but the peer hasn't replied with a FIN
                 * yet. Do nothing for the moment. */
                pxTCPHeader->ucTCPFlags = 0U;
 800c030:	2300      	movs	r3, #0
 800c032:	736b      	strb	r3, [r5, #13]
                /* And wait for the user to close this socket. */
                vTCPStateChange( pxSocket, eCLOSE_WAIT );
            }
        }

        pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800c034:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
 800c038:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140

        if( pxTCPHeader->ucTCPFlags != 0U )
 800c03c:	7b6b      	ldrb	r3, [r5, #13]
 800c03e:	bb5b      	cbnz	r3, 800c098 <prvTCPHandleFin+0xd8>
        BaseType_t xSendLength = 0;
 800c040:	2000      	movs	r0, #0
        {
            ucIntermediateResult = ( uint8_t ) ( uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength );
            xSendLength = ( BaseType_t ) ucIntermediateResult;
        }

        pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) << 2 );
 800c042:	f894 3150 	ldrb.w	r3, [r4, #336]	@ 0x150
 800c046:	3314      	adds	r3, #20
 800c048:	b2db      	uxtb	r3, r3
 800c04a:	009b      	lsls	r3, r3, #2
 800c04c:	732b      	strb	r3, [r5, #12]
                                     ( unsigned ) ( pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber ),
                                     ( unsigned ) ( pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) ) );
        }

        return xSendLength;
    }
 800c04e:	bd38      	pop	{r3, r4, r5, pc}
            if( ulAckNr == ( pxTCPWindow->tx.ulFINSequenceNumber + 1U ) )
 800c050:	f8d4 2138 	ldr.w	r2, [r4, #312]	@ 0x138
 800c054:	3201      	adds	r2, #1
 800c056:	429a      	cmp	r2, r3
 800c058:	d1dc      	bne.n	800c014 <prvTCPHandleFin+0x54>
                pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
 800c05a:	f894 306a 	ldrb.w	r3, [r4, #106]	@ 0x6a
 800c05e:	f043 0301 	orr.w	r3, r3, #1
 800c062:	f884 306a 	strb.w	r3, [r4, #106]	@ 0x6a
 800c066:	e7d5      	b.n	800c014 <prvTCPHandleFin+0x54>
            pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800c068:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
 800c06c:	f8c4 3134 	str.w	r3, [r4, #308]	@ 0x134
            pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_FIN;
 800c070:	2311      	movs	r3, #17
 800c072:	736b      	strb	r3, [r5, #13]
            vTCPStateChange( pxSocket, eLAST_ACK );
 800c074:	210a      	movs	r1, #10
 800c076:	4620      	mov	r0, r4
 800c078:	f7ff fb20 	bl	800b6bc <vTCPStateChange>
 800c07c:	e7da      	b.n	800c034 <prvTCPHandleFin+0x74>
                if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
 800c07e:	f012 0f02 	tst.w	r2, #2
 800c082:	d106      	bne.n	800c092 <prvTCPHandleFin+0xd2>
                    pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
 800c084:	2310      	movs	r3, #16
 800c086:	736b      	strb	r3, [r5, #13]
                vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800c088:	2108      	movs	r1, #8
 800c08a:	4620      	mov	r0, r4
 800c08c:	f7ff fb16 	bl	800b6bc <vTCPStateChange>
 800c090:	e7d0      	b.n	800c034 <prvTCPHandleFin+0x74>
                    pxTCPHeader->ucTCPFlags = 0U;
 800c092:	2300      	movs	r3, #0
 800c094:	736b      	strb	r3, [r5, #13]
 800c096:	e7f7      	b.n	800c088 <prvTCPHandleFin+0xc8>
            ucIntermediateResult = ( uint8_t ) ( uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength );
 800c098:	4620      	mov	r0, r4
 800c09a:	f7fb fc05 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c09e:	f894 3150 	ldrb.w	r3, [r4, #336]	@ 0x150
 800c0a2:	4418      	add	r0, r3
 800c0a4:	b2c0      	uxtb	r0, r0
 800c0a6:	3014      	adds	r0, #20
 800c0a8:	b2c0      	uxtb	r0, r0
            xSendLength = ( BaseType_t ) ucIntermediateResult;
 800c0aa:	e7ca      	b.n	800c042 <prvTCPHandleFin+0x82>

0800c0ac <prvHandleSynReceived>:
 */
    static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t * pxSocket,
                                            const NetworkBufferDescriptor_t * pxNetworkBuffer,
                                            uint32_t ulReceiveLength,
                                            UBaseType_t uxOptionsLength )
    {
 800c0ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c0b0:	b08a      	sub	sp, #40	@ 0x28
 800c0b2:	4604      	mov	r4, r0
 800c0b4:	4617      	mov	r7, r2
 800c0b6:	461d      	mov	r5, r3

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                  &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800c0b8:	6a4e      	ldr	r6, [r1, #36]	@ 0x24
 800c0ba:	f7fb fbf5 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c0be:	300e      	adds	r0, #14
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800c0c0:	4406      	add	r6, r0
        TCPHeader_t * pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
        TCPWindow_t * pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
        uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800c0c2:	7b72      	ldrb	r2, [r6, #13]
        uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800c0c4:	6873      	ldr	r3, [r6, #4]
 800c0c6:	0219      	lsls	r1, r3, #8
 800c0c8:	f401 017f 	and.w	r1, r1, #16711680	@ 0xff0000
 800c0cc:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 800c0d0:	0a18      	lsrs	r0, r3, #8
 800c0d2:	f400 407f 	and.w	r0, r0, #65280	@ 0xff00
 800c0d6:	4301      	orrs	r1, r0
 800c0d8:	ea41 6813 	orr.w	r8, r1, r3, lsr #24

        /* Either expect a ACK or a SYN+ACK. */
        uint8_t ucExpect = tcpTCP_FLAG_ACK;
        const uint8_t ucFlagsMask = tcpTCP_FLAG_ACK | tcpTCP_FLAG_RST | tcpTCP_FLAG_SYN | tcpTCP_FLAG_FIN;

        if( pxSocket->u.xTCP.eTCPState == eCONNECT_SYN )
 800c0dc:	f894 1079 	ldrb.w	r1, [r4, #121]	@ 0x79
 800c0e0:	2902      	cmp	r1, #2
 800c0e2:	d043      	beq.n	800c16c <prvHandleSynReceived+0xc0>
        uint8_t ucExpect = tcpTCP_FLAG_ACK;
 800c0e4:	2010      	movs	r0, #16
        {
            ucExpect |= tcpTCP_FLAG_SYN;
        }

        if( ( ucTCPFlags & ucFlagsMask ) != ucExpect )
 800c0e6:	f002 0317 	and.w	r3, r2, #23
 800c0ea:	4283      	cmp	r3, r0
 800c0ec:	d140      	bne.n	800c170 <prvHandleSynReceived+0xc4>

            pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
        }
        else
        {
            pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
 800c0ee:	f8b4 3064 	ldrh.w	r3, [r4, #100]	@ 0x64
 800c0f2:	f8a4 31ce 	strh.w	r3, [r4, #462]	@ 0x1ce
            pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
 800c0f6:	8f23      	ldrh	r3, [r4, #56]	@ 0x38
 800c0f8:	f8a4 31cc 	strh.w	r3, [r4, #460]	@ 0x1cc

            if( pxSocket->u.xTCP.eTCPState == eCONNECT_SYN )
 800c0fc:	2902      	cmp	r1, #2
 800c0fe:	d059      	beq.n	800c1b4 <prvHandleSynReceived+0x108>
                pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1U;
                pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
                pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
                pxTCPWindow->ulNextTxSequenceNumber++;
            }
            else if( ulReceiveLength == 0U )
 800c100:	b90f      	cbnz	r7, 800c106 <prvHandleSynReceived+0x5a>
            {
                pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 800c102:	f8c4 8124 	str.w	r8, [r4, #292]	@ 0x124
                /* Nothing. */
            }

            /* The SYN+ACK has been confirmed, increase the next sequence number by
             * 1. */
            pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U;
 800c106:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
 800c10a:	3301      	adds	r3, #1
 800c10c:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140

            #if ( ipconfigUSE_TCP_WIN == 1 )
            {
                char pcBuffer[ 40 ]; /* Space to print an IP-address. */
                ( void ) FreeRTOS_inet_ntop( ( pxSocket->bits.bIsIPv6 != 0U ) ? FREERTOS_AF_INET6 : FREERTOS_AF_INET,
 800c110:	7a23      	ldrb	r3, [r4, #8]
 800c112:	f013 0f01 	tst.w	r3, #1
 800c116:	d06f      	beq.n	800c1f8 <prvHandleSynReceived+0x14c>
 800c118:	200a      	movs	r0, #10
 800c11a:	2328      	movs	r3, #40	@ 0x28
 800c11c:	466a      	mov	r2, sp
 800c11e:	f104 0154 	add.w	r1, r4, #84	@ 0x54
 800c122:	f7fe fb39 	bl	800a798 <FreeRTOS_inet_ntop>
                                         pxSocket->u.xTCP.usRemotePort,
                                         ( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
            }
            #endif /* ipconfigUSE_TCP_WIN */

            if( ( pxSocket->u.xTCP.eTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0U ) )
 800c126:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800c12a:	2b02      	cmp	r3, #2
 800c12c:	d001      	beq.n	800c132 <prvHandleSynReceived+0x86>
 800c12e:	2f00      	cmp	r7, #0
 800c130:	d064      	beq.n	800c1fc <prvHandleSynReceived+0x150>
            {
                pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
 800c132:	2310      	movs	r3, #16
 800c134:	7373      	strb	r3, [r6, #13]

                uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ( size_t ) ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800c136:	4620      	mov	r0, r4
 800c138:	f7fb fbb6 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c13c:	1947      	adds	r7, r0, r5
 800c13e:	3714      	adds	r7, #20
                xSendLength = ( BaseType_t ) uxIntermediateResult;
                pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800c140:	3514      	adds	r5, #20
 800c142:	b2ed      	uxtb	r5, r5
 800c144:	00ad      	lsls	r5, r5, #2
 800c146:	7335      	strb	r5, [r6, #12]
            }

            #if ( ipconfigUSE_TCP_WIN != 0 )
            {
                if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
 800c148:	f894 306a 	ldrb.w	r3, [r4, #106]	@ 0x6a
 800c14c:	f013 0f10 	tst.w	r3, #16
 800c150:	d104      	bne.n	800c15c <prvHandleSynReceived+0xb0>
                {
                    /* The other party did not send a scaling factor.
                     * A shifting factor in this side must be canceled. */
                    pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
 800c152:	2300      	movs	r3, #0
 800c154:	f884 3105 	strb.w	r3, [r4, #261]	@ 0x105
                    pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
 800c158:	f884 3106 	strb.w	r3, [r4, #262]	@ 0x106
            }
            #endif /* ipconfigUSE_TCP_WIN */

            /* This was the third step of connecting: SYN, SYN+ACK, ACK so now the
             * connection is established. */
            vTCPStateChange( pxSocket, eESTABLISHED );
 800c15c:	2105      	movs	r1, #5
 800c15e:	4620      	mov	r0, r4
 800c160:	f7ff faac 	bl	800b6bc <vTCPStateChange>
        }

        return xSendLength;
    }
 800c164:	4638      	mov	r0, r7
 800c166:	b00a      	add	sp, #40	@ 0x28
 800c168:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ucExpect |= tcpTCP_FLAG_SYN;
 800c16c:	2012      	movs	r0, #18
 800c16e:	e7ba      	b.n	800c0e6 <prvHandleSynReceived+0x3a>
            vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800c170:	2108      	movs	r1, #8
 800c172:	4620      	mov	r0, r4
 800c174:	f7ff faa2 	bl	800b6bc <vTCPStateChange>
            pxTCPWindow->ulOurSequenceNumber = FreeRTOS_htonl( pxTCPHeader->ulAckNr );
 800c178:	68b2      	ldr	r2, [r6, #8]
 800c17a:	0213      	lsls	r3, r2, #8
 800c17c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800c180:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c184:	0a11      	lsrs	r1, r2, #8
 800c186:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800c18a:	430b      	orrs	r3, r1
 800c18c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c190:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
            pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 800c194:	f8c4 8124 	str.w	r8, [r4, #292]	@ 0x124
            pxTCPHeader->ucTCPFlags |= tcpTCP_FLAG_RST;
 800c198:	7b73      	ldrb	r3, [r6, #13]
 800c19a:	f043 0304 	orr.w	r3, r3, #4
 800c19e:	7373      	strb	r3, [r6, #13]
            uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800c1a0:	4620      	mov	r0, r4
 800c1a2:	f7fb fb81 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c1a6:	1947      	adds	r7, r0, r5
 800c1a8:	3714      	adds	r7, #20
            pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800c1aa:	3514      	adds	r5, #20
 800c1ac:	b2ed      	uxtb	r5, r5
 800c1ae:	00ad      	lsls	r5, r5, #2
 800c1b0:	7335      	strb	r5, [r6, #12]
 800c1b2:	e7d7      	b.n	800c164 <prvHandleSynReceived+0xb8>
                                                      &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800c1b4:	4620      	mov	r0, r4
 800c1b6:	f7fb fb77 	bl	80078a8 <uxIPHeaderSizeSocket>
                ProtocolHeaders_t * pxLastHeaders = ( ( ProtocolHeaders_t * )
 800c1ba:	30ae      	adds	r0, #174	@ 0xae
 800c1bc:	4420      	add	r0, r4
                pxLastHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
 800c1be:	2310      	movs	r3, #16
 800c1c0:	75c3      	strb	r3, [r0, #23]
                pxProtocolHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_ACK;
 800c1c2:	7373      	strb	r3, [r6, #13]
                vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
 800c1c4:	f8b4 3072 	ldrh.w	r3, [r4, #114]	@ 0x72
 800c1c8:	f8d4 2140 	ldr.w	r2, [r4, #320]	@ 0x140
 800c1cc:	4641      	mov	r1, r8
 800c1ce:	f504 708a 	add.w	r0, r4, #276	@ 0x114
 800c1d2:	f001 fe0e 	bl	800ddf2 <vTCPWindowInit>
                pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1U;
 800c1d6:	f108 0101 	add.w	r1, r8, #1
 800c1da:	f8c4 112c 	str.w	r1, [r4, #300]	@ 0x12c
                pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
 800c1de:	f8c4 1124 	str.w	r1, [r4, #292]	@ 0x124
                pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
 800c1e2:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
 800c1e6:	3301      	adds	r3, #1
 800c1e8:	f8c4 3134 	str.w	r3, [r4, #308]	@ 0x134
                pxTCPWindow->ulNextTxSequenceNumber++;
 800c1ec:	f8d4 3148 	ldr.w	r3, [r4, #328]	@ 0x148
 800c1f0:	3301      	adds	r3, #1
 800c1f2:	f8c4 3148 	str.w	r3, [r4, #328]	@ 0x148
 800c1f6:	e786      	b.n	800c106 <prvHandleSynReceived+0x5a>
                ( void ) FreeRTOS_inet_ntop( ( pxSocket->bits.bIsIPv6 != 0U ) ? FREERTOS_AF_INET6 : FREERTOS_AF_INET,
 800c1f8:	2002      	movs	r0, #2
 800c1fa:	e78e      	b.n	800c11a <prvHandleSynReceived+0x6e>
        BaseType_t xSendLength = 0;
 800c1fc:	2700      	movs	r7, #0
 800c1fe:	e7a3      	b.n	800c148 <prvHandleSynReceived+0x9c>

0800c200 <prvHandleEstablished>:
 */
    static BaseType_t prvHandleEstablished( FreeRTOS_Socket_t * pxSocket,
                                            NetworkBufferDescriptor_t ** ppxNetworkBuffer,
                                            uint32_t ulReceiveLength,
                                            UBaseType_t uxOptionsLength )
    {
 800c200:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c204:	b083      	sub	sp, #12
 800c206:	4604      	mov	r4, r0
 800c208:	460f      	mov	r7, r1
 800c20a:	4691      	mov	r9, r2
 800c20c:	4698      	mov	r8, r3

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                  &( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800c20e:	680b      	ldr	r3, [r1, #0]
 800c210:	6a5e      	ldr	r6, [r3, #36]	@ 0x24
 800c212:	f7fb fb49 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c216:	300e      	adds	r0, #14
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800c218:	4406      	add	r6, r0
        TCPHeader_t * pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
        TCPWindow_t * pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
        uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800c21a:	f896 a00d 	ldrb.w	sl, [r6, #13]
        uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount, ulIntermediateResult = 0;
 800c21e:	6873      	ldr	r3, [r6, #4]
 800c220:	021d      	lsls	r5, r3, #8
 800c222:	f405 057f 	and.w	r5, r5, #16711680	@ 0xff0000
 800c226:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
 800c22a:	0a1a      	lsrs	r2, r3, #8
 800c22c:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800c230:	4315      	orrs	r5, r2
 800c232:	ea45 6513 	orr.w	r5, r5, r3, lsr #24
        int32_t lDistance, lSendResult;
        uint16_t usWindow;
        UBaseType_t uxIntermediateResult = 0;

        /* Remember the window size the peer is advertising. */
        usWindow = FreeRTOS_ntohs( pxTCPHeader->usWindow );
 800c236:	89f2      	ldrh	r2, [r6, #14]
 800c238:	0213      	lsls	r3, r2, #8
 800c23a:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800c23e:	b29b      	uxth	r3, r3
        pxSocket->u.xTCP.ulWindowSize = ( uint32_t ) usWindow;
 800c240:	f8c4 3108 	str.w	r3, [r4, #264]	@ 0x108
        #if ( ipconfigUSE_TCP_WIN != 0 )
        {
            pxSocket->u.xTCP.ulWindowSize =
                ( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 800c244:	f894 2106 	ldrb.w	r2, [r4, #262]	@ 0x106
 800c248:	4093      	lsls	r3, r2
            pxSocket->u.xTCP.ulWindowSize =
 800c24a:	f8c4 3108 	str.w	r3, [r4, #264]	@ 0x108
        }
        #endif /* ipconfigUSE_TCP_WIN */

        if( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_ACK ) == 0U )
 800c24e:	f01a 0f10 	tst.w	sl, #16
 800c252:	d104      	bne.n	800c25e <prvHandleEstablished+0x5e>
        BaseType_t xSendLength = 0, xMayClose = pdFALSE, bRxComplete, bTxDone;
 800c254:	2500      	movs	r5, #0
                }
            }
        }

        return xSendLength;
    }
 800c256:	4628      	mov	r0, r5
 800c258:	b003      	add	sp, #12
 800c25a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c25e:	f504 7b8a 	add.w	fp, r4, #276	@ 0x114
            ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPHeader->ulAckNr ) );
 800c262:	68b1      	ldr	r1, [r6, #8]
 800c264:	020b      	lsls	r3, r1, #8
 800c266:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800c26a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800c26e:	0a0a      	lsrs	r2, r1, #8
 800c270:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800c274:	4313      	orrs	r3, r2
 800c276:	ea43 6111 	orr.w	r1, r3, r1, lsr #24
 800c27a:	4658      	mov	r0, fp
 800c27c:	f001 ff37 	bl	800e0ee <ulTCPWindowTxAck>
            if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0U ) )
 800c280:	f8d4 c0a0 	ldr.w	ip, [r4, #160]	@ 0xa0
 800c284:	f1bc 0f00 	cmp.w	ip, #0
 800c288:	d000      	beq.n	800c28c <prvHandleEstablished+0x8c>
 800c28a:	bbb8      	cbnz	r0, 800c2fc <prvHandleEstablished+0xfc>
            if( pxSocket->u.xTCP.txStream != NULL )
 800c28c:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800c290:	b113      	cbz	r3, 800c298 <prvHandleEstablished+0x98>
                prvTCPAddTxData( pxSocket );
 800c292:	4620      	mov	r0, r4
 800c294:	f000 fe27 	bl	800cee6 <prvTCPAddTxData>
            pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800c298:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
 800c29c:	f8c4 3140 	str.w	r3, [r4, #320]	@ 0x140
            if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_FIN ) != 0U ) )
 800c2a0:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800c2a4:	f013 0f20 	tst.w	r3, #32
 800c2a8:	d102      	bne.n	800c2b0 <prvHandleEstablished+0xb0>
 800c2aa:	f01a 0f01 	tst.w	sl, #1
 800c2ae:	d013      	beq.n	800c2d8 <prvHandleEstablished+0xd8>
                if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800c2b0:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800c2b4:	d139      	bne.n	800c32a <prvHandleEstablished+0x12a>
                    bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
 800c2b6:	4658      	mov	r0, fp
 800c2b8:	f001 fd71 	bl	800dd9e <xTCPWindowRxEmpty>
 800c2bc:	4682      	mov	sl, r0
                    bTxDone = xTCPWindowTxDone( pxTCPWindow );
 800c2be:	4658      	mov	r0, fp
 800c2c0:	f001 fe88 	bl	800dfd4 <xTCPWindowTxDone>
                    if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
 800c2c4:	f1ba 0f00 	cmp.w	sl, #0
 800c2c8:	d006      	beq.n	800c2d8 <prvHandleEstablished+0xd8>
 800c2ca:	b128      	cbz	r0, 800c2d8 <prvHandleEstablished+0xd8>
                        ulIntermediateResult = ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNumber;
 800c2cc:	444d      	add	r5, r9
 800c2ce:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
 800c2d2:	1aed      	subs	r5, r5, r3
                        if( lDistance > 1 )
 800c2d4:	2d01      	cmp	r5, #1
 800c2d6:	dd28      	ble.n	800c32a <prvHandleEstablished+0x12a>
                pxTCPHeader->ucTCPFlags = tcpTCP_FLAG_ACK;
 800c2d8:	2310      	movs	r3, #16
 800c2da:	7373      	strb	r3, [r6, #13]
                if( ulReceiveLength != 0U )
 800c2dc:	f1b9 0f00 	cmp.w	r9, #0
 800c2e0:	d12f      	bne.n	800c342 <prvHandleEstablished+0x142>
 800c2e2:	2500      	movs	r5, #0
                if( uxOptionsLength == 0U )
 800c2e4:	f1b8 0f00 	cmp.w	r8, #0
 800c2e8:	d1b5      	bne.n	800c256 <prvHandleEstablished+0x56>
                    lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 800c2ea:	4642      	mov	r2, r8
 800c2ec:	4639      	mov	r1, r7
 800c2ee:	4620      	mov	r0, r4
 800c2f0:	f000 fc8e 	bl	800cc10 <prvTCPPrepareSend>
                    if( lSendResult > 0 )
 800c2f4:	2800      	cmp	r0, #0
 800c2f6:	ddae      	ble.n	800c256 <prvHandleEstablished+0x56>
                        xSendLength = ( BaseType_t ) lSendResult;
 800c2f8:	4605      	mov	r5, r0
        return xSendLength;
 800c2fa:	e7ac      	b.n	800c256 <prvHandleEstablished+0x56>
                if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0U, NULL, ( size_t ) ulCount, pdFALSE ) != 0U )
 800c2fc:	2100      	movs	r1, #0
 800c2fe:	9100      	str	r1, [sp, #0]
 800c300:	4603      	mov	r3, r0
 800c302:	460a      	mov	r2, r1
 800c304:	4660      	mov	r0, ip
 800c306:	f7ff f918 	bl	800b53a <uxStreamBufferGet>
 800c30a:	2800      	cmp	r0, #0
 800c30c:	d0be      	beq.n	800c28c <prvHandleEstablished+0x8c>
                    pxSocket->xEventBits |= ( EventBits_t ) eSOCKET_SEND;
 800c30e:	6823      	ldr	r3, [r4, #0]
 800c310:	f043 0202 	orr.w	r2, r3, #2
 800c314:	6022      	str	r2, [r4, #0]
                        if( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_WRITE ) ) != 0U )
 800c316:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 800c318:	f012 0f02 	tst.w	r2, #2
 800c31c:	d0b6      	beq.n	800c28c <prvHandleEstablished+0x8c>
                            pxSocket->xEventBits |= ( ( EventBits_t ) eSELECT_WRITE ) << SOCKET_EVENT_BIT_COUNT;
 800c31e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800c322:	f043 0302 	orr.w	r3, r3, #2
 800c326:	6023      	str	r3, [r4, #0]
 800c328:	e7b0      	b.n	800c28c <prvHandleEstablished+0x8c>
                    pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
 800c32a:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800c32e:	f043 0320 	orr.w	r3, r3, #32
 800c332:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                    xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 800c336:	6839      	ldr	r1, [r7, #0]
 800c338:	4620      	mov	r0, r4
 800c33a:	f7ff fe41 	bl	800bfc0 <prvTCPHandleFin>
 800c33e:	4605      	mov	r5, r0
            if( xMayClose == pdFALSE )
 800c340:	e789      	b.n	800c256 <prvHandleEstablished+0x56>
                    uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800c342:	4620      	mov	r0, r4
 800c344:	f7fb fab0 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c348:	eb00 0508 	add.w	r5, r0, r8
 800c34c:	3514      	adds	r5, #20
                    pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800c34e:	f108 0314 	add.w	r3, r8, #20
 800c352:	b2db      	uxtb	r3, r3
 800c354:	009b      	lsls	r3, r3, #2
 800c356:	7333      	strb	r3, [r6, #12]
                    if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 800c358:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800c35c:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800c360:	d0c0      	beq.n	800c2e4 <prvHandleEstablished+0xe4>
                        pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800c362:	f8d4 3138 	ldr.w	r3, [r4, #312]	@ 0x138
 800c366:	f8c4 3134 	str.w	r3, [r4, #308]	@ 0x134
 800c36a:	e7bb      	b.n	800c2e4 <prvHandleEstablished+0xe4>

0800c36c <prvTCPSocketIsActive>:
        switch( eStatus )
 800c36c:	280b      	cmp	r0, #11
 800c36e:	d807      	bhi.n	800c380 <prvTCPSocketIsActive+0x14>
 800c370:	f640 3381 	movw	r3, #2945	@ 0xb81
 800c374:	40c3      	lsrs	r3, r0
 800c376:	f013 0f01 	tst.w	r3, #1
 800c37a:	d003      	beq.n	800c384 <prvTCPSocketIsActive+0x18>
 800c37c:	2000      	movs	r0, #0
 800c37e:	4770      	bx	lr
                xResult = pdTRUE;
 800c380:	2001      	movs	r0, #1
 800c382:	4770      	bx	lr
 800c384:	2001      	movs	r0, #1
    }
 800c386:	4770      	bx	lr

0800c388 <prvTCPStatusAgeCheck>:
        {
 800c388:	b510      	push	{r4, lr}
 800c38a:	4604      	mov	r4, r0
            eIPTCPState_t eState = pxSocket->u.xTCP.eTCPState;
 800c38c:	f890 2079 	ldrb.w	r2, [r0, #121]	@ 0x79
            switch( eState )
 800c390:	2a08      	cmp	r2, #8
 800c392:	d807      	bhi.n	800c3a4 <prvTCPStatusAgeCheck+0x1c>
 800c394:	f240 1323 	movw	r3, #291	@ 0x123
 800c398:	40d3      	lsrs	r3, r2
 800c39a:	f013 0f01 	tst.w	r3, #1
 800c39e:	d001      	beq.n	800c3a4 <prvTCPStatusAgeCheck+0x1c>
 800c3a0:	2000      	movs	r0, #0
        }
 800c3a2:	bd10      	pop	{r4, pc}
                TickType_t xAge = xTaskGetTickCount() - pxSocket->u.xTCP.xLastActTime;
 800c3a4:	f7f8 fc3e 	bl	8004c24 <xTaskGetTickCount>
 800c3a8:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
 800c3ac:	1ac0      	subs	r0, r0, r3
                if( xAge > ( ( TickType_t ) ipconfigTCP_HANG_PROTECTION_TIME * ( TickType_t ) configTICK_RATE_HZ ) )
 800c3ae:	f247 5330 	movw	r3, #30000	@ 0x7530
 800c3b2:	4298      	cmp	r0, r3
 800c3b4:	d801      	bhi.n	800c3ba <prvTCPStatusAgeCheck+0x32>
                    xResult = pdTRUE;
 800c3b6:	2001      	movs	r0, #1
 800c3b8:	e7f3      	b.n	800c3a2 <prvTCPStatusAgeCheck+0x1a>
                    vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800c3ba:	2108      	movs	r1, #8
 800c3bc:	4620      	mov	r0, r4
 800c3be:	f7ff f97d 	bl	800b6bc <vTCPStateChange>
                    if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 800c3c2:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800c3c6:	f013 0f04 	tst.w	r3, #4
 800c3ca:	d101      	bne.n	800c3d0 <prvTCPStatusAgeCheck+0x48>
                    xResult = pdTRUE;
 800c3cc:	2001      	movs	r0, #1
 800c3ce:	e7e8      	b.n	800c3a2 <prvTCPStatusAgeCheck+0x1a>
                        xResult = -1;
 800c3d0:	f04f 30ff 	mov.w	r0, #4294967295
            return xResult;
 800c3d4:	e7e5      	b.n	800c3a2 <prvTCPStatusAgeCheck+0x1a>

0800c3d6 <prvTCPHandleState>:
 * As these functions are declared static, and they're called from one location
 * only, most compilers will inline them, thus avoiding a call and return.
 */
    BaseType_t prvTCPHandleState( FreeRTOS_Socket_t * pxSocket,
                                  NetworkBufferDescriptor_t ** ppxNetworkBuffer )
    {
 800c3d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c3da:	b083      	sub	sp, #12
 800c3dc:	4604      	mov	r4, r0
 800c3de:	460e      	mov	r6, r1

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                  &( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( *ppxNetworkBuffer ) ] ) );
 800c3e0:	6808      	ldr	r0, [r1, #0]
 800c3e2:	6a47      	ldr	r7, [r0, #36]	@ 0x24
 800c3e4:	f7fb f878 	bl	80074d8 <uxIPHeaderSizePacket>
 800c3e8:	300e      	adds	r0, #14
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800c3ea:	4407      	add	r7, r0
        TCPHeader_t * pxTCPHeader = &( pxProtocolHeaders->xTCPHeader );
        BaseType_t xSendLength = 0;
        uint32_t ulReceiveLength; /* Number of bytes contained in the TCP message. */
        uint8_t * pucRecvData;
        uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800c3ec:	687b      	ldr	r3, [r7, #4]
 800c3ee:	021d      	lsls	r5, r3, #8
 800c3f0:	f405 057f 	and.w	r5, r5, #16711680	@ 0xff0000
 800c3f4:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
 800c3f8:	0a1a      	lsrs	r2, r3, #8
 800c3fa:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800c3fe:	4315      	orrs	r5, r2
 800c400:	ea45 6513 	orr.w	r5, r5, r3, lsr #24
         * 4 bytes)
         * 1. in the SYN phase, we shall communicate the MSS
         * 2. in case of a SACK, Selective ACK, ack a segment which comes in
         * out-of-order. */
        UBaseType_t uxOptionsLength = 0U;
        uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800c404:	f897 b00d 	ldrb.w	fp, [r7, #13]
        UBaseType_t uxIntermediateResult = 0;
        uint32_t ulSum;

        /* First get the length and the position of the received data, if any.
         * pucRecvData will point to the first byte of the TCP payload. */
        ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
 800c408:	a901      	add	r1, sp, #4
 800c40a:	6830      	ldr	r0, [r6, #0]
 800c40c:	f7ff fd36 	bl	800be7c <prvCheckRxData>
 800c410:	4681      	mov	r9, r0

        if( pxSocket->u.xTCP.eTCPState >= eESTABLISHED )
 800c412:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800c416:	2b04      	cmp	r3, #4
 800c418:	d904      	bls.n	800c424 <prvTCPHandleState+0x4e>
        {
            if( pxTCPWindow->rx.ulCurrentSequenceNumber == ( ulSequenceNumber + 1U ) )
 800c41a:	f8d4 2124 	ldr.w	r2, [r4, #292]	@ 0x124
 800c41e:	1c6b      	adds	r3, r5, #1
 800c420:	429a      	cmp	r2, r3
 800c422:	d040      	beq.n	800c4a6 <prvTCPHandleState+0xd0>
            }
        }

        /* Keep track of the highest sequence number that might be expected within
         * this connection. */
        ulSum = ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSequenceNumber;
 800c424:	eb05 0a09 	add.w	sl, r5, r9
 800c428:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
 800c42c:	ebaa 0303 	sub.w	r3, sl, r3

        if( ( ( int32_t ) ulSum ) > 0 )
 800c430:	2b00      	cmp	r3, #0
 800c432:	dd01      	ble.n	800c438 <prvTCPHandleState+0x62>
        {
            pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
 800c434:	f8c4 a12c 	str.w	sl, [r4, #300]	@ 0x12c
        }

        /* Storing data may result in a fatal error if malloc() fails. */
        if( prvStoreRxData( pxSocket, pucRecvData, *ppxNetworkBuffer, ulReceiveLength ) < 0 )
 800c438:	464b      	mov	r3, r9
 800c43a:	6832      	ldr	r2, [r6, #0]
 800c43c:	9901      	ldr	r1, [sp, #4]
 800c43e:	4620      	mov	r0, r4
 800c440:	f7ff fd63 	bl	800bf0a <prvStoreRxData>
 800c444:	2800      	cmp	r0, #0
 800c446:	f2c0 8089 	blt.w	800c55c <prvTCPHandleState+0x186>
        }
        else
        {
            eIPTCPState_t eState;

            uxOptionsLength = prvSetOptions( pxSocket, *ppxNetworkBuffer );
 800c44a:	6831      	ldr	r1, [r6, #0]
 800c44c:	4620      	mov	r0, r4
 800c44e:	f000 fd62 	bl	800cf16 <prvSetOptions>
 800c452:	4680      	mov	r8, r0

            if( ( pxSocket->u.xTCP.eTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_CTRL ) == ( uint8_t ) tcpTCP_FLAG_SYN ) )
 800c454:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800c458:	2b04      	cmp	r3, #4
 800c45a:	d02b      	beq.n	800c4b4 <prvTCPHandleState+0xde>
                 * a first incoming SYN is handled.  The SYN was counted already so
                 * decrease it first. */
                vTCPStateChange( pxSocket, eSYN_FIRST );
            }

            if( ( ( ucTCPFlags & tcpTCP_FLAG_FIN ) != 0U ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 800c45c:	f01b 0f01 	tst.w	fp, #1
 800c460:	d015      	beq.n	800c48e <prvTCPHandleState+0xb8>
 800c462:	f994 3069 	ldrsb.w	r3, [r4, #105]	@ 0x69
 800c466:	2b00      	cmp	r3, #0
 800c468:	db11      	blt.n	800c48e <prvTCPHandleState+0xb8>
            {
                /* It's the first time a FIN has been received, remember its
                 * sequence number. */
                pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
 800c46a:	f8c4 a128 	str.w	sl, [r4, #296]	@ 0x128
                pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
 800c46e:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800c472:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800c476:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69

                /* Was peer the first one to send a FIN? */
                if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800c47a:	b2db      	uxtb	r3, r3
 800c47c:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800c480:	d105      	bne.n	800c48e <prvTCPHandleState+0xb8>
                {
                    /* If so, don't send the-last-ACK. */
                    pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
 800c482:	f894 306a 	ldrb.w	r3, [r4, #106]	@ 0x6a
 800c486:	f043 0302 	orr.w	r3, r3, #2
 800c48a:	f884 306a 	strb.w	r3, [r4, #106]	@ 0x6a
                }
            }

            eState = ( eIPTCPState_t ) pxSocket->u.xTCP.eTCPState;
 800c48e:	f894 2079 	ldrb.w	r2, [r4, #121]	@ 0x79

            switch( eState )
 800c492:	3a02      	subs	r2, #2
 800c494:	2a08      	cmp	r2, #8
 800c496:	d864      	bhi.n	800c562 <prvTCPHandleState+0x18c>
 800c498:	e8df f002 	tbb	[pc, r2]
 800c49c:	4a421542 	.word	0x4a421542
 800c4a0:	63635252 	.word	0x63635252
 800c4a4:	52          	.byte	0x52
 800c4a5:	00          	.byte	0x00
                pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800c4a6:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800c4aa:	f043 0301 	orr.w	r3, r3, #1
 800c4ae:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
 800c4b2:	e7b7      	b.n	800c424 <prvTCPHandleState+0x4e>
            if( ( pxSocket->u.xTCP.eTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_CTRL ) == ( uint8_t ) tcpTCP_FLAG_SYN ) )
 800c4b4:	f00b 031f 	and.w	r3, fp, #31
 800c4b8:	2b02      	cmp	r3, #2
 800c4ba:	d1cf      	bne.n	800c45c <prvTCPHandleState+0x86>
                vTCPStateChange( pxSocket, eSYN_FIRST );
 800c4bc:	2103      	movs	r1, #3
 800c4be:	4620      	mov	r0, r4
 800c4c0:	f7ff f8fc 	bl	800b6bc <vTCPStateChange>
 800c4c4:	e7ca      	b.n	800c45c <prvTCPHandleState+0x86>
                                  * socket. */

                    /* A new socket has been created, reply with a SYN+ACK.
                     * Acknowledge with seq+1 because the SYN is seen as pseudo data
                     * with len = 1. */
                    uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPHeader );
 800c4c6:	4639      	mov	r1, r7
 800c4c8:	4620      	mov	r0, r4
 800c4ca:	f000 fb1a 	bl	800cb02 <prvSetSynAckOptions>
 800c4ce:	4682      	mov	sl, r0
                    pxTCPHeader->ucTCPFlags = ( uint8_t ) tcpTCP_FLAG_SYN | ( uint8_t ) tcpTCP_FLAG_ACK;
 800c4d0:	2312      	movs	r3, #18
 800c4d2:	737b      	strb	r3, [r7, #13]

                    uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800c4d4:	4620      	mov	r0, r4
 800c4d6:	f7fb f9e7 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c4da:	eb00 080a 	add.w	r8, r0, sl
 800c4de:	f108 0814 	add.w	r8, r8, #20
                    xSendLength = ( BaseType_t ) uxIntermediateResult;

                    /* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
                     * uxOptionsLength is a multiple of 4.  The complete expression is:
                     * ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
                    pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800c4e2:	f10a 0a14 	add.w	sl, sl, #20
 800c4e6:	fa5f fa8a 	uxtb.w	sl, sl
 800c4ea:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800c4ee:	f887 a00c 	strb.w	sl, [r7, #12]
                    vTCPStateChange( pxSocket, eSYN_RECEIVED );
 800c4f2:	2104      	movs	r1, #4
 800c4f4:	4620      	mov	r0, r4
 800c4f6:	f7ff f8e1 	bl	800b6bc <vTCPStateChange>

                    pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1U;
 800c4fa:	3501      	adds	r5, #1
 800c4fc:	f8c4 512c 	str.w	r5, [r4, #300]	@ 0x12c
                    pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber + 1U;
 800c500:	f8c4 5124 	str.w	r5, [r4, #292]	@ 0x124
                    pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U;
 800c504:	f8d4 3130 	ldr.w	r3, [r4, #304]	@ 0x130
 800c508:	3301      	adds	r3, #1
 800c50a:	f8c4 3148 	str.w	r3, [r4, #328]	@ 0x148
                    pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1U; /* because we send a TCP_SYN. */
 800c50e:	f8c4 3134 	str.w	r3, [r4, #308]	@ 0x134
                    /* No more known states. */
                    break;
            }
        }

        if( xSendLength > 0 )
 800c512:	f1b8 0f00 	cmp.w	r8, #0
 800c516:	dc19      	bgt.n	800c54c <prvTCPHandleState+0x176>
        {
            xSendLength = prvSendData( pxSocket, ppxNetworkBuffer, ulReceiveLength, xSendLength );
        }

        return xSendLength;
    }
 800c518:	4640      	mov	r0, r8
 800c51a:	b003      	add	sp, #12
 800c51c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    xSendLength = prvHandleSynReceived( pxSocket, *( ppxNetworkBuffer ), ulReceiveLength, uxOptionsLength );
 800c520:	4643      	mov	r3, r8
 800c522:	464a      	mov	r2, r9
 800c524:	6831      	ldr	r1, [r6, #0]
 800c526:	4620      	mov	r0, r4
 800c528:	f7ff fdc0 	bl	800c0ac <prvHandleSynReceived>
 800c52c:	4680      	mov	r8, r0
                    break;
 800c52e:	e7f0      	b.n	800c512 <prvTCPHandleState+0x13c>
                    xSendLength = prvHandleEstablished( pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength );
 800c530:	4643      	mov	r3, r8
 800c532:	464a      	mov	r2, r9
 800c534:	4631      	mov	r1, r6
 800c536:	4620      	mov	r0, r4
 800c538:	f7ff fe62 	bl	800c200 <prvHandleEstablished>
 800c53c:	4680      	mov	r8, r0
                    break;
 800c53e:	e7e8      	b.n	800c512 <prvTCPHandleState+0x13c>
                    xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 800c540:	6831      	ldr	r1, [r6, #0]
 800c542:	4620      	mov	r0, r4
 800c544:	f7ff fd3c 	bl	800bfc0 <prvTCPHandleFin>
 800c548:	4680      	mov	r8, r0
                    break;
 800c54a:	e7e2      	b.n	800c512 <prvTCPHandleState+0x13c>
            xSendLength = prvSendData( pxSocket, ppxNetworkBuffer, ulReceiveLength, xSendLength );
 800c54c:	4643      	mov	r3, r8
 800c54e:	464a      	mov	r2, r9
 800c550:	4631      	mov	r1, r6
 800c552:	4620      	mov	r0, r4
 800c554:	f000 fd15 	bl	800cf82 <prvSendData>
 800c558:	4680      	mov	r8, r0
 800c55a:	e7dd      	b.n	800c518 <prvTCPHandleState+0x142>
            xSendLength = -1;
 800c55c:	f04f 38ff 	mov.w	r8, #4294967295
 800c560:	e7da      	b.n	800c518 <prvTCPHandleState+0x142>
            switch( eState )
 800c562:	f04f 0800 	mov.w	r8, #0
        return xSendLength;
 800c566:	e7d7      	b.n	800c518 <prvTCPHandleState+0x142>

0800c568 <prvHandleListen>:
 * @return If a new socket/duplicate socket is created, then the pointer to
 *         that socket is returned or else, a NULL pointer is returned.
 */
    FreeRTOS_Socket_t * prvHandleListen( FreeRTOS_Socket_t * pxSocket,
                                         NetworkBufferDescriptor_t * pxNetworkBuffer )
    {
 800c568:	b538      	push	{r3, r4, r5, lr}
 800c56a:	4605      	mov	r5, r0
 800c56c:	460c      	mov	r4, r1
        FreeRTOS_Socket_t * pxNewSocket = NULL;

        switch( uxIPHeaderSizePacket( pxNetworkBuffer ) )
 800c56e:	4608      	mov	r0, r1
 800c570:	f7fa ffb2 	bl	80074d8 <uxIPHeaderSizePacket>
 800c574:	2814      	cmp	r0, #20
 800c576:	d003      	beq.n	800c580 <prvHandleListen+0x18>
 800c578:	2828      	cmp	r0, #40	@ 0x28
 800c57a:	d006      	beq.n	800c58a <prvHandleListen+0x22>
 800c57c:	2000      	movs	r0, #0
 800c57e:	e003      	b.n	800c588 <prvHandleListen+0x20>
        {
            #if ( ipconfigUSE_IPv4 != 0 )
                case ipSIZE_OF_IPv4_HEADER:
                    pxNewSocket = prvHandleListen_IPV4( pxSocket, pxNetworkBuffer );
 800c580:	4621      	mov	r1, r4
 800c582:	4628      	mov	r0, r5
 800c584:	f000 f854 	bl	800c630 <prvHandleListen_IPV4>
                /* MISRA 16.4 Compliance */
                break;
        }

        return pxNewSocket;
    }
 800c588:	bd38      	pop	{r3, r4, r5, pc}
                    pxNewSocket = prvHandleListen_IPV6( pxSocket, pxNetworkBuffer );
 800c58a:	4621      	mov	r1, r4
 800c58c:	4628      	mov	r0, r5
 800c58e:	f000 f8fa 	bl	800c786 <prvHandleListen_IPV6>
        return pxNewSocket;
 800c592:	e7f9      	b.n	800c588 <prvHandleListen+0x20>

0800c594 <prvTCPSocketCopy>:
 *
 * @return If all steps all successful, then pdTRUE is returned. Else, pdFALSE.
 */
    BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t * pxNewSocket,
                                 FreeRTOS_Socket_t * pxSocket )
    {
 800c594:	b530      	push	{r4, r5, lr}
 800c596:	b087      	sub	sp, #28
 800c598:	4605      	mov	r5, r0
 800c59a:	460c      	mov	r4, r1
        struct freertos_sockaddr xAddress;
        BaseType_t xResult;

        pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
 800c59c:	6a0b      	ldr	r3, [r1, #32]
 800c59e:	6203      	str	r3, [r0, #32]
        pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
 800c5a0:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
 800c5a2:	6243      	str	r3, [r0, #36]	@ 0x24
        pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
 800c5a4:	f891 303a 	ldrb.w	r3, [r1, #58]	@ 0x3a
 800c5a8:	f880 303a 	strb.w	r3, [r0, #58]	@ 0x3a
        pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
 800c5ac:	f8d1 3094 	ldr.w	r3, [r1, #148]	@ 0x94
 800c5b0:	f8c0 3094 	str.w	r3, [r0, #148]	@ 0x94
        pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
 800c5b4:	f8d1 3098 	ldr.w	r3, [r1, #152]	@ 0x98
 800c5b8:	f8c0 3098 	str.w	r3, [r0, #152]	@ 0x98
        pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
 800c5bc:	f8d1 308c 	ldr.w	r3, [r1, #140]	@ 0x8c
 800c5c0:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
        pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
 800c5c4:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 800c5c8:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
        pxNewSocket->u.xTCP.uxRxWinSize = pxSocket->u.xTCP.uxRxWinSize;
 800c5cc:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
 800c5d0:	f8c0 310c 	str.w	r3, [r0, #268]	@ 0x10c
        pxNewSocket->u.xTCP.uxTxWinSize = pxSocket->u.xTCP.uxTxWinSize;
 800c5d4:	f8d1 3110 	ldr.w	r3, [r1, #272]	@ 0x110
 800c5d8:	f8c0 3110 	str.w	r3, [r0, #272]	@ 0x110

        #if ( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
        {
            /* Child socket of listening sockets will inherit the Socket Set
             * Otherwise the owner has no chance of including it into the set. */
            if( pxSocket->pxSocketSet != NULL )
 800c5dc:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800c5de:	b123      	cbz	r3, 800c5ea <prvTCPSocketCopy+0x56>
            {
                pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
 800c5e0:	6403      	str	r3, [r0, #64]	@ 0x40
                pxNewSocket->xSelectBits = pxSocket->xSelectBits | ( ( EventBits_t ) eSELECT_READ ) | ( ( EventBits_t ) eSELECT_EXCEPT );
 800c5e2:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
 800c5e4:	f043 0305 	orr.w	r3, r3, #5
 800c5e8:	6443      	str	r3, [r0, #68]	@ 0x44
            }
        }
        #endif /* ipconfigSUPPORT_SELECT_FUNCTION */

        /* And bind it to the same local port as its parent. */
        ( void ) FreeRTOS_GetLocalAddress( pxSocket, &xAddress );
 800c5ea:	4669      	mov	r1, sp
 800c5ec:	4620      	mov	r0, r4
 800c5ee:	f7fe f8e6 	bl	800a7be <FreeRTOS_GetLocalAddress>
             * orphan temporarily.  Once this socket is really connected, the owner of
             * the server socket will be notified. */

            /* When bPassQueued is true, the socket is an orphan until it gets
             * connected. */
            pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 800c5f2:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 800c5f6:	f043 0304 	orr.w	r3, r3, #4
 800c5fa:	f885 3068 	strb.w	r3, [r5, #104]	@ 0x68
            pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
 800c5fe:	67ec      	str	r4, [r5, #124]	@ 0x7c
                pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
            }
        }
        #endif /* if ( ipconfigTCP_HANG_PROTECTION == 1 ) */

        pxSocket->u.xTCP.usChildCount++;
 800c600:	f8b4 3074 	ldrh.w	r3, [r4, #116]	@ 0x74
 800c604:	3301      	adds	r3, #1
 800c606:	f8a4 3074 	strh.w	r3, [r4, #116]	@ 0x74

        if( pxSocket->u.xTCP.pxPeerSocket == NULL )
 800c60a:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800c60c:	b14b      	cbz	r3, 800c622 <prvTCPSocketCopy+0x8e>
                                 ( void * ) pxNewSocket,
                                 ( void * ) pxSocket,
                                 pxSocket ? ( void * ) pxSocket->u.xTCP.pxPeerSocket : NULL ) );

        /* Now bind the child socket to the same port as the listening socket. */
        if( vSocketBind( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
 800c60e:	2301      	movs	r3, #1
 800c610:	2218      	movs	r2, #24
 800c612:	4669      	mov	r1, sp
 800c614:	4628      	mov	r0, r5
 800c616:	f7fe fdc7 	bl	800b1a8 <vSocketBind>
 800c61a:	b920      	cbnz	r0, 800c626 <prvTCPSocketCopy+0x92>
            ( void ) vSocketClose( pxNewSocket );
            xResult = pdFALSE;
        }
        else
        {
            xResult = pdTRUE;
 800c61c:	2001      	movs	r0, #1
        }

        return xResult;
    }
 800c61e:	b007      	add	sp, #28
 800c620:	bd30      	pop	{r4, r5, pc}
            pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
 800c622:	67e5      	str	r5, [r4, #124]	@ 0x7c
 800c624:	e7f3      	b.n	800c60e <prvTCPSocketCopy+0x7a>
            ( void ) vSocketClose( pxNewSocket );
 800c626:	4628      	mov	r0, r5
 800c628:	f7fd ffe1 	bl	800a5ee <vSocketClose>
            xResult = pdFALSE;
 800c62c:	2000      	movs	r0, #0
 800c62e:	e7f6      	b.n	800c61e <prvTCPSocketCopy+0x8a>

0800c630 <prvHandleListen_IPV4>:
 * @return If a new socket/duplicate socket is created, then the pointer to
 *         that socket is returned or else, a NULL pointer is returned.
 */
FreeRTOS_Socket_t * prvHandleListen_IPV4( FreeRTOS_Socket_t * pxSocket,
                                          NetworkBufferDescriptor_t * pxNetworkBuffer )
{
 800c630:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c634:	460d      	mov	r5, r1
    FreeRTOS_Socket_t * pxReturn = NULL;
    uint32_t ulInitialSequenceNumber = 0U;
    const NetworkEndPoint_t * pxEndpoint = NULL;
    BaseType_t xIsNewSocket = pdFALSE;

    if( ( pxSocket != NULL ) && ( pxNetworkBuffer != NULL ) )
 800c636:	4606      	mov	r6, r0
 800c638:	b1b0      	cbz	r0, 800c668 <prvHandleListen_IPV4+0x38>
 800c63a:	2900      	cmp	r1, #0
 800c63c:	f000 809f 	beq.w	800c77e <prvHandleListen_IPV4+0x14e>
    {
        /* Initialize pointers if inputs are valid. */
        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxTCPPacket = ( ( const TCPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800c640:	6a4f      	ldr	r7, [r1, #36]	@ 0x24
        pxEndpoint = pxNetworkBuffer->pxEndPoint;
 800c642:	6b0c      	ldr	r4, [r1, #48]	@ 0x30
    }

    /* Silently discard a SYN packet which was not specifically sent for this node. */
    if( ( pxEndpoint != NULL ) && ( pxTCPPacket->xIPHeader.ulDestinationIPAddress == pxEndpoint->ipv4_settings.ulIPAddress ) )
 800c644:	b12c      	cbz	r4, 800c652 <prvHandleListen_IPV4+0x22>
 800c646:	f8d7 001e 	ldr.w	r0, [r7, #30]
 800c64a:	6823      	ldr	r3, [r4, #0]
 800c64c:	4298      	cmp	r0, r3
 800c64e:	d003      	beq.n	800c658 <prvHandleListen_IPV4+0x28>
 800c650:	2400      	movs	r4, #0
                             xCopyLength );
        } while( ipFALSE_BOOL );
    }

    return pxReturn;
}
 800c652:	4620      	mov	r0, r4
 800c654:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( pxTCPPacket->xIPHeader.ulDestinationIPAddress,
 800c658:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 800c65a:	f8d7 201a 	ldr.w	r2, [r7, #26]
 800c65e:	8f31      	ldrh	r1, [r6, #56]	@ 0x38
 800c660:	f7f4 ff56 	bl	8001510 <ulApplicationGetNextSequenceNumber>
 800c664:	4680      	mov	r8, r0
 800c666:	e002      	b.n	800c66e <prvHandleListen_IPV4+0x3e>
    const TCPPacket_t * pxTCPPacket = NULL;
 800c668:	4607      	mov	r7, r0
        ulInitialSequenceNumber = 0U;
 800c66a:	f04f 0800 	mov.w	r8, #0
    if( ulInitialSequenceNumber != 0U )
 800c66e:	f1b8 0f00 	cmp.w	r8, #0
 800c672:	f000 8086 	beq.w	800c782 <prvHandleListen_IPV4+0x152>
        if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800c676:	f896 3068 	ldrb.w	r3, [r6, #104]	@ 0x68
 800c67a:	f013 0f08 	tst.w	r3, #8
 800c67e:	d046      	beq.n	800c70e <prvHandleListen_IPV4+0xde>
            pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 800c680:	f043 0304 	orr.w	r3, r3, #4
 800c684:	f886 3068 	strb.w	r3, [r6, #104]	@ 0x68
            pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 800c688:	67f6      	str	r6, [r6, #124]	@ 0x7c
            pxReturn = pxSocket;
 800c68a:	4634      	mov	r4, r6
    BaseType_t xIsNewSocket = pdFALSE;
 800c68c:	2600      	movs	r6, #0
    if( ( ulInitialSequenceNumber != 0U ) && ( pxReturn != NULL ) )
 800c68e:	2c00      	cmp	r4, #0
 800c690:	d0df      	beq.n	800c652 <prvHandleListen_IPV4+0x22>
                                                            &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer ) ] ) );
 800c692:	f8d5 9024 	ldr.w	r9, [r5, #36]	@ 0x24
 800c696:	4628      	mov	r0, r5
 800c698:	f7fa ff1e 	bl	80074d8 <uxIPHeaderSizePacket>
 800c69c:	300e      	adds	r0, #14
            const ProtocolHeaders_t * pxProtocolHeaders = ( ( const ProtocolHeaders_t * )
 800c69e:	eb09 0100 	add.w	r1, r9, r0
            pxReturn->pxEndPoint = pxNetworkBuffer->pxEndPoint;
 800c6a2:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800c6a4:	64e3      	str	r3, [r4, #76]	@ 0x4c
            pxReturn->bits.bIsIPv6 = pdFALSE_UNSIGNED;
 800c6a6:	7a23      	ldrb	r3, [r4, #8]
 800c6a8:	f023 0301 	bic.w	r3, r3, #1
 800c6ac:	7223      	strb	r3, [r4, #8]
            pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 800c6ae:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 800c6b0:	0213      	lsls	r3, r2, #8
 800c6b2:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800c6b6:	f8a4 3064 	strh.w	r3, [r4, #100]	@ 0x64
            pxReturn->u.xTCP.xRemoteIP.ulIP_IPv4 = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 800c6ba:	f8d7 201a 	ldr.w	r2, [r7, #26]
 800c6be:	0213      	lsls	r3, r2, #8
 800c6c0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800c6c4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c6c8:	0a10      	lsrs	r0, r2, #8
 800c6ca:	f400 407f 	and.w	r0, r0, #65280	@ 0xff00
 800c6ce:	4303      	orrs	r3, r0
 800c6d0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c6d4:	6563      	str	r3, [r4, #84]	@ 0x54
            pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 800c6d6:	f8c4 8140 	str.w	r8, [r4, #320]	@ 0x140
            pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 800c6da:	684a      	ldr	r2, [r1, #4]
 800c6dc:	0213      	lsls	r3, r2, #8
 800c6de:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800c6e2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c6e6:	0a11      	lsrs	r1, r2, #8
 800c6e8:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800c6ec:	430b      	orrs	r3, r1
 800c6ee:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c6f2:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
            prvSocketSetMSS( pxReturn );
 800c6f6:	4620      	mov	r0, r4
 800c6f8:	f001 f851 	bl	800d79e <prvSocketSetMSS>
            xReturnCreateWindow = prvTCPCreateWindow( pxReturn );
 800c6fc:	4620      	mov	r0, r4
 800c6fe:	f000 f9e6 	bl	800cace <prvTCPCreateWindow>
            if( xReturnCreateWindow != pdPASS )
 800c702:	2801      	cmp	r0, #1
 800c704:	d02d      	beq.n	800c762 <prvHandleListen_IPV4+0x132>
                if( xIsNewSocket == pdTRUE )
 800c706:	2e01      	cmp	r6, #1
 800c708:	d026      	beq.n	800c758 <prvHandleListen_IPV4+0x128>
                pxReturn = NULL;
 800c70a:	2400      	movs	r4, #0
    return pxReturn;
 800c70c:	e7a1      	b.n	800c652 <prvHandleListen_IPV4+0x22>
            if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 800c70e:	f8b6 2074 	ldrh.w	r2, [r6, #116]	@ 0x74
 800c712:	f8b6 3076 	ldrh.w	r3, [r6, #118]	@ 0x76
 800c716:	429a      	cmp	r2, r3
 800c718:	d305      	bcc.n	800c726 <prvHandleListen_IPV4+0xf6>
                ( void ) prvTCPSendReset( pxNetworkBuffer );
 800c71a:	4628      	mov	r0, r5
 800c71c:	f000 fca3 	bl	800d066 <prvTCPSendReset>
    BaseType_t xIsNewSocket = pdFALSE;
 800c720:	2600      	movs	r6, #0
            pxReturn = NULL;
 800c722:	4634      	mov	r4, r6
 800c724:	e7b3      	b.n	800c68e <prvHandleListen_IPV4+0x5e>
                                                  FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800c726:	2206      	movs	r2, #6
 800c728:	2101      	movs	r1, #1
 800c72a:	2002      	movs	r0, #2
 800c72c:	f7fd fef6 	bl	800a51c <FreeRTOS_socket>
 800c730:	4604      	mov	r4, r0
                if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 800c732:	1e43      	subs	r3, r0, #1
 800c734:	f113 0f03 	cmn.w	r3, #3
 800c738:	d905      	bls.n	800c746 <prvHandleListen_IPV4+0x116>
                    ( void ) prvTCPSendReset( pxNetworkBuffer );
 800c73a:	4628      	mov	r0, r5
 800c73c:	f000 fc93 	bl	800d066 <prvTCPSendReset>
    BaseType_t xIsNewSocket = pdFALSE;
 800c740:	2600      	movs	r6, #0
            pxReturn = NULL;
 800c742:	4634      	mov	r4, r6
 800c744:	e7a3      	b.n	800c68e <prvHandleListen_IPV4+0x5e>
                else if( prvTCPSocketCopy( pxNewSocket, pxSocket ) != pdFALSE )
 800c746:	4631      	mov	r1, r6
 800c748:	f7ff ff24 	bl	800c594 <prvTCPSocketCopy>
 800c74c:	4606      	mov	r6, r0
 800c74e:	b908      	cbnz	r0, 800c754 <prvHandleListen_IPV4+0x124>
            pxReturn = NULL;
 800c750:	2400      	movs	r4, #0
 800c752:	e79c      	b.n	800c68e <prvHandleListen_IPV4+0x5e>
                    xIsNewSocket = pdTRUE;
 800c754:	2601      	movs	r6, #1
 800c756:	e79a      	b.n	800c68e <prvHandleListen_IPV4+0x5e>
                    ( void ) vSocketClose( pxReturn );
 800c758:	4620      	mov	r0, r4
 800c75a:	f7fd ff48 	bl	800a5ee <vSocketClose>
                pxReturn = NULL;
 800c75e:	2400      	movs	r4, #0
 800c760:	e777      	b.n	800c652 <prvHandleListen_IPV4+0x22>
            vTCPStateChange( pxReturn, eSYN_FIRST );
 800c762:	2103      	movs	r1, #3
 800c764:	4620      	mov	r0, r4
 800c766:	f7fe ffa9 	bl	800b6bc <vTCPStateChange>
            if( pxNetworkBuffer->xDataLength > sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) )
 800c76a:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 800c76c:	2a5a      	cmp	r2, #90	@ 0x5a
 800c76e:	d900      	bls.n	800c772 <prvHandleListen_IPV4+0x142>
                xCopyLength = sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket );
 800c770:	225a      	movs	r2, #90	@ 0x5a
            ( void ) memcpy( ( void * ) pxReturn->u.xTCP.xPacket.u.ucLastPacket,
 800c772:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 800c774:	f104 00aa 	add.w	r0, r4, #170	@ 0xaa
 800c778:	f002 fb75 	bl	800ee66 <memcpy>
 800c77c:	e769      	b.n	800c652 <prvHandleListen_IPV4+0x22>
 800c77e:	460c      	mov	r4, r1
 800c780:	e767      	b.n	800c652 <prvHandleListen_IPV4+0x22>
 800c782:	2400      	movs	r4, #0
 800c784:	e765      	b.n	800c652 <prvHandleListen_IPV4+0x22>

0800c786 <prvHandleListen_IPV6>:
 * @return If a new socket/duplicate socket is created, then the pointer to
 *         that socket is returned or else, a NULL pointer is returned.
 */
FreeRTOS_Socket_t * prvHandleListen_IPV6( FreeRTOS_Socket_t * pxSocket,
                                          NetworkBufferDescriptor_t * pxNetworkBuffer )
{
 800c786:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c78a:	b083      	sub	sp, #12
 800c78c:	460c      	mov	r4, r1
    const TCPPacket_IPv6_t * pxTCPPacket = NULL;
    FreeRTOS_Socket_t * pxReturn = NULL;
    uint32_t ulInitialSequenceNumber = 0;
 800c78e:	2300      	movs	r3, #0
 800c790:	9301      	str	r3, [sp, #4]
    BaseType_t xHasSequence = pdFALSE;
    BaseType_t xIsNewSocket = pdFALSE;

    if( ( pxSocket != NULL ) && ( pxNetworkBuffer != NULL ) )
 800c792:	4605      	mov	r5, r0
 800c794:	2800      	cmp	r0, #0
 800c796:	d04c      	beq.n	800c832 <prvHandleListen_IPV6+0xac>
 800c798:	2900      	cmp	r1, #0
 800c79a:	f000 80a6 	beq.w	800c8ea <prvHandleListen_IPV6+0x164>
        /* Map the ethernet buffer onto a TCPPacket_IPv6_t struct for easy access to the fields. */

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxTCPPacket = ( ( const TCPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800c79e:	6a4f      	ldr	r7, [r1, #36]	@ 0x24

        configASSERT( pxNetworkBuffer->pxEndPoint != NULL );
 800c7a0:	6b09      	ldr	r1, [r1, #48]	@ 0x30
 800c7a2:	b1d9      	cbz	r1, 800c7dc <prvHandleListen_IPV6+0x56>

        /* Silently discard a SYN packet which was not specifically sent for this node. */
        if( memcmp( pxTCPPacket->xIPHeader.xDestinationAddress.ucBytes, pxNetworkBuffer->pxEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS ) == 0 )
 800c7a4:	2210      	movs	r2, #16
 800c7a6:	3138      	adds	r1, #56	@ 0x38
 800c7a8:	f107 0026 	add.w	r0, r7, #38	@ 0x26
 800c7ac:	f002 fa58 	bl	800ec60 <memcmp>
 800c7b0:	4680      	mov	r8, r0
 800c7b2:	2800      	cmp	r0, #0
 800c7b4:	f040 809b 	bne.w	800c8ee <prvHandleListen_IPV6+0x168>
        {
            /* Assume that a new Initial Sequence Number will be required. Request
             * it now in order to fail out if necessary. */
            if( xApplicationGetRandomNumber( &ulInitialSequenceNumber ) == pdPASS )
 800c7b8:	a801      	add	r0, sp, #4
 800c7ba:	f7f4 fe9f 	bl	80014fc <xApplicationGetRandomNumber>
 800c7be:	4606      	mov	r6, r0
 800c7c0:	2801      	cmp	r0, #1
 800c7c2:	f040 8096 	bne.w	800c8f2 <prvHandleListen_IPV6+0x16c>

    /* A pure SYN (without ACK) has come in, create a new socket to answer
     * it. */
    if( xHasSequence != pdFALSE )
    {
        if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800c7c6:	f895 3068 	ldrb.w	r3, [r5, #104]	@ 0x68
 800c7ca:	f013 0f08 	tst.w	r3, #8
 800c7ce:	d00e      	beq.n	800c7ee <prvHandleListen_IPV6+0x68>
        {
            /* The flag bReuseSocket indicates that the same instance of the
             * listening socket should be used for the connection. */
            pxReturn = pxSocket;
            pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 800c7d0:	f043 0304 	orr.w	r3, r3, #4
 800c7d4:	f885 3068 	strb.w	r3, [r5, #104]	@ 0x68
            pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 800c7d8:	67ed      	str	r5, [r5, #124]	@ 0x7c
 800c7da:	e02d      	b.n	800c838 <prvHandleListen_IPV6+0xb2>
 800c7dc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800c7e0:	f383 8811 	msr	BASEPRI, r3
 800c7e4:	f3bf 8f6f 	isb	sy
 800c7e8:	f3bf 8f4f 	dsb	sy
        configASSERT( pxNetworkBuffer->pxEndPoint != NULL );
 800c7ec:	e7fe      	b.n	800c7ec <prvHandleListen_IPV6+0x66>
        {
            /* The socket does not have the bReuseSocket flag set meaning create a
             * new socket when a connection comes in. */
            pxReturn = NULL;

            if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 800c7ee:	f8b5 2074 	ldrh.w	r2, [r5, #116]	@ 0x74
 800c7f2:	f8b5 3076 	ldrh.w	r3, [r5, #118]	@ 0x76
 800c7f6:	429a      	cmp	r2, r3
 800c7f8:	d304      	bcc.n	800c804 <prvHandleListen_IPV6+0x7e>
                FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
                                   pxSocket->usLocalPort,
                                   pxSocket->u.xTCP.usChildCount,
                                   pxSocket->u.xTCP.usBacklog,
                                   ( pxSocket->u.xTCP.usChildCount == 1U ) ? "" : "ren" ) );
                ( void ) prvTCPSendReset( pxNetworkBuffer );
 800c7fa:	4620      	mov	r0, r4
 800c7fc:	f000 fc33 	bl	800d066 <prvTCPSendReset>
            pxReturn = NULL;
 800c800:	2500      	movs	r5, #0
 800c802:	e019      	b.n	800c838 <prvHandleListen_IPV6+0xb2>
            }
            else
            {
                FreeRTOS_Socket_t * pxNewSocket = ( FreeRTOS_Socket_t * )
                                                  FreeRTOS_socket( FREERTOS_AF_INET6, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800c804:	2206      	movs	r2, #6
 800c806:	2101      	movs	r1, #1
 800c808:	200a      	movs	r0, #10
 800c80a:	f7fd fe87 	bl	800a51c <FreeRTOS_socket>
 800c80e:	4681      	mov	r9, r0

                /* MISRA Ref 11.4.1 [Socket error and integer to pointer conversion] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-114 */
                /* coverity[misra_c_2012_rule_11_4_violation] */
                if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 800c810:	1e43      	subs	r3, r0, #1
 800c812:	f113 0f03 	cmn.w	r3, #3
 800c816:	d904      	bls.n	800c822 <prvHandleListen_IPV6+0x9c>
                {
                    FreeRTOS_debug_printf( ( "TCP: Listen: new socket failed\n" ) );
                    ( void ) prvTCPSendReset( pxNetworkBuffer );
 800c818:	4620      	mov	r0, r4
 800c81a:	f000 fc24 	bl	800d066 <prvTCPSendReset>
            pxReturn = NULL;
 800c81e:	2500      	movs	r5, #0
 800c820:	e00a      	b.n	800c838 <prvHandleListen_IPV6+0xb2>
                }
                else if( prvTCPSocketCopy( pxNewSocket, pxSocket ) != pdFALSE )
 800c822:	4629      	mov	r1, r5
 800c824:	f7ff feb6 	bl	800c594 <prvTCPSocketCopy>
 800c828:	4680      	mov	r8, r0
 800c82a:	2800      	cmp	r0, #0
 800c82c:	d146      	bne.n	800c8bc <prvHandleListen_IPV6+0x136>
            pxReturn = NULL;
 800c82e:	2500      	movs	r5, #0
 800c830:	e002      	b.n	800c838 <prvHandleListen_IPV6+0xb2>
    const TCPPacket_IPv6_t * pxTCPPacket = NULL;
 800c832:	4607      	mov	r7, r0
    BaseType_t xHasSequence = pdFALSE;
 800c834:	2600      	movs	r6, #0
    BaseType_t xIsNewSocket = pdFALSE;
 800c836:	46b0      	mov	r8, r6
                }
            }
        }
    }

    if( ( xHasSequence != pdFALSE ) && ( pxReturn != NULL ) )
 800c838:	2e00      	cmp	r6, #0
 800c83a:	d05c      	beq.n	800c8f6 <prvHandleListen_IPV6+0x170>
 800c83c:	2d00      	cmp	r5, #0
 800c83e:	d05e      	beq.n	800c8fe <prvHandleListen_IPV6+0x178>

            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            const ProtocolHeaders_t * pxProtocolHeaders = ( ( const ProtocolHeaders_t * )
                                                            &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer ) ] ) );
 800c840:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 800c842:	4620      	mov	r0, r4
 800c844:	f7fa fe48 	bl	80074d8 <uxIPHeaderSizePacket>
 800c848:	f100 030e 	add.w	r3, r0, #14
            const ProtocolHeaders_t * pxProtocolHeaders = ( ( const ProtocolHeaders_t * )
 800c84c:	18f1      	adds	r1, r6, r3

            pxReturn->pxEndPoint = pxNetworkBuffer->pxEndPoint;
 800c84e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800c850:	64eb      	str	r3, [r5, #76]	@ 0x4c
            pxReturn->bits.bIsIPv6 = pdTRUE_UNSIGNED;
 800c852:	7a2b      	ldrb	r3, [r5, #8]
 800c854:	f043 0301 	orr.w	r3, r3, #1
 800c858:	722b      	strb	r3, [r5, #8]

            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxIPHeader_IPv6 = ( ( const IPHeader_IPv6_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 800c85a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
            pxReturn->u.xTCP.usRemotePort = FreeRTOS_ntohs( pxTCPPacket->xTCPHeader.usSourcePort );
 800c85c:	8ef8      	ldrh	r0, [r7, #54]	@ 0x36
 800c85e:	0202      	lsls	r2, r0, #8
 800c860:	ea42 2210 	orr.w	r2, r2, r0, lsr #8
 800c864:	f8a5 2064 	strh.w	r2, [r5, #100]	@ 0x64
            ( void ) memcpy( pxReturn->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, pxIPHeader_IPv6->xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800c868:	f8d3 6016 	ldr.w	r6, [r3, #22]
 800c86c:	f8d3 001a 	ldr.w	r0, [r3, #26]
 800c870:	f8d3 201e 	ldr.w	r2, [r3, #30]
 800c874:	f8d3 3022 	ldr.w	r3, [r3, #34]	@ 0x22
 800c878:	656e      	str	r6, [r5, #84]	@ 0x54
 800c87a:	65a8      	str	r0, [r5, #88]	@ 0x58
 800c87c:	65ea      	str	r2, [r5, #92]	@ 0x5c
 800c87e:	662b      	str	r3, [r5, #96]	@ 0x60
            pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 800c880:	9b01      	ldr	r3, [sp, #4]
 800c882:	f8c5 3140 	str.w	r3, [r5, #320]	@ 0x140

            /* Here is the SYN action. */
            pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 800c886:	684a      	ldr	r2, [r1, #4]
 800c888:	0213      	lsls	r3, r2, #8
 800c88a:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800c88e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800c892:	0a11      	lsrs	r1, r2, #8
 800c894:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800c898:	430b      	orrs	r3, r1
 800c89a:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c89e:	f8c5 3124 	str.w	r3, [r5, #292]	@ 0x124
            prvSocketSetMSS( pxReturn );
 800c8a2:	4628      	mov	r0, r5
 800c8a4:	f000 ff7b 	bl	800d79e <prvSocketSetMSS>

            xReturnCreateWindow = prvTCPCreateWindow( pxReturn );
 800c8a8:	4628      	mov	r0, r5
 800c8aa:	f000 f910 	bl	800cace <prvTCPCreateWindow>

            /* Did allocating TCP sectors fail? */
            if( xReturnCreateWindow != pdPASS )
 800c8ae:	2801      	cmp	r0, #1
 800c8b0:	d00c      	beq.n	800c8cc <prvHandleListen_IPV6+0x146>
            {
                /* Close the socket if it was newly created. */
                if( xIsNewSocket == pdTRUE )
 800c8b2:	f1b8 0f01 	cmp.w	r8, #1
 800c8b6:	d004      	beq.n	800c8c2 <prvHandleListen_IPV6+0x13c>
                {
                    ( void ) vSocketClose( pxReturn );
                }

                pxReturn = NULL;
 800c8b8:	2000      	movs	r0, #0
                             ( const void * ) pxNetworkBuffer->pucEthernetBuffer,
                             xCopyLength );
        } while( ipFALSE_BOOL );
    }

    return pxReturn;
 800c8ba:	e01d      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>
                    xIsNewSocket = pdTRUE;
 800c8bc:	46b0      	mov	r8, r6
                    pxReturn = pxNewSocket;
 800c8be:	464d      	mov	r5, r9
 800c8c0:	e7ba      	b.n	800c838 <prvHandleListen_IPV6+0xb2>
                    ( void ) vSocketClose( pxReturn );
 800c8c2:	4628      	mov	r0, r5
 800c8c4:	f7fd fe93 	bl	800a5ee <vSocketClose>
                pxReturn = NULL;
 800c8c8:	2000      	movs	r0, #0
 800c8ca:	e015      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>
            vTCPStateChange( pxReturn, eSYN_FIRST );
 800c8cc:	2103      	movs	r1, #3
 800c8ce:	4628      	mov	r0, r5
 800c8d0:	f7fe fef4 	bl	800b6bc <vTCPStateChange>
            if( pxNetworkBuffer->xDataLength > sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) )
 800c8d4:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 800c8d6:	2a5a      	cmp	r2, #90	@ 0x5a
 800c8d8:	d900      	bls.n	800c8dc <prvHandleListen_IPV6+0x156>
                xCopyLength = sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket );
 800c8da:	225a      	movs	r2, #90	@ 0x5a
            ( void ) memcpy( ( void * ) pxReturn->u.xTCP.xPacket.u.ucLastPacket,
 800c8dc:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800c8de:	f105 00aa 	add.w	r0, r5, #170	@ 0xaa
 800c8e2:	f002 fac0 	bl	800ee66 <memcpy>
 800c8e6:	4628      	mov	r0, r5
 800c8e8:	e006      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>
 800c8ea:	4608      	mov	r0, r1
 800c8ec:	e004      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>
 800c8ee:	2000      	movs	r0, #0
 800c8f0:	e002      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>
 800c8f2:	2000      	movs	r0, #0
 800c8f4:	e000      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>
 800c8f6:	4628      	mov	r0, r5
}
 800c8f8:	b003      	add	sp, #12
 800c8fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800c8fe:	4628      	mov	r0, r5
 800c900:	e7fa      	b.n	800c8f8 <prvHandleListen_IPV6+0x172>

0800c902 <prvWinScaleFactor>:
            size_t uxWinSize;
            uint8_t ucFactor;


            /* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
            uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usMSS;
 800c902:	f8d0 310c 	ldr.w	r3, [r0, #268]	@ 0x10c
 800c906:	f8b0 2072 	ldrh.w	r2, [r0, #114]	@ 0x72
 800c90a:	fb02 f303 	mul.w	r3, r2, r3
            ucFactor = 0U;
 800c90e:	2000      	movs	r0, #0

            while( uxWinSize > 0xffffU )
 800c910:	e002      	b.n	800c918 <prvWinScaleFactor+0x16>
            {
                /* Divide by two and increase the binary factor by 1. */
                uxWinSize >>= 1;
 800c912:	085b      	lsrs	r3, r3, #1
                ucFactor++;
 800c914:	3001      	adds	r0, #1
 800c916:	b2c0      	uxtb	r0, r0
            while( uxWinSize > 0xffffU )
 800c918:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c91c:	d2f9      	bcs.n	800c912 <prvWinScaleFactor+0x10>
                                     ( unsigned ) pxSocket->u.xTCP.uxRxWinSize,
                                     pxSocket->u.xTCP.usMSS,
                                     ucFactor ) );

            return ucFactor;
        }
 800c91e:	4770      	bx	lr

0800c920 <prvTCPPrepareConnect>:
    {
 800c920:	b508      	push	{r3, lr}
        switch( pxSocket->bits.bIsIPv6 ) /* LCOV_EXCL_BR_LINE */
 800c922:	7a03      	ldrb	r3, [r0, #8]
 800c924:	f013 0301 	ands.w	r3, r3, #1
 800c928:	d002      	beq.n	800c930 <prvTCPPrepareConnect+0x10>
 800c92a:	b923      	cbnz	r3, 800c936 <prvTCPPrepareConnect+0x16>
 800c92c:	2001      	movs	r0, #1
 800c92e:	e001      	b.n	800c934 <prvTCPPrepareConnect+0x14>
                    xReturn = prvTCPPrepareConnect_IPV4( pxSocket );
 800c930:	f000 fc7c 	bl	800d22c <prvTCPPrepareConnect_IPV4>
    }
 800c934:	bd08      	pop	{r3, pc}
                    xReturn = prvTCPPrepareConnect_IPV6( pxSocket );
 800c936:	f000 fe33 	bl	800d5a0 <prvTCPPrepareConnect_IPV6>
        return xReturn;
 800c93a:	e7fb      	b.n	800c934 <prvTCPPrepareConnect+0x14>

0800c93c <prvTCPMakeSurePrepared>:
    {
 800c93c:	b508      	push	{r3, lr}
        if( pxSocket->u.xTCP.bits.bConnPrepared == pdFALSE_UNSIGNED )
 800c93e:	f890 3069 	ldrb.w	r3, [r0, #105]	@ 0x69
 800c942:	f013 0f08 	tst.w	r3, #8
 800c946:	d001      	beq.n	800c94c <prvTCPMakeSurePrepared+0x10>
        BaseType_t xReturn = pdTRUE;
 800c948:	2001      	movs	r0, #1
    }
 800c94a:	bd08      	pop	{r3, pc}
            if( prvTCPPrepareConnect( pxSocket ) != pdTRUE )
 800c94c:	f7ff ffe8 	bl	800c920 <prvTCPPrepareConnect>
 800c950:	2801      	cmp	r0, #1
 800c952:	d0fa      	beq.n	800c94a <prvTCPMakeSurePrepared+0xe>
                xReturn = pdFALSE;
 800c954:	2000      	movs	r0, #0
        return xReturn;
 800c956:	e7f8      	b.n	800c94a <prvTCPMakeSurePrepared+0xe>

0800c958 <prvTCPReturnPacket>:
    {
 800c958:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c95a:	4604      	mov	r4, r0
 800c95c:	4615      	mov	r5, r2
 800c95e:	461e      	mov	r6, r3
        if( pxNetworkBuffer != NULL )
 800c960:	460f      	mov	r7, r1
 800c962:	b159      	cbz	r1, 800c97c <prvTCPReturnPacket+0x24>
                if( uxIPHeaderSizePacket( pxNetworkBuffer ) == ipSIZE_OF_IPv6_HEADER )
 800c964:	4608      	mov	r0, r1
 800c966:	f7fa fdb7 	bl	80074d8 <uxIPHeaderSizePacket>
 800c96a:	2828      	cmp	r0, #40	@ 0x28
 800c96c:	d00b      	beq.n	800c986 <prvTCPReturnPacket+0x2e>
                prvTCPReturnPacket_IPV4( pxSocket, pxDescriptor, ulLen, xReleaseAfterSend );
 800c96e:	4633      	mov	r3, r6
 800c970:	462a      	mov	r2, r5
 800c972:	4639      	mov	r1, r7
 800c974:	4620      	mov	r0, r4
 800c976:	f000 fb7b 	bl	800d070 <prvTCPReturnPacket_IPV4>
    }
 800c97a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        else if( pxSocket != NULL )
 800c97c:	b150      	cbz	r0, 800c994 <prvTCPReturnPacket+0x3c>
                if( uxIPHeaderSizeSocket( pxSocket ) == ipSIZE_OF_IPv6_HEADER )
 800c97e:	f7fa ff93 	bl	80078a8 <uxIPHeaderSizeSocket>
 800c982:	2828      	cmp	r0, #40	@ 0x28
 800c984:	d1f3      	bne.n	800c96e <prvTCPReturnPacket+0x16>
                prvTCPReturnPacket_IPV6( pxSocket, pxDescriptor, ulLen, xReleaseAfterSend );
 800c986:	4633      	mov	r3, r6
 800c988:	462a      	mov	r2, r5
 800c98a:	4639      	mov	r1, r7
 800c98c:	4620      	mov	r0, r4
 800c98e:	f000 fd0a 	bl	800d3a6 <prvTCPReturnPacket_IPV6>
    }
 800c992:	e7f2      	b.n	800c97a <prvTCPReturnPacket+0x22>
 800c994:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800c998:	f383 8811 	msr	BASEPRI, r3
 800c99c:	f3bf 8f6f 	isb	sy
 800c9a0:	f3bf 8f4f 	dsb	sy
            configASSERT( pdFALSE );
 800c9a4:	e7fe      	b.n	800c9a4 <prvTCPReturnPacket+0x4c>
	...

0800c9a8 <prvTCPReturn_CheckTCPWindow>:
    {
 800c9a8:	b570      	push	{r4, r5, r6, lr}
 800c9aa:	4604      	mov	r4, r0
                              &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSize ] ) );
 800c9ac:	6a4d      	ldr	r5, [r1, #36]	@ 0x24
 800c9ae:	320e      	adds	r2, #14
        pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800c9b0:	4415      	add	r5, r2
        if( pxSocket->u.xTCP.rxStream != NULL )
 800c9b2:	f8d0 009c 	ldr.w	r0, [r0, #156]	@ 0x9c
 800c9b6:	b368      	cbz	r0, 800ca14 <prvTCPReturn_CheckTCPWindow+0x6c>
            ulFrontSpace = ( uint32_t ) uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800c9b8:	f7fe fd35 	bl	800b426 <uxStreamBufferFrontSpace>
 800c9bc:	4606      	mov	r6, r0
        ulSpace = FreeRTOS_min_uint32( pxTCPWindow->xSize.ulRxWindowLength, ulFrontSpace );
 800c9be:	4631      	mov	r1, r6
 800c9c0:	f8d4 0118 	ldr.w	r0, [r4, #280]	@ 0x118
 800c9c4:	f7fb fc32 	bl	800822c <FreeRTOS_min_uint32>
        if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStopped != pdFALSE_UNSIGNED ) )
 800c9c8:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
 800c9ca:	4b14      	ldr	r3, [pc, #80]	@ (800ca1c <prvTCPReturn_CheckTCPWindow+0x74>)
 800c9cc:	4013      	ands	r3, r2
 800c9ce:	b103      	cbz	r3, 800c9d2 <prvTCPReturn_CheckTCPWindow+0x2a>
            ulSpace = 0U;
 800c9d0:	2000      	movs	r0, #0
        if( ( ulSpace < pxSocket->u.xTCP.usMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usMSS ) )
 800c9d2:	f8b4 3072 	ldrh.w	r3, [r4, #114]	@ 0x72
 800c9d6:	4283      	cmp	r3, r0
 800c9d8:	d902      	bls.n	800c9e0 <prvTCPReturn_CheckTCPWindow+0x38>
 800c9da:	42b3      	cmp	r3, r6
 800c9dc:	d800      	bhi.n	800c9e0 <prvTCPReturn_CheckTCPWindow+0x38>
            ulSpace = pxSocket->u.xTCP.usMSS;
 800c9de:	4618      	mov	r0, r3
            ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
 800c9e0:	f894 3105 	ldrb.w	r3, [r4, #261]	@ 0x105
 800c9e4:	fa20 f303 	lsr.w	r3, r0, r3
        if( ulWinSize > 0xfffcU )
 800c9e8:	f64f 72fc 	movw	r2, #65532	@ 0xfffc
 800c9ec:	4293      	cmp	r3, r2
 800c9ee:	d900      	bls.n	800c9f2 <prvTCPReturn_CheckTCPWindow+0x4a>
            ulWinSize = 0xfffcU;
 800c9f0:	4613      	mov	r3, r2
        pxProtocolHeaders->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
 800c9f2:	b29a      	uxth	r2, r3
 800c9f4:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800c9f8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800c9fc:	81eb      	strh	r3, [r5, #14]
        pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
 800c9fe:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800ca02:	f023 0301 	bic.w	r3, r3, #1
 800ca06:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
        pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
 800ca0a:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
 800ca0e:	4403      	add	r3, r0
 800ca10:	66e3      	str	r3, [r4, #108]	@ 0x6c
    }
 800ca12:	bd70      	pop	{r4, r5, r6, pc}
            ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 800ca14:	f8d4 6094 	ldr.w	r6, [r4, #148]	@ 0x94
 800ca18:	e7d1      	b.n	800c9be <prvTCPReturn_CheckTCPWindow+0x16>
 800ca1a:	bf00      	nop
 800ca1c:	00040080 	.word	0x00040080

0800ca20 <prvTCPReturn_SetSequenceNumber>:
    {
 800ca20:	b570      	push	{r4, r5, r6, lr}
 800ca22:	4604      	mov	r4, r0
 800ca24:	461e      	mov	r6, r3
                              &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSize ] ) );
 800ca26:	6a4d      	ldr	r5, [r1, #36]	@ 0x24
 800ca28:	320e      	adds	r2, #14
        pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800ca2a:	4415      	add	r5, r2
            if( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED )
 800ca2c:	f890 3069 	ldrb.w	r3, [r0, #105]	@ 0x69
 800ca30:	f013 0f02 	tst.w	r3, #2
 800ca34:	d029      	beq.n	800ca8a <prvTCPReturn_SetSequenceNumber+0x6a>
                pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800ca36:	f890 3069 	ldrb.w	r3, [r0, #105]	@ 0x69
 800ca3a:	f023 0302 	bic.w	r3, r3, #2
 800ca3e:	f880 3069 	strb.w	r3, [r0, #105]	@ 0x69
                pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 800ca42:	b2db      	uxtb	r3, r3
 800ca44:	f043 0304 	orr.w	r3, r3, #4
 800ca48:	f880 3069 	strb.w	r3, [r0, #105]	@ 0x69
                pxProtocolHeaders->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1U;
 800ca4c:	f8d0 2140 	ldr.w	r2, [r0, #320]	@ 0x140
 800ca50:	3a01      	subs	r2, #1
 800ca52:	606a      	str	r2, [r5, #4]
                pxProtocolHeaders->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxProtocolHeaders->xTCPHeader.ulSequenceNumber );
 800ca54:	0213      	lsls	r3, r2, #8
 800ca56:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800ca5a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800ca5e:	0a11      	lsrs	r1, r2, #8
 800ca60:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800ca64:	430b      	orrs	r3, r1
 800ca66:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800ca6a:	606b      	str	r3, [r5, #4]
        pxProtocolHeaders->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
 800ca6c:	f8d4 2124 	ldr.w	r2, [r4, #292]	@ 0x124
 800ca70:	0213      	lsls	r3, r2, #8
 800ca72:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800ca76:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800ca7a:	0a11      	lsrs	r1, r2, #8
 800ca7c:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800ca80:	430b      	orrs	r3, r1
 800ca82:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800ca86:	60ab      	str	r3, [r5, #8]
    }
 800ca88:	bd70      	pop	{r4, r5, r6, pc}
            pxProtocolHeaders->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber );
 800ca8a:	f8d0 3140 	ldr.w	r3, [r0, #320]	@ 0x140
 800ca8e:	021a      	lsls	r2, r3, #8
 800ca90:	f402 027f 	and.w	r2, r2, #16711680	@ 0xff0000
 800ca94:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 800ca98:	0a19      	lsrs	r1, r3, #8
 800ca9a:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800ca9e:	430a      	orrs	r2, r1
 800caa0:	ea42 6213 	orr.w	r2, r2, r3, lsr #24
 800caa4:	606a      	str	r2, [r5, #4]
            if( ( pxProtocolHeaders->xTCPHeader.ucTCPFlags & ( uint8_t ) tcpTCP_FLAG_FIN ) != 0U )
 800caa6:	7b6b      	ldrb	r3, [r5, #13]
 800caa8:	f013 0f01 	tst.w	r3, #1
 800caac:	d0de      	beq.n	800ca6c <prvTCPReturn_SetSequenceNumber+0x4c>
                uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + uxIPHeaderSizeSocket( pxSocket ) ) );
 800caae:	f7fa fefb 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cab2:	1a36      	subs	r6, r6, r0
 800cab4:	3e14      	subs	r6, #20
                if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
 800cab6:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
 800caba:	4433      	add	r3, r6
 800cabc:	f8d4 2138 	ldr.w	r2, [r4, #312]	@ 0x138
 800cac0:	4293      	cmp	r3, r2
 800cac2:	d0d3      	beq.n	800ca6c <prvTCPReturn_SetSequenceNumber+0x4c>
                    pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_FIN );
 800cac4:	7b6b      	ldrb	r3, [r5, #13]
 800cac6:	f023 0301 	bic.w	r3, r3, #1
 800caca:	736b      	strb	r3, [r5, #13]
 800cacc:	e7ce      	b.n	800ca6c <prvTCPReturn_SetSequenceNumber+0x4c>

0800cace <prvTCPCreateWindow>:
    {
 800cace:	b510      	push	{r4, lr}
 800cad0:	b082      	sub	sp, #8
        uint32_t ulTxWindowSize = ( uint32_t ) pxSocket->u.xTCP.uxTxWinSize;
 800cad2:	f8d0 2110 	ldr.w	r2, [r0, #272]	@ 0x110
            ( uint32_t ) pxSocket->u.xTCP.usMSS );
 800cad6:	f8b0 3072 	ldrh.w	r3, [r0, #114]	@ 0x72
        xReturn = xTCPWindowCreate(
 800cada:	f240 51b4 	movw	r1, #1460	@ 0x5b4
 800cade:	9301      	str	r3, [sp, #4]
 800cae0:	f8d0 3140 	ldr.w	r3, [r0, #320]	@ 0x140
 800cae4:	9300      	str	r3, [sp, #0]
 800cae6:	f8d0 3124 	ldr.w	r3, [r0, #292]	@ 0x124
 800caea:	fb01 f202 	mul.w	r2, r1, r2
 800caee:	f8d0 410c 	ldr.w	r4, [r0, #268]	@ 0x10c
 800caf2:	fb04 f101 	mul.w	r1, r4, r1
 800caf6:	f500 708a 	add.w	r0, r0, #276	@ 0x114
 800cafa:	f001 f9a5 	bl	800de48 <xTCPWindowCreate>
    }
 800cafe:	b002      	add	sp, #8
 800cb00:	bd10      	pop	{r4, pc}

0800cb02 <prvSetSynAckOptions>:
 *
 * @note MSS is the net size of the payload, an is always smaller than MTU.
 */
    UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t * pxSocket,
                                     TCPHeader_t * pxTCPHeader )
    {
 800cb02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cb04:	4605      	mov	r5, r0
 800cb06:	460c      	mov	r4, r1
        uint16_t usMSS = pxSocket->u.xTCP.usMSS;
 800cb08:	f8b0 3072 	ldrh.w	r3, [r0, #114]	@ 0x72
        UBaseType_t uxOptionsLength;

        /* We send out the TCP Maximum Segment Size option with our SYN[+ACK]. */

        pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) tcpTCP_OPT_MSS;
 800cb0c:	2602      	movs	r6, #2
 800cb0e:	750e      	strb	r6, [r1, #20]
        pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) tcpTCP_OPT_MSS_LEN;
 800cb10:	2704      	movs	r7, #4
 800cb12:	754f      	strb	r7, [r1, #21]
        pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 800cb14:	0a1a      	lsrs	r2, r3, #8
 800cb16:	758a      	strb	r2, [r1, #22]
        pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffU );
 800cb18:	75cb      	strb	r3, [r1, #23]

        #if ( ipconfigUSE_TCP_WIN != 0 )
        {
            pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 800cb1a:	f7ff fef2 	bl	800c902 <prvWinScaleFactor>
 800cb1e:	f885 0105 	strb.w	r0, [r5, #261]	@ 0x105

            pxTCPHeader->ucOptdata[ 4 ] = tcpTCP_OPT_NOOP;
 800cb22:	2301      	movs	r3, #1
 800cb24:	7623      	strb	r3, [r4, #24]
            pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT );
 800cb26:	2203      	movs	r2, #3
 800cb28:	7662      	strb	r2, [r4, #25]
            pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( tcpTCP_OPT_WSOPT_LEN );
 800cb2a:	76a2      	strb	r2, [r4, #26]
            pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 800cb2c:	f895 2105 	ldrb.w	r2, [r5, #261]	@ 0x105
 800cb30:	76e2      	strb	r2, [r4, #27]
        }
        #endif /* if ( ipconfigUSE_TCP_WIN != 0 ) */

        #if ( ipconfigUSE_TCP_WIN != 0 )
        {
            pxTCPHeader->ucOptdata[ uxOptionsLength ] = tcpTCP_OPT_NOOP;
 800cb32:	7723      	strb	r3, [r4, #28]
            pxTCPHeader->ucOptdata[ uxOptionsLength + 1U ] = tcpTCP_OPT_NOOP;
 800cb34:	7763      	strb	r3, [r4, #29]
            pxTCPHeader->ucOptdata[ uxOptionsLength + 2U ] = tcpTCP_OPT_SACK_P; /* 4: Sack-Permitted Option. */
 800cb36:	77a7      	strb	r7, [r4, #30]
            pxTCPHeader->ucOptdata[ uxOptionsLength + 3U ] = 2U;                /* 2: length of this option. */
 800cb38:	77e6      	strb	r6, [r4, #31]
            uxOptionsLength += 4U;
        }
        #endif /* ipconfigUSE_TCP_WIN == 0 */
        return uxOptionsLength; /* bytes, not words. */
    }
 800cb3a:	200c      	movs	r0, #12
 800cb3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800cb40 <prvTCPBufferResize>:
 */
    NetworkBufferDescriptor_t * prvTCPBufferResize( const FreeRTOS_Socket_t * pxSocket,
                                                    NetworkBufferDescriptor_t * pxNetworkBuffer,
                                                    int32_t lDataLen,
                                                    UBaseType_t uxOptionsLength )
    {
 800cb40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cb44:	4607      	mov	r7, r0
 800cb46:	460c      	mov	r4, r1
 800cb48:	4615      	mov	r5, r2
 800cb4a:	4698      	mov	r8, r3
        NetworkBufferDescriptor_t * pxReturn;
        size_t uxNeeded;
        BaseType_t xResize;

        if( xBufferAllocFixedSize != pdFALSE )
 800cb4c:	4b21      	ldr	r3, [pc, #132]	@ (800cbd4 <prvTCPBufferResize+0x94>)
 800cb4e:	681b      	ldr	r3, [r3, #0]
 800cb50:	b16b      	cbz	r3, 800cb6e <prvTCPBufferResize+0x2e>
             * MTU. */
            uxNeeded = ( size_t ) ipTOTAL_ETHERNET_FRAME_SIZE;

            /* and therefore, the buffer won't be too small.
             * Only ask for a new network buffer in case none was supplied. */
            if( pxNetworkBuffer == NULL )
 800cb52:	b1d1      	cbz	r1, 800cb8a <prvTCPBufferResize+0x4a>
            }
        }
        else
        {
            /* xResize is false, the network buffer provided was big enough. */
            configASSERT( pxNetworkBuffer != NULL ); /* LCOV_EXCL_BR_LINE this branch will not be covered, since it would never be NULL. to tell lint: when xResize is false, pxNetworkBuffer is not NULL. */
 800cb54:	b3a4      	cbz	r4, 800cbc0 <prvTCPBufferResize+0x80>
            pxReturn = pxNetworkBuffer;

            pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 800cb56:	4638      	mov	r0, r7
 800cb58:	f7fa fea6 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cb5c:	eb00 0308 	add.w	r3, r0, r8
 800cb60:	442b      	add	r3, r5
 800cb62:	3322      	adds	r3, #34	@ 0x22
 800cb64:	62a3      	str	r3, [r4, #40]	@ 0x28
            pxReturn = pxNetworkBuffer;
 800cb66:	4625      	mov	r5, r4
        }

        return pxReturn;
    }
 800cb68:	4628      	mov	r0, r5
 800cb6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            uxNeeded = ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800cb6e:	f7fa fe9b 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cb72:	eb00 0608 	add.w	r6, r0, r8
 800cb76:	3622      	adds	r6, #34	@ 0x22
            uxNeeded += ( size_t ) lDataLen;
 800cb78:	442e      	add	r6, r5
            if( uxNeeded < sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) )
 800cb7a:	2e59      	cmp	r6, #89	@ 0x59
 800cb7c:	d800      	bhi.n	800cb80 <prvTCPBufferResize+0x40>
                uxNeeded = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 800cb7e:	265a      	movs	r6, #90	@ 0x5a
            if( ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < uxNeeded ) )
 800cb80:	b12c      	cbz	r4, 800cb8e <prvTCPBufferResize+0x4e>
 800cb82:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800cb84:	42b3      	cmp	r3, r6
 800cb86:	d2e5      	bcs.n	800cb54 <prvTCPBufferResize+0x14>
 800cb88:	e001      	b.n	800cb8e <prvTCPBufferResize+0x4e>
            uxNeeded = ( size_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
 800cb8a:	f240 56f2 	movw	r6, #1522	@ 0x5f2
            pxReturn = pxGetNetworkBufferWithDescriptor( uxNeeded, 0U );
 800cb8e:	2100      	movs	r1, #0
 800cb90:	4630      	mov	r0, r6
 800cb92:	f001 fdab 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>
            if( pxReturn != NULL )
 800cb96:	4605      	mov	r5, r0
 800cb98:	2800      	cmp	r0, #0
 800cb9a:	d0e5      	beq.n	800cb68 <prvTCPBufferResize+0x28>
                pxReturn->xDataLength = uxNeeded;
 800cb9c:	6286      	str	r6, [r0, #40]	@ 0x28
                if( pxNetworkBuffer != NULL )
 800cb9e:	b144      	cbz	r4, 800cbb2 <prvTCPBufferResize+0x72>
                    ( void ) memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 800cba0:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 800cba2:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800cba4:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 800cba6:	f002 f95e 	bl	800ee66 <memcpy>
                    vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800cbaa:	4620      	mov	r0, r4
 800cbac:	f001 fd78 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 800cbb0:	e7da      	b.n	800cb68 <prvTCPBufferResize+0x28>
                    ( void ) memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800cbb2:	225a      	movs	r2, #90	@ 0x5a
 800cbb4:	f107 01aa 	add.w	r1, r7, #170	@ 0xaa
 800cbb8:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 800cbba:	f002 f954 	bl	800ee66 <memcpy>
 800cbbe:	e7d3      	b.n	800cb68 <prvTCPBufferResize+0x28>
 800cbc0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800cbc4:	f383 8811 	msr	BASEPRI, r3
 800cbc8:	f3bf 8f6f 	isb	sy
 800cbcc:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNetworkBuffer != NULL ); /* LCOV_EXCL_BR_LINE this branch will not be covered, since it would never be NULL. to tell lint: when xResize is false, pxNetworkBuffer is not NULL. */
 800cbd0:	e7fe      	b.n	800cbd0 <prvTCPBufferResize+0x90>
 800cbd2:	bf00      	nop
 800cbd4:	0801033c 	.word	0x0801033c

0800cbd8 <prvTCPReturn_SetEndPoint>:
 * @param[in] uxIPHeaderSize The size of the IP-header, which depends on the IP-type.
 */
    void prvTCPReturn_SetEndPoint( const FreeRTOS_Socket_t * pxSocket,
                                   NetworkBufferDescriptor_t * pxNetworkBuffer,
                                   size_t uxIPHeaderSize )
    {
 800cbd8:	b510      	push	{r4, lr}
 800cbda:	460c      	mov	r4, r1
        #endif
        #if ( ipconfigUSE_IPv6 != 0 )
            const IPHeader_IPv6_t * pxIPHeader_IPv6 = NULL;
        #endif

        if( ( pxSocket != NULL ) && ( pxSocket->pxEndPoint != NULL ) )
 800cbdc:	b118      	cbz	r0, 800cbe6 <prvTCPReturn_SetEndPoint+0xe>
 800cbde:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 800cbe0:	b10b      	cbz	r3, 800cbe6 <prvTCPReturn_SetEndPoint+0xe>
        {
            pxNetworkBuffer->pxEndPoint = pxSocket->pxEndPoint;
 800cbe2:	630b      	str	r3, [r1, #48]	@ 0x30
                FreeRTOS_printf( ( "prvTCPReturnPacket: packet's end-point %02x-%02x\n",
                                   pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes[ 4 ],
                                   pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes[ 5 ] ) );
            }
        }
    }
 800cbe4:	bd10      	pop	{r4, pc}
            switch( uxIPHeaderSize )
 800cbe6:	2a14      	cmp	r2, #20
 800cbe8:	d004      	beq.n	800cbf4 <prvTCPReturn_SetEndPoint+0x1c>
 800cbea:	2a28      	cmp	r2, #40	@ 0x28
 800cbec:	d00a      	beq.n	800cc04 <prvTCPReturn_SetEndPoint+0x2c>
                    pxNetworkBuffer->pxEndPoint = NULL;
 800cbee:	2300      	movs	r3, #0
 800cbf0:	6323      	str	r3, [r4, #48]	@ 0x30
    }
 800cbf2:	e7f7      	b.n	800cbe4 <prvTCPReturn_SetEndPoint+0xc>
                        pxIPHeader = ( ( IPHeader_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 800cbf4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
                        pxNetworkBuffer->pxEndPoint = FreeRTOS_FindEndPointOnNetMask( pxIPHeader->ulDestinationIPAddress, 8 );
 800cbf6:	2108      	movs	r1, #8
 800cbf8:	f8d3 001e 	ldr.w	r0, [r3, #30]
 800cbfc:	f7fc ffae 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
 800cc00:	6320      	str	r0, [r4, #48]	@ 0x30
                        break;
 800cc02:	e7ef      	b.n	800cbe4 <prvTCPReturn_SetEndPoint+0xc>
                        pxIPHeader_IPv6 = ( ( IPHeader_IPv6_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 800cc04:	6a60      	ldr	r0, [r4, #36]	@ 0x24
                        pxNetworkBuffer->pxEndPoint = FreeRTOS_FindEndPointOnIP_IPv6( &( pxIPHeader_IPv6->xDestinationAddress ) );
 800cc06:	3026      	adds	r0, #38	@ 0x26
 800cc08:	f7fc ffd2 	bl	8009bb0 <FreeRTOS_FindEndPointOnIP_IPv6>
 800cc0c:	6320      	str	r0, [r4, #48]	@ 0x30
                        break;
 800cc0e:	e7e9      	b.n	800cbe4 <prvTCPReturn_SetEndPoint+0xc>

0800cc10 <prvTCPPrepareSend>:
 *         is returned in case of any error.
 */
    int32_t prvTCPPrepareSend( FreeRTOS_Socket_t * pxSocket,
                               NetworkBufferDescriptor_t ** ppxNetworkBuffer,
                               UBaseType_t uxOptionsLength )
    {
 800cc10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cc14:	b085      	sub	sp, #20
 800cc16:	4604      	mov	r4, r0
 800cc18:	460f      	mov	r7, r1
 800cc1a:	4690      	mov	r8, r2
        TCPWindow_t * pxTCPWindow;
        NetworkBufferDescriptor_t * pxNewBuffer;
        int32_t lStreamPos;
        UBaseType_t uxIntermediateResult = 0;

        if( ( *ppxNetworkBuffer ) != NULL )
 800cc1c:	680b      	ldr	r3, [r1, #0]
 800cc1e:	2b00      	cmp	r3, #0
 800cc20:	d03b      	beq.n	800cc9a <prvTCPPrepareSend+0x8a>
        {
            /* A network buffer descriptor was already supplied */
            pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
 800cc22:	6a5d      	ldr	r5, [r3, #36]	@ 0x24
        /* Map the ethernet buffer onto the ProtocolHeader_t struct for easy access to the fields. */

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxProtocolHeaders = ( ( ProtocolHeaders_t * ) &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800cc24:	4620      	mov	r0, r4
 800cc26:	f7fa fe3f 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cc2a:	300e      	adds	r0, #14
 800cc2c:	4405      	add	r5, r0
        pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 800cc2e:	f504 798a 	add.w	r9, r4, #276	@ 0x114
        lDataLen = 0;
        lStreamPos = 0;
 800cc32:	2300      	movs	r3, #0
 800cc34:	9303      	str	r3, [sp, #12]
        pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_ACK;
 800cc36:	7b69      	ldrb	r1, [r5, #13]
 800cc38:	f041 0110 	orr.w	r1, r1, #16
 800cc3c:	7369      	strb	r1, [r5, #13]

        if( pxSocket->u.xTCP.txStream != NULL )
 800cc3e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800cc42:	2b00      	cmp	r3, #0
 800cc44:	f000 8081 	beq.w	800cd4a <prvTCPPrepareSend+0x13a>
        {
            /* ulTCPWindowTxGet will return the amount of data which may be sent
             * along with the position in the txStream.
             * Why check for MSS > 1 ?
             * Because some TCP-stacks (like uIP) use it for flow-control. */
            if( pxSocket->u.xTCP.usMSS > 1U )
 800cc48:	f8b4 3072 	ldrh.w	r3, [r4, #114]	@ 0x72
 800cc4c:	2b01      	cmp	r3, #1
 800cc4e:	d827      	bhi.n	800cca0 <prvTCPPrepareSend+0x90>
        lDataLen = 0;
 800cc50:	2600      	movs	r6, #0
                    lDataLen = -1;
                }
            }
        }

        if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.eTCPState == eESTABLISHED ) )
 800cc52:	2e00      	cmp	r6, #0
 800cc54:	db1d      	blt.n	800cc92 <prvTCPPrepareSend+0x82>
 800cc56:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800cc5a:	2b05      	cmp	r3, #5
 800cc5c:	d077      	beq.n	800cd4e <prvTCPPrepareSend+0x13e>
                }
            }
            #endif /* ipconfigTCP_KEEP_ALIVE */
        }

        if( lDataLen >= 0 )
 800cc5e:	2e00      	cmp	r6, #0
 800cc60:	db17      	blt.n	800cc92 <prvTCPPrepareSend+0x82>
        {
            /* Anything to send, a change of the advertised window size, or maybe send a
             * keep-alive message? */
            if( ( lDataLen > 0 ) ||
 800cc62:	f340 80d5 	ble.w	800ce10 <prvTCPPrepareSend+0x200>
                ( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
                ( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
            {
                pxProtocolHeaders->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~tcpTCP_FLAG_PSH );
 800cc66:	7b6b      	ldrb	r3, [r5, #13]
 800cc68:	f003 03f7 	and.w	r3, r3, #247	@ 0xf7
 800cc6c:	736b      	strb	r3, [r5, #13]
                pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 ); /*_RB_ "2" needs comment. */
 800cc6e:	f108 0214 	add.w	r2, r8, #20
 800cc72:	b2d2      	uxtb	r2, r2
 800cc74:	0092      	lsls	r2, r2, #2
 800cc76:	732a      	strb	r2, [r5, #12]

                pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_ACK;
 800cc78:	f043 0210 	orr.w	r2, r3, #16
 800cc7c:	736a      	strb	r2, [r5, #13]

                if( lDataLen != 0L )
 800cc7e:	b116      	cbz	r6, 800cc86 <prvTCPPrepareSend+0x76>
                {
                    pxProtocolHeaders->xTCPHeader.ucTCPFlags |= ( uint8_t ) tcpTCP_FLAG_PSH;
 800cc80:	f043 0318 	orr.w	r3, r3, #24
 800cc84:	736b      	strb	r3, [r5, #13]
                }

                uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800cc86:	4620      	mov	r0, r4
 800cc88:	f7fa fe0e 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cc8c:	4440      	add	r0, r8
 800cc8e:	3014      	adds	r0, #20
                lDataLen += ( int32_t ) uxIntermediateResult;
 800cc90:	4406      	add	r6, r0
            }
        }

        return lDataLen;
    }
 800cc92:	4630      	mov	r0, r6
 800cc94:	b005      	add	sp, #20
 800cc96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800cc9a:	f100 05aa 	add.w	r5, r0, #170	@ 0xaa
 800cc9e:	e7c1      	b.n	800cc24 <prvTCPPrepareSend+0x14>
                lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos );
 800cca0:	aa03      	add	r2, sp, #12
 800cca2:	f8d4 1108 	ldr.w	r1, [r4, #264]	@ 0x108
 800cca6:	4648      	mov	r0, r9
 800cca8:	f001 f9d7 	bl	800e05a <ulTCPWindowTxGet>
 800ccac:	4682      	mov	sl, r0
 800ccae:	4606      	mov	r6, r0
            if( lDataLen > 0 )
 800ccb0:	2800      	cmp	r0, #0
 800ccb2:	ddce      	ble.n	800cc52 <prvTCPPrepareSend+0x42>
                pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
 800ccb4:	4643      	mov	r3, r8
 800ccb6:	4602      	mov	r2, r0
 800ccb8:	6839      	ldr	r1, [r7, #0]
 800ccba:	4620      	mov	r0, r4
 800ccbc:	f7ff ff40 	bl	800cb40 <prvTCPBufferResize>
                if( pxNewBuffer != NULL )
 800ccc0:	2800      	cmp	r0, #0
 800ccc2:	f000 80ac 	beq.w	800ce1e <prvTCPPrepareSend+0x20e>
                    *ppxNetworkBuffer = pxNewBuffer;
 800ccc6:	6038      	str	r0, [r7, #0]
                    pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
 800ccc8:	f8d0 b024 	ldr.w	fp, [r0, #36]	@ 0x24
                    pxProtocolHeaders = ( ( ProtocolHeaders_t * ) &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800cccc:	4620      	mov	r0, r4
 800ccce:	f7fa fdeb 	bl	80078a8 <uxIPHeaderSizeSocket>
 800ccd2:	f100 050e 	add.w	r5, r0, #14
 800ccd6:	445d      	add	r5, fp
                    pucSendData = &( pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength ] );
 800ccd8:	4620      	mov	r0, r4
 800ccda:	f7fa fde5 	bl	80078a8 <uxIPHeaderSizeSocket>
 800ccde:	eb00 0708 	add.w	r7, r0, r8
 800cce2:	3722      	adds	r7, #34	@ 0x22
 800cce4:	445f      	add	r7, fp
                    uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, ( size_t ) lStreamPos );
 800cce6:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
 800ccea:	6801      	ldr	r1, [r0, #0]
 800ccec:	9a03      	ldr	r2, [sp, #12]
 800ccee:	f7fe fb8d 	bl	800b40c <uxStreamBufferDistance>
 800ccf2:	4601      	mov	r1, r0
                    ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, ( size_t ) lDataLen, pdTRUE );
 800ccf4:	2301      	movs	r3, #1
 800ccf6:	9300      	str	r3, [sp, #0]
 800ccf8:	4653      	mov	r3, sl
 800ccfa:	463a      	mov	r2, r7
 800ccfc:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
 800cd00:	f7fe fc1b 	bl	800b53a <uxStreamBufferGet>
 800cd04:	4607      	mov	r7, r0
                    if( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED )
 800cd06:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800cd0a:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800cd0e:	d0a0      	beq.n	800cc52 <prvTCPPrepareSend+0x42>
                        ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStreamPos, pxSocket->u.xTCP.txStream->uxHead );
 800cd10:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
 800cd14:	6882      	ldr	r2, [r0, #8]
 800cd16:	9903      	ldr	r1, [sp, #12]
 800cd18:	f7fe fb78 	bl	800b40c <uxStreamBufferDistance>
                        if( ulDistance == ulDataGot )
 800cd1c:	4287      	cmp	r7, r0
 800cd1e:	d198      	bne.n	800cc52 <prvTCPPrepareSend+0x42>
                                size_t uxHead = pxSocket->u.xTCP.txStream->uxHead;
 800cd20:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800cd24:	689a      	ldr	r2, [r3, #8]
                                size_t uxMid = pxSocket->u.xTCP.txStream->uxMid;
 800cd26:	685a      	ldr	r2, [r3, #4]
                                size_t uxTail = pxSocket->u.xTCP.txStream->uxTail;
 800cd28:	681b      	ldr	r3, [r3, #0]
                            pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
 800cd2a:	7b6b      	ldrb	r3, [r5, #13]
 800cd2c:	f043 0301 	orr.w	r3, r3, #1
 800cd30:	736b      	strb	r3, [r5, #13]
                            pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLen;
 800cd32:	f8d4 3140 	ldr.w	r3, [r4, #320]	@ 0x140
 800cd36:	4453      	add	r3, sl
 800cd38:	f8c4 3138 	str.w	r3, [r4, #312]	@ 0x138
                            pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800cd3c:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800cd40:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800cd44:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
 800cd48:	e783      	b.n	800cc52 <prvTCPPrepareSend+0x42>
        lDataLen = 0;
 800cd4a:	2600      	movs	r6, #0
 800cd4c:	e783      	b.n	800cc56 <prvTCPPrepareSend+0x46>
            if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 800cd4e:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800cd52:	f013 0f20 	tst.w	r3, #32
 800cd56:	d12e      	bne.n	800cdb6 <prvTCPPrepareSend+0x1a6>
                if( pxSocket->u.xTCP.ucKeepRepCount > 3U ) /*_RB_ Magic number. */
 800cd58:	f894 3080 	ldrb.w	r3, [r4, #128]	@ 0x80
 800cd5c:	2b03      	cmp	r3, #3
 800cd5e:	d84d      	bhi.n	800cdfc <prvTCPPrepareSend+0x1ec>
                if( ( lDataLen == 0 ) && ( pxSocket->u.xTCP.bits.bWinChange == pdFALSE_UNSIGNED ) )
 800cd60:	2e00      	cmp	r6, #0
 800cd62:	f47f af7c 	bne.w	800cc5e <prvTCPPrepareSend+0x4e>
 800cd66:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800cd6a:	f013 0f01 	tst.w	r3, #1
 800cd6e:	f47f af76 	bne.w	800cc5e <prvTCPPrepareSend+0x4e>
                    TickType_t xAge = xTaskGetTickCount() - pxSocket->u.xTCP.xLastAliveTime;
 800cd72:	f7f7 ff57 	bl	8004c24 <xTaskGetTickCount>
 800cd76:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
 800cd7a:	1ac0      	subs	r0, r0, r3
                    if( pxSocket->u.xTCP.ucKeepRepCount != 0U )
 800cd7c:	f894 3080 	ldrb.w	r3, [r4, #128]	@ 0x80
 800cd80:	2b00      	cmp	r3, #0
 800cd82:	d142      	bne.n	800ce0a <prvTCPPrepareSend+0x1fa>
                    xMax = ( ( TickType_t ) ipconfigTCP_KEEP_ALIVE_INTERVAL * ( TickType_t ) configTICK_RATE_HZ );
 800cd84:	f644 6320 	movw	r3, #20000	@ 0x4e20
                    if( xAge > xMax )
 800cd88:	4283      	cmp	r3, r0
 800cd8a:	f4bf af68 	bcs.w	800cc5e <prvTCPPrepareSend+0x4e>
                        pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount();
 800cd8e:	f7f7 ff49 	bl	8004c24 <xTaskGetTickCount>
 800cd92:	f8c4 0084 	str.w	r0, [r4, #132]	@ 0x84
                        pxSocket->u.xTCP.bits.bSendKeepAlive = pdTRUE_UNSIGNED;
 800cd96:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800cd9a:	f043 0302 	orr.w	r3, r3, #2
 800cd9e:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                        pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500U ) );
 800cda2:	f640 13c4 	movw	r3, #2500	@ 0x9c4
 800cda6:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                        pxSocket->u.xTCP.ucKeepRepCount++;
 800cdaa:	f894 3080 	ldrb.w	r3, [r4, #128]	@ 0x80
 800cdae:	3301      	adds	r3, #1
 800cdb0:	f884 3080 	strb.w	r3, [r4, #128]	@ 0x80
 800cdb4:	e753      	b.n	800cc5e <prvTCPPrepareSend+0x4e>
                ( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 800cdb6:	4648      	mov	r0, r9
 800cdb8:	f001 f90c 	bl	800dfd4 <xTCPWindowTxDone>
            if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 800cdbc:	2800      	cmp	r0, #0
 800cdbe:	d0cb      	beq.n	800cd58 <prvTCPPrepareSend+0x148>
                pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
 800cdc0:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800cdc4:	f023 0320 	bic.w	r3, r3, #32
 800cdc8:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
                pxProtocolHeaders->xTCPHeader.ucTCPFlags |= tcpTCP_FLAG_FIN;
 800cdcc:	7b6b      	ldrb	r3, [r5, #13]
 800cdce:	f043 0301 	orr.w	r3, r3, #1
 800cdd2:	736b      	strb	r3, [r5, #13]
                pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800cdd4:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800cdd8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800cddc:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800cde0:	b2db      	uxtb	r3, r3
 800cde2:	f043 0301 	orr.w	r3, r3, #1
 800cde6:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
                pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800cdea:	f8d4 3134 	ldr.w	r3, [r4, #308]	@ 0x134
 800cdee:	f8c4 3138 	str.w	r3, [r4, #312]	@ 0x138
                vTCPStateChange( pxSocket, eFIN_WAIT_1 );
 800cdf2:	2106      	movs	r1, #6
 800cdf4:	4620      	mov	r0, r4
 800cdf6:	f7fe fc61 	bl	800b6bc <vTCPStateChange>
 800cdfa:	e7ad      	b.n	800cd58 <prvTCPPrepareSend+0x148>
                    vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800cdfc:	2108      	movs	r1, #8
 800cdfe:	4620      	mov	r0, r4
 800ce00:	f7fe fc5c 	bl	800b6bc <vTCPStateChange>
                    lDataLen = -1;
 800ce04:	f04f 36ff 	mov.w	r6, #4294967295
 800ce08:	e729      	b.n	800cc5e <prvTCPPrepareSend+0x4e>
                        xMax = 3U * configTICK_RATE_HZ;
 800ce0a:	f640 33b8 	movw	r3, #3000	@ 0xbb8
 800ce0e:	e7bb      	b.n	800cd88 <prvTCPPrepareSend+0x178>
                ( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 800ce10:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800ce14:	f013 0f03 	tst.w	r3, #3
 800ce18:	f43f af3b 	beq.w	800cc92 <prvTCPPrepareSend+0x82>
 800ce1c:	e723      	b.n	800cc66 <prvTCPPrepareSend+0x56>
                    lDataLen = -1;
 800ce1e:	f04f 36ff 	mov.w	r6, #4294967295
        return lDataLen;
 800ce22:	e736      	b.n	800cc92 <prvTCPPrepareSend+0x82>

0800ce24 <prvTCPSendRepeated>:
    {
 800ce24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ce28:	4607      	mov	r7, r0
 800ce2a:	460e      	mov	r6, r1
        int32_t lResult = 0;
 800ce2c:	f04f 0800 	mov.w	r8, #0
        for( uxIndex = 0U; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 800ce30:	4645      	mov	r5, r8
 800ce32:	2d07      	cmp	r5, #7
 800ce34:	d80f      	bhi.n	800ce56 <prvTCPSendRepeated+0x32>
            xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 800ce36:	2200      	movs	r2, #0
 800ce38:	4631      	mov	r1, r6
 800ce3a:	4638      	mov	r0, r7
 800ce3c:	f7ff fee8 	bl	800cc10 <prvTCPPrepareSend>
            if( xSendLength <= 0 )
 800ce40:	1e04      	subs	r4, r0, #0
 800ce42:	dd08      	ble.n	800ce56 <prvTCPSendRepeated+0x32>
            prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 800ce44:	2300      	movs	r3, #0
 800ce46:	4622      	mov	r2, r4
 800ce48:	6831      	ldr	r1, [r6, #0]
 800ce4a:	4638      	mov	r0, r7
 800ce4c:	f7ff fd84 	bl	800c958 <prvTCPReturnPacket>
            lResult += xSendLength;
 800ce50:	44a0      	add	r8, r4
        for( uxIndex = 0U; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 800ce52:	3501      	adds	r5, #1
 800ce54:	e7ed      	b.n	800ce32 <prvTCPSendRepeated+0xe>
    }
 800ce56:	4640      	mov	r0, r8
 800ce58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ce5c <prvTCPSendPacket>:
    {
 800ce5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ce5e:	b083      	sub	sp, #12
 800ce60:	4604      	mov	r4, r0
        if( pxSocket->u.xTCP.eTCPState != eCONNECT_SYN )
 800ce62:	f890 3079 	ldrb.w	r3, [r0, #121]	@ 0x79
 800ce66:	2b02      	cmp	r3, #2
 800ce68:	d108      	bne.n	800ce7c <prvTCPSendPacket+0x20>
            if( pxSocket->u.xTCP.ucRepCount >= 3U )
 800ce6a:	f890 3078 	ldrb.w	r3, [r0, #120]	@ 0x78
 800ce6e:	2b02      	cmp	r3, #2
 800ce70:	d911      	bls.n	800ce96 <prvTCPSendPacket+0x3a>
                vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800ce72:	2108      	movs	r1, #8
 800ce74:	f7fe fc22 	bl	800b6bc <vTCPStateChange>
        int32_t lResult = 0;
 800ce78:	2500      	movs	r5, #0
 800ce7a:	e009      	b.n	800ce90 <prvTCPSendPacket+0x34>
            pxNetworkBuffer = NULL;
 800ce7c:	2300      	movs	r3, #0
 800ce7e:	9301      	str	r3, [sp, #4]
            lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 800ce80:	a901      	add	r1, sp, #4
 800ce82:	f7ff ffcf 	bl	800ce24 <prvTCPSendRepeated>
 800ce86:	4605      	mov	r5, r0
            if( pxNetworkBuffer != NULL )
 800ce88:	9801      	ldr	r0, [sp, #4]
 800ce8a:	b108      	cbz	r0, 800ce90 <prvTCPSendPacket+0x34>
                vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800ce8c:	f001 fc08 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
    }
 800ce90:	4628      	mov	r0, r5
 800ce92:	b003      	add	sp, #12
 800ce94:	bdf0      	pop	{r4, r5, r6, r7, pc}
            else if( prvTCPMakeSurePrepared( pxSocket ) == pdTRUE )
 800ce96:	f7ff fd51 	bl	800c93c <prvTCPMakeSurePrepared>
 800ce9a:	2801      	cmp	r0, #1
 800ce9c:	d001      	beq.n	800cea2 <prvTCPSendPacket+0x46>
        int32_t lResult = 0;
 800ce9e:	2500      	movs	r5, #0
        return lResult;
 800cea0:	e7f6      	b.n	800ce90 <prvTCPSendPacket+0x34>
                pxProtocolHeaders = ( ( ProtocolHeaders_t * ) &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800cea2:	4620      	mov	r0, r4
 800cea4:	f7fa fd00 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cea8:	f100 07ae 	add.w	r7, r0, #174	@ 0xae
 800ceac:	4427      	add	r7, r4
 800ceae:	370a      	adds	r7, #10
                uxOptionsLength = prvSetSynAckOptions( pxSocket, &( pxProtocolHeaders->xTCPHeader ) );
 800ceb0:	4639      	mov	r1, r7
 800ceb2:	4620      	mov	r0, r4
 800ceb4:	f7ff fe25 	bl	800cb02 <prvSetSynAckOptions>
 800ceb8:	4606      	mov	r6, r0
                uxIntermediateResult = uxIPHeaderSizeSocket( pxSocket ) + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800ceba:	4620      	mov	r0, r4
 800cebc:	f7fa fcf4 	bl	80078a8 <uxIPHeaderSizeSocket>
 800cec0:	1985      	adds	r5, r0, r6
 800cec2:	3514      	adds	r5, #20
                pxProtocolHeaders->xTCPHeader.ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800cec4:	f106 0314 	add.w	r3, r6, #20
 800cec8:	b2db      	uxtb	r3, r3
 800ceca:	009b      	lsls	r3, r3, #2
 800cecc:	733b      	strb	r3, [r7, #12]
                pxSocket->u.xTCP.ucRepCount++;
 800cece:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
 800ced2:	3301      	adds	r3, #1
 800ced4:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
                prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
 800ced8:	2300      	movs	r3, #0
 800ceda:	462a      	mov	r2, r5
 800cedc:	4619      	mov	r1, r3
 800cede:	4620      	mov	r0, r4
 800cee0:	f7ff fd3a 	bl	800c958 <prvTCPReturnPacket>
 800cee4:	e7d4      	b.n	800ce90 <prvTCPSendPacket+0x34>

0800cee6 <prvTCPAddTxData>:
 *        this data to the windowing system to it can be transmitted.
 *
 * @param[in] pxSocket The socket owning the connection.
 */
    void prvTCPAddTxData( FreeRTOS_Socket_t * pxSocket )
    {
 800cee6:	b510      	push	{r4, lr}
 800cee8:	4604      	mov	r4, r0
         * the sliding window.
         *
         * uxStreamBufferMidSpace() returns the distance between rxHead and rxMid.  It
         * contains new Tx data which has not been passed to the sliding window yet.
         * The oldest data not-yet-confirmed can be found at rxTail. */
        lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
 800ceea:	f8d0 00a0 	ldr.w	r0, [r0, #160]	@ 0xa0
 800ceee:	f7fe faa6 	bl	800b43e <uxStreamBufferMidSpace>

        if( lLength > 0 )
 800cef2:	1e01      	subs	r1, r0, #0
 800cef4:	dc00      	bgt.n	800cef8 <prvTCPAddTxData+0x12>
            if( lCount > 0 )
            {
                vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
            }
        }
    }
 800cef6:	bd10      	pop	{r4, pc}
                                      ( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
 800cef8:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
 800cefc:	685a      	ldr	r2, [r3, #4]
            lCount = lTCPWindowTxAdd( &pxSocket->u.xTCP.xTCPWindow,
 800cefe:	691b      	ldr	r3, [r3, #16]
 800cf00:	f504 708a 	add.w	r0, r4, #276	@ 0x114
 800cf04:	f001 f809 	bl	800df1a <lTCPWindowTxAdd>
            if( lCount > 0 )
 800cf08:	1e01      	subs	r1, r0, #0
 800cf0a:	ddf4      	ble.n	800cef6 <prvTCPAddTxData+0x10>
                vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
 800cf0c:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
 800cf10:	f7fe faa1 	bl	800b456 <vStreamBufferMoveMid>
    }
 800cf14:	e7ef      	b.n	800cef6 <prvTCPAddTxData+0x10>

0800cf16 <prvSetOptions>:
 *
 * @return Length of the TCP options after they are set.
 */
    UBaseType_t prvSetOptions( FreeRTOS_Socket_t * pxSocket,
                               const NetworkBufferDescriptor_t * pxNetworkBuffer )
    {
 800cf16:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cf18:	4604      	mov	r4, r0
 800cf1a:	4608      	mov	r0, r1

        /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                  &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( pxNetworkBuffer ) ] ) );
 800cf1c:	6a4e      	ldr	r6, [r1, #36]	@ 0x24
 800cf1e:	f7fa fadb 	bl	80074d8 <uxIPHeaderSizePacket>
 800cf22:	300e      	adds	r0, #14
        ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800cf24:	4406      	add	r6, r0
        TCPHeader_t * pxTCPHeader = &pxProtocolHeaders->xTCPHeader;
        const TCPWindow_t * pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
        UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 800cf26:	f894 5150 	ldrb.w	r5, [r4, #336]	@ 0x150
 800cf2a:	462f      	mov	r7, r5
        #if ( ipconfigUSE_TCP_WIN == 1 )
            /* memcpy() helper variables for MISRA Rule 21.15 compliance*/
            const void * pvCopySource;
            void * pvCopyDest;

            if( uxOptionsLength != 0U )
 800cf2c:	b9e5      	cbnz	r5, 800cf68 <prvSetOptions+0x52>
                pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
            }
            else
        #endif /* ipconfigUSE_TCP_WIN */

        if( ( pxSocket->u.xTCP.eTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMssChange != pdFALSE_UNSIGNED ) )
 800cf2e:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
 800cf32:	2b04      	cmp	r3, #4
 800cf34:	d923      	bls.n	800cf7e <prvSetOptions+0x68>
 800cf36:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800cf3a:	f013 0f01 	tst.w	r3, #1
 800cf3e:	d01e      	beq.n	800cf7e <prvSetOptions+0x68>
        {
            /* TCP options must be sent because the MSS has changed. */
            pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
 800cf40:	f894 3068 	ldrb.w	r3, [r4, #104]	@ 0x68
 800cf44:	f023 0301 	bic.w	r3, r3, #1
 800cf48:	f884 3068 	strb.w	r3, [r4, #104]	@ 0x68
            if( xTCPWindowLoggingLevel >= 0 )
            {
                FreeRTOS_debug_printf( ( "MSS: sending %u\n", pxSocket->u.xTCP.usMSS ) );
            }

            pxTCPHeader->ucOptdata[ 0 ] = tcpTCP_OPT_MSS;
 800cf4c:	2302      	movs	r3, #2
 800cf4e:	7533      	strb	r3, [r6, #20]
            pxTCPHeader->ucOptdata[ 1 ] = tcpTCP_OPT_MSS_LEN;
 800cf50:	2704      	movs	r7, #4
 800cf52:	7577      	strb	r7, [r6, #21]
            pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usMSS ) >> 8 );
 800cf54:	f8b4 3072 	ldrh.w	r3, [r4, #114]	@ 0x72
 800cf58:	0a1b      	lsrs	r3, r3, #8
 800cf5a:	75b3      	strb	r3, [r6, #22]
            pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usMSS ) & 0xffU );
 800cf5c:	f894 3072 	ldrb.w	r3, [r4, #114]	@ 0x72
 800cf60:	75f3      	strb	r3, [r6, #23]
            uxOptionsLength = 4U;
            pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800cf62:	2360      	movs	r3, #96	@ 0x60
 800cf64:	7333      	strb	r3, [r6, #12]
        else
        {
            /* Nothing. */
        }

        return uxOptionsLength;
 800cf66:	e00a      	b.n	800cf7e <prvSetOptions+0x68>
                ( void ) memcpy( pvCopyDest, pvCopySource, ( size_t ) uxOptionsLength );
 800cf68:	462a      	mov	r2, r5
 800cf6a:	f504 71ca 	add.w	r1, r4, #404	@ 0x194
 800cf6e:	f106 0014 	add.w	r0, r6, #20
 800cf72:	f001 ff78 	bl	800ee66 <memcpy>
                pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800cf76:	3514      	adds	r5, #20
 800cf78:	b2ed      	uxtb	r5, r5
 800cf7a:	00ad      	lsls	r5, r5, #2
 800cf7c:	7335      	strb	r5, [r6, #12]
    }
 800cf7e:	4638      	mov	r0, r7
 800cf80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800cf82 <prvSendData>:
 */
    BaseType_t prvSendData( FreeRTOS_Socket_t * pxSocket,
                            NetworkBufferDescriptor_t ** ppxNetworkBuffer,
                            uint32_t ulReceiveLength,
                            BaseType_t xByteCount )
    {
 800cf82:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cf86:	4604      	mov	r4, r0
 800cf88:	460d      	mov	r5, r1
 800cf8a:	4617      	mov	r7, r2
 800cf8c:	461e      	mov	r6, r3

        /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                                                        &( ( *ppxNetworkBuffer )->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizePacket( *ppxNetworkBuffer ) ] ) );
 800cf8e:	6808      	ldr	r0, [r1, #0]
 800cf90:	f8d0 8024 	ldr.w	r8, [r0, #36]	@ 0x24
 800cf94:	f7fa faa0 	bl	80074d8 <uxIPHeaderSizePacket>
 800cf98:	300e      	adds	r0, #14
        const ProtocolHeaders_t * pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800cf9a:	4480      	add	r8, r0
        BaseType_t xSendLength = xByteCount;
        uint32_t ulRxBufferSpace;

        #if ( ipconfigUSE_TCP_WIN == 1 )
            /* Two steps to please MISRA. */
            size_t uxSize = uxIPHeaderSizePacket( *ppxNetworkBuffer ) + ipSIZE_OF_TCP_HEADER;
 800cf9c:	6828      	ldr	r0, [r5, #0]
 800cf9e:	f7fa fa9b 	bl	80074d8 <uxIPHeaderSizePacket>
            int32_t lMinLength;
        #endif

        /* Set the time-out field, so that we'll be called by the IP-task in case no
         * next message will be received. */
        ulRxBufferSpace = pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber;
 800cfa2:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 800cfa4:	f8d4 2124 	ldr.w	r2, [r4, #292]	@ 0x124
 800cfa8:	1a9b      	subs	r3, r3, r2
        lRxSpace = ( int32_t ) ulRxBufferSpace;

        #if ipconfigUSE_TCP_WIN == 1
        {
            /* An ACK may be delayed if the peer has space for at least 2 x MSS. */
            lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usMSS );
 800cfaa:	f8b4 9072 	ldrh.w	r9, [r4, #114]	@ 0x72

            /* In case we're receiving data continuously, we might postpone sending
             * an ACK to gain performance. */
            /* lint e9007 is OK because 'uxIPHeaderSizeSocket()' has no side-effects. */
            if( ( ulReceiveLength > 0U ) &&                               /* Data was sent to this socket. */
 800cfae:	b15f      	cbz	r7, 800cfc8 <prvSendData+0x46>
 800cfb0:	3014      	adds	r0, #20
 800cfb2:	ea4f 0249 	mov.w	r2, r9, lsl #1
 800cfb6:	4293      	cmp	r3, r2
 800cfb8:	db06      	blt.n	800cfc8 <prvSendData+0x46>
                ( lRxSpace >= lMinLength ) &&                             /* There is Rx space for more data. */
                ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) && /* Not in a closure phase. */
 800cfba:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
                ( lRxSpace >= lMinLength ) &&                             /* There is Rx space for more data. */
 800cfbe:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800cfc2:	d101      	bne.n	800cfc8 <prvSendData+0x46>
                ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) && /* Not in a closure phase. */
 800cfc4:	4286      	cmp	r6, r0
 800cfc6:	d00e      	beq.n	800cfe6 <prvSendData+0x64>
                }

                *ppxNetworkBuffer = NULL;
                xSendLength = 0;
            }
            else if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800cfc8:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
 800cfcc:	b138      	cbz	r0, 800cfde <prvSendData+0x5c>
            {
                /* As an ACK is not being delayed, remove any earlier delayed ACK
                 * message. */
                if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 800cfce:	682b      	ldr	r3, [r5, #0]
 800cfd0:	4298      	cmp	r0, r3
 800cfd2:	d001      	beq.n	800cfd8 <prvSendData+0x56>
                {
                    vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800cfd4:	f001 fb64 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
                }

                pxSocket->u.xTCP.pxAckMessage = NULL;
 800cfd8:	2300      	movs	r3, #0
 800cfda:	f8c4 30a4 	str.w	r3, [r4, #164]	@ 0xa4
            ( void ) pxTCPHeader;
            ( void ) lRxSpace;
        }
        #endif /* ipconfigUSE_TCP_WIN */

        if( xSendLength != 0 )
 800cfde:	bb0e      	cbnz	r6, 800d024 <prvSendData+0xa2>
            }
            #endif
        }

        return xSendLength;
    }
 800cfe0:	4630      	mov	r0, r6
 800cfe2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                ( pxSocket->u.xTCP.eTCPState == eESTABLISHED ) &&         /* Connection established. */
 800cfe6:	f894 3079 	ldrb.w	r3, [r4, #121]	@ 0x79
                ( xSendLength == xSizeWithoutData ) &&                    /* No Tx data or options to be sent. */
 800cfea:	2b05      	cmp	r3, #5
 800cfec:	d1ec      	bne.n	800cfc8 <prvSendData+0x46>
                ( pxTCPHeader->ucTCPFlags == tcpTCP_FLAG_ACK ) )          /* There are no other flags than an ACK. */
 800cfee:	f898 300d 	ldrb.w	r3, [r8, #13]
                ( pxSocket->u.xTCP.eTCPState == eESTABLISHED ) &&         /* Connection established. */
 800cff2:	2b10      	cmp	r3, #16
 800cff4:	d1e8      	bne.n	800cfc8 <prvSendData+0x46>
                if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 800cff6:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
 800cffa:	682b      	ldr	r3, [r5, #0]
 800cffc:	4298      	cmp	r0, r3
 800cffe:	d005      	beq.n	800d00c <prvSendData+0x8a>
                    if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800d000:	b108      	cbz	r0, 800d006 <prvSendData+0x84>
                        vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800d002:	f001 fb4d 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
                    pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
 800d006:	682b      	ldr	r3, [r5, #0]
 800d008:	f8c4 30a4 	str.w	r3, [r4, #164]	@ 0xa4
                if( ulReceiveLength < ulCurMSS ) /* Received a small message. */
 800d00c:	454f      	cmp	r7, r9
 800d00e:	d205      	bcs.n	800d01c <prvSendData+0x9a>
                    pxSocket->u.xTCP.usTimeout = ( uint16_t ) tcpDELAYED_ACK_SHORT_DELAY_MS;
 800d010:	2302      	movs	r3, #2
 800d012:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                *ppxNetworkBuffer = NULL;
 800d016:	2600      	movs	r6, #0
 800d018:	602e      	str	r6, [r5, #0]
        if( xSendLength != 0 )
 800d01a:	e7e1      	b.n	800cfe0 <prvSendData+0x5e>
                    pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_TICKS( tcpDELAYED_ACK_LONGER_DELAY_MS );
 800d01c:	2314      	movs	r3, #20
 800d01e:	f8a4 3070 	strh.w	r3, [r4, #112]	@ 0x70
                    if( pxSocket->u.xTCP.usTimeout < 1U ) /* LCOV_EXCL_BR_LINE, the second branch will never be hit */
 800d022:	e7f8      	b.n	800d016 <prvSendData+0x94>
            prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 800d024:	2300      	movs	r3, #0
 800d026:	4632      	mov	r2, r6
 800d028:	6829      	ldr	r1, [r5, #0]
 800d02a:	4620      	mov	r0, r4
 800d02c:	f7ff fc94 	bl	800c958 <prvTCPReturnPacket>
 800d030:	e7d6      	b.n	800cfe0 <prvSendData+0x5e>

0800d032 <prvTCPSendSpecialPacketHelper>:
 *
 * @return pdFAIL always indicating that the packet was not consumed.
 */
    BaseType_t prvTCPSendSpecialPacketHelper( NetworkBufferDescriptor_t * pxNetworkBuffer,
                                              uint8_t ucTCPFlags )
    {
 800d032:	b538      	push	{r3, r4, r5, lr}
 800d034:	4604      	mov	r4, r0
 800d036:	460d      	mov	r5, r1
            /* Configured to ignore unknown packets just suppress a compiler warning. */
            ( void ) pxNetworkBuffer;
            ( void ) ucTCPFlags;
        #else
        {
            switch( uxIPHeaderSizePacket( pxNetworkBuffer ) )
 800d038:	f7fa fa4e 	bl	80074d8 <uxIPHeaderSizePacket>
 800d03c:	2814      	cmp	r0, #20
 800d03e:	d003      	beq.n	800d048 <prvTCPSendSpecialPacketHelper+0x16>
 800d040:	2828      	cmp	r0, #40	@ 0x28
 800d042:	d006      	beq.n	800d052 <prvTCPSendSpecialPacketHelper+0x20>
 800d044:	2000      	movs	r0, #0
 800d046:	e003      	b.n	800d050 <prvTCPSendSpecialPacketHelper+0x1e>
            {
                #if ( ipconfigUSE_IPv4 != 0 )
                    case ipSIZE_OF_IPv4_HEADER:
                        xReturn = prvTCPSendSpecialPktHelper_IPV4( pxNetworkBuffer, ucTCPFlags );
 800d048:	4629      	mov	r1, r5
 800d04a:	4620      	mov	r0, r4
 800d04c:	f000 f978 	bl	800d340 <prvTCPSendSpecialPktHelper_IPV4>
        }
        #endif /* !ipconfigIGNORE_UNKNOWN_PACKETS */

        /* The packet was not consumed. */
        return xReturn;
    }
 800d050:	bd38      	pop	{r3, r4, r5, pc}
                        xReturn = prvTCPSendSpecialPktHelper_IPV6( pxNetworkBuffer, ucTCPFlags );
 800d052:	4629      	mov	r1, r5
 800d054:	4620      	mov	r0, r4
 800d056:	f000 fb6f 	bl	800d738 <prvTCPSendSpecialPktHelper_IPV6>
        return xReturn;
 800d05a:	e7f9      	b.n	800d050 <prvTCPSendSpecialPacketHelper+0x1e>

0800d05c <prvTCPSendChallengeAck>:
 * @param[in] pxNetworkBuffer The network buffer descriptor with the packet.
 *
 * @return Returns the value back from #prvTCPSendSpecialPacketHelper.
 */
    BaseType_t prvTCPSendChallengeAck( NetworkBufferDescriptor_t * pxNetworkBuffer )
    {
 800d05c:	b508      	push	{r3, lr}
        return prvTCPSendSpecialPacketHelper( pxNetworkBuffer, tcpTCP_FLAG_ACK );
 800d05e:	2110      	movs	r1, #16
 800d060:	f7ff ffe7 	bl	800d032 <prvTCPSendSpecialPacketHelper>
    }
 800d064:	bd08      	pop	{r3, pc}

0800d066 <prvTCPSendReset>:
 * @param[in] pxNetworkBuffer The network buffer descriptor with the packet.
 *
 * @return Returns the value back from #prvTCPSendSpecialPacketHelper.
 */
    BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t * pxNetworkBuffer )
    {
 800d066:	b508      	push	{r3, lr}
        return prvTCPSendSpecialPacketHelper( pxNetworkBuffer,
 800d068:	2114      	movs	r1, #20
 800d06a:	f7ff ffe2 	bl	800d032 <prvTCPSendSpecialPacketHelper>
                                              ( uint8_t ) tcpTCP_FLAG_ACK | ( uint8_t ) tcpTCP_FLAG_RST );
    }
 800d06e:	bd08      	pop	{r3, pc}

0800d070 <prvTCPReturnPacket_IPV4>:
 */
void prvTCPReturnPacket_IPV4( FreeRTOS_Socket_t * pxSocket,
                              NetworkBufferDescriptor_t * pxDescriptor,
                              uint32_t ulLen,
                              BaseType_t xReleaseAfterSend )
{
 800d070:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d074:	b092      	sub	sp, #72	@ 0x48
 800d076:	4680      	mov	r8, r0
 800d078:	4616      	mov	r6, r2
 800d07a:	461f      	mov	r7, r3
    const void * pvCopySource = NULL;
    void * pvCopyDest = NULL;
    const size_t uxIPHeaderSize = ipSIZE_OF_IPv4_HEADER;
    uint32_t ulDestinationIPAddress;
    eARPLookupResult_t eResult;
    NetworkEndPoint_t * pxEndPoint = NULL;
 800d07c:	2300      	movs	r3, #0
 800d07e:	9300      	str	r3, [sp, #0]

    do
    {
        /* For sending, a pseudo network buffer will be used, as explained above. */

        if( pxNetworkBuffer == NULL )
 800d080:	460d      	mov	r5, r1
 800d082:	2900      	cmp	r1, #0
 800d084:	f000 808d 	beq.w	800d1a2 <prvTCPReturnPacket_IPV4+0x132>
            NetworkInterface_t * pxInterface;

            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxIPHeader = ( ( IPHeader_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER ] ) );
 800d088:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxProtocolHeaders = ( ProtocolHeaders_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSize ] );

            if( pxNetworkBuffer->pxEndPoint == NULL )
 800d08a:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d08c:	2b00      	cmp	r3, #0
 800d08e:	f000 8095 	beq.w	800d1bc <prvTCPReturnPacket_IPV4+0x14c>
                    break;
                }
            }

            /* Fill the packet, using hton translations. */
            if( pxSocket != NULL )
 800d092:	f1b8 0f00 	cmp.w	r8, #0
 800d096:	f000 809b 	beq.w	800d1d0 <prvTCPReturnPacket_IPV4+0x160>
            {
                prvTCPReturn_CheckTCPWindow( pxSocket, pxNetworkBuffer, uxIPHeaderSize );
 800d09a:	2214      	movs	r2, #20
 800d09c:	4629      	mov	r1, r5
 800d09e:	4640      	mov	r0, r8
 800d0a0:	f7ff fc82 	bl	800c9a8 <prvTCPReturn_CheckTCPWindow>
                prvTCPReturn_SetSequenceNumber( pxSocket, pxNetworkBuffer, uxIPHeaderSize, ulLen );
 800d0a4:	4633      	mov	r3, r6
 800d0a6:	2214      	movs	r2, #20
 800d0a8:	4629      	mov	r1, r5
 800d0aa:	4640      	mov	r0, r8
 800d0ac:	f7ff fcb8 	bl	800ca20 <prvTCPReturn_SetSequenceNumber>
                pxIPHeader->ulDestinationIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 );
 800d0b0:	f8d8 2054 	ldr.w	r2, [r8, #84]	@ 0x54
 800d0b4:	0213      	lsls	r3, r2, #8
 800d0b6:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800d0ba:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800d0be:	0a11      	lsrs	r1, r2, #8
 800d0c0:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800d0c4:	430b      	orrs	r3, r1
 800d0c6:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800d0ca:	f8c4 301e 	str.w	r3, [r4, #30]
                pxIPHeader->ulSourceIPAddress = pxNetworkBuffer->pxEndPoint->ipv4_settings.ulIPAddress;
 800d0ce:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d0d0:	681b      	ldr	r3, [r3, #0]
 800d0d2:	f8c4 301a 	str.w	r3, [r4, #26]
                 * Just swap the two sequence numbers. */
                vFlip_32( pxProtocolHeaders->xTCPHeader.ulSequenceNumber, pxProtocolHeaders->xTCPHeader.ulAckNr );
                vFlip_32( pxIPHeader->ulDestinationIPAddress, pxIPHeader->ulSourceIPAddress );
            }

            pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 800d0d6:	2380      	movs	r3, #128	@ 0x80
 800d0d8:	75a3      	strb	r3, [r4, #22]
            pxIPHeader->usLength = FreeRTOS_htons( ulLen );
 800d0da:	0233      	lsls	r3, r6, #8
 800d0dc:	b29b      	uxth	r3, r3
 800d0de:	ea43 2316 	orr.w	r3, r3, r6, lsr #8
 800d0e2:	8223      	strh	r3, [r4, #16]

            /* Just an increasing number. */
            pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
 800d0e4:	4950      	ldr	r1, [pc, #320]	@ (800d228 <prvTCPReturnPacket_IPV4+0x1b8>)
 800d0e6:	880b      	ldrh	r3, [r1, #0]
 800d0e8:	021a      	lsls	r2, r3, #8
 800d0ea:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
 800d0ee:	8262      	strh	r2, [r4, #18]
            usPacketIdentifier++;
 800d0f0:	3301      	adds	r3, #1
 800d0f2:	800b      	strh	r3, [r1, #0]
             * The header was never memset to zero, so set both the fragment offset and fragmentation flags in one go.
             */
            #if ( ipconfigFORCE_IP_DONT_FRAGMENT != 0 )
                pxIPHeader->usFragmentOffset = ipFRAGMENT_FLAGS_DONT_FRAGMENT;
            #else
                pxIPHeader->usFragmentOffset = 0U;
 800d0f4:	2000      	movs	r0, #0
 800d0f6:	7520      	strb	r0, [r4, #20]
 800d0f8:	7560      	strb	r0, [r4, #21]
            #endif

            #if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
            {
                /* calculate the IP header checksum, in case the driver won't do that. */
                pxIPHeader->usHeaderChecksum = 0x00U;
 800d0fa:	7620      	strb	r0, [r4, #24]
 800d0fc:	7660      	strb	r0, [r4, #25]
                pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), uxIPHeaderSize );
 800d0fe:	2214      	movs	r2, #20
 800d100:	f104 010e 	add.w	r1, r4, #14
 800d104:	f7fa ff3c 	bl	8007f80 <usGenerateChecksum>
 800d108:	8320      	strh	r0, [r4, #24]
                pxIPHeader->usHeaderChecksum = ( uint16_t ) ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 800d10a:	f3c0 220f 	ubfx	r2, r0, #8, #16
 800d10e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800d112:	b292      	uxth	r2, r2
 800d114:	43d2      	mvns	r2, r2
 800d116:	8322      	strh	r2, [r4, #24]

                /* calculate the TCP checksum for an outgoing packet. */
                ( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxTCPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
 800d118:	2201      	movs	r2, #1
 800d11a:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
 800d11c:	4620      	mov	r0, r4
 800d11e:	f7fb f811 	bl	8008144 <usGenerateProtocolChecksum>
            }
            #endif /* if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 ) */

            vFlip_16( pxProtocolHeaders->xTCPHeader.usSourcePort, pxProtocolHeaders->xTCPHeader.usDestinationPort );
 800d122:	8c63      	ldrh	r3, [r4, #34]	@ 0x22
 800d124:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
 800d126:	8462      	strh	r2, [r4, #34]	@ 0x22
 800d128:	84a3      	strh	r3, [r4, #36]	@ 0x24

            /* Important: tell NIC driver how many bytes must be sent. */
            pxNetworkBuffer->xDataLength = ( size_t ) ulLen;
 800d12a:	62ae      	str	r6, [r5, #40]	@ 0x28
            pxNetworkBuffer->xDataLength += ipSIZE_OF_ETH_HEADER;
 800d12c:	360e      	adds	r6, #14
 800d12e:	62ae      	str	r6, [r5, #40]	@ 0x28
                pxNetworkBuffer->pxNextBuffer = NULL;
            }
            #endif

            pvCopySource = &pxEthernetHeader->xSourceAddress;
            ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;
 800d130:	f8d4 301e 	ldr.w	r3, [r4, #30]
 800d134:	9301      	str	r3, [sp, #4]

            eResult = eARPGetCacheEntry( &ulDestinationIPAddress, &xMACAddress, &pxEndPoint );
 800d136:	466a      	mov	r2, sp
 800d138:	a902      	add	r1, sp, #8
 800d13a:	a801      	add	r0, sp, #4
 800d13c:	f7f8 ffdc 	bl	80060f8 <eARPGetCacheEntry>

            if( eResult == eARPCacheHit )
 800d140:	2801      	cmp	r0, #1
 800d142:	d056      	beq.n	800d1f2 <prvTCPReturnPacket_IPV4+0x182>
                pvCopySource = &xMACAddress;
                pxNetworkBuffer->pxEndPoint = pxEndPoint;
            }
            else
            {
                pvCopySource = &pxEthernetHeader->xSourceAddress;
 800d144:	1da3      	adds	r3, r4, #6
            }

            if( pxNetworkBuffer->pxEndPoint == NULL )
 800d146:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 800d148:	b332      	cbz	r2, 800d198 <prvTCPReturnPacket_IPV4+0x128>
                break;
            }

            /* Fill in the destination MAC addresses. */
            pvCopyDest = &pxEthernetHeader->xDestinationAddress;
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxEthernetHeader->xDestinationAddress ) );
 800d14a:	681a      	ldr	r2, [r3, #0]
 800d14c:	6022      	str	r2, [r4, #0]
 800d14e:	889b      	ldrh	r3, [r3, #4]
 800d150:	80a3      	strh	r3, [r4, #4]
            /*
             * Use helper variables for memcpy() to remain
             * compliant with MISRA Rule 21.15.  These should be
             * optimized away.
             */
            pvCopySource = pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes;
 800d152:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
            pvCopyDest = &pxEthernetHeader->xSourceAddress;
            ( void ) memcpy( pvCopyDest, pvCopySource, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800d154:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 800d158:	f8c4 2006 	str.w	r2, [r4, #6]
 800d15c:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 800d160:	8163      	strh	r3, [r4, #10]
            #endif /* if( ipconfigETHERNET_MINIMUM_PACKET_BYTES > 0 ) */

            /* Send! */
            iptraceNETWORK_INTERFACE_OUTPUT( pxNetworkBuffer->xDataLength, pxNetworkBuffer->pucEthernetBuffer );

            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface != NULL );
 800d162:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d164:	f8d3 0158 	ldr.w	r0, [r3, #344]	@ 0x158
 800d168:	2800      	cmp	r0, #0
 800d16a:	d046      	beq.n	800d1fa <prvTCPReturnPacket_IPV4+0x18a>
            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface->pfOutput != NULL );
 800d16c:	68c3      	ldr	r3, [r0, #12]
 800d16e:	2b00      	cmp	r3, #0
 800d170:	d04c      	beq.n	800d20c <prvTCPReturnPacket_IPV4+0x19c>

            pxInterface = pxNetworkBuffer->pxEndPoint->pxNetworkInterface;
            ( void ) pxInterface->pfOutput( pxInterface, pxNetworkBuffer, xDoRelease );
 800d172:	463a      	mov	r2, r7
 800d174:	4629      	mov	r1, r5
 800d176:	4798      	blx	r3

            if( xDoRelease == pdFALSE )
 800d178:	b987      	cbnz	r7, 800d19c <prvTCPReturnPacket_IPV4+0x12c>
            {
                /* Swap-back some fields, as pxBuffer probably points to a socket field
                 * containing the packet header. */
                vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 800d17a:	8c63      	ldrh	r3, [r4, #34]	@ 0x22
 800d17c:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
 800d17e:	8462      	strh	r2, [r4, #34]	@ 0x22
 800d180:	84a3      	strh	r3, [r4, #36]	@ 0x24

                pxIPHeader->ulSourceIPAddress = pxIPHeader->ulDestinationIPAddress;
 800d182:	f8d4 301e 	ldr.w	r3, [r4, #30]
 800d186:	f8c4 301a 	str.w	r3, [r4, #26]

                ( void ) memcpy( pxEthernetHeader->xSourceAddress.ucBytes, pxEthernetHeader->xDestinationAddress.ucBytes, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800d18a:	4623      	mov	r3, r4
 800d18c:	f853 2b06 	ldr.w	r2, [r3], #6
 800d190:	f8c4 2006 	str.w	r2, [r4, #6]
 800d194:	88a2      	ldrh	r2, [r4, #4]
 800d196:	809a      	strh	r2, [r3, #4]
                /* The buffer has been passed to DMA and will be released after use */
            }
        } /* if( pxNetworkBuffer != NULL ) */
    } while( ipFALSE_BOOL );

    if( xDoRelease == pdTRUE )
 800d198:	2f01      	cmp	r7, #1
 800d19a:	d040      	beq.n	800d21e <prvTCPReturnPacket_IPV4+0x1ae>
    {
        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
    }
}
 800d19c:	b012      	add	sp, #72	@ 0x48
 800d19e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ( void ) memset( &xTempBuffer, 0, sizeof( xTempBuffer ) );
 800d1a2:	2238      	movs	r2, #56	@ 0x38
 800d1a4:	4619      	mov	r1, r3
 800d1a6:	a804      	add	r0, sp, #16
 800d1a8:	f001 fd84 	bl	800ecb4 <memset>
            pxNetworkBuffer->pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800d1ac:	f108 03aa 	add.w	r3, r8, #170	@ 0xaa
 800d1b0:	930d      	str	r3, [sp, #52]	@ 0x34
            pxNetworkBuffer->xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 800d1b2:	235a      	movs	r3, #90	@ 0x5a
 800d1b4:	930e      	str	r3, [sp, #56]	@ 0x38
            pxNetworkBuffer = &xTempBuffer;
 800d1b6:	ad04      	add	r5, sp, #16
            xDoRelease = pdFALSE;
 800d1b8:	2700      	movs	r7, #0
 800d1ba:	e765      	b.n	800d088 <prvTCPReturnPacket_IPV4+0x18>
                prvTCPReturn_SetEndPoint( pxSocket, pxNetworkBuffer, uxIPHeaderSize );
 800d1bc:	2214      	movs	r2, #20
 800d1be:	4629      	mov	r1, r5
 800d1c0:	4640      	mov	r0, r8
 800d1c2:	f7ff fd09 	bl	800cbd8 <prvTCPReturn_SetEndPoint>
                if( pxNetworkBuffer->pxEndPoint == NULL )
 800d1c6:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d1c8:	2b00      	cmp	r3, #0
 800d1ca:	f47f af62 	bne.w	800d092 <prvTCPReturnPacket_IPV4+0x22>
 800d1ce:	e7e3      	b.n	800d198 <prvTCPReturnPacket_IPV4+0x128>
                vFlip_32( pxProtocolHeaders->xTCPHeader.ulSequenceNumber, pxProtocolHeaders->xTCPHeader.ulAckNr );
 800d1d0:	f8d4 3026 	ldr.w	r3, [r4, #38]	@ 0x26
 800d1d4:	f8d4 202a 	ldr.w	r2, [r4, #42]	@ 0x2a
 800d1d8:	f8c4 2026 	str.w	r2, [r4, #38]	@ 0x26
 800d1dc:	f8c4 302a 	str.w	r3, [r4, #42]	@ 0x2a
                vFlip_32( pxIPHeader->ulDestinationIPAddress, pxIPHeader->ulSourceIPAddress );
 800d1e0:	f8d4 301e 	ldr.w	r3, [r4, #30]
 800d1e4:	f8d4 201a 	ldr.w	r2, [r4, #26]
 800d1e8:	f8c4 201e 	str.w	r2, [r4, #30]
 800d1ec:	f8c4 301a 	str.w	r3, [r4, #26]
 800d1f0:	e771      	b.n	800d0d6 <prvTCPReturnPacket_IPV4+0x66>
                pxNetworkBuffer->pxEndPoint = pxEndPoint;
 800d1f2:	9b00      	ldr	r3, [sp, #0]
 800d1f4:	632b      	str	r3, [r5, #48]	@ 0x30
                pvCopySource = &xMACAddress;
 800d1f6:	ab02      	add	r3, sp, #8
 800d1f8:	e7a5      	b.n	800d146 <prvTCPReturnPacket_IPV4+0xd6>
 800d1fa:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d1fe:	f383 8811 	msr	BASEPRI, r3
 800d202:	f3bf 8f6f 	isb	sy
 800d206:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface != NULL );
 800d20a:	e7fe      	b.n	800d20a <prvTCPReturnPacket_IPV4+0x19a>
 800d20c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d210:	f383 8811 	msr	BASEPRI, r3
 800d214:	f3bf 8f6f 	isb	sy
 800d218:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface->pfOutput != NULL );
 800d21c:	e7fe      	b.n	800d21c <prvTCPReturnPacket_IPV4+0x1ac>
        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800d21e:	4628      	mov	r0, r5
 800d220:	f001 fa3e 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
}
 800d224:	e7ba      	b.n	800d19c <prvTCPReturnPacket_IPV4+0x12c>
 800d226:	bf00      	nop
 800d228:	200133ac 	.word	0x200133ac

0800d22c <prvTCPPrepareConnect_IPV4>:
 *       the Ethernet address of the target will be found using ARP. In case the
 *       target IP address is not within the netmask, the hardware address of the
 *       gateway will be used.
 */
BaseType_t prvTCPPrepareConnect_IPV4( FreeRTOS_Socket_t * pxSocket )
{
 800d22c:	b570      	push	{r4, r5, r6, lr}
 800d22e:	b084      	sub	sp, #16
 800d230:	4604      	mov	r4, r0
    uint32_t ulInitialSequenceNumber = 0;

    #if ( ipconfigHAS_PRINTF != 0 )
    {
        /* Only necessary for nicer logging. */
        ( void ) memset( xEthAddress.ucBytes, 0, sizeof( xEthAddress.ucBytes ) );
 800d232:	2300      	movs	r3, #0
 800d234:	9301      	str	r3, [sp, #4]
 800d236:	f8ad 3008 	strh.w	r3, [sp, #8]
    }
    #endif /* ipconfigHAS_PRINTF != 0 */

    ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 );
 800d23a:	6d42      	ldr	r2, [r0, #84]	@ 0x54
 800d23c:	0213      	lsls	r3, r2, #8
 800d23e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800d242:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800d246:	0a11      	lsrs	r1, r2, #8
 800d248:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800d24c:	430b      	orrs	r3, r1
 800d24e:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800d252:	9303      	str	r3, [sp, #12]
    /* Determine the ARP cache status for the requested IP address. */
    eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ), &( pxSocket->pxEndPoint ) );
 800d254:	f100 024c 	add.w	r2, r0, #76	@ 0x4c
 800d258:	a901      	add	r1, sp, #4
 800d25a:	a803      	add	r0, sp, #12
 800d25c:	f7f8 ff4c 	bl	80060f8 <eARPGetCacheEntry>

    switch( eReturned )
 800d260:	2801      	cmp	r0, #1
 800d262:	d00a      	beq.n	800d27a <prvTCPPrepareConnect_IPV4+0x4e>

        case eARPCacheMiss:   /* An ARP table lookup did not find a valid entry. */
        case eCantSendPacket: /* There is no IP address, or an ARP is still in progress. */
        default:
            /* Count the number of times it could not find the ARP address. */
            pxSocket->u.xTCP.ucRepCount++;
 800d264:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
 800d268:	3301      	adds	r3, #1
 800d26a:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
                                     xEthAddress.ucBytes[ 3 ],
                                     xEthAddress.ucBytes[ 4 ],
                                     xEthAddress.ucBytes[ 5 ] ) );

            /* And issue a (new) ARP request */
            FreeRTOS_OutputARPRequest( ulRemoteIP );
 800d26e:	9803      	ldr	r0, [sp, #12]
 800d270:	f7f9 f961 	bl	8006536 <FreeRTOS_OutputARPRequest>
            xReturn = pdFALSE;
 800d274:	2000      	movs	r0, #0
            xReturn = pdFALSE;
        }
    }

    return xReturn;
}
 800d276:	b004      	add	sp, #16
 800d278:	bd70      	pop	{r4, r5, r6, pc}
        ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( pxSocket->xLocalAddress.ulIP_IPv4,
 800d27a:	f8b4 3064 	ldrh.w	r3, [r4, #100]	@ 0x64
 800d27e:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800d280:	8f21      	ldrh	r1, [r4, #56]	@ 0x38
 800d282:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 800d284:	f7f4 f944 	bl	8001510 <ulApplicationGetNextSequenceNumber>
        if( ulInitialSequenceNumber == 0U )
 800d288:	4605      	mov	r5, r0
 800d28a:	b908      	cbnz	r0, 800d290 <prvTCPPrepareConnect_IPV4+0x64>
            xReturn = pdFALSE;
 800d28c:	2000      	movs	r0, #0
 800d28e:	e7f2      	b.n	800d276 <prvTCPPrepareConnect_IPV4+0x4a>
        pxSocket->u.xTCP.ucRepCount = 0U;
 800d290:	2600      	movs	r6, #0
 800d292:	f884 6078 	strb.w	r6, [r4, #120]	@ 0x78
        pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
 800d296:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800d29a:	f043 0308 	orr.w	r3, r3, #8
 800d29e:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69
        ( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800d2a2:	225a      	movs	r2, #90	@ 0x5a
 800d2a4:	4631      	mov	r1, r6
 800d2a6:	f104 00aa 	add.w	r0, r4, #170	@ 0xaa
 800d2aa:	f001 fd03 	bl	800ecb4 <memset>
        ( void ) memcpy( ( void * ) ( &pxTCPPacket->xEthernetHeader.xSourceAddress ), ( const void * ) ( &xEthAddress ), sizeof( xEthAddress ) );
 800d2ae:	9801      	ldr	r0, [sp, #4]
 800d2b0:	f8c4 00b0 	str.w	r0, [r4, #176]	@ 0xb0
 800d2b4:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 800d2b8:	f8a4 30b4 	strh.w	r3, [r4, #180]	@ 0xb4
        pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
 800d2bc:	2308      	movs	r3, #8
 800d2be:	f884 30b6 	strb.w	r3, [r4, #182]	@ 0xb6
 800d2c2:	f884 60b7 	strb.w	r6, [r4, #183]	@ 0xb7
        pxIPHeader->ucVersionHeaderLength = 0x45U;
 800d2c6:	2345      	movs	r3, #69	@ 0x45
 800d2c8:	f884 30b8 	strb.w	r3, [r4, #184]	@ 0xb8
        pxIPHeader->usLength = FreeRTOS_htons( usLength );
 800d2cc:	f884 60ba 	strb.w	r6, [r4, #186]	@ 0xba
 800d2d0:	2338      	movs	r3, #56	@ 0x38
 800d2d2:	f884 30bb 	strb.w	r3, [r4, #187]	@ 0xbb
        pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 800d2d6:	2380      	movs	r3, #128	@ 0x80
 800d2d8:	f884 30c0 	strb.w	r3, [r4, #192]	@ 0xc0
        pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
 800d2dc:	2306      	movs	r3, #6
 800d2de:	f884 30c1 	strb.w	r3, [r4, #193]	@ 0xc1
        pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 );
 800d2e2:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800d2e4:	0213      	lsls	r3, r2, #8
 800d2e6:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800d2ea:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800d2ee:	0a11      	lsrs	r1, r2, #8
 800d2f0:	f401 417f 	and.w	r1, r1, #65280	@ 0xff00
 800d2f4:	430b      	orrs	r3, r1
 800d2f6:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800d2fa:	f8c4 30c4 	str.w	r3, [r4, #196]	@ 0xc4
        pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
 800d2fe:	f8b4 2064 	ldrh.w	r2, [r4, #100]	@ 0x64
 800d302:	0213      	lsls	r3, r2, #8
 800d304:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800d308:	f8a4 30cc 	strh.w	r3, [r4, #204]	@ 0xcc
        pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 800d30c:	8f22      	ldrh	r2, [r4, #56]	@ 0x38
 800d30e:	0213      	lsls	r3, r2, #8
 800d310:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800d314:	f8a4 30ce 	strh.w	r3, [r4, #206]	@ 0xce
        pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0U;
 800d318:	f8c4 6124 	str.w	r6, [r4, #292]	@ 0x124
        pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 800d31c:	f8c4 5140 	str.w	r5, [r4, #320]	@ 0x140
        pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50U;
 800d320:	2350      	movs	r3, #80	@ 0x50
 800d322:	f884 30d8 	strb.w	r3, [r4, #216]	@ 0xd8
        pxTCPPacket->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_SYN;
 800d326:	2302      	movs	r3, #2
 800d328:	f884 30d9 	strb.w	r3, [r4, #217]	@ 0xd9
        prvSocketSetMSS( pxSocket );
 800d32c:	4620      	mov	r0, r4
 800d32e:	f000 fa36 	bl	800d79e <prvSocketSetMSS>
        if( prvTCPCreateWindow( pxSocket ) != pdTRUE )
 800d332:	4620      	mov	r0, r4
 800d334:	f7ff fbcb 	bl	800cace <prvTCPCreateWindow>
 800d338:	2801      	cmp	r0, #1
 800d33a:	d09c      	beq.n	800d276 <prvTCPPrepareConnect_IPV4+0x4a>
            xReturn = pdFALSE;
 800d33c:	2000      	movs	r0, #0
    return xReturn;
 800d33e:	e79a      	b.n	800d276 <prvTCPPrepareConnect_IPV4+0x4a>

0800d340 <prvTCPSendSpecialPktHelper_IPV4>:
 *
 * @return pdFAIL always indicating that the packet was not consumed.
 */
BaseType_t prvTCPSendSpecialPktHelper_IPV4( NetworkBufferDescriptor_t * pxNetworkBuffer,
                                            uint8_t ucTCPFlags )
{
 800d340:	b508      	push	{r3, lr}
        /* Map the ethernet buffer onto the TCPPacket_t struct for easy access to the fields. */

        /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        TCPPacket_t * pxTCPPacket = ( ( TCPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800d342:	6a42      	ldr	r2, [r0, #36]	@ 0x24
        const uint32_t ulSendLength =
            ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER; /* Plus 0 options. */

        uint8_t ucFlagsReceived = pxTCPPacket->xTCPHeader.ucTCPFlags;
 800d344:	f892 302f 	ldrb.w	r3, [r2, #47]	@ 0x2f
        pxTCPPacket->xTCPHeader.ucTCPFlags = ucTCPFlags;
 800d348:	f882 102f 	strb.w	r1, [r2, #47]	@ 0x2f
        pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
 800d34c:	2150      	movs	r1, #80	@ 0x50
 800d34e:	f882 102e 	strb.w	r1, [r2, #46]	@ 0x2e

        if( ( ucFlagsReceived & tcpTCP_FLAG_SYN ) != 0U )
 800d352:	f013 0f02 	tst.w	r3, #2
 800d356:	d01e      	beq.n	800d396 <prvTCPSendSpecialPktHelper_IPV4+0x56>
        {
            /* A synchronize packet is received. It counts as 1 pseudo byte of data,
             * so increase the variable with 1. Before sending a reply, the values of
             * 'ulSequenceNumber' and 'ulAckNr' will be swapped. */
            uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 800d358:	f8d2 1026 	ldr.w	r1, [r2, #38]	@ 0x26
 800d35c:	020b      	lsls	r3, r1, #8
 800d35e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800d362:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800d366:	ea4f 2c11 	mov.w	ip, r1, lsr #8
 800d36a:	f40c 4c7f 	and.w	ip, ip, #65280	@ 0xff00
 800d36e:	ea43 030c 	orr.w	r3, r3, ip
 800d372:	ea43 6311 	orr.w	r3, r3, r1, lsr #24
            ulSequenceNumber++;
 800d376:	3301      	adds	r3, #1
            pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( ulSequenceNumber );
 800d378:	0219      	lsls	r1, r3, #8
 800d37a:	f401 017f 	and.w	r1, r1, #16711680	@ 0xff0000
 800d37e:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 800d382:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 800d386:	f40c 4c7f 	and.w	ip, ip, #65280	@ 0xff00
 800d38a:	ea41 010c 	orr.w	r1, r1, ip
 800d38e:	ea41 6313 	orr.w	r3, r1, r3, lsr #24
 800d392:	f8c2 3026 	str.w	r3, [r2, #38]	@ 0x26
        }

        prvTCPReturnPacket( NULL, pxNetworkBuffer, ulSendLength, pdFALSE );
 800d396:	2300      	movs	r3, #0
 800d398:	2228      	movs	r2, #40	@ 0x28
 800d39a:	4601      	mov	r1, r0
 800d39c:	4618      	mov	r0, r3
 800d39e:	f7ff fadb 	bl	800c958 <prvTCPReturnPacket>
    }
    #endif /* !ipconfigIGNORE_UNKNOWN_PACKETS */

    /* The packet was not consumed. */
    return pdFAIL;
}
 800d3a2:	2000      	movs	r0, #0
 800d3a4:	bd08      	pop	{r3, pc}

0800d3a6 <prvTCPReturnPacket_IPV6>:
 */
void prvTCPReturnPacket_IPV6( FreeRTOS_Socket_t * pxSocket,
                              NetworkBufferDescriptor_t * pxDescriptor,
                              uint32_t ulLen,
                              BaseType_t xReleaseAfterSend )
{
 800d3a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d3aa:	b098      	sub	sp, #96	@ 0x60
 800d3ac:	4606      	mov	r6, r0
 800d3ae:	4617      	mov	r7, r2
 800d3b0:	4698      	mov	r8, r3
    IPv6_Address_t xDestinationIPAddress;

    do
    {
        /* Use do/while to be able to break out of the flow */
        if( ( pxNetworkBuffer == NULL ) && ( pxSocket == NULL ) )
 800d3b2:	460d      	mov	r5, r1
 800d3b4:	2900      	cmp	r1, #0
 800d3b6:	d075      	beq.n	800d4a4 <prvTCPReturnPacket_IPV6+0xfe>
        #endif
        {
            eARPLookupResult_t eResult;
            NetworkInterface_t * pxInterface;

            configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800d3b8:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
 800d3ba:	2c00      	cmp	r4, #0
 800d3bc:	f000 8081 	beq.w	800d4c2 <prvTCPReturnPacket_IPV6+0x11c>
            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxProtocolHeaders = ( ProtocolHeaders_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSize ] );

            if( pxNetworkBuffer->pxEndPoint == NULL )
 800d3c0:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d3c2:	2b00      	cmp	r3, #0
 800d3c4:	f000 8086 	beq.w	800d4d4 <prvTCPReturnPacket_IPV6+0x12e>
                    break;
                }
            }

            /* Fill the packet, swapping from- and to-addresses. */
            if( pxSocket != NULL )
 800d3c8:	2e00      	cmp	r6, #0
 800d3ca:	f000 8093 	beq.w	800d4f4 <prvTCPReturnPacket_IPV6+0x14e>
            {
                prvTCPReturn_CheckTCPWindow( pxSocket, pxNetworkBuffer, uxIPHeaderSize );
 800d3ce:	2228      	movs	r2, #40	@ 0x28
 800d3d0:	4629      	mov	r1, r5
 800d3d2:	4630      	mov	r0, r6
 800d3d4:	f7ff fae8 	bl	800c9a8 <prvTCPReturn_CheckTCPWindow>
                prvTCPReturn_SetSequenceNumber( pxSocket, pxNetworkBuffer, uxIPHeaderSize, ulLen );
 800d3d8:	463b      	mov	r3, r7
 800d3da:	2228      	movs	r2, #40	@ 0x28
 800d3dc:	4629      	mov	r1, r5
 800d3de:	4630      	mov	r0, r6
 800d3e0:	f7ff fb1e 	bl	800ca20 <prvTCPReturn_SetSequenceNumber>
                ( void ) memcpy( pxIPHeader->xDestinationAddress.ucBytes, pxSocket->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d3e4:	6d70      	ldr	r0, [r6, #84]	@ 0x54
 800d3e6:	6db1      	ldr	r1, [r6, #88]	@ 0x58
 800d3e8:	6df2      	ldr	r2, [r6, #92]	@ 0x5c
 800d3ea:	6e33      	ldr	r3, [r6, #96]	@ 0x60
 800d3ec:	f8c4 0026 	str.w	r0, [r4, #38]	@ 0x26
 800d3f0:	f8c4 102a 	str.w	r1, [r4, #42]	@ 0x2a
 800d3f4:	f8c4 202e 	str.w	r2, [r4, #46]	@ 0x2e
 800d3f8:	f8c4 3032 	str.w	r3, [r4, #50]	@ 0x32
                ( void ) memcpy( pxIPHeader->xSourceAddress.ucBytes, pxNetworkBuffer->pxEndPoint->ipv6_settings.xIPAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d3fc:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d3fe:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 800d400:	6bd9      	ldr	r1, [r3, #60]	@ 0x3c
 800d402:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800d404:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d406:	f8c4 0016 	str.w	r0, [r4, #22]
 800d40a:	f8c4 101a 	str.w	r1, [r4, #26]
 800d40e:	f8c4 201e 	str.w	r2, [r4, #30]
 800d412:	f8c4 3022 	str.w	r3, [r4, #34]	@ 0x22
                ( void ) memcpy( pxIPHeader->xDestinationAddress.ucBytes, pxIPHeader->xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
                ( void ) memcpy( pxIPHeader->xSourceAddress.ucBytes, xTempAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
            }

            /* In IPv6, the "payload length" does not include the size of the IP-header */
            pxIPHeader->usPayloadLength = FreeRTOS_htons( ulLen - sizeof( IPHeader_IPv6_t ) );
 800d416:	f1a7 0228 	sub.w	r2, r7, #40	@ 0x28
 800d41a:	b292      	uxth	r2, r2
 800d41c:	0212      	lsls	r2, r2, #8
 800d41e:	b292      	uxth	r2, r2
 800d420:	f1a7 0328 	sub.w	r3, r7, #40	@ 0x28
 800d424:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
 800d428:	8262      	strh	r2, [r4, #18]

            #if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
            {
                /* calculate the TCP checksum for an outgoing packet. */
                uint32_t ulTotalLength = ulLen + ipSIZE_OF_ETH_HEADER;
 800d42a:	f107 060e 	add.w	r6, r7, #14
                ( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxNetworkBuffer->pucEthernetBuffer, ulTotalLength, pdTRUE );
 800d42e:	2201      	movs	r2, #1
 800d430:	4631      	mov	r1, r6
 800d432:	6a68      	ldr	r0, [r5, #36]	@ 0x24
 800d434:	f7fa fe86 	bl	8008144 <usGenerateProtocolChecksum>
            }
            #endif /* ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 */

            vFlip_16( pxProtocolHeaders->xTCPHeader.usSourcePort, pxProtocolHeaders->xTCPHeader.usDestinationPort );
 800d438:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 800d43a:	8f22      	ldrh	r2, [r4, #56]	@ 0x38
 800d43c:	86e2      	strh	r2, [r4, #54]	@ 0x36
 800d43e:	8723      	strh	r3, [r4, #56]	@ 0x38

            /* Important: tell NIC driver how many bytes must be sent. */
            pxNetworkBuffer->xDataLength = ( size_t ) ulLen;
 800d440:	62af      	str	r7, [r5, #40]	@ 0x28
            pxNetworkBuffer->xDataLength += ipSIZE_OF_ETH_HEADER;
 800d442:	62ae      	str	r6, [r5, #40]	@ 0x28
            {
                pxNetworkBuffer->pxNextBuffer = NULL;
            }
            #endif

            ( void ) memcpy( xDestinationIPAddress.ucBytes, pxIPHeader->xDestinationAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d444:	ae04      	add	r6, sp, #16
 800d446:	f8d4 0026 	ldr.w	r0, [r4, #38]	@ 0x26
 800d44a:	f8d4 102a 	ldr.w	r1, [r4, #42]	@ 0x2a
 800d44e:	f8d4 202e 	ldr.w	r2, [r4, #46]	@ 0x2e
 800d452:	f8d4 3032 	ldr.w	r3, [r4, #50]	@ 0x32
 800d456:	c60f      	stmia	r6!, {r0, r1, r2, r3}

            eResult = eNDGetCacheEntry( &xDestinationIPAddress, &xMACAddress, &( pxNetworkBuffer->pxEndPoint ) );
 800d458:	f105 0230 	add.w	r2, r5, #48	@ 0x30
 800d45c:	4631      	mov	r1, r6
 800d45e:	a804      	add	r0, sp, #16
 800d460:	f7fb fcdc 	bl	8008e1c <eNDGetCacheEntry>

            if( eResult == eARPCacheHit )
 800d464:	2801      	cmp	r0, #1
 800d466:	d072      	beq.n	800d54e <prvTCPReturnPacket_IPV6+0x1a8>
            {
                pvCopySource = &xMACAddress;
            }
            else
            {
                pvCopySource = &pxEthernetHeader->xSourceAddress;
 800d468:	1da3      	adds	r3, r4, #6
            }

            /* Fill in the destination MAC addresses. */
            pvCopyDest = &pxEthernetHeader->xDestinationAddress;
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( pxEthernetHeader->xDestinationAddress ) );
 800d46a:	681a      	ldr	r2, [r3, #0]
 800d46c:	6022      	str	r2, [r4, #0]
 800d46e:	889b      	ldrh	r3, [r3, #4]
 800d470:	80a3      	strh	r3, [r4, #4]
            /*
             * Use helper variables for memcpy() to remain
             * compliant with MISRA Rule 21.15.  These should be
             * optimized away.
             */
            pvCopySource = pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes;
 800d472:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
            pvCopyDest = &pxEthernetHeader->xSourceAddress;
            ( void ) memcpy( pvCopyDest, pvCopySource, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800d474:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 800d478:	f8c4 2006 	str.w	r2, [r4, #6]
 800d47c:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 800d480:	8163      	strh	r3, [r4, #10]
            #endif /* if( ipconfigETHERNET_MINIMUM_PACKET_BYTES > 0 ) */

            /* Send! */
            iptraceNETWORK_INTERFACE_OUTPUT( pxNetworkBuffer->xDataLength, pxNetworkBuffer->pucEthernetBuffer );

            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface != NULL );
 800d482:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d484:	f8d3 0158 	ldr.w	r0, [r3, #344]	@ 0x158
 800d488:	2800      	cmp	r0, #0
 800d48a:	d062      	beq.n	800d552 <prvTCPReturnPacket_IPV6+0x1ac>
            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface->pfOutput != NULL );
 800d48c:	68c3      	ldr	r3, [r0, #12]
 800d48e:	2b00      	cmp	r3, #0
 800d490:	d068      	beq.n	800d564 <prvTCPReturnPacket_IPV6+0x1be>

            pxInterface = pxNetworkBuffer->pxEndPoint->pxNetworkInterface;
            ( void ) pxInterface->pfOutput( pxInterface, pxNetworkBuffer, xDoRelease );
 800d492:	4642      	mov	r2, r8
 800d494:	4629      	mov	r1, r5
 800d496:	4798      	blx	r3

            if( xDoRelease == pdFALSE )
 800d498:	f1b8 0f00 	cmp.w	r8, #0
 800d49c:	d06b      	beq.n	800d576 <prvTCPReturnPacket_IPV6+0x1d0>
            {
                /* Nothing to do: the buffer has been passed to DMA and will be released after use */
            }
        } /* if( pxNetworkBuffer != NULL ) */
    } while( ipFALSE_BOOL );
}
 800d49e:	b018      	add	sp, #96	@ 0x60
 800d4a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( pxNetworkBuffer == NULL ) && ( pxSocket == NULL ) )
 800d4a4:	2800      	cmp	r0, #0
 800d4a6:	d0fa      	beq.n	800d49e <prvTCPReturnPacket_IPV6+0xf8>
            ( void ) memset( &xTempBuffer, 0, sizeof( xTempBuffer ) );
 800d4a8:	2238      	movs	r2, #56	@ 0x38
 800d4aa:	a80a      	add	r0, sp, #40	@ 0x28
 800d4ac:	f001 fc02 	bl	800ecb4 <memset>
            pxNetworkBuffer->pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800d4b0:	f106 03aa 	add.w	r3, r6, #170	@ 0xaa
 800d4b4:	9313      	str	r3, [sp, #76]	@ 0x4c
            pxNetworkBuffer->xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 800d4b6:	235a      	movs	r3, #90	@ 0x5a
 800d4b8:	9314      	str	r3, [sp, #80]	@ 0x50
            pxNetworkBuffer = &xTempBuffer;
 800d4ba:	ad0a      	add	r5, sp, #40	@ 0x28
            xDoRelease = pdFALSE;
 800d4bc:	f04f 0800 	mov.w	r8, #0
 800d4c0:	e77a      	b.n	800d3b8 <prvTCPReturnPacket_IPV6+0x12>
 800d4c2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d4c6:	f383 8811 	msr	BASEPRI, r3
 800d4ca:	f3bf 8f6f 	isb	sy
 800d4ce:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800d4d2:	e7fe      	b.n	800d4d2 <prvTCPReturnPacket_IPV6+0x12c>
                prvTCPReturn_SetEndPoint( pxSocket, pxNetworkBuffer, uxIPHeaderSize );
 800d4d4:	2228      	movs	r2, #40	@ 0x28
 800d4d6:	4629      	mov	r1, r5
 800d4d8:	4630      	mov	r0, r6
 800d4da:	f7ff fb7d 	bl	800cbd8 <prvTCPReturn_SetEndPoint>
                if( pxNetworkBuffer->pxEndPoint == NULL )
 800d4de:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 800d4e0:	2b00      	cmp	r3, #0
 800d4e2:	f47f af71 	bne.w	800d3c8 <prvTCPReturnPacket_IPV6+0x22>
                    if( xDoRelease != pdFALSE )
 800d4e6:	f1b8 0f00 	cmp.w	r8, #0
 800d4ea:	d0d8      	beq.n	800d49e <prvTCPReturnPacket_IPV6+0xf8>
                        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800d4ec:	4628      	mov	r0, r5
 800d4ee:	f001 f8d7 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 800d4f2:	e7d4      	b.n	800d49e <prvTCPReturnPacket_IPV6+0xf8>
                vFlip_32( pxProtocolHeaders->xTCPHeader.ulSequenceNumber, pxProtocolHeaders->xTCPHeader.ulAckNr );
 800d4f4:	f8d4 303a 	ldr.w	r3, [r4, #58]	@ 0x3a
 800d4f8:	f8d4 203e 	ldr.w	r2, [r4, #62]	@ 0x3e
 800d4fc:	f8c4 203a 	str.w	r2, [r4, #58]	@ 0x3a
 800d500:	f8c4 303e 	str.w	r3, [r4, #62]	@ 0x3e
                ( void ) memcpy( xTempAddress.ucBytes, pxIPHeader->xDestinationAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d504:	466e      	mov	r6, sp
 800d506:	f8d4 0026 	ldr.w	r0, [r4, #38]	@ 0x26
 800d50a:	f8d4 102a 	ldr.w	r1, [r4, #42]	@ 0x2a
 800d50e:	f8d4 202e 	ldr.w	r2, [r4, #46]	@ 0x2e
 800d512:	f8d4 3032 	ldr.w	r3, [r4, #50]	@ 0x32
 800d516:	c60f      	stmia	r6!, {r0, r1, r2, r3}
                ( void ) memcpy( pxIPHeader->xDestinationAddress.ucBytes, pxIPHeader->xSourceAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d518:	f8d4 0016 	ldr.w	r0, [r4, #22]
 800d51c:	f8d4 101a 	ldr.w	r1, [r4, #26]
 800d520:	f8d4 201e 	ldr.w	r2, [r4, #30]
 800d524:	f8d4 3022 	ldr.w	r3, [r4, #34]	@ 0x22
 800d528:	f8c4 0026 	str.w	r0, [r4, #38]	@ 0x26
 800d52c:	f8c4 102a 	str.w	r1, [r4, #42]	@ 0x2a
 800d530:	f8c4 202e 	str.w	r2, [r4, #46]	@ 0x2e
 800d534:	f8c4 3032 	str.w	r3, [r4, #50]	@ 0x32
                ( void ) memcpy( pxIPHeader->xSourceAddress.ucBytes, xTempAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d538:	466e      	mov	r6, sp
 800d53a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800d53c:	f8c4 0016 	str.w	r0, [r4, #22]
 800d540:	f8c4 101a 	str.w	r1, [r4, #26]
 800d544:	f8c4 201e 	str.w	r2, [r4, #30]
 800d548:	f8c4 3022 	str.w	r3, [r4, #34]	@ 0x22
 800d54c:	e763      	b.n	800d416 <prvTCPReturnPacket_IPV6+0x70>
                pvCopySource = &xMACAddress;
 800d54e:	ab08      	add	r3, sp, #32
 800d550:	e78b      	b.n	800d46a <prvTCPReturnPacket_IPV6+0xc4>
 800d552:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d556:	f383 8811 	msr	BASEPRI, r3
 800d55a:	f3bf 8f6f 	isb	sy
 800d55e:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface != NULL );
 800d562:	e7fe      	b.n	800d562 <prvTCPReturnPacket_IPV6+0x1bc>
 800d564:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d568:	f383 8811 	msr	BASEPRI, r3
 800d56c:	f3bf 8f6f 	isb	sy
 800d570:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNetworkBuffer->pxEndPoint->pxNetworkInterface->pfOutput != NULL );
 800d574:	e7fe      	b.n	800d574 <prvTCPReturnPacket_IPV6+0x1ce>
                vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 800d576:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 800d578:	8f22      	ldrh	r2, [r4, #56]	@ 0x38
 800d57a:	86e2      	strh	r2, [r4, #54]	@ 0x36
 800d57c:	8723      	strh	r3, [r4, #56]	@ 0x38
                ( void ) memcpy( pxIPHeader->xSourceAddress.ucBytes, pxIPHeader->xDestinationAddress.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d57e:	f8d4 0026 	ldr.w	r0, [r4, #38]	@ 0x26
 800d582:	f8d4 102a 	ldr.w	r1, [r4, #42]	@ 0x2a
 800d586:	f8d4 202e 	ldr.w	r2, [r4, #46]	@ 0x2e
 800d58a:	f8d4 3032 	ldr.w	r3, [r4, #50]	@ 0x32
 800d58e:	f8c4 0016 	str.w	r0, [r4, #22]
 800d592:	f8c4 101a 	str.w	r1, [r4, #26]
 800d596:	f8c4 201e 	str.w	r2, [r4, #30]
 800d59a:	f8c4 3022 	str.w	r3, [r4, #34]	@ 0x22
}
 800d59e:	e77e      	b.n	800d49e <prvTCPReturnPacket_IPV6+0xf8>

0800d5a0 <prvTCPPrepareConnect_IPV6>:
 *       the Ethernet address of the target will be found using ARP. In case the
 *       target IP address is not within the netmask, the hardware address of the
 *       gateway will be used.
 */
BaseType_t prvTCPPrepareConnect_IPV6( FreeRTOS_Socket_t * pxSocket )
{
 800d5a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d5a4:	b088      	sub	sp, #32
 800d5a6:	4604      	mov	r4, r0
    IP_Address_t xRemoteIP;
    MACAddress_t xEthAddress;
    BaseType_t xReturn = pdTRUE;
    uint32_t ulInitialSequenceNumber = 0;
    ProtocolHeaders_t * pxProtocolHeaders = NULL;
    NetworkEndPoint_t * pxEndPoint = NULL;
 800d5a8:	2300      	movs	r3, #0
 800d5aa:	9301      	str	r3, [sp, #4]

    #if ( ipconfigHAS_PRINTF != 0 )
    {
        /* Only necessary for nicer logging. */
        ( void ) memset( xEthAddress.ucBytes, 0, sizeof( xEthAddress.ucBytes ) );
 800d5ac:	9302      	str	r3, [sp, #8]
 800d5ae:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    #endif /* ipconfigHAS_PRINTF != 0 */

    ( void ) memset( xRemoteIP.xIP_IPv6.ucBytes, 0, ipSIZE_OF_IPv6_ADDRESS );
 800d5b2:	9304      	str	r3, [sp, #16]
 800d5b4:	9305      	str	r3, [sp, #20]
 800d5b6:	9306      	str	r3, [sp, #24]
 800d5b8:	9307      	str	r3, [sp, #28]
    ( void ) memcpy( xRemoteIP.xIP_IPv6.ucBytes, pxSocket->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, ipSIZE_OF_IPv6_ADDRESS );
 800d5ba:	f10d 0c10 	add.w	ip, sp, #16
 800d5be:	6d40      	ldr	r0, [r0, #84]	@ 0x54
 800d5c0:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 800d5c2:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 800d5c4:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 800d5c6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    eReturned = eNDGetCacheEntry( &( xRemoteIP.xIP_IPv6 ), &( xEthAddress ), &( pxEndPoint ) );
 800d5ca:	aa01      	add	r2, sp, #4
 800d5cc:	a902      	add	r1, sp, #8
 800d5ce:	a804      	add	r0, sp, #16
 800d5d0:	f7fb fc24 	bl	8008e1c <eNDGetCacheEntry>
 800d5d4:	4606      	mov	r6, r0
    FreeRTOS_printf( ( "eNDGetCacheEntry: %d with end-point %p\n", eReturned, ( void * ) pxEndPoint ) );

    if( pxEndPoint != NULL )
 800d5d6:	9b01      	ldr	r3, [sp, #4]
 800d5d8:	b103      	cbz	r3, 800d5dc <prvTCPPrepareConnect_IPV6+0x3c>
    {
        pxSocket->pxEndPoint = pxEndPoint;
 800d5da:	64e3      	str	r3, [r4, #76]	@ 0x4c

    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    pxProtocolHeaders = ( ( ProtocolHeaders_t * )
                          &( pxSocket->u.xTCP.xPacket.u.ucLastPacket[ ipSIZE_OF_ETH_HEADER + uxIPHeaderSizeSocket( pxSocket ) ] ) );
 800d5dc:	4620      	mov	r0, r4
 800d5de:	f7fa f963 	bl	80078a8 <uxIPHeaderSizeSocket>
    pxProtocolHeaders = ( ( ProtocolHeaders_t * )
 800d5e2:	f100 05ae 	add.w	r5, r0, #174	@ 0xae
 800d5e6:	4425      	add	r5, r4
 800d5e8:	f105 070a 	add.w	r7, r5, #10

    switch( eReturned )
 800d5ec:	2e01      	cmp	r6, #1
 800d5ee:	d017      	beq.n	800d620 <prvTCPPrepareConnect_IPV6+0x80>

        case eARPCacheMiss:   /* An ARP table lookup did not find a valid entry. */
        case eCantSendPacket: /* There is no IP address, or an ARP is still in progress. */
        default:
            /* Count the number of times it could not find the ARP address. */
            pxSocket->u.xTCP.ucRepCount++;
 800d5f0:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
 800d5f4:	3301      	adds	r3, #1
 800d5f6:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78

            FreeRTOS_printf( ( "Looking up %pip with%s end-point\n", ( void * ) xRemoteIP.xIP_IPv6.ucBytes, ( pxEndPoint != NULL ) ? "" : "out" ) );

            if( pxEndPoint != NULL )
 800d5fa:	9b01      	ldr	r3, [sp, #4]
 800d5fc:	2b00      	cmp	r3, #0
 800d5fe:	d06e      	beq.n	800d6de <prvTCPPrepareConnect_IPV6+0x13e>
            {
                size_t uxNeededSize;
                NetworkBufferDescriptor_t * pxNetworkBuffer;

                uxNeededSize = ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER + sizeof( ICMPHeader_IPv6_t );
                pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( uxNeededSize, 0U );
 800d600:	2100      	movs	r1, #0
 800d602:	2056      	movs	r0, #86	@ 0x56
 800d604:	f001 f872 	bl	800e6ec <pxGetNetworkBufferWithDescriptor>

                if( pxNetworkBuffer != NULL )
 800d608:	2800      	cmp	r0, #0
 800d60a:	f000 808c 	beq.w	800d726 <prvTCPPrepareConnect_IPV6+0x186>
                {
                    pxNetworkBuffer->pxEndPoint = pxEndPoint;
 800d60e:	9a01      	ldr	r2, [sp, #4]
 800d610:	6302      	str	r2, [r0, #48]	@ 0x30
                    vNDSendNeighbourSolicitation( pxNetworkBuffer, &( xRemoteIP.xIP_IPv6 ) );
 800d612:	a904      	add	r1, sp, #16
 800d614:	f7fb fcae 	bl	8008f74 <vNDSendNeighbourSolicitation>
    uint32_t ulInitialSequenceNumber = 0;
 800d618:	f04f 0800 	mov.w	r8, #0
                }
            }

            xReturn = pdFALSE;
 800d61c:	4646      	mov	r6, r8
 800d61e:	e061      	b.n	800d6e4 <prvTCPPrepareConnect_IPV6+0x144>
    }

    if( xReturn != pdFALSE )
    {
        /* Get a difficult-to-predict initial sequence number for this 4-tuple. */
        ulInitialSequenceNumber = ulApplicationGetNextSequenceNumber( pxSocket->xLocalAddress.ulIP_IPv4,
 800d620:	f8b4 3064 	ldrh.w	r3, [r4, #100]	@ 0x64
 800d624:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800d626:	8f21      	ldrh	r1, [r4, #56]	@ 0x38
 800d628:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 800d62a:	f7f3 ff71 	bl	8001510 <ulApplicationGetNextSequenceNumber>
                                                                      pxSocket->usLocalPort,
                                                                      pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4,
                                                                      pxSocket->u.xTCP.usRemotePort );

        /* Check for a random number generation error. */
        if( ulInitialSequenceNumber == 0U )
 800d62e:	4680      	mov	r8, r0
 800d630:	b908      	cbnz	r0, 800d636 <prvTCPPrepareConnect_IPV6+0x96>
        {
            xReturn = pdFALSE;
 800d632:	2600      	movs	r6, #0
 800d634:	e056      	b.n	800d6e4 <prvTCPPrepareConnect_IPV6+0x144>
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxTCPPacket = ( ( TCPPacket_IPv6_t * ) pxSocket->u.xTCP.xPacket.u.ucLastPacket );
        pxIPHeader = &( pxTCPPacket->xIPHeader );

        /* reset the retry counter to zero. */
        pxSocket->u.xTCP.ucRepCount = 0U;
 800d636:	2100      	movs	r1, #0
 800d638:	f884 1078 	strb.w	r1, [r4, #120]	@ 0x78

        /* And remember that the connect/SYN data are prepared. */
        pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
 800d63c:	f894 3069 	ldrb.w	r3, [r4, #105]	@ 0x69
 800d640:	f043 0308 	orr.w	r3, r3, #8
 800d644:	f884 3069 	strb.w	r3, [r4, #105]	@ 0x69

        /* Now that the Ethernet address is known, the initial packet can be
         * prepared. */
        ( void ) memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, 0, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800d648:	225a      	movs	r2, #90	@ 0x5a
 800d64a:	f104 00aa 	add.w	r0, r4, #170	@ 0xaa
 800d64e:	f001 fb31 	bl	800ecb4 <memset>

        /* Write the Ethernet address in Source, because it will be swapped by
         * prvTCPReturnPacket(). */
        ( void ) memcpy( ( void * ) ( &( pxTCPPacket->xEthernetHeader.xSourceAddress ) ), ( const void * ) ( &xEthAddress ), sizeof( xEthAddress ) );
 800d652:	9802      	ldr	r0, [sp, #8]
 800d654:	f8c4 00b0 	str.w	r0, [r4, #176]	@ 0xb0
 800d658:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 800d65c:	f8a4 30b4 	strh.w	r3, [r4, #180]	@ 0xb4

        if( pxSocket->bits.bIsIPv6 != pdFALSE_UNSIGNED )
 800d660:	7a23      	ldrb	r3, [r4, #8]
 800d662:	f013 0f01 	tst.w	r3, #1
 800d666:	d101      	bne.n	800d66c <prvTCPPrepareConnect_IPV6+0xcc>
 800d668:	2601      	movs	r6, #1
 800d66a:	e03b      	b.n	800d6e4 <prvTCPPrepareConnect_IPV6+0x144>
        {
            /* 'ipIPv4_FRAME_TYPE' is already in network-byte-order. */
            pxTCPPacket->xEthernetHeader.usFrameType = ipIPv6_FRAME_TYPE;
 800d66c:	2300      	movs	r3, #0
 800d66e:	f06f 0279 	mvn.w	r2, #121	@ 0x79
 800d672:	f884 20b6 	strb.w	r2, [r4, #182]	@ 0xb6
 800d676:	f06f 0222 	mvn.w	r2, #34	@ 0x22
 800d67a:	f884 20b7 	strb.w	r2, [r4, #183]	@ 0xb7

            pxIPHeader->ucVersionTrafficClass = ( uint8_t ) 0x60U;
 800d67e:	2260      	movs	r2, #96	@ 0x60
 800d680:	f884 20b8 	strb.w	r2, [r4, #184]	@ 0xb8
            pxIPHeader->ucTrafficClassFlow = ( uint8_t ) 0x00;
 800d684:	f884 30b9 	strb.w	r3, [r4, #185]	@ 0xb9
            pxIPHeader->usFlowLabel = ( uint16_t ) 0x0000U;
 800d688:	f884 30ba 	strb.w	r3, [r4, #186]	@ 0xba
 800d68c:	f884 30bb 	strb.w	r3, [r4, #187]	@ 0xbb
            pxIPHeader->usPayloadLength = FreeRTOS_htons( sizeof( TCPHeader_t ) );
 800d690:	f884 30bc 	strb.w	r3, [r4, #188]	@ 0xbc
 800d694:	2324      	movs	r3, #36	@ 0x24
 800d696:	f884 30bd 	strb.w	r3, [r4, #189]	@ 0xbd
            pxIPHeader->ucNextHeader = ( uint8_t ) ipPROTOCOL_TCP;
 800d69a:	2306      	movs	r3, #6
 800d69c:	f884 30be 	strb.w	r3, [r4, #190]	@ 0xbe
            pxIPHeader->ucHopLimit = 128;
 800d6a0:	2380      	movs	r3, #128	@ 0x80
 800d6a2:	f884 30bf 	strb.w	r3, [r4, #191]	@ 0xbf
            /* The Source and Destination addresses will be swapped later. */
            ( void ) memcpy( pxIPHeader->xSourceAddress.ucBytes, pxSocket->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, sizeof( pxIPHeader->xSourceAddress.ucBytes ) );
 800d6a6:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 800d6a8:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 800d6aa:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 800d6ac:	6e23      	ldr	r3, [r4, #96]	@ 0x60
 800d6ae:	f8c4 00c0 	str.w	r0, [r4, #192]	@ 0xc0
 800d6b2:	f8c4 10c4 	str.w	r1, [r4, #196]	@ 0xc4
 800d6b6:	f8c4 20c8 	str.w	r2, [r4, #200]	@ 0xc8
 800d6ba:	f8c4 30cc 	str.w	r3, [r4, #204]	@ 0xcc
            ( void ) memcpy( pxIPHeader->xDestinationAddress.ucBytes, pxSocket->xLocalAddress.xIP_IPv6.ucBytes, sizeof( pxIPHeader->xDestinationAddress.ucBytes ) );
 800d6be:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 800d6c0:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800d6c2:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 800d6c4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800d6c6:	f8c4 00d0 	str.w	r0, [r4, #208]	@ 0xd0
 800d6ca:	f8c4 10d4 	str.w	r1, [r4, #212]	@ 0xd4
 800d6ce:	f8c4 20d8 	str.w	r2, [r4, #216]	@ 0xd8
 800d6d2:	f8c4 30dc 	str.w	r3, [r4, #220]	@ 0xdc
            pxEndPoint = pxSocket->pxEndPoint;
 800d6d6:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 800d6d8:	9301      	str	r3, [sp, #4]
 800d6da:	2601      	movs	r6, #1
 800d6dc:	e002      	b.n	800d6e4 <prvTCPPrepareConnect_IPV6+0x144>
    uint32_t ulInitialSequenceNumber = 0;
 800d6de:	f04f 0800 	mov.w	r8, #0
            xReturn = pdFALSE;
 800d6e2:	4646      	mov	r6, r8
        }
    }

    if( pxEndPoint != NULL )
 800d6e4:	9b01      	ldr	r3, [sp, #4]
 800d6e6:	b313      	cbz	r3, 800d72e <prvTCPPrepareConnect_IPV6+0x18e>
    {
        pxSocket->pxEndPoint = pxEndPoint;
 800d6e8:	64e3      	str	r3, [r4, #76]	@ 0x4c

        pxProtocolHeaders->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
 800d6ea:	f8b4 2064 	ldrh.w	r2, [r4, #100]	@ 0x64
 800d6ee:	0213      	lsls	r3, r2, #8
 800d6f0:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800d6f4:	816b      	strh	r3, [r5, #10]
        pxProtocolHeaders->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 800d6f6:	8f22      	ldrh	r2, [r4, #56]	@ 0x38
 800d6f8:	0213      	lsls	r3, r2, #8
 800d6fa:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800d6fe:	807b      	strh	r3, [r7, #2]

        /* We are actively connecting, so the peer's Initial Sequence Number (ISN)
         * isn't known yet. */
        pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0U;
 800d700:	2300      	movs	r3, #0
 800d702:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124

        /* Start with ISN (Initial Sequence Number). */
        pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulInitialSequenceNumber;
 800d706:	f8c4 8140 	str.w	r8, [r4, #320]	@ 0x140

        /* The TCP header size is 20 bytes, divided by 4 equals 5, which is put in
         * the high nibble of the TCP offset field. */
        pxProtocolHeaders->xTCPHeader.ucTCPOffset = 0x50U;
 800d70a:	2350      	movs	r3, #80	@ 0x50
 800d70c:	733b      	strb	r3, [r7, #12]

        /* Only set the SYN flag. */
        pxProtocolHeaders->xTCPHeader.ucTCPFlags = tcpTCP_FLAG_SYN;
 800d70e:	2302      	movs	r3, #2
 800d710:	737b      	strb	r3, [r7, #13]

        /* Set the value of usMSS for this socket. */
        prvSocketSetMSS( pxSocket );
 800d712:	4620      	mov	r0, r4
 800d714:	f000 f843 	bl	800d79e <prvSocketSetMSS>

        /* The initial sequence numbers at our side are known.  Later
         * vTCPWindowInit() will be called to fill in the peer's sequence numbers, but
         * first wait for a SYN+ACK reply. */
        if( prvTCPCreateWindow( pxSocket ) != pdTRUE )
 800d718:	4620      	mov	r0, r4
 800d71a:	f7ff f9d8 	bl	800cace <prvTCPCreateWindow>
 800d71e:	2801      	cmp	r0, #1
 800d720:	d006      	beq.n	800d730 <prvTCPPrepareConnect_IPV6+0x190>
        {
            xReturn = pdFAIL;
 800d722:	2600      	movs	r6, #0
    {
        FreeRTOS_printf( ( "prvTCPPrepareConnect: No pxEndPoint yet?\n" ) );
        xReturn = pdFAIL;
    }

    return xReturn;
 800d724:	e004      	b.n	800d730 <prvTCPPrepareConnect_IPV6+0x190>
    uint32_t ulInitialSequenceNumber = 0;
 800d726:	f04f 0800 	mov.w	r8, #0
            xReturn = pdFALSE;
 800d72a:	4646      	mov	r6, r8
 800d72c:	e7da      	b.n	800d6e4 <prvTCPPrepareConnect_IPV6+0x144>
        xReturn = pdFAIL;
 800d72e:	2600      	movs	r6, #0
}
 800d730:	4630      	mov	r0, r6
 800d732:	b008      	add	sp, #32
 800d734:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d738 <prvTCPSendSpecialPktHelper_IPV6>:
 *
 * @return pdFAIL always indicating that the packet was not consumed.
 */
BaseType_t prvTCPSendSpecialPktHelper_IPV6( NetworkBufferDescriptor_t * pxNetworkBuffer,
                                            uint8_t ucTCPFlags )
{
 800d738:	b508      	push	{r3, lr}
        /* Map the ethernet buffer onto the TCPPacket_t struct for easy access to the fields. */

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        TCPPacket_IPv6_t * pxTCPPacket = ( ( TCPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800d73a:	6a42      	ldr	r2, [r0, #36]	@ 0x24
        const uint32_t ulSendLength =
            ipSIZE_OF_IPv6_HEADER + ipSIZE_OF_TCP_HEADER; /* Plus 0 options. */

        uint8_t ucFlagsReceived = pxTCPPacket->xTCPHeader.ucTCPFlags;
 800d73c:	f892 3043 	ldrb.w	r3, [r2, #67]	@ 0x43
        pxTCPPacket->xTCPHeader.ucTCPFlags = ucTCPFlags;
 800d740:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
        pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER ) << 2;
 800d744:	2150      	movs	r1, #80	@ 0x50
 800d746:	f882 1042 	strb.w	r1, [r2, #66]	@ 0x42

        if( ( ucFlagsReceived & tcpTCP_FLAG_SYN ) != 0U )
 800d74a:	f013 0f02 	tst.w	r3, #2
 800d74e:	d01e      	beq.n	800d78e <prvTCPSendSpecialPktHelper_IPV6+0x56>
        {
            /* A synchronize packet is received. It counts as 1 pseudo byte of data,
             * so increase the variable with 1. Before sending a reply, the values of
             * 'ulSequenceNumber' and 'ulAckNr' will be swapped. */
            uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 800d750:	f8d2 103a 	ldr.w	r1, [r2, #58]	@ 0x3a
 800d754:	020b      	lsls	r3, r1, #8
 800d756:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800d75a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800d75e:	ea4f 2c11 	mov.w	ip, r1, lsr #8
 800d762:	f40c 4c7f 	and.w	ip, ip, #65280	@ 0xff00
 800d766:	ea43 030c 	orr.w	r3, r3, ip
 800d76a:	ea43 6311 	orr.w	r3, r3, r1, lsr #24
            ulSequenceNumber++;
 800d76e:	3301      	adds	r3, #1
            pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( ulSequenceNumber );
 800d770:	0219      	lsls	r1, r3, #8
 800d772:	f401 017f 	and.w	r1, r1, #16711680	@ 0xff0000
 800d776:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 800d77a:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 800d77e:	f40c 4c7f 	and.w	ip, ip, #65280	@ 0xff00
 800d782:	ea41 010c 	orr.w	r1, r1, ip
 800d786:	ea41 6313 	orr.w	r3, r1, r3, lsr #24
 800d78a:	f8c2 303a 	str.w	r3, [r2, #58]	@ 0x3a
        }

        prvTCPReturnPacket( NULL, pxNetworkBuffer, ulSendLength, pdFALSE );
 800d78e:	2300      	movs	r3, #0
 800d790:	223c      	movs	r2, #60	@ 0x3c
 800d792:	4601      	mov	r1, r0
 800d794:	4618      	mov	r0, r3
 800d796:	f7ff f8df 	bl	800c958 <prvTCPReturnPacket>
    }
    #endif /* !ipconfigIGNORE_UNKNOWN_PACKETS */

    /* The packet was not consumed. */
    return pdFAIL;
}
 800d79a:	2000      	movs	r0, #0
 800d79c:	bd08      	pop	{r3, pc}

0800d79e <prvSocketSetMSS>:
 * @brief Set the MSS (Maximum segment size) associated with the given socket.
 *
 * @param[in] pxSocket The socket whose MSS is to be set.
 */
    void prvSocketSetMSS( FreeRTOS_Socket_t * pxSocket )
    {
 800d79e:	b508      	push	{r3, lr}
        switch( pxSocket->bits.bIsIPv6 ) /* LCOV_EXCL_BR_LINE */
 800d7a0:	7a03      	ldrb	r3, [r0, #8]
 800d7a2:	f013 0301 	ands.w	r3, r3, #1
 800d7a6:	d003      	beq.n	800d7b0 <prvSocketSetMSS+0x12>
 800d7a8:	b123      	cbz	r3, 800d7b4 <prvSocketSetMSS+0x16>
                    break;
            #endif /* ( ipconfigUSE_IPv4 != 0 ) */

            #if ( ipconfigUSE_IPv6 != 0 )
                case pdTRUE_UNSIGNED:
                    prvSocketSetMSS_IPV6( pxSocket );
 800d7aa:	f000 f828 	bl	800d7fe <prvSocketSetMSS_IPV6>
            default: /* LCOV_EXCL_LINE */
                /* Shouldn't reach here */
                /* MISRA 16.4 Compliance */
                break; /* LCOV_EXCL_LINE */
        }
    }
 800d7ae:	e001      	b.n	800d7b4 <prvSocketSetMSS+0x16>
                    prvSocketSetMSS_IPV4( pxSocket );
 800d7b0:	f000 f801 	bl	800d7b6 <prvSocketSetMSS_IPV4>
    }
 800d7b4:	bd08      	pop	{r3, pc}

0800d7b6 <prvSocketSetMSS_IPV4>:
 * @brief Set the MSS (Maximum segment size) associated with the given socket.
 *
 * @param[in] pxSocket The socket whose MSS is to be set.
 */
void prvSocketSetMSS_IPV4( FreeRTOS_Socket_t * pxSocket )
{
 800d7b6:	b510      	push	{r4, lr}
 800d7b8:	4604      	mov	r4, r0
    uint32_t ulMSS = ipconfigTCP_MSS;
    const NetworkEndPoint_t * pxEndPoint = pxSocket->pxEndPoint;
 800d7ba:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c

    if( pxEndPoint != NULL )
 800d7bc:	b1e1      	cbz	r1, 800d7f8 <prvSocketSetMSS_IPV4+0x42>
            ulMSS = tcpMINIMUM_SEGMENT_LENGTH;
        }
        #endif

        /* Check if the remote IP-address belongs to the same netmask. */
        if( ( ( FreeRTOS_ntohl( pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4 ) ^ pxEndPoint->ipv4_settings.ulIPAddress ) & pxEndPoint->ipv4_settings.ulNetMask ) != 0U )
 800d7be:	6d42      	ldr	r2, [r0, #84]	@ 0x54
 800d7c0:	0213      	lsls	r3, r2, #8
 800d7c2:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800d7c6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800d7ca:	0a10      	lsrs	r0, r2, #8
 800d7cc:	f400 407f 	and.w	r0, r0, #65280	@ 0xff00
 800d7d0:	4303      	orrs	r3, r0
 800d7d2:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800d7d6:	680a      	ldr	r2, [r1, #0]
 800d7d8:	4053      	eors	r3, r2
 800d7da:	684a      	ldr	r2, [r1, #4]
 800d7dc:	4213      	tst	r3, r2
 800d7de:	d104      	bne.n	800d7ea <prvSocketSetMSS_IPV4+0x34>
            ulMSS = ipconfigTCP_MSS;
 800d7e0:	f240 50b4 	movw	r0, #1460	@ 0x5b4
        }
    }

    FreeRTOS_debug_printf( ( "prvSocketSetMSS: %u bytes for %xip port %u\n", ( unsigned ) ulMSS, ( unsigned ) pxSocket->u.xTCP.xRemoteIP.ulIP_IPv4, pxSocket->u.xTCP.usRemotePort ) );

    pxSocket->u.xTCP.usMSS = ( uint16_t ) ulMSS;
 800d7e4:	f8a4 0072 	strh.w	r0, [r4, #114]	@ 0x72
}
 800d7e8:	bd10      	pop	{r4, pc}
            ulMSS = FreeRTOS_min_uint32( ( uint32_t ) tcpREDUCED_MSS_THROUGH_INTERNET, ulMSS );
 800d7ea:	f240 51b4 	movw	r1, #1460	@ 0x5b4
 800d7ee:	f44f 60af 	mov.w	r0, #1400	@ 0x578
 800d7f2:	f7fa fd1b 	bl	800822c <FreeRTOS_min_uint32>
 800d7f6:	e7f5      	b.n	800d7e4 <prvSocketSetMSS_IPV4+0x2e>
    uint32_t ulMSS = ipconfigTCP_MSS;
 800d7f8:	f240 50b4 	movw	r0, #1460	@ 0x5b4
 800d7fc:	e7f2      	b.n	800d7e4 <prvSocketSetMSS_IPV4+0x2e>

0800d7fe <prvSocketSetMSS_IPV6>:

    const NetworkEndPoint_t * pxEndPoint = NULL;

    do
    {
        if( pxSocket == NULL )
 800d7fe:	b300      	cbz	r0, 800d842 <prvSocketSetMSS_IPV6+0x44>
{
 800d800:	b530      	push	{r4, r5, lr}
 800d802:	b08b      	sub	sp, #44	@ 0x2c
 800d804:	4604      	mov	r4, r0
            FreeRTOS_debug_printf( ( "prvSocketSetMSS_IPV6: NULL socket handler\n" ) );

            break;
        }

        pxEndPoint = pxSocket->pxEndPoint;
 800d806:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c

        if( pxEndPoint != NULL )
 800d808:	b173      	cbz	r3, 800d828 <prvSocketSetMSS_IPV6+0x2a>
            size_t uxDifference = ipSIZE_OF_IPv6_HEADER - ipSIZE_OF_IPv4_HEADER;

            /* Because ipconfigTCP_MSS is guaranteed not less than tcpMINIMUM_SEGMENT_LENGTH by FreeRTOSIPConfigDefaults.h,
             * it's unnecessary to check if xSocket->u.xTCP.usMSS is greater than difference. */
            ulMSS = ( uint32_t ) ( ipconfigTCP_MSS - uxDifference );
            eType = xIPv6_GetIPType( &( pxSocket->u.xTCP.xRemoteIP.xIP_IPv6 ) );
 800d80a:	3054      	adds	r0, #84	@ 0x54
 800d80c:	f7fc f9fc 	bl	8009c08 <xIPv6_GetIPType>

            if( eType == eIPv6_Global )
 800d810:	b110      	cbz	r0, 800d818 <prvSocketSetMSS_IPV6+0x1a>
            ulMSS = ( uint32_t ) ( ipconfigTCP_MSS - uxDifference );
 800d812:	f44f 65b4 	mov.w	r5, #1440	@ 0x5a0
 800d816:	e009      	b.n	800d82c <prvSocketSetMSS_IPV6+0x2e>
            {
                /* The packet will travel through Internet, make the MSS
                 * smaller. */
                ulMSS = FreeRTOS_min_uint32( ( uint32_t ) tcpREDUCED_MSS_THROUGH_INTERNET, ulMSS );
 800d818:	f44f 61b4 	mov.w	r1, #1440	@ 0x5a0
 800d81c:	f44f 60af 	mov.w	r0, #1400	@ 0x578
 800d820:	f7fa fd04 	bl	800822c <FreeRTOS_min_uint32>
 800d824:	4605      	mov	r5, r0
 800d826:	e001      	b.n	800d82c <prvSocketSetMSS_IPV6+0x2e>
    uint32_t ulMSS = ipconfigTCP_MSS;
 800d828:	f240 55b4 	movw	r5, #1460	@ 0x5b4
            }
        }

        #if ( ipconfigHAS_DEBUG_PRINTF == 1 )
        {
            ( void ) FreeRTOS_inet_ntop( FREERTOS_AF_INET6, ( const void * ) pxSocket->u.xTCP.xRemoteIP.xIP_IPv6.ucBytes, cIPv6Address, sizeof( cIPv6Address ) );
 800d82c:	2328      	movs	r3, #40	@ 0x28
 800d82e:	466a      	mov	r2, sp
 800d830:	f104 0154 	add.w	r1, r4, #84	@ 0x54
 800d834:	200a      	movs	r0, #10
 800d836:	f7fc ffaf 	bl	800a798 <FreeRTOS_inet_ntop>
            FreeRTOS_debug_printf( ( "prvSocketSetMSS: %u bytes for %s ip port %u\n", ( unsigned ) ulMSS, cIPv6Address, pxSocket->u.xTCP.usRemotePort ) );
        }
        #endif

        pxSocket->u.xTCP.usMSS = ( uint16_t ) ulMSS;
 800d83a:	f8a4 5072 	strh.w	r5, [r4, #114]	@ 0x72
    } while( ipFALSE_BOOL );
}
 800d83e:	b00b      	add	sp, #44	@ 0x2c
 800d840:	bd30      	pop	{r4, r5, pc}
 800d842:	4770      	bx	lr

0800d844 <vListInsertGeneric>:
             * returned by listGET_HEAD_ENTRY() */

            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxNewListItem->pxNext = ( ( ListItem_t * ) pxWhere );
 800d844:	604a      	str	r2, [r1, #4]

            pxNewListItem->pxPrevious = pxWhere->pxPrevious;
 800d846:	6893      	ldr	r3, [r2, #8]
 800d848:	608b      	str	r3, [r1, #8]
            pxWhere->pxPrevious->pxNext = pxNewListItem;
 800d84a:	6059      	str	r1, [r3, #4]
            pxWhere->pxPrevious = pxNewListItem;
 800d84c:	6091      	str	r1, [r2, #8]

            /* Remember which list the item is in. */
            listLIST_ITEM_CONTAINER( pxNewListItem ) = ( struct xLIST * configLIST_VOLATILE ) pxList;
 800d84e:	6108      	str	r0, [r1, #16]

            ( pxList->uxNumberOfItems )++;
 800d850:	6803      	ldr	r3, [r0, #0]
 800d852:	3301      	adds	r3, #1
 800d854:	6003      	str	r3, [r0, #0]
        }
 800d856:	4770      	bx	lr

0800d858 <xTCPWindowRxFind>:
             * segments. */

            /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxEnd = ( ( const ListItem_t * ) &( pxWindow->xRxSegments.xListEnd ) );
 800d858:	f100 0cac 	add.w	ip, r0, #172	@ 0xac

            for( pxIterator = listGET_NEXT( pxEnd );
 800d85c:	f8d0 30b0 	ldr.w	r3, [r0, #176]	@ 0xb0
 800d860:	e000      	b.n	800d864 <xTCPWindowRxFind+0xc>
                 pxIterator != pxEnd;
                 pxIterator = listGET_NEXT( pxIterator ) )
 800d862:	685b      	ldr	r3, [r3, #4]
                 pxIterator != pxEnd;
 800d864:	4563      	cmp	r3, ip
 800d866:	d004      	beq.n	800d872 <xTCPWindowRxFind+0x1a>
            {
                pxSegment = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800d868:	68d8      	ldr	r0, [r3, #12]

                if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 800d86a:	6802      	ldr	r2, [r0, #0]
 800d86c:	428a      	cmp	r2, r1
 800d86e:	d1f8      	bne.n	800d862 <xTCPWindowRxFind+0xa>
 800d870:	e000      	b.n	800d874 <xTCPWindowRxFind+0x1c>
            TCPSegment_t * pxSegment, * pxReturn = NULL;
 800d872:	2000      	movs	r0, #0
                    break;
                }
            }

            return pxReturn;
        }
 800d874:	4770      	bx	lr

0800d876 <xTCPWindowPeekHead>:
        {
            const ListItem_t * pxItem;
            TCPSegment_t * pxReturn;

            /* Returns the head of a queue but it won't be detached. */
            if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 800d876:	6803      	ldr	r3, [r0, #0]
 800d878:	b113      	cbz	r3, 800d880 <xTCPWindowPeekHead+0xa>
            {
                pxReturn = NULL;
            }
            else
            {
                pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 800d87a:	68c3      	ldr	r3, [r0, #12]
                pxReturn = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem ) );
 800d87c:	68d8      	ldr	r0, [r3, #12]
 800d87e:	4770      	bx	lr
                pxReturn = NULL;
 800d880:	2000      	movs	r0, #0
            }

            return pxReturn;
        }
 800d882:	4770      	bx	lr

0800d884 <lTCPIncrementTxPosition>:
            int32_t lReturn;


            /* +TCP stores data in circular buffers.  Calculate the next position to
             * store. */
            lReturn = lPosition + lCount;
 800d884:	4410      	add	r0, r2

            if( lReturn >= lMax )
 800d886:	4288      	cmp	r0, r1
 800d888:	db00      	blt.n	800d88c <lTCPIncrementTxPosition+0x8>
            {
                lReturn -= lMax;
 800d88a:	1a40      	subs	r0, r0, r1
            }

            return lReturn;
        }
 800d88c:	4770      	bx	lr
	...

0800d890 <vTCPWindowFree>:
        {
 800d890:	b510      	push	{r4, lr}
 800d892:	4604      	mov	r4, r0
            if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
 800d894:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800d896:	b113      	cbz	r3, 800d89e <vTCPWindowFree+0xe>
                ( void ) uxListRemove( &( pxSegment->xQueueItem ) );
 800d898:	3018      	adds	r0, #24
 800d89a:	f7f6 fab7 	bl	8003e0c <uxListRemove>
            pxSegment->ulSequenceNumber = 0U;
 800d89e:	2300      	movs	r3, #0
 800d8a0:	6023      	str	r3, [r4, #0]
            pxSegment->lDataLength = 0;
 800d8a2:	60a3      	str	r3, [r4, #8]
            pxSegment->u.ulFlags = 0U;
 800d8a4:	6163      	str	r3, [r4, #20]
            if( listLIST_ITEM_CONTAINER( &( pxSegment->xSegmentItem ) ) != NULL )
 800d8a6:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 800d8a8:	b11b      	cbz	r3, 800d8b2 <vTCPWindowFree+0x22>
                ( void ) uxListRemove( &( pxSegment->xSegmentItem ) );
 800d8aa:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 800d8ae:	f7f6 faad 	bl	8003e0c <uxListRemove>
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800d8b2:	4a04      	ldr	r2, [pc, #16]	@ (800d8c4 <vTCPWindowFree+0x34>)
 800d8b4:	f104 012c 	add.w	r1, r4, #44	@ 0x2c
 800d8b8:	f1a2 0008 	sub.w	r0, r2, #8
 800d8bc:	f7ff ffc2 	bl	800d844 <vListInsertGeneric>
        }
 800d8c0:	bd10      	pop	{r4, pc}
 800d8c2:	bf00      	nop
 800d8c4:	200137bc 	.word	0x200137bc

0800d8c8 <xTCPWindowGetHead>:
        {
 800d8c8:	b510      	push	{r4, lr}
            if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 800d8ca:	6803      	ldr	r3, [r0, #0]
 800d8cc:	b12b      	cbz	r3, 800d8da <xTCPWindowGetHead+0x12>
                pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 800d8ce:	68c0      	ldr	r0, [r0, #12]
                pxSegment = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem ) );
 800d8d0:	68c4      	ldr	r4, [r0, #12]
                ( void ) uxListRemove( pxItem );
 800d8d2:	f7f6 fa9b 	bl	8003e0c <uxListRemove>
        }
 800d8d6:	4620      	mov	r0, r4
 800d8d8:	bd10      	pop	{r4, pc}
                pxSegment = NULL;
 800d8da:	2400      	movs	r4, #0
            return pxSegment;
 800d8dc:	e7fb      	b.n	800d8d6 <xTCPWindowGetHead+0xe>
	...

0800d8e0 <prvCreateSectors>:
        {
 800d8e0:	b510      	push	{r4, lr}
            vListInitialise( &xSegmentList );
 800d8e2:	4812      	ldr	r0, [pc, #72]	@ (800d92c <prvCreateSectors+0x4c>)
 800d8e4:	f7f6 fa60 	bl	8003da8 <vListInitialise>
            xTCPSegments = ( ( TCPSegment_t * ) pvPortMallocLarge( ( size_t ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) ) );
 800d8e8:	f44f 5070 	mov.w	r0, #15360	@ 0x3c00
 800d8ec:	f7f8 f9da 	bl	8005ca4 <pvPortMalloc>
 800d8f0:	4b0f      	ldr	r3, [pc, #60]	@ (800d930 <prvCreateSectors+0x50>)
 800d8f2:	6018      	str	r0, [r3, #0]
            if( xTCPSegments == NULL )
 800d8f4:	b1b8      	cbz	r0, 800d926 <prvCreateSectors+0x46>
                ( void ) memset( xTCPSegments, 0, ( size_t ) ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 800d8f6:	f44f 5270 	mov.w	r2, #15360	@ 0x3c00
 800d8fa:	2100      	movs	r1, #0
 800d8fc:	f001 f9da 	bl	800ecb4 <memset>
                for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 800d900:	2400      	movs	r4, #0
 800d902:	e00c      	b.n	800d91e <prvCreateSectors+0x3e>
                    listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xSegmentItem ), ( void * ) &( xTCPSegments[ xIndex ] ) );
 800d904:	4b0a      	ldr	r3, [pc, #40]	@ (800d930 <prvCreateSectors+0x50>)
 800d906:	6819      	ldr	r1, [r3, #0]
 800d908:	eb01 1184 	add.w	r1, r1, r4, lsl #6
 800d90c:	6389      	str	r1, [r1, #56]	@ 0x38
                    listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void * ) &( xTCPSegments[ xIndex ] ) );
 800d90e:	6249      	str	r1, [r1, #36]	@ 0x24
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800d910:	4a08      	ldr	r2, [pc, #32]	@ (800d934 <prvCreateSectors+0x54>)
 800d912:	312c      	adds	r1, #44	@ 0x2c
 800d914:	f1a2 0008 	sub.w	r0, r2, #8
 800d918:	f7ff ff94 	bl	800d844 <vListInsertGeneric>
                for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 800d91c:	3401      	adds	r4, #1
 800d91e:	2cef      	cmp	r4, #239	@ 0xef
 800d920:	ddf0      	ble.n	800d904 <prvCreateSectors+0x24>
                xReturn = pdPASS;
 800d922:	2001      	movs	r0, #1
        }
 800d924:	bd10      	pop	{r4, pc}
                xReturn = pdFAIL;
 800d926:	2000      	movs	r0, #0
            return xReturn;
 800d928:	e7fc      	b.n	800d924 <prvCreateSectors+0x44>
 800d92a:	bf00      	nop
 800d92c:	200137b4 	.word	0x200137b4
 800d930:	200137c8 	.word	0x200137c8
 800d934:	200137bc 	.word	0x200137bc

0800d938 <xTCPWindowNew>:
        {
 800d938:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d93c:	4615      	mov	r5, r2
            if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
 800d93e:	4a29      	ldr	r2, [pc, #164]	@ (800d9e4 <xTCPWindowNew+0xac>)
 800d940:	6812      	ldr	r2, [r2, #0]
 800d942:	2a00      	cmp	r2, #0
 800d944:	d04a      	beq.n	800d9dc <xTCPWindowNew+0xa4>
 800d946:	4607      	mov	r7, r0
 800d948:	4688      	mov	r8, r1
 800d94a:	4699      	mov	r9, r3
                pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
 800d94c:	4b25      	ldr	r3, [pc, #148]	@ (800d9e4 <xTCPWindowNew+0xac>)
 800d94e:	68de      	ldr	r6, [r3, #12]
                pxSegment = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem ) );
 800d950:	68f4      	ldr	r4, [r6, #12]
                configASSERT( pxItem != NULL );
 800d952:	b33e      	cbz	r6, 800d9a4 <xTCPWindowNew+0x6c>
                configASSERT( pxSegment != NULL );
 800d954:	b37c      	cbz	r4, 800d9b6 <xTCPWindowNew+0x7e>
                ( void ) uxListRemove( pxItem );
 800d956:	4630      	mov	r0, r6
 800d958:	f7f6 fa58 	bl	8003e0c <uxListRemove>
                if( xIsForRx != 0 )
 800d95c:	f1b9 0f00 	cmp.w	r9, #0
 800d960:	d032      	beq.n	800d9c8 <xTCPWindowNew+0x90>
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800d962:	f107 02ac 	add.w	r2, r7, #172	@ 0xac
 800d966:	4631      	mov	r1, r6
 800d968:	f107 00a4 	add.w	r0, r7, #164	@ 0xa4
 800d96c:	f7ff ff6a 	bl	800d844 <vListInsertGeneric>
        pxTimer->uxBorn = xTaskGetTickCount();
 800d970:	f7f7 f958 	bl	8004c24 <xTaskGetTickCount>
 800d974:	6120      	str	r0, [r4, #16]
                pxSegment->u.ulFlags = 0;
 800d976:	2300      	movs	r3, #0
 800d978:	6163      	str	r3, [r4, #20]
                pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 ) ? 1U : 0U;
 800d97a:	f1b9 0f00 	cmp.w	r9, #0
 800d97e:	d02b      	beq.n	800d9d8 <xTCPWindowNew+0xa0>
 800d980:	2201      	movs	r2, #1
 800d982:	7da3      	ldrb	r3, [r4, #22]
 800d984:	f362 0382 	bfi	r3, r2, #2, #1
 800d988:	75a3      	strb	r3, [r4, #22]
                pxSegment->lMaxLength = lCount;
 800d98a:	6065      	str	r5, [r4, #4]
                pxSegment->lDataLength = lCount;
 800d98c:	60a5      	str	r5, [r4, #8]
                pxSegment->ulSequenceNumber = ulSequenceNumber;
 800d98e:	f8c4 8000 	str.w	r8, [r4]
                    UBaseType_t xLength = listCURRENT_LIST_LENGTH( &xSegmentList );
 800d992:	4b14      	ldr	r3, [pc, #80]	@ (800d9e4 <xTCPWindowNew+0xac>)
 800d994:	681b      	ldr	r3, [r3, #0]
                    if( xLowestLength > xLength )
 800d996:	4a14      	ldr	r2, [pc, #80]	@ (800d9e8 <xTCPWindowNew+0xb0>)
 800d998:	6812      	ldr	r2, [r2, #0]
 800d99a:	429a      	cmp	r2, r3
 800d99c:	d91f      	bls.n	800d9de <xTCPWindowNew+0xa6>
                        xLowestLength = xLength;
 800d99e:	4a12      	ldr	r2, [pc, #72]	@ (800d9e8 <xTCPWindowNew+0xb0>)
 800d9a0:	6013      	str	r3, [r2, #0]
 800d9a2:	e01c      	b.n	800d9de <xTCPWindowNew+0xa6>
 800d9a4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d9a8:	f383 8811 	msr	BASEPRI, r3
 800d9ac:	f3bf 8f6f 	isb	sy
 800d9b0:	f3bf 8f4f 	dsb	sy
                configASSERT( pxItem != NULL );
 800d9b4:	e7fe      	b.n	800d9b4 <xTCPWindowNew+0x7c>
 800d9b6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d9ba:	f383 8811 	msr	BASEPRI, r3
 800d9be:	f3bf 8f6f 	isb	sy
 800d9c2:	f3bf 8f4f 	dsb	sy
                configASSERT( pxSegment != NULL );
 800d9c6:	e7fe      	b.n	800d9c6 <xTCPWindowNew+0x8e>
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800d9c8:	f107 0298 	add.w	r2, r7, #152	@ 0x98
 800d9cc:	4631      	mov	r1, r6
 800d9ce:	f107 0090 	add.w	r0, r7, #144	@ 0x90
 800d9d2:	f7ff ff37 	bl	800d844 <vListInsertGeneric>
        }
 800d9d6:	e7cb      	b.n	800d970 <xTCPWindowNew+0x38>
                pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 ) ? 1U : 0U;
 800d9d8:	2200      	movs	r2, #0
 800d9da:	e7d2      	b.n	800d982 <xTCPWindowNew+0x4a>
                pxSegment = NULL;
 800d9dc:	2400      	movs	r4, #0
        }
 800d9de:	4620      	mov	r0, r4
 800d9e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d9e4:	200137b4 	.word	0x200137b4
 800d9e8:	20000020 	.word	0x20000020

0800d9ec <prvTCPWindowRx_UnexpectedRX>:
        {
 800d9ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d9f0:	4605      	mov	r5, r0
 800d9f2:	460e      	mov	r6, r1
 800d9f4:	4617      	mov	r7, r2
            uint32_t ulLast = ulSequenceNumber + ulLength;
 800d9f6:	188c      	adds	r4, r1, r2
            uint32_t ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 800d9f8:	f8d0 8010 	ldr.w	r8, [r0, #16]
 800d9fc:	e001      	b.n	800da02 <prvTCPWindowRx_UnexpectedRX+0x16>
                ulLast += ( uint32_t ) pxFound->lDataLength;
 800d9fe:	6883      	ldr	r3, [r0, #8]
 800da00:	441c      	add	r4, r3
                pxFound = xTCPWindowRxFind( pxWindow, ulLast );
 800da02:	4621      	mov	r1, r4
 800da04:	4628      	mov	r0, r5
 800da06:	f7ff ff27 	bl	800d858 <xTCPWindowRxFind>
                if( pxFound == NULL )
 800da0a:	2800      	cmp	r0, #0
 800da0c:	d1f7      	bne.n	800d9fe <prvTCPWindowRx_UnexpectedRX+0x12>
            pxWindow->ulOptionsData[ 0 ] = OPTION_CODE_SINGLE_SACK;
 800da0e:	4b1c      	ldr	r3, [pc, #112]	@ (800da80 <prvTCPWindowRx_UnexpectedRX+0x94>)
 800da10:	f8c5 3080 	str.w	r3, [r5, #128]	@ 0x80
            pxWindow->ulOptionsData[ 1 ] = FreeRTOS_htonl( ulSequenceNumber );
 800da14:	0233      	lsls	r3, r6, #8
 800da16:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800da1a:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 800da1e:	0a32      	lsrs	r2, r6, #8
 800da20:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800da24:	4313      	orrs	r3, r2
 800da26:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
 800da2a:	f8c5 3084 	str.w	r3, [r5, #132]	@ 0x84
            pxWindow->ulOptionsData[ 2 ] = FreeRTOS_htonl( ulLast );
 800da2e:	0223      	lsls	r3, r4, #8
 800da30:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 800da34:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 800da38:	0a22      	lsrs	r2, r4, #8
 800da3a:	f402 427f 	and.w	r2, r2, #65280	@ 0xff00
 800da3e:	4313      	orrs	r3, r2
 800da40:	ea43 6314 	orr.w	r3, r3, r4, lsr #24
 800da44:	f8c5 3088 	str.w	r3, [r5, #136]	@ 0x88
            pxWindow->ucOptionLength = ( uint8_t ) ( 3U * sizeof( pxWindow->ulOptionsData[ 0 ] ) );
 800da48:	230c      	movs	r3, #12
 800da4a:	f885 303c 	strb.w	r3, [r5, #60]	@ 0x3c
            pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
 800da4e:	4631      	mov	r1, r6
 800da50:	4628      	mov	r0, r5
 800da52:	f7ff ff01 	bl	800d858 <xTCPWindowRxFind>
            if( pxFound != NULL )
 800da56:	b980      	cbnz	r0, 800da7a <prvTCPWindowRx_UnexpectedRX+0x8e>
                pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
 800da58:	2301      	movs	r3, #1
 800da5a:	463a      	mov	r2, r7
 800da5c:	4631      	mov	r1, r6
 800da5e:	4628      	mov	r0, r5
 800da60:	f7ff ff6a 	bl	800d938 <xTCPWindowNew>
                if( pxFound == NULL )
 800da64:	b118      	cbz	r0, 800da6e <prvTCPWindowRx_UnexpectedRX+0x82>
                    ulIntermediateResult = ulSequenceNumber - ulCurrentSequenceNumber;
 800da66:	eba6 0008 	sub.w	r0, r6, r8
        }
 800da6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    pxWindow->ucOptionLength = 0U;
 800da6e:	2300      	movs	r3, #0
 800da70:	f885 303c 	strb.w	r3, [r5, #60]	@ 0x3c
            int32_t lReturn = -1;
 800da74:	f04f 30ff 	mov.w	r0, #4294967295
 800da78:	e7f7      	b.n	800da6a <prvTCPWindowRx_UnexpectedRX+0x7e>
 800da7a:	f04f 30ff 	mov.w	r0, #4294967295
            return lReturn;
 800da7e:	e7f4      	b.n	800da6a <prvTCPWindowRx_UnexpectedRX+0x7e>
 800da80:	0a050101 	.word	0x0a050101

0800da84 <pxTCPWindowTx_GetWaitQueue>:
 *        the normal TX queue of unsent data.  Message in the waiting queue will
 *        be sent when their timer has expired.
 * @param[in] pxWindow The descriptor of the TCP sliding windows.
 */
        static TCPSegment_t * pxTCPWindowTx_GetWaitQueue( const TCPWindow_t * pxWindow )
        {
 800da84:	b570      	push	{r4, r5, r6, lr}
 800da86:	4604      	mov	r4, r0
            TCPSegment_t * pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 800da88:	f100 0668 	add.w	r6, r0, #104	@ 0x68
 800da8c:	4630      	mov	r0, r6
 800da8e:	f7ff fef2 	bl	800d876 <xTCPWindowPeekHead>

            if( pxSegment != NULL )
 800da92:	4605      	mov	r5, r0
 800da94:	b170      	cbz	r0, 800dab4 <pxTCPWindowTx_GetWaitQueue+0x30>
            {
                /* Do check the timing. */
                uint32_t ulMaxTime;

                ulMaxTime = ( ( uint32_t ) 1U ) << pxSegment->u.bits.ucTransmitCount;
 800da96:	7d03      	ldrb	r3, [r0, #20]
                ulMaxTime *= ( uint32_t ) pxWindow->lSRTT;
 800da98:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
 800da9a:	409c      	lsls	r4, r3
        TickType_t uxNow = xTaskGetTickCount();
 800da9c:	f7f7 f8c2 	bl	8004c24 <xTaskGetTickCount>
        TickType_t uxDiff = uxNow - pxTimer->uxBorn;
 800daa0:	692b      	ldr	r3, [r5, #16]
 800daa2:	1ac0      	subs	r0, r0, r3

                if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
 800daa4:	4284      	cmp	r4, r0
 800daa6:	d207      	bcs.n	800dab8 <pxTCPWindowTx_GetWaitQueue+0x34>
                {
                    /* A normal (non-fast) retransmission.  Move it from the
                     * head of the waiting queue. */
                    pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
 800daa8:	4630      	mov	r0, r6
 800daaa:	f7ff ff0d 	bl	800d8c8 <xTCPWindowGetHead>
 800daae:	4605      	mov	r5, r0
                    pxSegment->u.bits.ucDupAckCount = ( uint8_t ) pdFALSE_UNSIGNED;
 800dab0:	2300      	movs	r3, #0
 800dab2:	7543      	strb	r3, [r0, #21]
                    pxSegment = NULL;
                }
            }

            return pxSegment;
        }
 800dab4:	4628      	mov	r0, r5
 800dab6:	bd70      	pop	{r4, r5, r6, pc}
                    pxSegment = NULL;
 800dab8:	2500      	movs	r5, #0
            return pxSegment;
 800daba:	e7fb      	b.n	800dab4 <pxTCPWindowTx_GetWaitQueue+0x30>

0800dabc <prvTCPWindowTxCheckAck_CalcSRTT>:
 * @param[in] pxWindow The descriptor of the TCP sliding windows.
 * @param[in] pxSegment The segment that was just acknowledged.
 */
        static void prvTCPWindowTxCheckAck_CalcSRTT( TCPWindow_t * pxWindow,
                                                     const TCPSegment_t * pxSegment )
        {
 800dabc:	b538      	push	{r3, r4, r5, lr}
 800dabe:	4604      	mov	r4, r0
 800dac0:	460d      	mov	r5, r1
        TickType_t uxNow = xTaskGetTickCount();
 800dac2:	f7f7 f8af 	bl	8004c24 <xTaskGetTickCount>
        TickType_t uxDiff = uxNow - pxTimer->uxBorn;
 800dac6:	692b      	ldr	r3, [r5, #16]
 800dac8:	1ac0      	subs	r0, r0, r3
            int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );

            if( pxWindow->lSRTT >= mS )
 800daca:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 800dacc:	4283      	cmp	r3, r0
 800dace:	db0d      	blt.n	800daec <prvTCPWindowTxCheckAck_CalcSRTT+0x30>
            {
                /* RTT becomes smaller: adapt slowly. */
                pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
 800dad0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800dad4:	181b      	adds	r3, r3, r0
 800dad6:	d407      	bmi.n	800dae8 <prvTCPWindowTxCheckAck_CalcSRTT+0x2c>
 800dad8:	10db      	asrs	r3, r3, #3
 800dada:	63a3      	str	r3, [r4, #56]	@ 0x38
                /* RTT becomes larger: adapt quicker */
                pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
            }

            /* Cap to the minimum of 50ms. */
            if( pxWindow->lSRTT < winSRTT_CAP_mS )
 800dadc:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 800dade:	2b31      	cmp	r3, #49	@ 0x31
 800dae0:	dc01      	bgt.n	800dae6 <prvTCPWindowTxCheckAck_CalcSRTT+0x2a>
            {
                pxWindow->lSRTT = winSRTT_CAP_mS;
 800dae2:	2332      	movs	r3, #50	@ 0x32
 800dae4:	63a3      	str	r3, [r4, #56]	@ 0x38
            }
        }
 800dae6:	bd38      	pop	{r3, r4, r5, pc}
                pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
 800dae8:	3307      	adds	r3, #7
 800daea:	e7f5      	b.n	800dad8 <prvTCPWindowTxCheckAck_CalcSRTT+0x1c>
                pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
 800daec:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800daf0:	181b      	adds	r3, r3, r0
 800daf2:	d402      	bmi.n	800dafa <prvTCPWindowTxCheckAck_CalcSRTT+0x3e>
 800daf4:	109b      	asrs	r3, r3, #2
 800daf6:	63a3      	str	r3, [r4, #56]	@ 0x38
 800daf8:	e7f0      	b.n	800dadc <prvTCPWindowTxCheckAck_CalcSRTT+0x20>
 800dafa:	3303      	adds	r3, #3
 800dafc:	e7fa      	b.n	800daf4 <prvTCPWindowTxCheckAck_CalcSRTT+0x38>

0800dafe <prvTCPWindowTxAdd_FrontSegment>:
        {
 800dafe:	b538      	push	{r3, r4, r5, lr}
 800db00:	4605      	mov	r5, r0
 800db02:	460c      	mov	r4, r1
            int32_t lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
 800db04:	6849      	ldr	r1, [r1, #4]
 800db06:	68a3      	ldr	r3, [r4, #8]
 800db08:	1ac9      	subs	r1, r1, r3
 800db0a:	4610      	mov	r0, r2
 800db0c:	f7fa fb8a 	bl	8008224 <FreeRTOS_min_int32>
            pxSegment->lDataLength += lToWrite;
 800db10:	68a3      	ldr	r3, [r4, #8]
 800db12:	4403      	add	r3, r0
 800db14:	60a3      	str	r3, [r4, #8]
            if( pxSegment->lDataLength >= pxSegment->lMaxLength )
 800db16:	6862      	ldr	r2, [r4, #4]
 800db18:	4293      	cmp	r3, r2
 800db1a:	db01      	blt.n	800db20 <prvTCPWindowTxAdd_FrontSegment+0x22>
                pxWindow->pxHeadSegment = NULL;
 800db1c:	2300      	movs	r3, #0
 800db1e:	67eb      	str	r3, [r5, #124]	@ 0x7c
            pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 800db20:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
 800db22:	4403      	add	r3, r0
 800db24:	636b      	str	r3, [r5, #52]	@ 0x34
        }
 800db26:	bd38      	pop	{r3, r4, r5, pc}

0800db28 <prvTCPWindowTxHasSpace>:
        {
 800db28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800db2a:	4605      	mov	r5, r0
 800db2c:	460c      	mov	r4, r1
            pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 800db2e:	3054      	adds	r0, #84	@ 0x54
 800db30:	f7ff fea1 	bl	800d876 <xTCPWindowPeekHead>
            if( pxSegment == NULL )
 800db34:	b1c8      	cbz	r0, 800db6a <prvTCPWindowTxHasSpace+0x42>
 800db36:	4607      	mov	r7, r0
                if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
 800db38:	6aae      	ldr	r6, [r5, #40]	@ 0x28
 800db3a:	6a2b      	ldr	r3, [r5, #32]
 800db3c:	429e      	cmp	r6, r3
 800db3e:	d301      	bcc.n	800db44 <prvTCPWindowTxHasSpace+0x1c>
                    ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
 800db40:	1af6      	subs	r6, r6, r3
 800db42:	e000      	b.n	800db46 <prvTCPWindowTxHasSpace+0x1e>
                    ulTxOutstanding = 0U;
 800db44:	2600      	movs	r6, #0
                ulNettSize = ulWindowSize - FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
 800db46:	4631      	mov	r1, r6
 800db48:	4620      	mov	r0, r4
 800db4a:	f7fa fb6f 	bl	800822c <FreeRTOS_min_uint32>
 800db4e:	1a24      	subs	r4, r4, r0
                if( ulNettSize >= ( uint32_t ) pxSegment->lDataLength )
 800db50:	68bb      	ldr	r3, [r7, #8]
 800db52:	42a3      	cmp	r3, r4
 800db54:	d807      	bhi.n	800db66 <prvTCPWindowTxHasSpace+0x3e>
                    xHasSpace = pdTRUE;
 800db56:	2001      	movs	r0, #1
                if( ( ulTxOutstanding != 0U ) &&
 800db58:	b146      	cbz	r6, 800db6c <prvTCPWindowTxHasSpace+0x44>
                    ( pxWindow->xSize.ulTxWindowLength <
 800db5a:	68aa      	ldr	r2, [r5, #8]
                      ( ulTxOutstanding + ( ( uint32_t ) pxSegment->lDataLength ) ) ) )
 800db5c:	4433      	add	r3, r6
                if( ( ulTxOutstanding != 0U ) &&
 800db5e:	429a      	cmp	r2, r3
 800db60:	d204      	bcs.n	800db6c <prvTCPWindowTxHasSpace+0x44>
                    xHasSpace = pdFALSE;
 800db62:	2000      	movs	r0, #0
            return xHasSpace;
 800db64:	e002      	b.n	800db6c <prvTCPWindowTxHasSpace+0x44>
                    xHasSpace = pdFALSE;
 800db66:	2000      	movs	r0, #0
 800db68:	e7f6      	b.n	800db58 <prvTCPWindowTxHasSpace+0x30>
                xHasSpace = pdFALSE;
 800db6a:	2000      	movs	r0, #0
        }
 800db6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800db6e <pxTCPWindowTx_GetTXQueue>:
        {
 800db6e:	b570      	push	{r4, r5, r6, lr}
 800db70:	4604      	mov	r4, r0
 800db72:	460d      	mov	r5, r1
            TCPSegment_t * pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 800db74:	f100 0654 	add.w	r6, r0, #84	@ 0x54
 800db78:	4630      	mov	r0, r6
 800db7a:	f7ff fe7c 	bl	800d876 <xTCPWindowPeekHead>
            if( pxSegment == NULL )
 800db7e:	b1b0      	cbz	r0, 800dbae <pxTCPWindowTx_GetTXQueue+0x40>
            else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) &&
 800db80:	7823      	ldrb	r3, [r4, #0]
 800db82:	f013 0f02 	tst.w	r3, #2
 800db86:	d003      	beq.n	800db90 <pxTCPWindowTx_GetTXQueue+0x22>
                     ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 800db88:	6882      	ldr	r2, [r0, #8]
 800db8a:	6843      	ldr	r3, [r0, #4]
            else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) &&
 800db8c:	429a      	cmp	r2, r3
 800db8e:	db12      	blt.n	800dbb6 <pxTCPWindowTx_GetTXQueue+0x48>
            else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 800db90:	4629      	mov	r1, r5
 800db92:	4620      	mov	r0, r4
 800db94:	f7ff ffc8 	bl	800db28 <prvTCPWindowTxHasSpace>
 800db98:	b178      	cbz	r0, 800dbba <pxTCPWindowTx_GetTXQueue+0x4c>
                pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );
 800db9a:	4630      	mov	r0, r6
 800db9c:	f7ff fe94 	bl	800d8c8 <xTCPWindowGetHead>
                if( pxWindow->pxHeadSegment == pxSegment )
 800dba0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 800dba2:	4283      	cmp	r3, r0
 800dba4:	d004      	beq.n	800dbb0 <pxTCPWindowTx_GetTXQueue+0x42>
                pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
 800dba6:	6803      	ldr	r3, [r0, #0]
 800dba8:	6882      	ldr	r2, [r0, #8]
 800dbaa:	4413      	add	r3, r2
 800dbac:	62a3      	str	r3, [r4, #40]	@ 0x28
        }
 800dbae:	bd70      	pop	{r4, r5, r6, pc}
                    pxWindow->pxHeadSegment = NULL;
 800dbb0:	2300      	movs	r3, #0
 800dbb2:	67e3      	str	r3, [r4, #124]	@ 0x7c
 800dbb4:	e7f7      	b.n	800dba6 <pxTCPWindowTx_GetTXQueue+0x38>
                pxSegment = NULL;
 800dbb6:	2000      	movs	r0, #0
 800dbb8:	e7f9      	b.n	800dbae <pxTCPWindowTx_GetTXQueue+0x40>
                pxSegment = NULL;
 800dbba:	2000      	movs	r0, #0
            return pxSegment;
 800dbbc:	e7f7      	b.n	800dbae <pxTCPWindowTx_GetTXQueue+0x40>

0800dbbe <xSequenceLessThan>:
        if( ( ( b - ( a + 1U ) ) & 0x80000000U ) == 0U )
 800dbbe:	1a09      	subs	r1, r1, r0
 800dbc0:	2901      	cmp	r1, #1
 800dbc2:	d401      	bmi.n	800dbc8 <xSequenceLessThan+0xa>
            xResult = pdTRUE;
 800dbc4:	2001      	movs	r0, #1
    }
 800dbc6:	4770      	bx	lr
        BaseType_t xResult = pdFALSE;
 800dbc8:	2000      	movs	r0, #0
 800dbca:	4770      	bx	lr

0800dbcc <xTCPWindowRxConfirm>:
        {
 800dbcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800dbd0:	460f      	mov	r7, r1
            uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
 800dbd2:	eb01 0902 	add.w	r9, r1, r2
            const ListItem_t * pxEnd = ( ( const ListItem_t * ) &( pxWindow->xRxSegments.xListEnd ) );
 800dbd6:	f100 08ac 	add.w	r8, r0, #172	@ 0xac
            for( pxIterator = listGET_NEXT( pxEnd );
 800dbda:	f8d0 40b0 	ldr.w	r4, [r0, #176]	@ 0xb0
            TCPSegment_t * pxBest = NULL;
 800dbde:	f04f 0a00 	mov.w	sl, #0
            for( pxIterator = listGET_NEXT( pxEnd );
 800dbe2:	e001      	b.n	800dbe8 <xTCPWindowRxConfirm+0x1c>
                        pxBest = pxSegment;
 800dbe4:	46b2      	mov	sl, r6
                 pxIterator = listGET_NEXT( pxIterator ) )
 800dbe6:	6864      	ldr	r4, [r4, #4]
                 pxIterator != pxEnd;
 800dbe8:	4544      	cmp	r4, r8
 800dbea:	d016      	beq.n	800dc1a <xTCPWindowRxConfirm+0x4e>
                pxSegment = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800dbec:	68e6      	ldr	r6, [r4, #12]
                if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 800dbee:	6835      	ldr	r5, [r6, #0]
        if( ( ( a - b ) & 0x80000000U ) == 0U )
 800dbf0:	1beb      	subs	r3, r5, r7
 800dbf2:	2b00      	cmp	r3, #0
 800dbf4:	dbf7      	blt.n	800dbe6 <xTCPWindowRxConfirm+0x1a>
                    ( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
 800dbf6:	4649      	mov	r1, r9
 800dbf8:	4628      	mov	r0, r5
 800dbfa:	f7ff ffe0 	bl	800dbbe <xSequenceLessThan>
                if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 800dbfe:	2800      	cmp	r0, #0
 800dc00:	d0f1      	beq.n	800dbe6 <xTCPWindowRxConfirm+0x1a>
                    if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
 800dc02:	f1ba 0f00 	cmp.w	sl, #0
 800dc06:	d0ed      	beq.n	800dbe4 <xTCPWindowRxConfirm+0x18>
 800dc08:	f8da 1000 	ldr.w	r1, [sl]
 800dc0c:	4628      	mov	r0, r5
 800dc0e:	f7ff ffd6 	bl	800dbbe <xSequenceLessThan>
 800dc12:	2800      	cmp	r0, #0
 800dc14:	d0e7      	beq.n	800dbe6 <xTCPWindowRxConfirm+0x1a>
                        pxBest = pxSegment;
 800dc16:	46b2      	mov	sl, r6
 800dc18:	e7e5      	b.n	800dbe6 <xTCPWindowRxConfirm+0x1a>
        }
 800dc1a:	4650      	mov	r0, sl
 800dc1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800dc20 <prvTCPWindowRx_ExpectedRX>:
        {
 800dc20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800dc24:	4604      	mov	r4, r0
 800dc26:	460e      	mov	r6, r1
            uint32_t ulSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 800dc28:	f8d0 8010 	ldr.w	r8, [r0, #16]
            uint32_t ulCurrentSequenceNumber = ulSequenceNumber + ulLength;
 800dc2c:	eb08 0701 	add.w	r7, r8, r1
            if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0U )
 800dc30:	f8d0 30a4 	ldr.w	r3, [r0, #164]	@ 0xa4
 800dc34:	b92b      	cbnz	r3, 800dc42 <prvTCPWindowRx_ExpectedRX+0x22>
            pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
 800dc36:	6127      	str	r7, [r4, #16]
        }
 800dc38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                        vTCPWindowFree( pxFound );
 800dc3c:	f7ff fe28 	bl	800d890 <vTCPWindowFree>
                } while( pxFound != NULL );
 800dc40:	b145      	cbz	r5, 800dc54 <prvTCPWindowRx_ExpectedRX+0x34>
                    pxFound = xTCPWindowRxConfirm( pxWindow, ulSequenceNumber, ulLength );
 800dc42:	4632      	mov	r2, r6
 800dc44:	4641      	mov	r1, r8
 800dc46:	4620      	mov	r0, r4
 800dc48:	f7ff ffc0 	bl	800dbcc <xTCPWindowRxConfirm>
                    if( pxFound != NULL )
 800dc4c:	4605      	mov	r5, r0
 800dc4e:	2800      	cmp	r0, #0
 800dc50:	d1f4      	bne.n	800dc3c <prvTCPWindowRx_ExpectedRX+0x1c>
 800dc52:	e7f5      	b.n	800dc40 <prvTCPWindowRx_ExpectedRX+0x20>
            uint32_t ulCurrentSequenceNumber = ulSequenceNumber + ulLength;
 800dc54:	463d      	mov	r5, r7
 800dc56:	e003      	b.n	800dc60 <prvTCPWindowRx_ExpectedRX+0x40>
                    ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
 800dc58:	6882      	ldr	r2, [r0, #8]
 800dc5a:	4415      	add	r5, r2
                    vTCPWindowFree( pxFound );
 800dc5c:	f7ff fe18 	bl	800d890 <vTCPWindowFree>
                    pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber );
 800dc60:	4629      	mov	r1, r5
 800dc62:	4620      	mov	r0, r4
 800dc64:	f7ff fdf8 	bl	800d858 <xTCPWindowRxFind>
                    if( pxFound == NULL )
 800dc68:	2800      	cmp	r0, #0
 800dc6a:	d1f5      	bne.n	800dc58 <prvTCPWindowRx_ExpectedRX+0x38>
                if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
 800dc6c:	42bd      	cmp	r5, r7
 800dc6e:	d003      	beq.n	800dc78 <prvTCPWindowRx_ExpectedRX+0x58>
                    pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
 800dc70:	1bef      	subs	r7, r5, r7
 800dc72:	6327      	str	r7, [r4, #48]	@ 0x30
                    if( xTCPWindowLoggingLevel >= 1 )
 800dc74:	462f      	mov	r7, r5
 800dc76:	e7de      	b.n	800dc36 <prvTCPWindowRx_ExpectedRX+0x16>
 800dc78:	462f      	mov	r7, r5
 800dc7a:	e7dc      	b.n	800dc36 <prvTCPWindowRx_ExpectedRX+0x16>

0800dc7c <prvTCPWindowFastRetransmit>:
 *
 * @return The number of segments that need a fast retransmission.
 */
        static uint32_t prvTCPWindowFastRetransmit( TCPWindow_t * pxWindow,
                                                    uint32_t ulFirst )
        {
 800dc7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800dc80:	4680      	mov	r8, r0
 800dc82:	460f      	mov	r7, r1
             * xWaitQueue to find a possible condition for a FAST retransmission. */

            /* MISRA Ref 11.3.1 [Misaligned access] */
/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxEnd = ( ( const ListItem_t * ) &( pxWindow->xWaitQueue.xListEnd ) );
 800dc84:	f100 0670 	add.w	r6, r0, #112	@ 0x70

            pxIterator = listGET_NEXT( pxEnd );
 800dc88:	6f44      	ldr	r4, [r0, #116]	@ 0x74
            uint32_t ulCount = 0U;
 800dc8a:	f04f 0900 	mov.w	r9, #0

            while( pxIterator != pxEnd )
 800dc8e:	42b4      	cmp	r4, r6
 800dc90:	d021      	beq.n	800dcd6 <prvTCPWindowFastRetransmit+0x5a>
            {
                /* Get the owner, which is a TCP segment. */
                pxSegment = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800dc92:	68e5      	ldr	r5, [r4, #12]

                /* Hop to the next item before the current gets unlinked. */
                pxIterator = listGET_NEXT( pxIterator );
 800dc94:	6864      	ldr	r4, [r4, #4]

                /* Fast retransmission:
                 * When 3 packets with a higher sequence number have been acknowledged
                 * by the peer, it is very unlikely a current packet will ever arrive.
                 * It will be retransmitted far before the RTO. */
                if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 800dc96:	7dab      	ldrb	r3, [r5, #22]
 800dc98:	f013 0f02 	tst.w	r3, #2
 800dc9c:	d1f7      	bne.n	800dc8e <prvTCPWindowFastRetransmit+0x12>
                {
                    if( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE )
 800dc9e:	4639      	mov	r1, r7
 800dca0:	6828      	ldr	r0, [r5, #0]
 800dca2:	f7ff ff8c 	bl	800dbbe <xSequenceLessThan>
 800dca6:	2800      	cmp	r0, #0
 800dca8:	d0f1      	beq.n	800dc8e <prvTCPWindowFastRetransmit+0x12>
                    {
                        pxSegment->u.bits.ucDupAckCount++;
 800dcaa:	7d6b      	ldrb	r3, [r5, #21]
 800dcac:	3301      	adds	r3, #1
 800dcae:	b2db      	uxtb	r3, r3
 800dcb0:	756b      	strb	r3, [r5, #21]

                        if( pxSegment->u.bits.ucDupAckCount == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT )
 800dcb2:	2b03      	cmp	r3, #3
 800dcb4:	d1eb      	bne.n	800dc8e <prvTCPWindowFastRetransmit+0x12>
                        {
                            pxSegment->u.bits.ucTransmitCount = ( uint8_t ) pdFALSE;
 800dcb6:	2300      	movs	r3, #0
 800dcb8:	752b      	strb	r3, [r5, #20]
                                                         ( unsigned ) ( pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ),
                                                         ( unsigned ) ( ulFirst - pxWindow->tx.ulFirstSequenceNumber ) ) );
                            }

                            /* Remove it from xWaitQueue. */
                            ( void ) uxListRemove( &pxSegment->xQueueItem );
 800dcba:	3518      	adds	r5, #24
 800dcbc:	4628      	mov	r0, r5
 800dcbe:	f7f6 f8a5 	bl	8003e0c <uxListRemove>
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800dcc2:	f108 0248 	add.w	r2, r8, #72	@ 0x48
 800dcc6:	4629      	mov	r1, r5
 800dcc8:	f108 0040 	add.w	r0, r8, #64	@ 0x40
 800dccc:	f7ff fdba 	bl	800d844 <vListInsertGeneric>

                            /* Add this segment to the priority queue so it gets
                             * retransmitted immediately. */
                            vListInsertFifo( &( pxWindow->xPriorityQueue ), &( pxSegment->xQueueItem ) );
                            ulCount++;
 800dcd0:	f109 0901 	add.w	r9, r9, #1
 800dcd4:	e7db      	b.n	800dc8e <prvTCPWindowFastRetransmit+0x12>
                    }
                }
            }

            return ulCount;
        }
 800dcd6:	4648      	mov	r0, r9
 800dcd8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800dcdc <xSequenceGreaterThan>:
        if( ( ( a - ( b + 1U ) ) & 0x80000000U ) == 0U )
 800dcdc:	1a40      	subs	r0, r0, r1
 800dcde:	2801      	cmp	r0, #1
 800dce0:	d401      	bmi.n	800dce6 <xSequenceGreaterThan+0xa>
            xResult = pdTRUE;
 800dce2:	2001      	movs	r0, #1
    }
 800dce4:	4770      	bx	lr
        BaseType_t xResult = pdFALSE;
 800dce6:	2000      	movs	r0, #0
 800dce8:	4770      	bx	lr

0800dcea <prvTCPWindowTxCheckAck>:
        {
 800dcea:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dcee:	b083      	sub	sp, #12
 800dcf0:	4682      	mov	sl, r0
 800dcf2:	460c      	mov	r4, r1
 800dcf4:	4691      	mov	r9, r2
            const ListItem_t * pxEnd = ( ( const ListItem_t * ) &( pxWindow->xTxSegments.xListEnd ) );
 800dcf6:	f100 0b98 	add.w	fp, r0, #152	@ 0x98
            pxIterator = listGET_NEXT( pxEnd );
 800dcfa:	f8d0 609c 	ldr.w	r6, [r0, #156]	@ 0x9c
            uint32_t ulBytesConfirmed = 0U;
 800dcfe:	2300      	movs	r3, #0
 800dd00:	9301      	str	r3, [sp, #4]
            while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 800dd02:	e013      	b.n	800dd2c <prvTCPWindowTxCheckAck+0x42>
                    if( ( pxSegment->u.bits.ucTransmitCount == 1U ) &&
 800dd04:	454f      	cmp	r7, r9
 800dd06:	d001      	beq.n	800dd0c <prvTCPWindowTxCheckAck+0x22>
                    xDoUnlink = pdTRUE;
 800dd08:	2301      	movs	r3, #1
 800dd0a:	e036      	b.n	800dd7a <prvTCPWindowTxCheckAck+0x90>
                        prvTCPWindowTxCheckAck_CalcSRTT( pxWindow, pxSegment );
 800dd0c:	4629      	mov	r1, r5
 800dd0e:	4650      	mov	r0, sl
 800dd10:	f7ff fed4 	bl	800dabc <prvTCPWindowTxCheckAck_CalcSRTT>
                    xDoUnlink = pdTRUE;
 800dd14:	2301      	movs	r3, #1
 800dd16:	e030      	b.n	800dd7a <prvTCPWindowTxCheckAck+0x90>
                    pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
 800dd18:	4442      	add	r2, r8
 800dd1a:	f8ca 2020 	str.w	r2, [sl, #32]
                    ulBytesConfirmed += ulDataLength;
 800dd1e:	9b01      	ldr	r3, [sp, #4]
 800dd20:	4443      	add	r3, r8
 800dd22:	9301      	str	r3, [sp, #4]
                    vTCPWindowFree( pxSegment );
 800dd24:	4628      	mov	r0, r5
 800dd26:	f7ff fdb3 	bl	800d890 <vTCPWindowFree>
                ulSequenceNumber += ulDataLength;
 800dd2a:	4444      	add	r4, r8
            while( ( pxIterator != pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 ) )
 800dd2c:	455e      	cmp	r6, fp
 800dd2e:	d032      	beq.n	800dd96 <prvTCPWindowTxCheckAck+0xac>
 800dd30:	4649      	mov	r1, r9
 800dd32:	4620      	mov	r0, r4
 800dd34:	f7ff ff43 	bl	800dbbe <xSequenceLessThan>
 800dd38:	b368      	cbz	r0, 800dd96 <prvTCPWindowTxCheckAck+0xac>
                pxSegment = ( ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator ) );
 800dd3a:	68f5      	ldr	r5, [r6, #12]
                pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 800dd3c:	6876      	ldr	r6, [r6, #4]
                if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 800dd3e:	682f      	ldr	r7, [r5, #0]
 800dd40:	4639      	mov	r1, r7
 800dd42:	4620      	mov	r0, r4
 800dd44:	f7ff ffca 	bl	800dcdc <xSequenceGreaterThan>
 800dd48:	4603      	mov	r3, r0
 800dd4a:	2800      	cmp	r0, #0
 800dd4c:	d1ee      	bne.n	800dd2c <prvTCPWindowTxCheckAck+0x42>
                if( ulSequenceNumber != pxSegment->ulSequenceNumber )
 800dd4e:	42a7      	cmp	r7, r4
 800dd50:	d121      	bne.n	800dd96 <prvTCPWindowTxCheckAck+0xac>
                ulDataLength = ( uint32_t ) pxSegment->lDataLength;
 800dd52:	f8d5 8008 	ldr.w	r8, [r5, #8]
                if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 800dd56:	7daa      	ldrb	r2, [r5, #22]
 800dd58:	f012 0f02 	tst.w	r2, #2
 800dd5c:	d10d      	bne.n	800dd7a <prvTCPWindowTxCheckAck+0x90>
                    if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t ) ulDataLength, ulLast ) != pdFALSE )
 800dd5e:	4447      	add	r7, r8
 800dd60:	4649      	mov	r1, r9
 800dd62:	4638      	mov	r0, r7
 800dd64:	f7ff ffba 	bl	800dcdc <xSequenceGreaterThan>
 800dd68:	b9a8      	cbnz	r0, 800dd96 <prvTCPWindowTxCheckAck+0xac>
                    pxSegment->u.bits.bAcked = pdTRUE;
 800dd6a:	7dab      	ldrb	r3, [r5, #22]
 800dd6c:	f043 0302 	orr.w	r3, r3, #2
 800dd70:	75ab      	strb	r3, [r5, #22]
                    if( ( pxSegment->u.bits.ucTransmitCount == 1U ) &&
 800dd72:	7d2b      	ldrb	r3, [r5, #20]
 800dd74:	2b01      	cmp	r3, #1
 800dd76:	d0c5      	beq.n	800dd04 <prvTCPWindowTxCheckAck+0x1a>
                    xDoUnlink = pdTRUE;
 800dd78:	2301      	movs	r3, #1
                if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 800dd7a:	f8da 2020 	ldr.w	r2, [sl, #32]
 800dd7e:	42a2      	cmp	r2, r4
 800dd80:	d0ca      	beq.n	800dd18 <prvTCPWindowTxCheckAck+0x2e>
                if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
 800dd82:	2b00      	cmp	r3, #0
 800dd84:	d0d1      	beq.n	800dd2a <prvTCPWindowTxCheckAck+0x40>
 800dd86:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 800dd88:	2b00      	cmp	r3, #0
 800dd8a:	d0ce      	beq.n	800dd2a <prvTCPWindowTxCheckAck+0x40>
                    ( void ) uxListRemove( &pxSegment->xQueueItem );
 800dd8c:	f105 0018 	add.w	r0, r5, #24
 800dd90:	f7f6 f83c 	bl	8003e0c <uxListRemove>
 800dd94:	e7c9      	b.n	800dd2a <prvTCPWindowTxCheckAck+0x40>
        }
 800dd96:	9801      	ldr	r0, [sp, #4]
 800dd98:	b003      	add	sp, #12
 800dd9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800dd9e <xTCPWindowRxEmpty>:
            if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
 800dd9e:	f8d0 30a4 	ldr.w	r3, [r0, #164]	@ 0xa4
 800dda2:	b94b      	cbnz	r3, 800ddb8 <xTCPWindowRxEmpty+0x1a>
            else if( xSequenceGreaterThanOrEqual( pxWindow->rx.ulCurrentSequenceNumber + 1U, pxWindow->rx.ulHighestSequenceNumber ) != pdFALSE )
 800dda4:	6903      	ldr	r3, [r0, #16]
 800dda6:	3301      	adds	r3, #1
 800dda8:	6982      	ldr	r2, [r0, #24]
        if( ( ( a - b ) & 0x80000000U ) == 0U )
 800ddaa:	1a9b      	subs	r3, r3, r2
 800ddac:	2b00      	cmp	r3, #0
 800ddae:	db01      	blt.n	800ddb4 <xTCPWindowRxEmpty+0x16>
                xReturn = pdTRUE;
 800ddb0:	2001      	movs	r0, #1
        }
 800ddb2:	4770      	bx	lr
                xReturn = pdFALSE;
 800ddb4:	2000      	movs	r0, #0
 800ddb6:	4770      	bx	lr
                xReturn = pdFALSE;
 800ddb8:	2000      	movs	r0, #0
 800ddba:	4770      	bx	lr

0800ddbc <vTCPWindowDestroy>:
        {
 800ddbc:	b570      	push	{r4, r5, r6, lr}
 800ddbe:	4606      	mov	r6, r0
            for( xRound = 0; xRound < 2; xRound++ )
 800ddc0:	2400      	movs	r4, #0
 800ddc2:	e006      	b.n	800ddd2 <vTCPWindowDestroy+0x16>
                    pxSegments = &( pxWindow->xTxSegments );
 800ddc4:	f106 0590 	add.w	r5, r6, #144	@ 0x90
                if( listLIST_IS_INITIALISED( pxSegments ) )
 800ddc8:	68ab      	ldr	r3, [r5, #8]
 800ddca:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ddce:	d00b      	beq.n	800dde8 <vTCPWindowDestroy+0x2c>
            for( xRound = 0; xRound < 2; xRound++ )
 800ddd0:	3401      	adds	r4, #1
 800ddd2:	2c01      	cmp	r4, #1
 800ddd4:	dc0c      	bgt.n	800ddf0 <vTCPWindowDestroy+0x34>
                if( xRound != 0 )
 800ddd6:	2c00      	cmp	r4, #0
 800ddd8:	d0f4      	beq.n	800ddc4 <vTCPWindowDestroy+0x8>
                    pxSegments = &( pxWindow->xRxSegments );
 800ddda:	f106 05a4 	add.w	r5, r6, #164	@ 0xa4
 800ddde:	e7f3      	b.n	800ddc8 <vTCPWindowDestroy+0xc>
                        pxSegment = ( ( TCPSegment_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxSegments ) );
 800dde0:	68eb      	ldr	r3, [r5, #12]
                        vTCPWindowFree( pxSegment );
 800dde2:	68d8      	ldr	r0, [r3, #12]
 800dde4:	f7ff fd54 	bl	800d890 <vTCPWindowFree>
                    while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 800dde8:	682b      	ldr	r3, [r5, #0]
 800ddea:	2b00      	cmp	r3, #0
 800ddec:	d1f8      	bne.n	800dde0 <vTCPWindowDestroy+0x24>
 800ddee:	e7ef      	b.n	800ddd0 <vTCPWindowDestroy+0x14>
        }
 800ddf0:	bd70      	pop	{r4, r5, r6, pc}

0800ddf2 <vTCPWindowInit>:
    {
 800ddf2:	b410      	push	{r4}
        pxWindow->u.ulFlags = 0U;
 800ddf4:	2400      	movs	r4, #0
 800ddf6:	6004      	str	r4, [r0, #0]
        pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 800ddf8:	f890 c000 	ldrb.w	ip, [r0]
 800ddfc:	f04c 0c01 	orr.w	ip, ip, #1
 800de00:	f880 c000 	strb.w	ip, [r0]
        if( ulMSS != 0U )
 800de04:	b193      	cbz	r3, 800de2c <vTCPWindowInit+0x3a>
 800de06:	469c      	mov	ip, r3
            if( pxWindow->usMSSInit != 0U )
 800de08:	f8b0 30be 	ldrh.w	r3, [r0, #190]	@ 0xbe
 800de0c:	b10b      	cbz	r3, 800de12 <vTCPWindowInit+0x20>
                pxWindow->usMSSInit = ( uint16_t ) ulMSS;
 800de0e:	f8a0 c0be 	strh.w	ip, [r0, #190]	@ 0xbe
            if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0U ) )
 800de12:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	@ 0xbc
 800de16:	4563      	cmp	r3, ip
 800de18:	d800      	bhi.n	800de1c <vTCPWindowInit+0x2a>
 800de1a:	b93b      	cbnz	r3, 800de2c <vTCPWindowInit+0x3a>
                pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
 800de1c:	6843      	ldr	r3, [r0, #4]
 800de1e:	fbb3 f3fc 	udiv	r3, r3, ip
 800de22:	fb0c f303 	mul.w	r3, ip, r3
 800de26:	6043      	str	r3, [r0, #4]
                pxWindow->usMSS = ( uint16_t ) ulMSS;
 800de28:	f8a0 c0bc 	strh.w	ip, [r0, #188]	@ 0xbc
        pxWindow->lSRTT = l500ms;
 800de2c:	f44f 73fa 	mov.w	r3, #500	@ 0x1f4
 800de30:	6383      	str	r3, [r0, #56]	@ 0x38
        pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
 800de32:	60c1      	str	r1, [r0, #12]
        pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
 800de34:	6101      	str	r1, [r0, #16]
        pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
 800de36:	6181      	str	r1, [r0, #24]
        pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
 800de38:	61c2      	str	r2, [r0, #28]
        pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
 800de3a:	6202      	str	r2, [r0, #32]
        pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
 800de3c:	6342      	str	r2, [r0, #52]	@ 0x34
        pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
 800de3e:	6282      	str	r2, [r0, #40]	@ 0x28
        pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 800de40:	62c2      	str	r2, [r0, #44]	@ 0x2c
    }
 800de42:	f85d 4b04 	ldr.w	r4, [sp], #4
 800de46:	4770      	bx	lr

0800de48 <xTCPWindowCreate>:
    {
 800de48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800de4c:	4604      	mov	r4, r0
 800de4e:	460f      	mov	r7, r1
 800de50:	4616      	mov	r6, r2
 800de52:	461d      	mov	r5, r3
            if( xTCPSegments == NULL )
 800de54:	4b13      	ldr	r3, [pc, #76]	@ (800dea4 <xTCPWindowCreate+0x5c>)
 800de56:	681b      	ldr	r3, [r3, #0]
 800de58:	b303      	cbz	r3, 800de9c <xTCPWindowCreate+0x54>
        BaseType_t xReturn = pdPASS;
 800de5a:	f04f 0801 	mov.w	r8, #1
            vListInitialise( &( pxWindow->xTxSegments ) );
 800de5e:	f104 0090 	add.w	r0, r4, #144	@ 0x90
 800de62:	f7f5 ffa1 	bl	8003da8 <vListInitialise>
            vListInitialise( &( pxWindow->xRxSegments ) );
 800de66:	f104 00a4 	add.w	r0, r4, #164	@ 0xa4
 800de6a:	f7f5 ff9d 	bl	8003da8 <vListInitialise>
            vListInitialise( &( pxWindow->xPriorityQueue ) ); /* Priority queue: segments which must be sent immediately */
 800de6e:	f104 0040 	add.w	r0, r4, #64	@ 0x40
 800de72:	f7f5 ff99 	bl	8003da8 <vListInitialise>
            vListInitialise( &( pxWindow->xTxQueue ) );       /* Transmit queue: segments queued for transmission */
 800de76:	f104 0054 	add.w	r0, r4, #84	@ 0x54
 800de7a:	f7f5 ff95 	bl	8003da8 <vListInitialise>
            vListInitialise( &( pxWindow->xWaitQueue ) );     /* Waiting queue:  outstanding segments */
 800de7e:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 800de82:	f7f5 ff91 	bl	8003da8 <vListInitialise>
        pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
 800de86:	6067      	str	r7, [r4, #4]
        pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 800de88:	60a6      	str	r6, [r4, #8]
        vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
 800de8a:	9b07      	ldr	r3, [sp, #28]
 800de8c:	9a06      	ldr	r2, [sp, #24]
 800de8e:	4629      	mov	r1, r5
 800de90:	4620      	mov	r0, r4
 800de92:	f7ff ffae 	bl	800ddf2 <vTCPWindowInit>
    }
 800de96:	4640      	mov	r0, r8
 800de98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                xReturn = prvCreateSectors();
 800de9c:	f7ff fd20 	bl	800d8e0 <prvCreateSectors>
 800dea0:	4680      	mov	r8, r0
 800dea2:	e7dc      	b.n	800de5e <xTCPWindowCreate+0x16>
 800dea4:	200137c8 	.word	0x200137c8

0800dea8 <lTCPWindowRxCheck>:
        {
 800dea8:	b538      	push	{r3, r4, r5, lr}
 800deaa:	9d04      	ldr	r5, [sp, #16]
            *( pulSkipCount ) = 0U;
 800deac:	2400      	movs	r4, #0
 800deae:	602c      	str	r4, [r5, #0]
            ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 800deb0:	6904      	ldr	r4, [r0, #16]
            ulLast = ulRxSequenceNumber + ulRxLength;
 800deb2:	eb01 0c02 	add.w	ip, r1, r2
            ulIntermediateResult = ulLast - ulCurrentSequenceNumber;
 800deb6:	ebac 0c04 	sub.w	ip, ip, r4
            if( ( lStartDistance < 0 ) && ( lLastDistance > 0 ) )
 800deba:	ebb1 0e04 	subs.w	lr, r1, r4
 800debe:	d410      	bmi.n	800dee2 <lTCPWindowRxCheck+0x3a>
            pxWindow->ucOptionLength = 0U;
 800dec0:	2500      	movs	r5, #0
 800dec2:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
            pxWindow->ulUserDataLength = 0U;
 800dec6:	6305      	str	r5, [r0, #48]	@ 0x30
            if( ulCurrentSequenceNumber == ulRxSequenceNumber )
 800dec8:	42a1      	cmp	r1, r4
 800deca:	d013      	beq.n	800def4 <lTCPWindowRxCheck+0x4c>
            else if( ulCurrentSequenceNumber == ( ulRxSequenceNumber + 1U ) )
 800decc:	1c4d      	adds	r5, r1, #1
 800dece:	42a5      	cmp	r5, r4
 800ded0:	d01a      	beq.n	800df08 <lTCPWindowRxCheck+0x60>
                if( lLastDistance <= 0 )
 800ded2:	f1bc 0f00 	cmp.w	ip, #0
 800ded6:	dd1a      	ble.n	800df0e <lTCPWindowRxCheck+0x66>
                else if( lLastDistance > ( int32_t ) ulSpace )
 800ded8:	4563      	cmp	r3, ip
 800deda:	db1b      	blt.n	800df14 <lTCPWindowRxCheck+0x6c>
                    lReturn = prvTCPWindowRx_UnexpectedRX( pxWindow, ulRxSequenceNumber, ulRxLength );
 800dedc:	f7ff fd86 	bl	800d9ec <prvTCPWindowRx_UnexpectedRX>
        }
 800dee0:	bd38      	pop	{r3, r4, r5, pc}
            if( ( lStartDistance < 0 ) && ( lLastDistance > 0 ) )
 800dee2:	f1bc 0f00 	cmp.w	ip, #0
 800dee6:	ddeb      	ble.n	800dec0 <lTCPWindowRxCheck+0x18>
                ulRxLength += ( uint32_t ) lStartDistance;
 800dee8:	4472      	add	r2, lr
                *( pulSkipCount ) = ( uint32_t ) ( -lStartDistance );
 800deea:	f1ce 0100 	rsb	r1, lr, #0
 800deee:	6029      	str	r1, [r5, #0]
                ulRxSequenceNumber += ( uint32_t ) ( -lStartDistance );
 800def0:	4621      	mov	r1, r4
 800def2:	e7e5      	b.n	800dec0 <lTCPWindowRxCheck+0x18>
                if( ulRxLength > ulSpace )
 800def4:	429a      	cmp	r2, r3
 800def6:	d804      	bhi.n	800df02 <lTCPWindowRxCheck+0x5a>
                    prvTCPWindowRx_ExpectedRX( pxWindow, ulRxLength );
 800def8:	4611      	mov	r1, r2
 800defa:	f7ff fe91 	bl	800dc20 <prvTCPWindowRx_ExpectedRX>
                    lReturn = 0;
 800defe:	4628      	mov	r0, r5
 800df00:	e7ee      	b.n	800dee0 <lTCPWindowRxCheck+0x38>
            int32_t lReturn = -1;
 800df02:	f04f 30ff 	mov.w	r0, #4294967295
 800df06:	e7eb      	b.n	800dee0 <lTCPWindowRxCheck+0x38>
 800df08:	f04f 30ff 	mov.w	r0, #4294967295
 800df0c:	e7e8      	b.n	800dee0 <lTCPWindowRxCheck+0x38>
 800df0e:	f04f 30ff 	mov.w	r0, #4294967295
 800df12:	e7e5      	b.n	800dee0 <lTCPWindowRxCheck+0x38>
 800df14:	f04f 30ff 	mov.w	r0, #4294967295
            return lReturn;
 800df18:	e7e2      	b.n	800dee0 <lTCPWindowRxCheck+0x38>

0800df1a <lTCPWindowTxAdd>:
        {
 800df1a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800df1e:	4604      	mov	r4, r0
 800df20:	460d      	mov	r5, r1
 800df22:	4617      	mov	r7, r2
 800df24:	469a      	mov	sl, r3
            int32_t lBytesLeft = ( int32_t ) ulLength;
 800df26:	4688      	mov	r8, r1
            TCPSegment_t * pxSegment = pxWindow->pxHeadSegment;
 800df28:	6fc1      	ldr	r1, [r0, #124]	@ 0x7c
            if( ( pxSegment != NULL ) &&
 800df2a:	b1c1      	cbz	r1, 800df5e <lTCPWindowTxAdd+0x44>
                ( pxSegment->lDataLength < pxSegment->lMaxLength ) &&
 800df2c:	f8d1 9008 	ldr.w	r9, [r1, #8]
 800df30:	684b      	ldr	r3, [r1, #4]
            if( ( pxSegment != NULL ) &&
 800df32:	4599      	cmp	r9, r3
 800df34:	da16      	bge.n	800df64 <lTCPWindowTxAdd+0x4a>
                ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) &&
 800df36:	7d8b      	ldrb	r3, [r1, #22]
                ( pxSegment->lDataLength < pxSegment->lMaxLength ) &&
 800df38:	f013 0f01 	tst.w	r3, #1
 800df3c:	d115      	bne.n	800df6a <lTCPWindowTxAdd+0x50>
                ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) &&
 800df3e:	f1b9 0f00 	cmp.w	r9, #0
 800df42:	d017      	beq.n	800df74 <lTCPWindowTxAdd+0x5a>
                lToWrite = prvTCPWindowTxAdd_FrontSegment( pxWindow, pxSegment, lBytesLeft );
 800df44:	462a      	mov	r2, r5
 800df46:	f7ff fdda 	bl	800dafe <prvTCPWindowTxAdd_FrontSegment>
 800df4a:	4681      	mov	r9, r0
                lBytesLeft -= lToWrite;
 800df4c:	eba5 0800 	sub.w	r8, r5, r0
                lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
 800df50:	4602      	mov	r2, r0
 800df52:	4651      	mov	r1, sl
 800df54:	4638      	mov	r0, r7
 800df56:	f7ff fc95 	bl	800d884 <lTCPIncrementTxPosition>
 800df5a:	4607      	mov	r7, r0
 800df5c:	e00a      	b.n	800df74 <lTCPWindowTxAdd+0x5a>
            int32_t lDone = 0;
 800df5e:	f04f 0900 	mov.w	r9, #0
 800df62:	e007      	b.n	800df74 <lTCPWindowTxAdd+0x5a>
 800df64:	f04f 0900 	mov.w	r9, #0
 800df68:	e004      	b.n	800df74 <lTCPWindowTxAdd+0x5a>
 800df6a:	f04f 0900 	mov.w	r9, #0
 800df6e:	e001      	b.n	800df74 <lTCPWindowTxAdd+0x5a>
                        pxWindow->pxHeadSegment = NULL;
 800df70:	2300      	movs	r3, #0
 800df72:	67e3      	str	r3, [r4, #124]	@ 0x7c
            while( lBytesLeft > 0 )
 800df74:	f1b8 0f00 	cmp.w	r8, #0
 800df78:	dd29      	ble.n	800dfce <lTCPWindowTxAdd+0xb4>
                pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, ( int32_t ) pxWindow->usMSS );
 800df7a:	2300      	movs	r3, #0
 800df7c:	f8b4 20bc 	ldrh.w	r2, [r4, #188]	@ 0xbc
 800df80:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800df82:	4620      	mov	r0, r4
 800df84:	f7ff fcd8 	bl	800d938 <xTCPWindowNew>
                if( pxSegment != NULL )
 800df88:	4606      	mov	r6, r0
 800df8a:	b300      	cbz	r0, 800dfce <lTCPWindowTxAdd+0xb4>
                    lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength );
 800df8c:	6841      	ldr	r1, [r0, #4]
 800df8e:	4640      	mov	r0, r8
 800df90:	f7fa f948 	bl	8008224 <FreeRTOS_min_int32>
 800df94:	4605      	mov	r5, r0
                    pxSegment->lDataLength = lToWrite;
 800df96:	60b0      	str	r0, [r6, #8]
                    pxSegment->lStreamPos = lBufferIndex;
 800df98:	60f7      	str	r7, [r6, #12]
                    lBytesLeft -= lToWrite;
 800df9a:	eba8 0800 	sub.w	r8, r8, r0
                    lBufferIndex = lTCPIncrementTxPosition( lBufferIndex, lMax, lToWrite );
 800df9e:	4602      	mov	r2, r0
 800dfa0:	4651      	mov	r1, sl
 800dfa2:	4638      	mov	r0, r7
 800dfa4:	f7ff fc6e 	bl	800d884 <lTCPIncrementTxPosition>
 800dfa8:	4607      	mov	r7, r0
                    pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 800dfaa:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 800dfac:	442a      	add	r2, r5
 800dfae:	6362      	str	r2, [r4, #52]	@ 0x34
                    lDone += lToWrite;
 800dfb0:	44a9      	add	r9, r5
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800dfb2:	f104 025c 	add.w	r2, r4, #92	@ 0x5c
 800dfb6:	f106 0118 	add.w	r1, r6, #24
 800dfba:	f104 0054 	add.w	r0, r4, #84	@ 0x54
 800dfbe:	f7ff fc41 	bl	800d844 <vListInsertGeneric>
                    if( pxSegment->lDataLength < pxSegment->lMaxLength )
 800dfc2:	68b2      	ldr	r2, [r6, #8]
 800dfc4:	6873      	ldr	r3, [r6, #4]
 800dfc6:	429a      	cmp	r2, r3
 800dfc8:	dad2      	bge.n	800df70 <lTCPWindowTxAdd+0x56>
                        pxWindow->pxHeadSegment = pxSegment;
 800dfca:	67e6      	str	r6, [r4, #124]	@ 0x7c
 800dfcc:	e7d2      	b.n	800df74 <lTCPWindowTxAdd+0x5a>
        }
 800dfce:	4648      	mov	r0, r9
 800dfd0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800dfd4 <xTCPWindowTxDone>:
            return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments ) );
 800dfd4:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
 800dfd8:	b90b      	cbnz	r3, 800dfde <xTCPWindowTxDone+0xa>
 800dfda:	2001      	movs	r0, #1
 800dfdc:	4770      	bx	lr
 800dfde:	2000      	movs	r0, #0
        }
 800dfe0:	4770      	bx	lr

0800dfe2 <xTCPWindowTxHasData>:
        {
 800dfe2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            *pulDelay = 0U;
 800dfe4:	2300      	movs	r3, #0
 800dfe6:	6013      	str	r3, [r2, #0]
            if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
 800dfe8:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800dfea:	b10b      	cbz	r3, 800dff0 <xTCPWindowTxHasData+0xe>
                xReturn = pdTRUE;
 800dfec:	2001      	movs	r0, #1
        }
 800dfee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800dff0:	4604      	mov	r4, r0
 800dff2:	460d      	mov	r5, r1
 800dff4:	4616      	mov	r6, r2
                pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 800dff6:	3068      	adds	r0, #104	@ 0x68
 800dff8:	f7ff fc3d 	bl	800d876 <xTCPWindowPeekHead>
                if( pxSegment != NULL )
 800dffc:	4607      	mov	r7, r0
 800dffe:	b170      	cbz	r0, 800e01e <xTCPWindowTxHasData+0x3c>
                    uint32_t ulSRTT = ( uint32_t ) pxWindow->lSRTT;
 800e000:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
        TickType_t uxNow = xTaskGetTickCount();
 800e002:	f7f6 fe0f 	bl	8004c24 <xTaskGetTickCount>
        TickType_t uxDiff = uxNow - pxTimer->uxBorn;
 800e006:	693a      	ldr	r2, [r7, #16]
 800e008:	1a81      	subs	r1, r0, r2
                    ulMaxAge = ( ( uint32_t ) 1U << pxSegment->u.bits.ucTransmitCount );
 800e00a:	7d3b      	ldrb	r3, [r7, #20]
                    ulMaxAge *= ulSRTT;
 800e00c:	fa04 f303 	lsl.w	r3, r4, r3
                    if( ulMaxAge > ulAge )
 800e010:	428b      	cmp	r3, r1
 800e012:	d91a      	bls.n	800e04a <xTCPWindowTxHasData+0x68>
                        *pulDelay = ulMaxAge - ulAge;
 800e014:	1a12      	subs	r2, r2, r0
 800e016:	441a      	add	r2, r3
 800e018:	6032      	str	r2, [r6, #0]
                    xReturn = pdTRUE;
 800e01a:	2001      	movs	r0, #1
 800e01c:	e7e7      	b.n	800dfee <xTCPWindowTxHasData+0xc>
                    pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );
 800e01e:	f104 0054 	add.w	r0, r4, #84	@ 0x54
 800e022:	f7ff fc28 	bl	800d876 <xTCPWindowPeekHead>
                    if( pxSegment == NULL )
 800e026:	4606      	mov	r6, r0
 800e028:	b188      	cbz	r0, 800e04e <xTCPWindowTxHasData+0x6c>
                    else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 800e02a:	4629      	mov	r1, r5
 800e02c:	4620      	mov	r0, r4
 800e02e:	f7ff fd7b 	bl	800db28 <prvTCPWindowTxHasSpace>
 800e032:	2800      	cmp	r0, #0
 800e034:	d0db      	beq.n	800dfee <xTCPWindowTxHasData+0xc>
                    else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) &&
 800e036:	7823      	ldrb	r3, [r4, #0]
 800e038:	f013 0f02 	tst.w	r3, #2
 800e03c:	d009      	beq.n	800e052 <xTCPWindowTxHasData+0x70>
                             ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 800e03e:	68b2      	ldr	r2, [r6, #8]
 800e040:	6873      	ldr	r3, [r6, #4]
                    else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) &&
 800e042:	429a      	cmp	r2, r3
 800e044:	db07      	blt.n	800e056 <xTCPWindowTxHasData+0x74>
                        xReturn = pdTRUE;
 800e046:	2001      	movs	r0, #1
 800e048:	e7d1      	b.n	800dfee <xTCPWindowTxHasData+0xc>
                    xReturn = pdTRUE;
 800e04a:	2001      	movs	r0, #1
 800e04c:	e7cf      	b.n	800dfee <xTCPWindowTxHasData+0xc>
                        xReturn = pdFALSE;
 800e04e:	2000      	movs	r0, #0
 800e050:	e7cd      	b.n	800dfee <xTCPWindowTxHasData+0xc>
                        xReturn = pdTRUE;
 800e052:	2001      	movs	r0, #1
 800e054:	e7cb      	b.n	800dfee <xTCPWindowTxHasData+0xc>
                        xReturn = pdFALSE;
 800e056:	2000      	movs	r0, #0
            return xReturn;
 800e058:	e7c9      	b.n	800dfee <xTCPWindowTxHasData+0xc>

0800e05a <ulTCPWindowTxGet>:
        {
 800e05a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e05c:	4604      	mov	r4, r0
 800e05e:	460e      	mov	r6, r1
 800e060:	4617      	mov	r7, r2
            pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
 800e062:	3040      	adds	r0, #64	@ 0x40
 800e064:	f7ff fc30 	bl	800d8c8 <xTCPWindowGetHead>
            pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
 800e068:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800e06a:	62e3      	str	r3, [r4, #44]	@ 0x2c
            if( pxSegment != NULL )
 800e06c:	4605      	mov	r5, r0
 800e06e:	b150      	cbz	r0, 800e086 <ulTCPWindowTxGet+0x2c>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) == NULL );
 800e070:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 800e072:	b1bb      	cbz	r3, 800e0a4 <ulTCPWindowTxGet+0x4a>
 800e074:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e078:	f383 8811 	msr	BASEPRI, r3
 800e07c:	f3bf 8f6f 	isb	sy
 800e080:	f3bf 8f4f 	dsb	sy
 800e084:	e7fe      	b.n	800e084 <ulTCPWindowTxGet+0x2a>
                pxSegment = pxTCPWindowTx_GetWaitQueue( pxWindow );
 800e086:	4620      	mov	r0, r4
 800e088:	f7ff fcfc 	bl	800da84 <pxTCPWindowTx_GetWaitQueue>
                if( pxSegment == NULL )
 800e08c:	4605      	mov	r5, r0
 800e08e:	2800      	cmp	r0, #0
 800e090:	d1ee      	bne.n	800e070 <ulTCPWindowTxGet+0x16>
                    pxSegment = pxTCPWindowTx_GetTXQueue( pxWindow, ulWindowSize );
 800e092:	4631      	mov	r1, r6
 800e094:	4620      	mov	r0, r4
 800e096:	f7ff fd6a 	bl	800db6e <pxTCPWindowTx_GetTXQueue>
            if( pxSegment != NULL )
 800e09a:	4605      	mov	r5, r0
 800e09c:	2800      	cmp	r0, #0
 800e09e:	d1e7      	bne.n	800e070 <ulTCPWindowTxGet+0x16>
            uint32_t ulReturn = 0U;
 800e0a0:	2000      	movs	r0, #0
            return ulReturn;
 800e0a2:	e019      	b.n	800e0d8 <ulTCPWindowTxGet+0x7e>
            vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800e0a4:	f104 0270 	add.w	r2, r4, #112	@ 0x70
 800e0a8:	f105 0118 	add.w	r1, r5, #24
 800e0ac:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 800e0b0:	f7ff fbc8 	bl	800d844 <vListInsertGeneric>
                pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
 800e0b4:	7dab      	ldrb	r3, [r5, #22]
 800e0b6:	f043 0301 	orr.w	r3, r3, #1
 800e0ba:	75ab      	strb	r3, [r5, #22]
                ( pxSegment->u.bits.ucTransmitCount )++;
 800e0bc:	7d2b      	ldrb	r3, [r5, #20]
 800e0be:	3301      	adds	r3, #1
 800e0c0:	b2db      	uxtb	r3, r3
 800e0c2:	752b      	strb	r3, [r5, #20]
                if( ( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW ) &&
 800e0c4:	2b04      	cmp	r3, #4
 800e0c6:	d008      	beq.n	800e0da <ulTCPWindowTxGet+0x80>
        pxTimer->uxBorn = xTaskGetTickCount();
 800e0c8:	f7f6 fdac 	bl	8004c24 <xTaskGetTickCount>
 800e0cc:	6128      	str	r0, [r5, #16]
                pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
 800e0ce:	682b      	ldr	r3, [r5, #0]
 800e0d0:	62e3      	str	r3, [r4, #44]	@ 0x2c
                *plPosition = pxSegment->lStreamPos;
 800e0d2:	68eb      	ldr	r3, [r5, #12]
 800e0d4:	603b      	str	r3, [r7, #0]
                ulReturn = ( uint32_t ) pxSegment->lDataLength;
 800e0d6:	68a8      	ldr	r0, [r5, #8]
        }
 800e0d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    ( pxWindow->xSize.ulTxWindowLength > ( 2U * ( ( uint32_t ) pxWindow->usMSS ) ) ) )
 800e0da:	68a1      	ldr	r1, [r4, #8]
 800e0dc:	f8b4 20bc 	ldrh.w	r2, [r4, #188]	@ 0xbc
 800e0e0:	0053      	lsls	r3, r2, #1
                if( ( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW ) &&
 800e0e2:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
 800e0e6:	d9ef      	bls.n	800e0c8 <ulTCPWindowTxGet+0x6e>
                    pxWindow->xSize.ulTxWindowLength = usMSS2;
 800e0e8:	b29b      	uxth	r3, r3
 800e0ea:	60a3      	str	r3, [r4, #8]
 800e0ec:	e7ec      	b.n	800e0c8 <ulTCPWindowTxGet+0x6e>

0800e0ee <ulTCPWindowTxAck>:
 *
 * @return The location where the packet should be added.
 */
        uint32_t ulTCPWindowTxAck( TCPWindow_t * pxWindow,
                                   uint32_t ulSequenceNumber )
        {
 800e0ee:	b508      	push	{r3, lr}
 800e0f0:	460a      	mov	r2, r1
            uint32_t ulFirstSequence;
            uint32_t ulReturn;

            /* Receive a normal ACK. */

            ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
 800e0f2:	6a01      	ldr	r1, [r0, #32]
            if( ( ( b - a ) & 0x80000000U ) == 0U )
 800e0f4:	1a8b      	subs	r3, r1, r2
 800e0f6:	2b00      	cmp	r3, #0
 800e0f8:	db01      	blt.n	800e0fe <ulTCPWindowTxAck+0x10>

            if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
            {
                ulReturn = 0U;
 800e0fa:	2000      	movs	r0, #0
            {
                ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
            }

            return ulReturn;
        }
 800e0fc:	bd08      	pop	{r3, pc}
                ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
 800e0fe:	f7ff fdf4 	bl	800dcea <prvTCPWindowTxCheckAck>
 800e102:	e7fb      	b.n	800e0fc <ulTCPWindowTxAck+0xe>

0800e104 <ulTCPWindowTxSack>:
 *         the head position.
 */
        uint32_t ulTCPWindowTxSack( TCPWindow_t * pxWindow,
                                    uint32_t ulFirst,
                                    uint32_t ulLast )
        {
 800e104:	b570      	push	{r4, r5, r6, lr}
 800e106:	4605      	mov	r5, r0
 800e108:	460e      	mov	r6, r1
            uint32_t ulAckCount;
            uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;

            /* Receive a SACK option. */
            ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
 800e10a:	f7ff fdee 	bl	800dcea <prvTCPWindowTxCheckAck>
 800e10e:	4604      	mov	r4, r0
            ( void ) prvTCPWindowFastRetransmit( pxWindow, ulFirst );
 800e110:	4631      	mov	r1, r6
 800e112:	4628      	mov	r0, r5
 800e114:	f7ff fdb2 	bl	800dc7c <prvTCPWindowFastRetransmit>
                                         ( unsigned ) ( ulLast - pxWindow->tx.ulFirstSequenceNumber ),
                                         ( unsigned ) ( pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) ) );
            }

            return ulAckCount;
        }
 800e118:	4620      	mov	r0, r4
 800e11a:	bd70      	pop	{r4, r5, r6, pc}

0800e11c <vProcessGeneratedUDPPacket>:
 */
void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
    const UDPPacket_t * pxUDPPacket;

    if( pxNetworkBuffer != NULL )
 800e11c:	b170      	cbz	r0, 800e13c <vProcessGeneratedUDPPacket+0x20>
{
 800e11e:	b508      	push	{r3, lr}
        /* Map the UDP packet onto the start of the frame. */

        /* MISRA Ref 11.3.1 [Misaligned access] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
        /* coverity[misra_c_2012_rule_11_3_violation] */
        pxUDPPacket = ( ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800e120:	6a42      	ldr	r2, [r0, #36]	@ 0x24

        switch( pxUDPPacket->xEthernetHeader.usFrameType )
 800e122:	8992      	ldrh	r2, [r2, #12]
 800e124:	2a08      	cmp	r2, #8
 800e126:	d006      	beq.n	800e136 <vProcessGeneratedUDPPacket+0x1a>
 800e128:	f64d 5186 	movw	r1, #56710	@ 0xdd86
 800e12c:	428a      	cmp	r2, r1
 800e12e:	d104      	bne.n	800e13a <vProcessGeneratedUDPPacket+0x1e>
                    vProcessGeneratedUDPPacket_IPv4( pxNetworkBuffer );
                    break;
            #endif
            #if ( ipconfigUSE_IPv6 != 0 )
                case ipIPv6_FRAME_TYPE:
                    vProcessGeneratedUDPPacket_IPv6( pxNetworkBuffer );
 800e130:	f000 f979 	bl	800e426 <vProcessGeneratedUDPPacket_IPv6>
            default:
                /* do nothing, coverity happy */
                break;
        }
    }
}
 800e134:	e001      	b.n	800e13a <vProcessGeneratedUDPPacket+0x1e>
                    vProcessGeneratedUDPPacket_IPv4( pxNetworkBuffer );
 800e136:	f000 f82b 	bl	800e190 <vProcessGeneratedUDPPacket_IPv4>
}
 800e13a:	bd08      	pop	{r3, pc}
 800e13c:	4770      	bx	lr

0800e13e <xProcessReceivedUDPPacket>:
 * @return pdPASS in case the UDP packet could be processed. Else pdFAIL is returned.
 */
BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t * pxNetworkBuffer,
                                      uint16_t usPort,
                                      BaseType_t * pxIsWaitingForARPResolution )
{
 800e13e:	b508      	push	{r3, lr}
    /* Returning pdPASS means that the packet was consumed, released. */
    BaseType_t xReturn = pdFAIL;
    const UDPPacket_t * pxUDPPacket;

    configASSERT( pxNetworkBuffer != NULL );
 800e140:	b158      	cbz	r0, 800e15a <xProcessReceivedUDPPacket+0x1c>
 800e142:	4603      	mov	r3, r0
    configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800e144:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 800e146:	b188      	cbz	r0, 800e16c <xProcessReceivedUDPPacket+0x2e>
    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    pxUDPPacket = ( ( const UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );

    switch( pxUDPPacket->xEthernetHeader.usFrameType )
 800e148:	8980      	ldrh	r0, [r0, #12]
 800e14a:	2808      	cmp	r0, #8
 800e14c:	d017      	beq.n	800e17e <xProcessReceivedUDPPacket+0x40>
 800e14e:	f64d 5c86 	movw	ip, #56710	@ 0xdd86
 800e152:	4560      	cmp	r0, ip
 800e154:	d017      	beq.n	800e186 <xProcessReceivedUDPPacket+0x48>
 800e156:	2000      	movs	r0, #0
            /* do nothing, coverity happy */
            break;
    }

    return xReturn;
}
 800e158:	bd08      	pop	{r3, pc}
 800e15a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e15e:	f383 8811 	msr	BASEPRI, r3
 800e162:	f3bf 8f6f 	isb	sy
 800e166:	f3bf 8f4f 	dsb	sy
    configASSERT( pxNetworkBuffer != NULL );
 800e16a:	e7fe      	b.n	800e16a <xProcessReceivedUDPPacket+0x2c>
 800e16c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e170:	f383 8811 	msr	BASEPRI, r3
 800e174:	f3bf 8f6f 	isb	sy
 800e178:	f3bf 8f4f 	dsb	sy
    configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800e17c:	e7fe      	b.n	800e17c <xProcessReceivedUDPPacket+0x3e>
                xReturn = xProcessReceivedUDPPacket_IPv4( pxNetworkBuffer,
 800e17e:	4618      	mov	r0, r3
 800e180:	f000 f8b4 	bl	800e2ec <xProcessReceivedUDPPacket_IPv4>
                break;
 800e184:	e7e8      	b.n	800e158 <xProcessReceivedUDPPacket+0x1a>
                xReturn = xProcessReceivedUDPPacket_IPv6( pxNetworkBuffer,
 800e186:	4618      	mov	r0, r3
 800e188:	f000 f9e2 	bl	800e550 <xProcessReceivedUDPPacket_IPv6>
    return xReturn;
 800e18c:	e7e4      	b.n	800e158 <xProcessReceivedUDPPacket+0x1a>
	...

0800e190 <vProcessGeneratedUDPPacket_IPv4>:
 *        packet such as ARP cache check and address resolution.
 *
 * @param[in] pxNetworkBuffer The network buffer carrying the packet.
 */
void vProcessGeneratedUDPPacket_IPv4( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 800e190:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e194:	b082      	sub	sp, #8
 800e196:	4604      	mov	r4, r0
    UDPPacket_t * pxUDPPacket;
    IPHeader_t * pxIPHeader;
    eARPLookupResult_t eReturned;
    uint32_t ulIPAddress = pxNetworkBuffer->xIPAddress.ulIP_IPv4;
 800e198:	6943      	ldr	r3, [r0, #20]
 800e19a:	9301      	str	r3, [sp, #4]
    NetworkEndPoint_t * pxEndPoint = pxNetworkBuffer->pxEndPoint;
 800e19c:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 800e19e:	9300      	str	r3, [sp, #0]
    /* Map the UDP packet onto the start of the frame. */

    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    pxUDPPacket = ( ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800e1a0:	6a45      	ldr	r5, [r0, #36]	@ 0x24
            uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( ICMPPacket_t );
        }
        else
    #endif
    {
        uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_t );
 800e1a2:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 800e1a4:	f1a3 062a 	sub.w	r6, r3, #42	@ 0x2a
    }

    /* Determine the ARP cache status for the requested IP address. */
    eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ), &( pxEndPoint ) );
 800e1a8:	466a      	mov	r2, sp
 800e1aa:	4629      	mov	r1, r5
 800e1ac:	a801      	add	r0, sp, #4
 800e1ae:	f7f7 ffa3 	bl	80060f8 <eARPGetCacheEntry>

    if( pxNetworkBuffer->pxEndPoint == NULL )
 800e1b2:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800e1b4:	b15b      	cbz	r3, 800e1ce <vProcessGeneratedUDPPacket_IPv4+0x3e>
    {
        pxNetworkBuffer->pxEndPoint = pxEndPoint;
    }

    if( eReturned != eCantSendPacket )
 800e1b6:	2802      	cmp	r0, #2
 800e1b8:	d003      	beq.n	800e1c2 <vProcessGeneratedUDPPacket_IPv4+0x32>
    {
        if( eReturned == eARPCacheHit )
 800e1ba:	2801      	cmp	r0, #1
 800e1bc:	d00a      	beq.n	800e1d4 <vProcessGeneratedUDPPacket_IPv4+0x44>
                    pxUDPPacket->xUDPHeader.usChecksum = 0U;
                }
            }
            #endif /* if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 ) */
        }
        else if( eReturned == eARPCacheMiss )
 800e1be:	2800      	cmp	r0, #0
 800e1c0:	d07a      	beq.n	800e2b8 <vProcessGeneratedUDPPacket_IPv4+0x128>
    }
    else
    {
        /* The packet can't be sent (DHCP not completed?).  Just drop the
         * packet. */
        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800e1c2:	4620      	mov	r0, r4
 800e1c4:	f000 fa6c 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
    }
}
 800e1c8:	b002      	add	sp, #8
 800e1ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        pxNetworkBuffer->pxEndPoint = pxEndPoint;
 800e1ce:	9b00      	ldr	r3, [sp, #0]
 800e1d0:	6323      	str	r3, [r4, #48]	@ 0x30
 800e1d2:	e7f0      	b.n	800e1b6 <vProcessGeneratedUDPPacket_IPv4+0x26>
                pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 800e1d4:	8ea3      	ldrh	r3, [r4, #52]	@ 0x34
 800e1d6:	84ab      	strh	r3, [r5, #36]	@ 0x24
                pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 800e1d8:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 800e1da:	846b      	strh	r3, [r5, #34]	@ 0x22
                pxUDPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( UDPHeader_t ) );
 800e1dc:	fa1f fe86 	uxth.w	lr, r6
 800e1e0:	f10e 0308 	add.w	r3, lr, #8
 800e1e4:	b29a      	uxth	r2, r3
 800e1e6:	84eb      	strh	r3, [r5, #38]	@ 0x26
                pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 800e1e8:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800e1ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800e1f0:	84eb      	strh	r3, [r5, #38]	@ 0x26
                pxUDPHeader->usChecksum = 0U;
 800e1f2:	2300      	movs	r3, #0
 800e1f4:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
 800e1f8:	f885 3029 	strb.w	r3, [r5, #41]	@ 0x29
                ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
 800e1fc:	6a67      	ldr	r7, [r4, #36]	@ 0x24
 800e1fe:	46bc      	mov	ip, r7
 800e200:	f81c 8f06 	ldrb.w	r8, [ip, #6]!
            ( void ) memcpy( pvCopyDest, pvCopySource, sizeof( ucDefaultPartUDPPacketHeader ) );
 800e204:	4e38      	ldr	r6, [pc, #224]	@ (800e2e8 <vProcessGeneratedUDPPacket_IPv4+0x158>)
 800e206:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e208:	f8c7 0006 	str.w	r0, [r7, #6]
 800e20c:	f8cc 1004 	str.w	r1, [ip, #4]
 800e210:	f8cc 2008 	str.w	r2, [ip, #8]
 800e214:	f8cc 300c 	str.w	r3, [ip, #12]
 800e218:	ce03      	ldmia	r6!, {r0, r1}
 800e21a:	f8cc 0010 	str.w	r0, [ip, #16]
 800e21e:	f8cc 1014 	str.w	r1, [ip, #20]
                pxIPHeader->usLength = ( uint16_t ) ( uxPayloadSize + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
 800e222:	f10e 031c 	add.w	r3, lr, #28
 800e226:	b29a      	uxth	r2, r3
 800e228:	822b      	strh	r3, [r5, #16]
            pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 800e22a:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800e22e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800e232:	822b      	strh	r3, [r5, #16]
            pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->xIPAddress.ulIP_IPv4;
 800e234:	6963      	ldr	r3, [r4, #20]
 800e236:	f8c5 301e 	str.w	r3, [r5, #30]
            if( pxNetworkBuffer->pxEndPoint != NULL )
 800e23a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800e23c:	b113      	cbz	r3, 800e244 <vProcessGeneratedUDPPacket_IPv4+0xb4>
                pxIPHeader->ulSourceIPAddress = pxNetworkBuffer->pxEndPoint->ipv4_settings.ulIPAddress;
 800e23e:	681b      	ldr	r3, [r3, #0]
 800e240:	f8c5 301a 	str.w	r3, [r5, #26]
                pxIPHeader->usFragmentOffset = 0U;
 800e244:	2600      	movs	r6, #0
 800e246:	752e      	strb	r6, [r5, #20]
 800e248:	756e      	strb	r6, [r5, #21]
                pxIPHeader->usHeaderChecksum = 0U;
 800e24a:	762e      	strb	r6, [r5, #24]
 800e24c:	766e      	strb	r6, [r5, #25]
                pxIPHeader->usHeaderChecksum = usGenerateChecksum( 0U, ( uint8_t * ) &( pxIPHeader->ucVersionHeaderLength ), uxIPHeaderSizePacket( pxNetworkBuffer ) );
 800e24e:	f105 070e 	add.w	r7, r5, #14
 800e252:	4620      	mov	r0, r4
 800e254:	f7f9 f940 	bl	80074d8 <uxIPHeaderSizePacket>
 800e258:	4602      	mov	r2, r0
 800e25a:	4639      	mov	r1, r7
 800e25c:	4630      	mov	r0, r6
 800e25e:	f7f9 fe8f 	bl	8007f80 <usGenerateChecksum>
 800e262:	8328      	strh	r0, [r5, #24]
                pxIPHeader->usHeaderChecksum = ( uint16_t ) ~FreeRTOS_htons( pxIPHeader->usHeaderChecksum );
 800e264:	f3c0 230f 	ubfx	r3, r0, #8, #16
 800e268:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800e26c:	b29b      	uxth	r3, r3
 800e26e:	43db      	mvns	r3, r3
 800e270:	832b      	strh	r3, [r5, #24]
                if( ( ucSocketOptions & ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT ) != 0U )
 800e272:	f018 0f02 	tst.w	r8, #2
 800e276:	d119      	bne.n	800e2ac <vProcessGeneratedUDPPacket_IPv4+0x11c>
                    pxUDPPacket->xUDPHeader.usChecksum = 0U;
 800e278:	2300      	movs	r3, #0
 800e27a:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
 800e27e:	f885 3029 	strb.w	r3, [r5, #41]	@ 0x29
        if( pxNetworkBuffer->pxEndPoint != NULL )
 800e282:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800e284:	b35b      	cbz	r3, 800e2de <vProcessGeneratedUDPPacket_IPv4+0x14e>
            NetworkInterface_t * pxInterface = pxNetworkBuffer->pxEndPoint->pxNetworkInterface;
 800e286:	f8d3 0158 	ldr.w	r0, [r3, #344]	@ 0x158
            EthernetHeader_t * pxEthernetHeader = ( ( EthernetHeader_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800e28a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
            ( void ) memcpy( pxEthernetHeader->xSourceAddress.ucBytes, pxNetworkBuffer->pxEndPoint->xMACAddress.ucBytes, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800e28c:	f8d3 10e8 	ldr.w	r1, [r3, #232]	@ 0xe8
 800e290:	f8c2 1006 	str.w	r1, [r2, #6]
 800e294:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 800e298:	8153      	strh	r3, [r2, #10]
            if( ( pxInterface != NULL ) && ( pxInterface->pfOutput != NULL ) )
 800e29a:	2800      	cmp	r0, #0
 800e29c:	d094      	beq.n	800e1c8 <vProcessGeneratedUDPPacket_IPv4+0x38>
 800e29e:	68c3      	ldr	r3, [r0, #12]
 800e2a0:	2b00      	cmp	r3, #0
 800e2a2:	d091      	beq.n	800e1c8 <vProcessGeneratedUDPPacket_IPv4+0x38>
                ( void ) pxInterface->pfOutput( pxInterface, pxNetworkBuffer, pdTRUE );
 800e2a4:	2201      	movs	r2, #1
 800e2a6:	4621      	mov	r1, r4
 800e2a8:	4798      	blx	r3
 800e2aa:	e78d      	b.n	800e1c8 <vProcessGeneratedUDPPacket_IPv4+0x38>
                    ( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxUDPPacket, pxNetworkBuffer->xDataLength, pdTRUE );
 800e2ac:	2201      	movs	r2, #1
 800e2ae:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800e2b0:	4628      	mov	r0, r5
 800e2b2:	f7f9 ff47 	bl	8008144 <usGenerateProtocolChecksum>
 800e2b6:	e7e4      	b.n	800e282 <vProcessGeneratedUDPPacket_IPv4+0xf2>
            vARPRefreshCacheEntry( NULL, ulIPAddress, NULL );
 800e2b8:	2200      	movs	r2, #0
 800e2ba:	9901      	ldr	r1, [sp, #4]
 800e2bc:	4610      	mov	r0, r2
 800e2be:	f7f7 fe77 	bl	8005fb0 <vARPRefreshCacheEntry>
            pxNetworkBuffer->pxEndPoint = FreeRTOS_FindEndPointOnNetMask( pxNetworkBuffer->xIPAddress.ulIP_IPv4, 11 );
 800e2c2:	210b      	movs	r1, #11
 800e2c4:	6960      	ldr	r0, [r4, #20]
 800e2c6:	f7fb fc49 	bl	8009b5c <FreeRTOS_FindEndPointOnNetMask>
 800e2ca:	6320      	str	r0, [r4, #48]	@ 0x30
            if( pxNetworkBuffer->pxEndPoint == NULL )
 800e2cc:	2800      	cmp	r0, #0
 800e2ce:	f43f af78 	beq.w	800e1c2 <vProcessGeneratedUDPPacket_IPv4+0x32>
                pxNetworkBuffer->xIPAddress.ulIP_IPv4 = ulIPAddress;
 800e2d2:	9b01      	ldr	r3, [sp, #4]
 800e2d4:	6163      	str	r3, [r4, #20]
                vARPGenerateRequestPacket( pxNetworkBuffer );
 800e2d6:	4620      	mov	r0, r4
 800e2d8:	f7f7 ff76 	bl	80061c8 <vARPGenerateRequestPacket>
 800e2dc:	e7d1      	b.n	800e282 <vProcessGeneratedUDPPacket_IPv4+0xf2>
            vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800e2de:	4620      	mov	r0, r4
 800e2e0:	f000 f9de 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 800e2e4:	e770      	b.n	800e1c8 <vProcessGeneratedUDPPacket_IPv4+0x38>
 800e2e6:	bf00      	nop
 800e2e8:	0800ff4c 	.word	0x0800ff4c

0800e2ec <xProcessReceivedUDPPacket_IPv4>:
    BaseType_t xReturn = pdPASS;
    FreeRTOS_Socket_t * pxSocket;
    const UDPPacket_t * pxUDPPacket;
    const NetworkEndPoint_t * pxEndpoint;

    configASSERT( pxNetworkBuffer != NULL );
 800e2ec:	b380      	cbz	r0, 800e350 <xProcessReceivedUDPPacket_IPv4+0x64>
{
 800e2ee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e2f2:	4615      	mov	r5, r2
 800e2f4:	4604      	mov	r4, r0
    configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800e2f6:	6a46      	ldr	r6, [r0, #36]	@ 0x24
 800e2f8:	b39e      	cbz	r6, 800e362 <xProcessReceivedUDPPacket_IPv4+0x76>

    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    pxUDPPacket = ( ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
    pxEndpoint = pxNetworkBuffer->pxEndPoint;
 800e2fa:	f8d0 8030 	ldr.w	r8, [r0, #48]	@ 0x30

    /* Caller must check for minimum packet size. */
    pxSocket = pxUDPSocketLookup( usPort );
 800e2fe:	4608      	mov	r0, r1
 800e300:	f7fc f9ea 	bl	800a6d8 <pxUDPSocketLookup>

    *pxIsWaitingForARPResolution = pdFALSE;
 800e304:	2300      	movs	r3, #0
 800e306:	602b      	str	r3, [r5, #0]

    do
    {
        if( pxSocket != NULL )
 800e308:	4607      	mov	r7, r0
 800e30a:	2800      	cmp	r0, #0
 800e30c:	d04b      	beq.n	800e3a6 <xProcessReceivedUDPPacket_IPv4+0xba>
        {
            if( ( pxEndpoint != NULL ) && ( pxEndpoint->ipv4_settings.ulIPAddress != 0U ) )
 800e30e:	f1b8 0f00 	cmp.w	r8, #0
 800e312:	d002      	beq.n	800e31a <xProcessReceivedUDPPacket_IPv4+0x2e>
 800e314:	f8d8 3000 	ldr.w	r3, [r8]
 800e318:	bb63      	cbnz	r3, 800e374 <xProcessReceivedUDPPacket_IPv4+0x88>
                if( xReturn == pdPASS ) /*lint !e774: Boolean within 'if' always evaluates to True, depending on configuration. [MISRA 2012 Rule 14.3, required. */
            #else
                /* xReturn is still pdPASS. */
            #endif
            {
                vTaskSuspendAll();
 800e31a:	f7f6 fc7b 	bl	8004c14 <vTaskSuspendAll>
                {
                    /* Add the network packet to the list of packets to be
                     * processed by the socket. */
                    vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
 800e31e:	4621      	mov	r1, r4
 800e320:	f107 0054 	add.w	r0, r7, #84	@ 0x54
 800e324:	f7f5 fd4e 	bl	8003dc4 <vListInsertEnd>
                }
                ( void ) xTaskResumeAll();
 800e328:	f7f6 fd0e 	bl	8004d48 <xTaskResumeAll>

                /* Set the socket's receive event */
                if( pxSocket->xEventGroup != NULL )
 800e32c:	6878      	ldr	r0, [r7, #4]
 800e32e:	b110      	cbz	r0, 800e336 <xProcessReceivedUDPPacket_IPv4+0x4a>
                {
                    ( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_RECEIVE );
 800e330:	2101      	movs	r1, #1
 800e332:	f7f5 fcd0 	bl	8003cd6 <xEventGroupSetBits>
                }

                #if ( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
                {
                    if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_READ ) ) != 0U ) )
 800e336:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e338:	b11b      	cbz	r3, 800e342 <xProcessReceivedUDPPacket_IPv4+0x56>
 800e33a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e33c:	f012 0f01 	tst.w	r2, #1
 800e340:	d127      	bne.n	800e392 <xProcessReceivedUDPPacket_IPv4+0xa6>
                }
                #endif

                #if ( ipconfigUSE_DHCP == 1 )
                {
                    if( xIsDHCPSocket( pxSocket ) != 0 )
 800e342:	4638      	mov	r0, r7
 800e344:	f7f8 fe08 	bl	8006f58 <xIsDHCPSocket>
 800e348:	bb40      	cbnz	r0, 800e39c <xProcessReceivedUDPPacket_IPv4+0xb0>
    BaseType_t xReturn = pdPASS;
 800e34a:	2001      	movs	r0, #1
            }
        }
    } while( ipFALSE_BOOL );

    return xReturn;
}
 800e34c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e350:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e354:	f383 8811 	msr	BASEPRI, r3
 800e358:	f3bf 8f6f 	isb	sy
 800e35c:	f3bf 8f4f 	dsb	sy
    configASSERT( pxNetworkBuffer != NULL );
 800e360:	e7fe      	b.n	800e360 <xProcessReceivedUDPPacket_IPv4+0x74>
 800e362:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e366:	f383 8811 	msr	BASEPRI, r3
 800e36a:	f3bf 8f6f 	isb	sy
 800e36e:	f3bf 8f4f 	dsb	sy
    configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800e372:	e7fe      	b.n	800e372 <xProcessReceivedUDPPacket_IPv4+0x86>
                if( xCheckRequiresARPResolution( pxNetworkBuffer ) == pdTRUE )
 800e374:	4620      	mov	r0, r4
 800e376:	f7f8 f88d 	bl	8006494 <xCheckRequiresARPResolution>
 800e37a:	2801      	cmp	r0, #1
 800e37c:	d103      	bne.n	800e386 <xProcessReceivedUDPPacket_IPv4+0x9a>
                    *pxIsWaitingForARPResolution = pdTRUE;
 800e37e:	2301      	movs	r3, #1
 800e380:	602b      	str	r3, [r5, #0]
                    xReturn = pdFAIL;
 800e382:	2000      	movs	r0, #0
                    break;
 800e384:	e7e2      	b.n	800e34c <xProcessReceivedUDPPacket_IPv4+0x60>
                    vARPRefreshCacheEntryAge( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 800e386:	f8d6 101a 	ldr.w	r1, [r6, #26]
 800e38a:	1db0      	adds	r0, r6, #6
 800e38c:	f7f7 fdf0 	bl	8005f70 <vARPRefreshCacheEntryAge>
 800e390:	e7c3      	b.n	800e31a <xProcessReceivedUDPPacket_IPv4+0x2e>
                        ( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, ( EventBits_t ) eSELECT_READ );
 800e392:	2101      	movs	r1, #1
 800e394:	6818      	ldr	r0, [r3, #0]
 800e396:	f7f5 fc9e 	bl	8003cd6 <xEventGroupSetBits>
 800e39a:	e7d2      	b.n	800e342 <xProcessReceivedUDPPacket_IPv4+0x56>
                        ( void ) xSendDHCPEvent( pxNetworkBuffer->pxEndPoint );
 800e39c:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 800e39e:	f7f9 ff71 	bl	8008284 <xSendDHCPEvent>
    BaseType_t xReturn = pdPASS;
 800e3a2:	2001      	movs	r0, #1
 800e3a4:	e7d2      	b.n	800e34c <xProcessReceivedUDPPacket_IPv4+0x60>
                xReturn = pdFAIL;
 800e3a6:	2000      	movs	r0, #0
 800e3a8:	e7d0      	b.n	800e34c <xProcessReceivedUDPPacket_IPv4+0x60>

0800e3aa <pxGetEndpoint>:
 * @returns Pointer to the first end point of the given IP type from the
 *          list of end points.
 */
static NetworkEndPoint_t * pxGetEndpoint( BaseType_t xIPType,
                                          BaseType_t xIsGlobal )
{
 800e3aa:	b570      	push	{r4, r5, r6, lr}
 800e3ac:	4605      	mov	r5, r0
 800e3ae:	460e      	mov	r6, r1
    NetworkEndPoint_t * pxEndPoint;

    for( pxEndPoint = FreeRTOS_FirstEndPoint( NULL );
 800e3b0:	2000      	movs	r0, #0
 800e3b2:	f7fb fb39 	bl	8009a28 <FreeRTOS_FirstEndPoint>
 800e3b6:	4604      	mov	r4, r0
 800e3b8:	e007      	b.n	800e3ca <pxGetEndpoint+0x20>
        if( xIPType == ( BaseType_t ) ipTYPE_IPv6 )
        {
            if( pxEndPoint->bits.bIPv6 != 0U )
            {
                IPv6_Type_t eEndpointType = xIPv6_GetIPType( &( pxEndPoint->ipv6_settings.xIPAddress ) );
                BaseType_t xEndpointGlobal = ( eEndpointType == eIPv6_Global ) ? pdTRUE : pdFALSE;
 800e3ba:	2300      	movs	r3, #0

                if( xEndpointGlobal == xIsGlobal )
 800e3bc:	42b3      	cmp	r3, r6
 800e3be:	d014      	beq.n	800e3ea <pxGetEndpoint+0x40>
         pxEndPoint = FreeRTOS_NextEndPoint( NULL, pxEndPoint ) )
 800e3c0:	4621      	mov	r1, r4
 800e3c2:	2000      	movs	r0, #0
 800e3c4:	f7fb fb40 	bl	8009a48 <FreeRTOS_NextEndPoint>
 800e3c8:	4604      	mov	r4, r0
         pxEndPoint != NULL;
 800e3ca:	b174      	cbz	r4, 800e3ea <pxGetEndpoint+0x40>
        if( xIPType == ( BaseType_t ) ipTYPE_IPv6 )
 800e3cc:	2d60      	cmp	r5, #96	@ 0x60
 800e3ce:	d1f7      	bne.n	800e3c0 <pxGetEndpoint+0x16>
            if( pxEndPoint->bits.bIPv6 != 0U )
 800e3d0:	f894 30f0 	ldrb.w	r3, [r4, #240]	@ 0xf0
 800e3d4:	f013 0f08 	tst.w	r3, #8
 800e3d8:	d0f2      	beq.n	800e3c0 <pxGetEndpoint+0x16>
                IPv6_Type_t eEndpointType = xIPv6_GetIPType( &( pxEndPoint->ipv6_settings.xIPAddress ) );
 800e3da:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 800e3de:	f7fb fc13 	bl	8009c08 <xIPv6_GetIPType>
                BaseType_t xEndpointGlobal = ( eEndpointType == eIPv6_Global ) ? pdTRUE : pdFALSE;
 800e3e2:	2800      	cmp	r0, #0
 800e3e4:	d1e9      	bne.n	800e3ba <pxGetEndpoint+0x10>
 800e3e6:	2301      	movs	r3, #1
 800e3e8:	e7e8      	b.n	800e3bc <pxGetEndpoint+0x12>
            }
        }
    }

    return pxEndPoint;
}
 800e3ea:	4620      	mov	r0, r4
 800e3ec:	bd70      	pop	{r4, r5, r6, pc}

0800e3ee <prvStartLookup>:
 * @param[out] pxLostBuffer  The pointee will be set to true in case the network packet got released
 *                            ( the ownership was taken ).
 */
static eARPLookupResult_t prvStartLookup( NetworkBufferDescriptor_t * const pxNetworkBuffer,
                                          BaseType_t * pxLostBuffer )
{
 800e3ee:	b538      	push	{r3, r4, r5, lr}
 800e3f0:	4604      	mov	r4, r0
 800e3f2:	460d      	mov	r5, r1

    FreeRTOS_printf( ( "Looking up %pip with%s end-point\n",
                       ( void * ) pxNetworkBuffer->xIPAddress.xIP_IPv6.ucBytes,
                       ( pxNetworkBuffer->pxEndPoint != NULL ) ? "" : "out" ) );

    if( pxNetworkBuffer->pxEndPoint == NULL )
 800e3f4:	6b03      	ldr	r3, [r0, #48]	@ 0x30
 800e3f6:	b153      	cbz	r3, 800e40e <prvStartLookup+0x20>
        BaseType_t xIsGlobal = ( eTargetType == eIPv6_Global ) ? pdTRUE : pdFALSE;
        pxNetworkBuffer->pxEndPoint = pxGetEndpoint( ( BaseType_t ) ipTYPE_IPv6, xIsGlobal );
        FreeRTOS_printf( ( "prvStartLookup: Got an end-point: %s\n", pxNetworkBuffer->pxEndPoint ? "yes" : "no" ) );
    }

    if( pxNetworkBuffer->pxEndPoint != NULL )
 800e3f8:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800e3fa:	b133      	cbz	r3, 800e40a <prvStartLookup+0x1c>
    {
        vNDSendNeighbourSolicitation( pxNetworkBuffer, &( pxNetworkBuffer->xIPAddress.xIP_IPv6 ) );
 800e3fc:	f104 0114 	add.w	r1, r4, #20
 800e400:	4620      	mov	r0, r4
 800e402:	f7fa fdb7 	bl	8008f74 <vNDSendNeighbourSolicitation>

        /* pxNetworkBuffer has been sent and released.
         * Make sure it won't be used again.. */
        *pxLostBuffer = pdTRUE;
 800e406:	2301      	movs	r3, #1
 800e408:	602b      	str	r3, [r5, #0]
    }

    return eReturned;
}
 800e40a:	2000      	movs	r0, #0
 800e40c:	bd38      	pop	{r3, r4, r5, pc}
        IPv6_Type_t eTargetType = xIPv6_GetIPType( &( pxNetworkBuffer->xIPAddress.xIP_IPv6 ) );
 800e40e:	3014      	adds	r0, #20
 800e410:	f7fb fbfa 	bl	8009c08 <xIPv6_GetIPType>
        BaseType_t xIsGlobal = ( eTargetType == eIPv6_Global ) ? pdTRUE : pdFALSE;
 800e414:	b928      	cbnz	r0, 800e422 <prvStartLookup+0x34>
 800e416:	2101      	movs	r1, #1
        pxNetworkBuffer->pxEndPoint = pxGetEndpoint( ( BaseType_t ) ipTYPE_IPv6, xIsGlobal );
 800e418:	2060      	movs	r0, #96	@ 0x60
 800e41a:	f7ff ffc6 	bl	800e3aa <pxGetEndpoint>
 800e41e:	6320      	str	r0, [r4, #48]	@ 0x30
 800e420:	e7ea      	b.n	800e3f8 <prvStartLookup+0xa>
        BaseType_t xIsGlobal = ( eTargetType == eIPv6_Global ) ? pdTRUE : pdFALSE;
 800e422:	2100      	movs	r1, #0
 800e424:	e7f8      	b.n	800e418 <prvStartLookup+0x2a>

0800e426 <vProcessGeneratedUDPPacket_IPv6>:
 *        packet such as ARP cache check and address resolution.
 *
 * @param[in] pxNetworkBuffer The network buffer carrying the packet.
 */
void vProcessGeneratedUDPPacket_IPv6( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 800e426:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e42a:	b086      	sub	sp, #24
 800e42c:	4604      	mov	r4, r0
    eARPLookupResult_t eReturned;
    size_t uxPayloadSize;
    /* memcpy() helper variables for MISRA Rule 21.15 compliance*/
    NetworkInterface_t * pxInterface = NULL;
    EthernetHeader_t * pxEthernetHeader = NULL;
    BaseType_t xLostBuffer = pdFALSE;
 800e42e:	2300      	movs	r3, #0
 800e430:	9305      	str	r3, [sp, #20]
    NetworkEndPoint_t * pxEndPoint = NULL;
 800e432:	9304      	str	r3, [sp, #16]
    /* Map the UDP packet onto the start of the frame. */

    /* MISRA Ref 11.3.1 [Misaligned access] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    pxUDPPacket_IPv6 = ( ( UDPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800e434:	6a46      	ldr	r6, [r0, #36]	@ 0x24
    pxIPHeader_IPv6 = &( pxUDPPacket_IPv6->xIPHeader );

    /* Remember the original address. It might get replaced with
     * the address of the gateway. */
    ( void ) memcpy( xIPv6Address.ucBytes, pxNetworkBuffer->xIPAddress.xIP_IPv6.ucBytes, sizeof( xIPv6Address.ucBytes ) );
 800e436:	46ec      	mov	ip, sp
 800e438:	6940      	ldr	r0, [r0, #20]
 800e43a:	69a1      	ldr	r1, [r4, #24]
 800e43c:	69e2      	ldr	r2, [r4, #28]
 800e43e:	6a23      	ldr	r3, [r4, #32]
 800e440:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
            uxPayloadSize = pxNetworkBuffer->xDataLength - uxHeadersSize;
        }
        else
    #endif
    {
        uxPayloadSize = pxNetworkBuffer->xDataLength - sizeof( UDPPacket_IPv6_t );
 800e444:	f8d4 8028 	ldr.w	r8, [r4, #40]	@ 0x28
    }

    /* Look in the IPv6 MAC-address cache for the target IP-address. */
    eReturned = eNDGetCacheEntry( &( pxNetworkBuffer->xIPAddress.xIP_IPv6 ), &( pxUDPPacket_IPv6->xEthernetHeader.xDestinationAddress ),
 800e448:	4662      	mov	r2, ip
 800e44a:	4631      	mov	r1, r6
 800e44c:	f104 0014 	add.w	r0, r4, #20
 800e450:	f7fa fce4 	bl	8008e1c <eNDGetCacheEntry>
 800e454:	4605      	mov	r5, r0
                                  &( pxEndPoint ) );

    if( eReturned != eCantSendPacket )
 800e456:	2802      	cmp	r0, #2
 800e458:	d00d      	beq.n	800e476 <vProcessGeneratedUDPPacket_IPv6+0x50>
 800e45a:	f1a8 073e 	sub.w	r7, r8, #62	@ 0x3e
    {
        if( eReturned == eARPCacheHit )
 800e45e:	2801      	cmp	r0, #1
 800e460:	d022      	beq.n	800e4a8 <vProcessGeneratedUDPPacket_IPv6+0x82>
                    pxUDPPacket_IPv6->xUDPHeader.usChecksum = 0U;
                }
            }
            #endif /* if ( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 ) */
        }
        else if( eReturned == eARPCacheMiss )
 800e462:	2800      	cmp	r0, #0
 800e464:	d16a      	bne.n	800e53c <vProcessGeneratedUDPPacket_IPv6+0x116>
        {
            if( pxEndPoint != NULL )
 800e466:	9b04      	ldr	r3, [sp, #16]
 800e468:	b103      	cbz	r3, 800e46c <vProcessGeneratedUDPPacket_IPv6+0x46>
            {
                pxNetworkBuffer->pxEndPoint = pxEndPoint;
 800e46a:	6323      	str	r3, [r4, #48]	@ 0x30
            }

            eReturned = prvStartLookup( pxNetworkBuffer, &( xLostBuffer ) );
 800e46c:	a905      	add	r1, sp, #20
 800e46e:	4620      	mov	r0, r4
 800e470:	f7ff ffbd 	bl	800e3ee <prvStartLookup>
 800e474:	4605      	mov	r5, r0
             * sent out for the queried IP address. */
            eReturned = eCantSendPacket;
        }
    }

    if( xLostBuffer == pdTRUE )
 800e476:	9b05      	ldr	r3, [sp, #20]
 800e478:	2b01      	cmp	r3, #1
 800e47a:	d012      	beq.n	800e4a2 <vProcessGeneratedUDPPacket_IPv6+0x7c>
    {
        /* An ND solicitation or ARP request has been sent. */
    }
    else if( eReturned != eCantSendPacket )
 800e47c:	2d02      	cmp	r5, #2
 800e47e:	d063      	beq.n	800e548 <vProcessGeneratedUDPPacket_IPv6+0x122>
    {
        /* The network driver is responsible for freeing the network buffer
         * after the packet has been sent. */

        if( pxNetworkBuffer->pxEndPoint != NULL )
 800e480:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800e482:	2b00      	cmp	r3, #0
 800e484:	d05c      	beq.n	800e540 <vProcessGeneratedUDPPacket_IPv6+0x11a>
        {
            pxInterface = pxNetworkBuffer->pxEndPoint->pxNetworkInterface;
 800e486:	f8d3 0158 	ldr.w	r0, [r3, #344]	@ 0x158
            /* MISRA Ref 11.3.1 [Misaligned access] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
            /* coverity[misra_c_2012_rule_11_3_violation] */
            pxEthernetHeader = ( ( EthernetHeader_t * ) pxNetworkBuffer->pucEthernetBuffer );
 800e48a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
            ( void ) memcpy( pxEthernetHeader->xSourceAddress.ucBytes,
 800e48c:	f8d3 10e8 	ldr.w	r1, [r3, #232]	@ 0xe8
 800e490:	f8c2 1006 	str.w	r1, [r2, #6]
 800e494:	f8b3 30ec 	ldrh.w	r3, [r3, #236]	@ 0xec
 800e498:	8153      	strh	r3, [r2, #10]
                    pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
                }
            }
            #endif /* if( ipconfigETHERNET_MINIMUM_PACKET_BYTES > 0 ) */
            iptraceNETWORK_INTERFACE_OUTPUT( pxNetworkBuffer->xDataLength, pxNetworkBuffer->pucEthernetBuffer );
            ( void ) pxInterface->pfOutput( pxInterface, pxNetworkBuffer, pdTRUE );
 800e49a:	68c3      	ldr	r3, [r0, #12]
 800e49c:	2201      	movs	r2, #1
 800e49e:	4621      	mov	r1, r4
 800e4a0:	4798      	blx	r3
    {
        /* The packet can't be sent (DHCP not completed?).  Just drop the
         * packet. */
        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
    }
}
 800e4a2:	b006      	add	sp, #24
 800e4a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            pxNetworkBuffer->pxEndPoint = pxEndPoint;
 800e4a8:	9b04      	ldr	r3, [sp, #16]
 800e4aa:	6323      	str	r3, [r4, #48]	@ 0x30
                pxIPHeader_IPv6->ucVersionTrafficClass = 0x60;
 800e4ac:	2360      	movs	r3, #96	@ 0x60
 800e4ae:	73b3      	strb	r3, [r6, #14]
                pxIPHeader_IPv6->ucTrafficClassFlow = 0;
 800e4b0:	2100      	movs	r1, #0
 800e4b2:	73f1      	strb	r1, [r6, #15]
                pxIPHeader_IPv6->usFlowLabel = 0;
 800e4b4:	7431      	strb	r1, [r6, #16]
 800e4b6:	7471      	strb	r1, [r6, #17]
                pxIPHeader_IPv6->ucHopLimit = 255;
 800e4b8:	23ff      	movs	r3, #255	@ 0xff
 800e4ba:	7573      	strb	r3, [r6, #21]
                pxUDPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength - ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv6_HEADER ) );
 800e4bc:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800e4be:	3b36      	subs	r3, #54	@ 0x36
 800e4c0:	b298      	uxth	r0, r3
 800e4c2:	8773      	strh	r3, [r6, #58]	@ 0x3a
                pxIPHeader_IPv6->ucNextHeader = ipPROTOCOL_UDP;
 800e4c4:	2211      	movs	r2, #17
 800e4c6:	7532      	strb	r2, [r6, #20]
                pxIPHeader_IPv6->usPayloadLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength - sizeof( IPPacket_IPv6_t ) );
 800e4c8:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 800e4ca:	3a36      	subs	r2, #54	@ 0x36
 800e4cc:	fa1f fc82 	uxth.w	ip, r2
 800e4d0:	8272      	strh	r2, [r6, #18]
                pxIPHeader_IPv6->usPayloadLength = FreeRTOS_htons( pxIPHeader_IPv6->usPayloadLength );
 800e4d2:	f3c2 2207 	ubfx	r2, r2, #8, #8
 800e4d6:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
 800e4da:	8272      	strh	r2, [r6, #18]
                pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 800e4dc:	8ea2      	ldrh	r2, [r4, #52]	@ 0x34
 800e4de:	8732      	strh	r2, [r6, #56]	@ 0x38
                pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 800e4e0:	8ee2      	ldrh	r2, [r4, #54]	@ 0x36
 800e4e2:	86f2      	strh	r2, [r6, #54]	@ 0x36
                pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 800e4e4:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800e4e8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800e4ec:	8773      	strh	r3, [r6, #58]	@ 0x3a
                pxUDPHeader->usChecksum = 0U;
 800e4ee:	f886 103c 	strb.w	r1, [r6, #60]	@ 0x3c
 800e4f2:	f886 103d 	strb.w	r1, [r6, #61]	@ 0x3d
                if( pxNetworkBuffer->pxEndPoint != NULL )
 800e4f6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800e4f8:	b15b      	cbz	r3, 800e512 <vProcessGeneratedUDPPacket_IPv6+0xec>
                    ( void ) memcpy( pxIPHeader_IPv6->xSourceAddress.ucBytes,
 800e4fa:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 800e4fc:	6bd9      	ldr	r1, [r3, #60]	@ 0x3c
 800e4fe:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800e500:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800e502:	f8c6 0016 	str.w	r0, [r6, #22]
 800e506:	f8c6 101a 	str.w	r1, [r6, #26]
 800e50a:	f8c6 201e 	str.w	r2, [r6, #30]
 800e50e:	f8c6 3022 	str.w	r3, [r6, #34]	@ 0x22
                ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
 800e512:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800e514:	799a      	ldrb	r2, [r3, #6]
                pxIPHeader_IPv6->usPayloadLength = FreeRTOS_htons( sizeof( UDPHeader_t ) + uxPayloadSize );
 800e516:	f107 0308 	add.w	r3, r7, #8
 800e51a:	b29b      	uxth	r3, r3
 800e51c:	021b      	lsls	r3, r3, #8
 800e51e:	b29b      	uxth	r3, r3
 800e520:	f1a8 0836 	sub.w	r8, r8, #54	@ 0x36
 800e524:	ea43 2318 	orr.w	r3, r3, r8, lsr #8
 800e528:	8273      	strh	r3, [r6, #18]
                if( ( ucSocketOptions & ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT ) != 0U )
 800e52a:	f012 0f02 	tst.w	r2, #2
 800e52e:	d0a2      	beq.n	800e476 <vProcessGeneratedUDPPacket_IPv6+0x50>
                    ( void ) usGenerateProtocolChecksum( ( uint8_t * ) pxUDPPacket_IPv6, pxNetworkBuffer->xDataLength, pdTRUE );
 800e530:	2201      	movs	r2, #1
 800e532:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800e534:	4630      	mov	r0, r6
 800e536:	f7f9 fe05 	bl	8008144 <usGenerateProtocolChecksum>
 800e53a:	e79c      	b.n	800e476 <vProcessGeneratedUDPPacket_IPv6+0x50>
            eReturned = eCantSendPacket;
 800e53c:	2502      	movs	r5, #2
 800e53e:	e79a      	b.n	800e476 <vProcessGeneratedUDPPacket_IPv6+0x50>
            vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800e540:	4620      	mov	r0, r4
 800e542:	f000 f8ad 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
 800e546:	e7ac      	b.n	800e4a2 <vProcessGeneratedUDPPacket_IPv6+0x7c>
        vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800e548:	4620      	mov	r0, r4
 800e54a:	f000 f8a9 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
}
 800e54e:	e7a8      	b.n	800e4a2 <vProcessGeneratedUDPPacket_IPv6+0x7c>

0800e550 <xProcessReceivedUDPPacket_IPv6>:
 * @return pdPASS in case the UDP packet could be processed. Else pdFAIL is returned.
 */
BaseType_t xProcessReceivedUDPPacket_IPv6( NetworkBufferDescriptor_t * pxNetworkBuffer,
                                           uint16_t usPort,
                                           BaseType_t * pxIsWaitingForARPResolution )
{
 800e550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* Returning pdPASS means that the packet was consumed, released. */
    BaseType_t xReturn = pdPASS;
    FreeRTOS_Socket_t * pxSocket;
    const UDPPacket_IPv6_t * pxUDPPacket_IPv6;

    configASSERT( pxNetworkBuffer != NULL );
 800e552:	b1b8      	cbz	r0, 800e584 <xProcessReceivedUDPPacket_IPv6+0x34>
 800e554:	4614      	mov	r4, r2
 800e556:	4605      	mov	r5, r0
    configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800e558:	6a46      	ldr	r6, [r0, #36]	@ 0x24
 800e55a:	b1e6      	cbz	r6, 800e596 <xProcessReceivedUDPPacket_IPv6+0x46>
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
    /* coverity[misra_c_2012_rule_11_3_violation] */
    pxUDPPacket_IPv6 = ( ( UDPPacket_IPv6_t * ) pxNetworkBuffer->pucEthernetBuffer );

    /* Caller must check for minimum packet size. */
    pxSocket = pxUDPSocketLookup( usPort );
 800e55c:	4608      	mov	r0, r1
 800e55e:	f7fc f8bb 	bl	800a6d8 <pxUDPSocketLookup>
 800e562:	4607      	mov	r7, r0

    *pxIsWaitingForARPResolution = pdFALSE;
 800e564:	2300      	movs	r3, #0
 800e566:	6023      	str	r3, [r4, #0]

    do
    {
        /* UDPv6 doesn't allow zero-checksum, refer to RFC2460 - section 8.1.
         * Some platforms (such as Zynq) pass the packet to upper layer for flexibility to allow zero-checksum. */
        if( pxUDPPacket_IPv6->xUDPHeader.usChecksum == 0U )
 800e568:	8fb3      	ldrh	r3, [r6, #60]	@ 0x3c
 800e56a:	2b00      	cmp	r3, #0
 800e56c:	d046      	beq.n	800e5fc <xProcessReceivedUDPPacket_IPv6+0xac>

            xReturn = pdFAIL;
            break;
        }

        if( pxSocket != NULL )
 800e56e:	2800      	cmp	r0, #0
 800e570:	d046      	beq.n	800e600 <xProcessReceivedUDPPacket_IPv6+0xb0>
        {
            if( xCheckRequiresARPResolution( pxNetworkBuffer ) == pdTRUE )
 800e572:	4628      	mov	r0, r5
 800e574:	f7f7 ff8e 	bl	8006494 <xCheckRequiresARPResolution>
 800e578:	2801      	cmp	r0, #1
 800e57a:	d115      	bne.n	800e5a8 <xProcessReceivedUDPPacket_IPv6+0x58>
            {
                /* Mark this packet as waiting for ARP resolution. */
                *pxIsWaitingForARPResolution = pdTRUE;
 800e57c:	2301      	movs	r3, #1
 800e57e:	6023      	str	r3, [r4, #0]

                /* Return a fail to show that the frame will not be processed right now. */
                xReturn = pdFAIL;
 800e580:	2000      	movs	r0, #0
                break;
 800e582:	e03c      	b.n	800e5fe <xProcessReceivedUDPPacket_IPv6+0xae>
 800e584:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e588:	f383 8811 	msr	BASEPRI, r3
 800e58c:	f3bf 8f6f 	isb	sy
 800e590:	f3bf 8f4f 	dsb	sy
    configASSERT( pxNetworkBuffer != NULL );
 800e594:	e7fe      	b.n	800e594 <xProcessReceivedUDPPacket_IPv6+0x44>
 800e596:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e59a:	f383 8811 	msr	BASEPRI, r3
 800e59e:	f3bf 8f6f 	isb	sy
 800e5a2:	f3bf 8f4f 	dsb	sy
    configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 800e5a6:	e7fe      	b.n	800e5a6 <xProcessReceivedUDPPacket_IPv6+0x56>
            }

            vNDRefreshCacheEntry( &( pxUDPPacket_IPv6->xEthernetHeader.xSourceAddress ), &( pxUDPPacket_IPv6->xIPHeader.xSourceAddress ),
 800e5a8:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
 800e5aa:	f106 0116 	add.w	r1, r6, #22
 800e5ae:	1db0      	adds	r0, r6, #6
 800e5b0:	f7fa fc8c 	bl	8008ecc <vNDRefreshCacheEntry>
                if( xReturn == pdPASS ) /*lint !e774: Boolean within 'if' always evaluates to True, depending on configuration. [MISRA 2012 Rule 14.3, required. */
            #else
                /* xReturn is still pdPASS. */
            #endif
            {
                vTaskSuspendAll();
 800e5b4:	f7f6 fb2e 	bl	8004c14 <vTaskSuspendAll>
                {
                    /* Add the network packet to the list of packets to be
                     * processed by the socket. */
                    vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
 800e5b8:	4629      	mov	r1, r5
 800e5ba:	f107 0054 	add.w	r0, r7, #84	@ 0x54
 800e5be:	f7f5 fc01 	bl	8003dc4 <vListInsertEnd>
                }
                ( void ) xTaskResumeAll();
 800e5c2:	f7f6 fbc1 	bl	8004d48 <xTaskResumeAll>

                /* Set the socket's receive event */
                if( pxSocket->xEventGroup != NULL )
 800e5c6:	6878      	ldr	r0, [r7, #4]
 800e5c8:	b110      	cbz	r0, 800e5d0 <xProcessReceivedUDPPacket_IPv6+0x80>
                {
                    ( void ) xEventGroupSetBits( pxSocket->xEventGroup, ( EventBits_t ) eSOCKET_RECEIVE );
 800e5ca:	2101      	movs	r1, #1
 800e5cc:	f7f5 fb83 	bl	8003cd6 <xEventGroupSetBits>
                }

                #if ( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
                {
                    if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & ( ( EventBits_t ) eSELECT_READ ) ) != 0U ) )
 800e5d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e5d2:	b11b      	cbz	r3, 800e5dc <xProcessReceivedUDPPacket_IPv6+0x8c>
 800e5d4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e5d6:	f012 0f01 	tst.w	r2, #1
 800e5da:	d105      	bne.n	800e5e8 <xProcessReceivedUDPPacket_IPv6+0x98>
                }
                #endif

                #if ( ipconfigUSE_DHCP == 1 )
                {
                    if( xIsDHCPSocket( pxSocket ) != 0 )
 800e5dc:	4638      	mov	r0, r7
 800e5de:	f7f8 fcbb 	bl	8006f58 <xIsDHCPSocket>
 800e5e2:	b930      	cbnz	r0, 800e5f2 <xProcessReceivedUDPPacket_IPv6+0xa2>
    BaseType_t xReturn = pdPASS;
 800e5e4:	2001      	movs	r0, #1
                xReturn = pdFAIL;
            }
        }
    } while( ipFALSE_BOOL );

    return xReturn;
 800e5e6:	e00a      	b.n	800e5fe <xProcessReceivedUDPPacket_IPv6+0xae>
                        ( void ) xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, ( EventBits_t ) eSELECT_READ );
 800e5e8:	2101      	movs	r1, #1
 800e5ea:	6818      	ldr	r0, [r3, #0]
 800e5ec:	f7f5 fb73 	bl	8003cd6 <xEventGroupSetBits>
 800e5f0:	e7f4      	b.n	800e5dc <xProcessReceivedUDPPacket_IPv6+0x8c>
                        ( void ) xSendDHCPEvent( pxNetworkBuffer->pxEndPoint );
 800e5f2:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 800e5f4:	f7f9 fe46 	bl	8008284 <xSendDHCPEvent>
    BaseType_t xReturn = pdPASS;
 800e5f8:	2001      	movs	r0, #1
 800e5fa:	e000      	b.n	800e5fe <xProcessReceivedUDPPacket_IPv6+0xae>
            xReturn = pdFAIL;
 800e5fc:	2000      	movs	r0, #0
}
 800e5fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                xReturn = pdFAIL;
 800e600:	2000      	movs	r0, #0
 800e602:	e7fc      	b.n	800e5fe <xProcessReceivedUDPPacket_IPv6+0xae>

0800e604 <xNetworkBuffersInitialise>:
static SemaphoreHandle_t xNetworkBufferSemaphore = NULL;

/*-----------------------------------------------------------*/

BaseType_t xNetworkBuffersInitialise( void )
{
 800e604:	b538      	push	{r3, r4, r5, lr}
    BaseType_t xReturn;
    uint32_t x;

    /* Only initialise the buffers and their associated kernel objects if they
     * have not been initialised before. */
    if( xNetworkBufferSemaphore == NULL )
 800e606:	4b1c      	ldr	r3, [pc, #112]	@ (800e678 <xNetworkBuffersInitialise+0x74>)
 800e608:	681b      	ldr	r3, [r3, #0]
 800e60a:	b123      	cbz	r3, 800e616 <xNetworkBuffersInitialise+0x12>

            uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
        }
    }

    if( xNetworkBufferSemaphore == NULL )
 800e60c:	4b1a      	ldr	r3, [pc, #104]	@ (800e678 <xNetworkBuffersInitialise+0x74>)
 800e60e:	681b      	ldr	r3, [r3, #0]
 800e610:	b383      	cbz	r3, 800e674 <xNetworkBuffersInitialise+0x70>
    {
        xReturn = pdFAIL;
    }
    else
    {
        xReturn = pdPASS;
 800e612:	2001      	movs	r0, #1
    }

    return xReturn;
}
 800e614:	bd38      	pop	{r3, r4, r5, pc}
            xNetworkBufferSemaphore = xSemaphoreCreateCountingStatic(
 800e616:	4a19      	ldr	r2, [pc, #100]	@ (800e67c <xNetworkBuffersInitialise+0x78>)
 800e618:	213c      	movs	r1, #60	@ 0x3c
 800e61a:	4608      	mov	r0, r1
 800e61c:	f7f5 fd4e 	bl	80040bc <xQueueCreateCountingSemaphoreStatic>
 800e620:	4b15      	ldr	r3, [pc, #84]	@ (800e678 <xNetworkBuffersInitialise+0x74>)
 800e622:	6018      	str	r0, [r3, #0]
        configASSERT( xNetworkBufferSemaphore != NULL );
 800e624:	b1c8      	cbz	r0, 800e65a <xNetworkBuffersInitialise+0x56>
                vQueueAddToRegistry( xNetworkBufferSemaphore, "NetBufSem" );
 800e626:	4916      	ldr	r1, [pc, #88]	@ (800e680 <xNetworkBuffersInitialise+0x7c>)
 800e628:	f7f6 f82c 	bl	8004684 <vQueueAddToRegistry>
            vListInitialise( &xFreeBuffersList );
 800e62c:	4815      	ldr	r0, [pc, #84]	@ (800e684 <xNetworkBuffersInitialise+0x80>)
 800e62e:	f7f5 fbbb 	bl	8003da8 <vListInitialise>
            for( x = 0U; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 800e632:	2500      	movs	r5, #0
 800e634:	2d3b      	cmp	r5, #59	@ 0x3b
 800e636:	d819      	bhi.n	800e66c <xNetworkBuffersInitialise+0x68>
                xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 800e638:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
 800e63c:	4c12      	ldr	r4, [pc, #72]	@ (800e688 <xNetworkBuffersInitialise+0x84>)
 800e63e:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 800e642:	2300      	movs	r3, #0
 800e644:	6263      	str	r3, [r4, #36]	@ 0x24
                vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 800e646:	4620      	mov	r0, r4
 800e648:	f7f5 fbb9 	bl	8003dbe <vListInitialiseItem>
                listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );
 800e64c:	60e4      	str	r4, [r4, #12]
                vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 800e64e:	4621      	mov	r1, r4
 800e650:	480c      	ldr	r0, [pc, #48]	@ (800e684 <xNetworkBuffersInitialise+0x80>)
 800e652:	f7f5 fbc2 	bl	8003dda <vListInsert>
            for( x = 0U; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 800e656:	3501      	adds	r5, #1
 800e658:	e7ec      	b.n	800e634 <xNetworkBuffersInitialise+0x30>
 800e65a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e65e:	f383 8811 	msr	BASEPRI, r3
 800e662:	f3bf 8f6f 	isb	sy
 800e666:	f3bf 8f4f 	dsb	sy
        configASSERT( xNetworkBufferSemaphore != NULL );
 800e66a:	e7fe      	b.n	800e66a <xNetworkBuffersInitialise+0x66>
            uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
 800e66c:	4b07      	ldr	r3, [pc, #28]	@ (800e68c <xNetworkBuffersInitialise+0x88>)
 800e66e:	223c      	movs	r2, #60	@ 0x3c
 800e670:	601a      	str	r2, [r3, #0]
 800e672:	e7cb      	b.n	800e60c <xNetworkBuffersInitialise+0x8>
        xReturn = pdFAIL;
 800e674:	2000      	movs	r0, #0
 800e676:	e7cd      	b.n	800e614 <xNetworkBuffersInitialise+0x10>
 800e678:	2001453c 	.word	0x2001453c
 800e67c:	200144ec 	.word	0x200144ec
 800e680:	08010200 	.word	0x08010200
 800e684:	20014544 	.word	0x20014544
 800e688:	200137cc 	.word	0x200137cc
 800e68c:	20014540 	.word	0x20014540

0800e690 <vReleaseNetworkBuffer>:
    uint8_t * pucEthernetBufferCopy = pucEthernetBuffer;

    /* There is space before the Ethernet buffer in which a pointer to the
     * network buffer that references this Ethernet buffer is stored.  Remove the
     * space before freeing the buffer. */
    if( pucEthernetBufferCopy != NULL )
 800e690:	b120      	cbz	r0, 800e69c <vReleaseNetworkBuffer+0xc>
{
 800e692:	b508      	push	{r3, lr}
    {
        /* MISRA Ref 18.4.1 [Usage of +, -, += and -= operators on expression of pointer type]. */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-184. */
        /* coverity[misra_c_2012_rule_18_4_violation] */
        pucEthernetBufferCopy -= ipBUFFER_PADDING;
        vPortFree( ( void * ) pucEthernetBufferCopy );
 800e694:	380a      	subs	r0, #10
 800e696:	f7f7 fb87 	bl	8005da8 <vPortFree>
    }
}
 800e69a:	bd08      	pop	{r3, pc}
 800e69c:	4770      	bx	lr
	...

0800e6a0 <vReleaseNetworkBufferAndDescriptor>:
    return pxReturn;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBufferAndDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 800e6a0:	b510      	push	{r4, lr}
 800e6a2:	4604      	mov	r4, r0
    /* Ensure the buffer is returned to the list of free buffers before the
    * counting semaphore is 'given' to say a buffer is available.  Release the
    * storage allocated to the buffer payload.  THIS FILE SHOULD NOT BE USED
    * IF THE PROJECT INCLUDES A MEMORY ALLOCATOR THAT WILL FRAGMENT THE HEAP
    * MEMORY.  For example, heap_2 must not be used, heap_4 can be used. */
    vReleaseNetworkBuffer( pxNetworkBuffer->pucEthernetBuffer );
 800e6a4:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 800e6a6:	f7ff fff3 	bl	800e690 <vReleaseNetworkBuffer>
    pxNetworkBuffer->pucEthernetBuffer = NULL;
 800e6aa:	2300      	movs	r3, #0
 800e6ac:	6263      	str	r3, [r4, #36]	@ 0x24
    pxNetworkBuffer->xDataLength = 0U;
 800e6ae:	62a3      	str	r3, [r4, #40]	@ 0x28

    taskENTER_CRITICAL();
 800e6b0:	f7f7 f940 	bl	8005934 <vPortEnterCritical>
    {
        xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 800e6b4:	6922      	ldr	r2, [r4, #16]
 800e6b6:	4b0b      	ldr	r3, [pc, #44]	@ (800e6e4 <vReleaseNetworkBufferAndDescriptor+0x44>)
 800e6b8:	429a      	cmp	r2, r3
 800e6ba:	d008      	beq.n	800e6ce <vReleaseNetworkBufferAndDescriptor+0x2e>

        if( xListItemAlreadyInFreeList == pdFALSE )
        {
            vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 800e6bc:	4621      	mov	r1, r4
 800e6be:	4618      	mov	r0, r3
 800e6c0:	f7f5 fb80 	bl	8003dc4 <vListInsertEnd>
        xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 800e6c4:	2400      	movs	r4, #0
        }
    }
    taskEXIT_CRITICAL();
 800e6c6:	f7f7 f957 	bl	8005978 <vPortExitCritical>

    /*
     * Update the network state machine, unless the program fails to release its 'xNetworkBufferSemaphore'.
     * The program should only try to release its semaphore if 'xListItemAlreadyInFreeList' is false.
     */
    if( xListItemAlreadyInFreeList == pdFALSE )
 800e6ca:	b114      	cbz	r4, 800e6d2 <vReleaseNetworkBufferAndDescriptor+0x32>
    else
    {
        /* No action. */
        iptraceNETWORK_BUFFER_RELEASED( pxNetworkBuffer );
    }
}
 800e6cc:	bd10      	pop	{r4, pc}
        xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 800e6ce:	2401      	movs	r4, #1
 800e6d0:	e7f9      	b.n	800e6c6 <vReleaseNetworkBufferAndDescriptor+0x26>
        if( xSemaphoreGive( xNetworkBufferSemaphore ) == pdTRUE )
 800e6d2:	2300      	movs	r3, #0
 800e6d4:	461a      	mov	r2, r3
 800e6d6:	4619      	mov	r1, r3
 800e6d8:	4803      	ldr	r0, [pc, #12]	@ (800e6e8 <vReleaseNetworkBufferAndDescriptor+0x48>)
 800e6da:	6800      	ldr	r0, [r0, #0]
 800e6dc:	f7f5 fd11 	bl	8004102 <xQueueGenericSend>
}
 800e6e0:	e7f4      	b.n	800e6cc <vReleaseNetworkBufferAndDescriptor+0x2c>
 800e6e2:	bf00      	nop
 800e6e4:	20014544 	.word	0x20014544
 800e6e8:	2001453c 	.word	0x2001453c

0800e6ec <pxGetNetworkBufferWithDescriptor>:
{
 800e6ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( ( xRequestedSizeBytesCopy < ( size_t ) baMINIMAL_BUFFER_SIZE ) )
 800e6ee:	2845      	cmp	r0, #69	@ 0x45
 800e6f0:	d905      	bls.n	800e6fe <pxGetNetworkBufferWithDescriptor+0x12>
 800e6f2:	4604      	mov	r4, r0
    if( baADD_WILL_OVERFLOW( xRequestedSizeBytesCopy, 2U ) == pdFAIL )
 800e6f4:	f110 0f03 	cmn.w	r0, #3
 800e6f8:	d902      	bls.n	800e700 <pxGetNetworkBufferWithDescriptor+0x14>
        xIntegerOverflowed = pdTRUE;
 800e6fa:	2201      	movs	r2, #1
 800e6fc:	e005      	b.n	800e70a <pxGetNetworkBufferWithDescriptor+0x1e>
        xRequestedSizeBytesCopy = baMINIMAL_BUFFER_SIZE;
 800e6fe:	2446      	movs	r4, #70	@ 0x46
        xRequestedSizeBytesCopy += 2U;
 800e700:	3402      	adds	r4, #2
    if( ( xRequestedSizeBytesCopy & baALIGNMENT_MASK ) != 0U )
 800e702:	f014 0f03 	tst.w	r4, #3
 800e706:	d01c      	beq.n	800e742 <pxGetNetworkBufferWithDescriptor+0x56>
 800e708:	2200      	movs	r2, #0
        xBytesRequiredForAlignment = baALIGNMENT_BYTES - ( xRequestedSizeBytesCopy & baALIGNMENT_MASK );
 800e70a:	f004 0303 	and.w	r3, r4, #3
 800e70e:	f1c3 0004 	rsb	r0, r3, #4
        if( baADD_WILL_OVERFLOW( xRequestedSizeBytesCopy, xBytesRequiredForAlignment ) == pdFAIL )
 800e712:	3b05      	subs	r3, #5
 800e714:	42a3      	cmp	r3, r4
 800e716:	d347      	bcc.n	800e7a8 <pxGetNetworkBufferWithDescriptor+0xbc>
            xRequestedSizeBytesCopy += xBytesRequiredForAlignment;
 800e718:	4404      	add	r4, r0
    if( baADD_WILL_OVERFLOW( xRequestedSizeBytesCopy, ipBUFFER_PADDING ) == pdFAIL )
 800e71a:	f114 0f0b 	cmn.w	r4, #11
 800e71e:	d845      	bhi.n	800e7ac <pxGetNetworkBufferWithDescriptor+0xc0>
        xAllocatedBytes = xRequestedSizeBytesCopy + ipBUFFER_PADDING;
 800e720:	f104 060a 	add.w	r6, r4, #10
    if( ( xIntegerOverflowed == pdFALSE ) && ( xAllocatedBytes <= uxMaxAllowedBytes ) && ( xNetworkBufferSemaphore != NULL ) )
 800e724:	2a00      	cmp	r2, #0
 800e726:	d144      	bne.n	800e7b2 <pxGetNetworkBufferWithDescriptor+0xc6>
 800e728:	2e00      	cmp	r6, #0
 800e72a:	db44      	blt.n	800e7b6 <pxGetNetworkBufferWithDescriptor+0xca>
 800e72c:	4b23      	ldr	r3, [pc, #140]	@ (800e7bc <pxGetNetworkBufferWithDescriptor+0xd0>)
 800e72e:	681d      	ldr	r5, [r3, #0]
 800e730:	2d00      	cmp	r5, #0
 800e732:	d03c      	beq.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
        if( xSemaphoreTake( xNetworkBufferSemaphore, xBlockTimeTicks ) == pdPASS )
 800e734:	4628      	mov	r0, r5
 800e736:	f7f5 febe 	bl	80044b6 <xQueueSemaphoreTake>
 800e73a:	2801      	cmp	r0, #1
 800e73c:	d003      	beq.n	800e746 <pxGetNetworkBufferWithDescriptor+0x5a>
    NetworkBufferDescriptor_t * pxReturn = NULL;
 800e73e:	2500      	movs	r5, #0
    return pxReturn;
 800e740:	e035      	b.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
 800e742:	2200      	movs	r2, #0
 800e744:	e7e9      	b.n	800e71a <pxGetNetworkBufferWithDescriptor+0x2e>
            taskENTER_CRITICAL();
 800e746:	f7f7 f8f5 	bl	8005934 <vPortEnterCritical>
                pxReturn = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &xFreeBuffersList );
 800e74a:	4f1d      	ldr	r7, [pc, #116]	@ (800e7c0 <pxGetNetworkBufferWithDescriptor+0xd4>)
 800e74c:	68fb      	ldr	r3, [r7, #12]
 800e74e:	68dd      	ldr	r5, [r3, #12]
                ( void ) uxListRemove( &( pxReturn->xBufferListItem ) );
 800e750:	4628      	mov	r0, r5
 800e752:	f7f5 fb5b 	bl	8003e0c <uxListRemove>
            taskEXIT_CRITICAL();
 800e756:	f7f7 f90f 	bl	8005978 <vPortExitCritical>
            uxCount = listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 800e75a:	683b      	ldr	r3, [r7, #0]
            if( uxMinimumFreeNetworkBuffers > uxCount )
 800e75c:	4a19      	ldr	r2, [pc, #100]	@ (800e7c4 <pxGetNetworkBufferWithDescriptor+0xd8>)
 800e75e:	6812      	ldr	r2, [r2, #0]
 800e760:	429a      	cmp	r2, r3
 800e762:	d901      	bls.n	800e768 <pxGetNetworkBufferWithDescriptor+0x7c>
                uxMinimumFreeNetworkBuffers = uxCount;
 800e764:	4a17      	ldr	r2, [pc, #92]	@ (800e7c4 <pxGetNetworkBufferWithDescriptor+0xd8>)
 800e766:	6013      	str	r3, [r2, #0]
            configASSERT( pxReturn->pucEthernetBuffer == NULL );
 800e768:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800e76a:	b143      	cbz	r3, 800e77e <pxGetNetworkBufferWithDescriptor+0x92>
 800e76c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e770:	f383 8811 	msr	BASEPRI, r3
 800e774:	f3bf 8f6f 	isb	sy
 800e778:	f3bf 8f4f 	dsb	sy
 800e77c:	e7fe      	b.n	800e77c <pxGetNetworkBufferWithDescriptor+0x90>
            if( xRequestedSizeBytesCopy > 0U )
 800e77e:	b1b4      	cbz	r4, 800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
                pxReturn->pucEthernetBuffer = ( uint8_t * ) pvPortMalloc( xAllocatedBytes );
 800e780:	4630      	mov	r0, r6
 800e782:	f7f7 fa8f 	bl	8005ca4 <pvPortMalloc>
 800e786:	4606      	mov	r6, r0
 800e788:	6268      	str	r0, [r5, #36]	@ 0x24
                if( pxReturn->pucEthernetBuffer == NULL )
 800e78a:	b140      	cbz	r0, 800e79e <pxGetNetworkBufferWithDescriptor+0xb2>
                    *( ( NetworkBufferDescriptor_t ** ) ( pxReturn->pucEthernetBuffer ) ) = pxReturn;
 800e78c:	6005      	str	r5, [r0, #0]
                    pxReturn->pucEthernetBuffer += ipBUFFER_PADDING;
 800e78e:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 800e790:	330a      	adds	r3, #10
 800e792:	626b      	str	r3, [r5, #36]	@ 0x24
                    pxReturn->xDataLength = xRequestedSizeBytesCopy;
 800e794:	62ac      	str	r4, [r5, #40]	@ 0x28
                    pxReturn->pxInterface = NULL;
 800e796:	2300      	movs	r3, #0
 800e798:	62eb      	str	r3, [r5, #44]	@ 0x2c
                    pxReturn->pxEndPoint = NULL;
 800e79a:	632b      	str	r3, [r5, #48]	@ 0x30
 800e79c:	e007      	b.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
                    vReleaseNetworkBufferAndDescriptor( pxReturn );
 800e79e:	4628      	mov	r0, r5
 800e7a0:	f7ff ff7e 	bl	800e6a0 <vReleaseNetworkBufferAndDescriptor>
                    pxReturn = NULL;
 800e7a4:	4635      	mov	r5, r6
 800e7a6:	e002      	b.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
    NetworkBufferDescriptor_t * pxReturn = NULL;
 800e7a8:	2500      	movs	r5, #0
 800e7aa:	e000      	b.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
 800e7ac:	2500      	movs	r5, #0
}
 800e7ae:	4628      	mov	r0, r5
 800e7b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    NetworkBufferDescriptor_t * pxReturn = NULL;
 800e7b2:	2500      	movs	r5, #0
 800e7b4:	e7fb      	b.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
 800e7b6:	2500      	movs	r5, #0
 800e7b8:	e7f9      	b.n	800e7ae <pxGetNetworkBufferWithDescriptor+0xc2>
 800e7ba:	bf00      	nop
 800e7bc:	2001453c 	.word	0x2001453c
 800e7c0:	20014544 	.word	0x20014544
 800e7c4:	20014540 	.word	0x20014540

0800e7c8 <uxGetNumberOfFreeNetworkBuffers>:
/*
 * Returns the number of free network buffers
 */
UBaseType_t uxGetNumberOfFreeNetworkBuffers( void )
{
    return listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 800e7c8:	4b01      	ldr	r3, [pc, #4]	@ (800e7d0 <uxGetNumberOfFreeNetworkBuffers+0x8>)
 800e7ca:	6818      	ldr	r0, [r3, #0]
}
 800e7cc:	4770      	bx	lr
 800e7ce:	bf00      	nop
 800e7d0:	20014544 	.word	0x20014544

0800e7d4 <uxGetMinimumFreeNetworkBuffers>:
/*-----------------------------------------------------------*/

UBaseType_t uxGetMinimumFreeNetworkBuffers( void )
{
    return uxMinimumFreeNetworkBuffers;
}
 800e7d4:	4b01      	ldr	r3, [pc, #4]	@ (800e7dc <uxGetMinimumFreeNetworkBuffers+0x8>)
 800e7d6:	6818      	ldr	r0, [r3, #0]
 800e7d8:	4770      	bx	lr
 800e7da:	bf00      	nop
 800e7dc:	20014540 	.word	0x20014540

0800e7e0 <std>:
 800e7e0:	2300      	movs	r3, #0
 800e7e2:	b510      	push	{r4, lr}
 800e7e4:	4604      	mov	r4, r0
 800e7e6:	e9c0 3300 	strd	r3, r3, [r0]
 800e7ea:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800e7ee:	6083      	str	r3, [r0, #8]
 800e7f0:	8181      	strh	r1, [r0, #12]
 800e7f2:	6643      	str	r3, [r0, #100]	@ 0x64
 800e7f4:	81c2      	strh	r2, [r0, #14]
 800e7f6:	6183      	str	r3, [r0, #24]
 800e7f8:	4619      	mov	r1, r3
 800e7fa:	2208      	movs	r2, #8
 800e7fc:	305c      	adds	r0, #92	@ 0x5c
 800e7fe:	f000 fa59 	bl	800ecb4 <memset>
 800e802:	4b0d      	ldr	r3, [pc, #52]	@ (800e838 <std+0x58>)
 800e804:	6263      	str	r3, [r4, #36]	@ 0x24
 800e806:	4b0d      	ldr	r3, [pc, #52]	@ (800e83c <std+0x5c>)
 800e808:	62a3      	str	r3, [r4, #40]	@ 0x28
 800e80a:	4b0d      	ldr	r3, [pc, #52]	@ (800e840 <std+0x60>)
 800e80c:	62e3      	str	r3, [r4, #44]	@ 0x2c
 800e80e:	4b0d      	ldr	r3, [pc, #52]	@ (800e844 <std+0x64>)
 800e810:	6323      	str	r3, [r4, #48]	@ 0x30
 800e812:	4b0d      	ldr	r3, [pc, #52]	@ (800e848 <std+0x68>)
 800e814:	6224      	str	r4, [r4, #32]
 800e816:	429c      	cmp	r4, r3
 800e818:	d006      	beq.n	800e828 <std+0x48>
 800e81a:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 800e81e:	4294      	cmp	r4, r2
 800e820:	d002      	beq.n	800e828 <std+0x48>
 800e822:	33d0      	adds	r3, #208	@ 0xd0
 800e824:	429c      	cmp	r4, r3
 800e826:	d105      	bne.n	800e834 <std+0x54>
 800e828:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 800e82c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800e830:	f000 bb16 	b.w	800ee60 <__retarget_lock_init_recursive>
 800e834:	bd10      	pop	{r4, pc}
 800e836:	bf00      	nop
 800e838:	0800eab1 	.word	0x0800eab1
 800e83c:	0800ead3 	.word	0x0800ead3
 800e840:	0800eb0b 	.word	0x0800eb0b
 800e844:	0800eb2f 	.word	0x0800eb2f
 800e848:	20014558 	.word	0x20014558

0800e84c <stdio_exit_handler>:
 800e84c:	4a02      	ldr	r2, [pc, #8]	@ (800e858 <stdio_exit_handler+0xc>)
 800e84e:	4903      	ldr	r1, [pc, #12]	@ (800e85c <stdio_exit_handler+0x10>)
 800e850:	4803      	ldr	r0, [pc, #12]	@ (800e860 <stdio_exit_handler+0x14>)
 800e852:	f000 b869 	b.w	800e928 <_fwalk_sglue>
 800e856:	bf00      	nop
 800e858:	20000024 	.word	0x20000024
 800e85c:	0800f9c9 	.word	0x0800f9c9
 800e860:	20000034 	.word	0x20000034

0800e864 <cleanup_stdio>:
 800e864:	6841      	ldr	r1, [r0, #4]
 800e866:	4b0c      	ldr	r3, [pc, #48]	@ (800e898 <cleanup_stdio+0x34>)
 800e868:	4299      	cmp	r1, r3
 800e86a:	b510      	push	{r4, lr}
 800e86c:	4604      	mov	r4, r0
 800e86e:	d001      	beq.n	800e874 <cleanup_stdio+0x10>
 800e870:	f001 f8aa 	bl	800f9c8 <_fflush_r>
 800e874:	68a1      	ldr	r1, [r4, #8]
 800e876:	4b09      	ldr	r3, [pc, #36]	@ (800e89c <cleanup_stdio+0x38>)
 800e878:	4299      	cmp	r1, r3
 800e87a:	d002      	beq.n	800e882 <cleanup_stdio+0x1e>
 800e87c:	4620      	mov	r0, r4
 800e87e:	f001 f8a3 	bl	800f9c8 <_fflush_r>
 800e882:	68e1      	ldr	r1, [r4, #12]
 800e884:	4b06      	ldr	r3, [pc, #24]	@ (800e8a0 <cleanup_stdio+0x3c>)
 800e886:	4299      	cmp	r1, r3
 800e888:	d004      	beq.n	800e894 <cleanup_stdio+0x30>
 800e88a:	4620      	mov	r0, r4
 800e88c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800e890:	f001 b89a 	b.w	800f9c8 <_fflush_r>
 800e894:	bd10      	pop	{r4, pc}
 800e896:	bf00      	nop
 800e898:	20014558 	.word	0x20014558
 800e89c:	200145c0 	.word	0x200145c0
 800e8a0:	20014628 	.word	0x20014628

0800e8a4 <global_stdio_init.part.0>:
 800e8a4:	b510      	push	{r4, lr}
 800e8a6:	4b0b      	ldr	r3, [pc, #44]	@ (800e8d4 <global_stdio_init.part.0+0x30>)
 800e8a8:	4c0b      	ldr	r4, [pc, #44]	@ (800e8d8 <global_stdio_init.part.0+0x34>)
 800e8aa:	4a0c      	ldr	r2, [pc, #48]	@ (800e8dc <global_stdio_init.part.0+0x38>)
 800e8ac:	601a      	str	r2, [r3, #0]
 800e8ae:	4620      	mov	r0, r4
 800e8b0:	2200      	movs	r2, #0
 800e8b2:	2104      	movs	r1, #4
 800e8b4:	f7ff ff94 	bl	800e7e0 <std>
 800e8b8:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 800e8bc:	2201      	movs	r2, #1
 800e8be:	2109      	movs	r1, #9
 800e8c0:	f7ff ff8e 	bl	800e7e0 <std>
 800e8c4:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 800e8c8:	2202      	movs	r2, #2
 800e8ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800e8ce:	2112      	movs	r1, #18
 800e8d0:	f7ff bf86 	b.w	800e7e0 <std>
 800e8d4:	20014690 	.word	0x20014690
 800e8d8:	20014558 	.word	0x20014558
 800e8dc:	0800e84d 	.word	0x0800e84d

0800e8e0 <__sfp_lock_acquire>:
 800e8e0:	4801      	ldr	r0, [pc, #4]	@ (800e8e8 <__sfp_lock_acquire+0x8>)
 800e8e2:	f000 babe 	b.w	800ee62 <__retarget_lock_acquire_recursive>
 800e8e6:	bf00      	nop
 800e8e8:	20014699 	.word	0x20014699

0800e8ec <__sfp_lock_release>:
 800e8ec:	4801      	ldr	r0, [pc, #4]	@ (800e8f4 <__sfp_lock_release+0x8>)
 800e8ee:	f000 bab9 	b.w	800ee64 <__retarget_lock_release_recursive>
 800e8f2:	bf00      	nop
 800e8f4:	20014699 	.word	0x20014699

0800e8f8 <__sinit>:
 800e8f8:	b510      	push	{r4, lr}
 800e8fa:	4604      	mov	r4, r0
 800e8fc:	f7ff fff0 	bl	800e8e0 <__sfp_lock_acquire>
 800e900:	6a23      	ldr	r3, [r4, #32]
 800e902:	b11b      	cbz	r3, 800e90c <__sinit+0x14>
 800e904:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800e908:	f7ff bff0 	b.w	800e8ec <__sfp_lock_release>
 800e90c:	4b04      	ldr	r3, [pc, #16]	@ (800e920 <__sinit+0x28>)
 800e90e:	6223      	str	r3, [r4, #32]
 800e910:	4b04      	ldr	r3, [pc, #16]	@ (800e924 <__sinit+0x2c>)
 800e912:	681b      	ldr	r3, [r3, #0]
 800e914:	2b00      	cmp	r3, #0
 800e916:	d1f5      	bne.n	800e904 <__sinit+0xc>
 800e918:	f7ff ffc4 	bl	800e8a4 <global_stdio_init.part.0>
 800e91c:	e7f2      	b.n	800e904 <__sinit+0xc>
 800e91e:	bf00      	nop
 800e920:	0800e865 	.word	0x0800e865
 800e924:	20014690 	.word	0x20014690

0800e928 <_fwalk_sglue>:
 800e928:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800e92c:	4607      	mov	r7, r0
 800e92e:	4688      	mov	r8, r1
 800e930:	4614      	mov	r4, r2
 800e932:	2600      	movs	r6, #0
 800e934:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 800e938:	f1b9 0901 	subs.w	r9, r9, #1
 800e93c:	d505      	bpl.n	800e94a <_fwalk_sglue+0x22>
 800e93e:	6824      	ldr	r4, [r4, #0]
 800e940:	2c00      	cmp	r4, #0
 800e942:	d1f7      	bne.n	800e934 <_fwalk_sglue+0xc>
 800e944:	4630      	mov	r0, r6
 800e946:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800e94a:	89ab      	ldrh	r3, [r5, #12]
 800e94c:	2b01      	cmp	r3, #1
 800e94e:	d907      	bls.n	800e960 <_fwalk_sglue+0x38>
 800e950:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800e954:	3301      	adds	r3, #1
 800e956:	d003      	beq.n	800e960 <_fwalk_sglue+0x38>
 800e958:	4629      	mov	r1, r5
 800e95a:	4638      	mov	r0, r7
 800e95c:	47c0      	blx	r8
 800e95e:	4306      	orrs	r6, r0
 800e960:	3568      	adds	r5, #104	@ 0x68
 800e962:	e7e9      	b.n	800e938 <_fwalk_sglue+0x10>

0800e964 <iprintf>:
 800e964:	b40f      	push	{r0, r1, r2, r3}
 800e966:	b507      	push	{r0, r1, r2, lr}
 800e968:	4906      	ldr	r1, [pc, #24]	@ (800e984 <iprintf+0x20>)
 800e96a:	ab04      	add	r3, sp, #16
 800e96c:	6808      	ldr	r0, [r1, #0]
 800e96e:	f853 2b04 	ldr.w	r2, [r3], #4
 800e972:	6881      	ldr	r1, [r0, #8]
 800e974:	9301      	str	r3, [sp, #4]
 800e976:	f000 fcff 	bl	800f378 <_vfiprintf_r>
 800e97a:	b003      	add	sp, #12
 800e97c:	f85d eb04 	ldr.w	lr, [sp], #4
 800e980:	b004      	add	sp, #16
 800e982:	4770      	bx	lr
 800e984:	20000030 	.word	0x20000030

0800e988 <_puts_r>:
 800e988:	6a03      	ldr	r3, [r0, #32]
 800e98a:	b570      	push	{r4, r5, r6, lr}
 800e98c:	6884      	ldr	r4, [r0, #8]
 800e98e:	4605      	mov	r5, r0
 800e990:	460e      	mov	r6, r1
 800e992:	b90b      	cbnz	r3, 800e998 <_puts_r+0x10>
 800e994:	f7ff ffb0 	bl	800e8f8 <__sinit>
 800e998:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800e99a:	07db      	lsls	r3, r3, #31
 800e99c:	d405      	bmi.n	800e9aa <_puts_r+0x22>
 800e99e:	89a3      	ldrh	r3, [r4, #12]
 800e9a0:	0598      	lsls	r0, r3, #22
 800e9a2:	d402      	bmi.n	800e9aa <_puts_r+0x22>
 800e9a4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800e9a6:	f000 fa5c 	bl	800ee62 <__retarget_lock_acquire_recursive>
 800e9aa:	89a3      	ldrh	r3, [r4, #12]
 800e9ac:	0719      	lsls	r1, r3, #28
 800e9ae:	d502      	bpl.n	800e9b6 <_puts_r+0x2e>
 800e9b0:	6923      	ldr	r3, [r4, #16]
 800e9b2:	2b00      	cmp	r3, #0
 800e9b4:	d135      	bne.n	800ea22 <_puts_r+0x9a>
 800e9b6:	4621      	mov	r1, r4
 800e9b8:	4628      	mov	r0, r5
 800e9ba:	f000 f8fb 	bl	800ebb4 <__swsetup_r>
 800e9be:	b380      	cbz	r0, 800ea22 <_puts_r+0x9a>
 800e9c0:	f04f 35ff 	mov.w	r5, #4294967295
 800e9c4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800e9c6:	07da      	lsls	r2, r3, #31
 800e9c8:	d405      	bmi.n	800e9d6 <_puts_r+0x4e>
 800e9ca:	89a3      	ldrh	r3, [r4, #12]
 800e9cc:	059b      	lsls	r3, r3, #22
 800e9ce:	d402      	bmi.n	800e9d6 <_puts_r+0x4e>
 800e9d0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800e9d2:	f000 fa47 	bl	800ee64 <__retarget_lock_release_recursive>
 800e9d6:	4628      	mov	r0, r5
 800e9d8:	bd70      	pop	{r4, r5, r6, pc}
 800e9da:	2b00      	cmp	r3, #0
 800e9dc:	da04      	bge.n	800e9e8 <_puts_r+0x60>
 800e9de:	69a2      	ldr	r2, [r4, #24]
 800e9e0:	429a      	cmp	r2, r3
 800e9e2:	dc17      	bgt.n	800ea14 <_puts_r+0x8c>
 800e9e4:	290a      	cmp	r1, #10
 800e9e6:	d015      	beq.n	800ea14 <_puts_r+0x8c>
 800e9e8:	6823      	ldr	r3, [r4, #0]
 800e9ea:	1c5a      	adds	r2, r3, #1
 800e9ec:	6022      	str	r2, [r4, #0]
 800e9ee:	7019      	strb	r1, [r3, #0]
 800e9f0:	68a3      	ldr	r3, [r4, #8]
 800e9f2:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800e9f6:	3b01      	subs	r3, #1
 800e9f8:	60a3      	str	r3, [r4, #8]
 800e9fa:	2900      	cmp	r1, #0
 800e9fc:	d1ed      	bne.n	800e9da <_puts_r+0x52>
 800e9fe:	2b00      	cmp	r3, #0
 800ea00:	da11      	bge.n	800ea26 <_puts_r+0x9e>
 800ea02:	4622      	mov	r2, r4
 800ea04:	210a      	movs	r1, #10
 800ea06:	4628      	mov	r0, r5
 800ea08:	f000 f895 	bl	800eb36 <__swbuf_r>
 800ea0c:	3001      	adds	r0, #1
 800ea0e:	d0d7      	beq.n	800e9c0 <_puts_r+0x38>
 800ea10:	250a      	movs	r5, #10
 800ea12:	e7d7      	b.n	800e9c4 <_puts_r+0x3c>
 800ea14:	4622      	mov	r2, r4
 800ea16:	4628      	mov	r0, r5
 800ea18:	f000 f88d 	bl	800eb36 <__swbuf_r>
 800ea1c:	3001      	adds	r0, #1
 800ea1e:	d1e7      	bne.n	800e9f0 <_puts_r+0x68>
 800ea20:	e7ce      	b.n	800e9c0 <_puts_r+0x38>
 800ea22:	3e01      	subs	r6, #1
 800ea24:	e7e4      	b.n	800e9f0 <_puts_r+0x68>
 800ea26:	6823      	ldr	r3, [r4, #0]
 800ea28:	1c5a      	adds	r2, r3, #1
 800ea2a:	6022      	str	r2, [r4, #0]
 800ea2c:	220a      	movs	r2, #10
 800ea2e:	701a      	strb	r2, [r3, #0]
 800ea30:	e7ee      	b.n	800ea10 <_puts_r+0x88>
	...

0800ea34 <puts>:
 800ea34:	4b02      	ldr	r3, [pc, #8]	@ (800ea40 <puts+0xc>)
 800ea36:	4601      	mov	r1, r0
 800ea38:	6818      	ldr	r0, [r3, #0]
 800ea3a:	f7ff bfa5 	b.w	800e988 <_puts_r>
 800ea3e:	bf00      	nop
 800ea40:	20000030 	.word	0x20000030

0800ea44 <sniprintf>:
 800ea44:	b40c      	push	{r2, r3}
 800ea46:	b530      	push	{r4, r5, lr}
 800ea48:	4b18      	ldr	r3, [pc, #96]	@ (800eaac <sniprintf+0x68>)
 800ea4a:	1e0c      	subs	r4, r1, #0
 800ea4c:	681d      	ldr	r5, [r3, #0]
 800ea4e:	b09d      	sub	sp, #116	@ 0x74
 800ea50:	da08      	bge.n	800ea64 <sniprintf+0x20>
 800ea52:	238b      	movs	r3, #139	@ 0x8b
 800ea54:	602b      	str	r3, [r5, #0]
 800ea56:	f04f 30ff 	mov.w	r0, #4294967295
 800ea5a:	b01d      	add	sp, #116	@ 0x74
 800ea5c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800ea60:	b002      	add	sp, #8
 800ea62:	4770      	bx	lr
 800ea64:	f44f 7302 	mov.w	r3, #520	@ 0x208
 800ea68:	f8ad 3014 	strh.w	r3, [sp, #20]
 800ea6c:	f04f 0300 	mov.w	r3, #0
 800ea70:	931b      	str	r3, [sp, #108]	@ 0x6c
 800ea72:	bf14      	ite	ne
 800ea74:	f104 33ff 	addne.w	r3, r4, #4294967295
 800ea78:	4623      	moveq	r3, r4
 800ea7a:	9304      	str	r3, [sp, #16]
 800ea7c:	9307      	str	r3, [sp, #28]
 800ea7e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800ea82:	9002      	str	r0, [sp, #8]
 800ea84:	9006      	str	r0, [sp, #24]
 800ea86:	f8ad 3016 	strh.w	r3, [sp, #22]
 800ea8a:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 800ea8c:	ab21      	add	r3, sp, #132	@ 0x84
 800ea8e:	a902      	add	r1, sp, #8
 800ea90:	4628      	mov	r0, r5
 800ea92:	9301      	str	r3, [sp, #4]
 800ea94:	f000 fb4a 	bl	800f12c <_svfiprintf_r>
 800ea98:	1c43      	adds	r3, r0, #1
 800ea9a:	bfbc      	itt	lt
 800ea9c:	238b      	movlt	r3, #139	@ 0x8b
 800ea9e:	602b      	strlt	r3, [r5, #0]
 800eaa0:	2c00      	cmp	r4, #0
 800eaa2:	d0da      	beq.n	800ea5a <sniprintf+0x16>
 800eaa4:	9b02      	ldr	r3, [sp, #8]
 800eaa6:	2200      	movs	r2, #0
 800eaa8:	701a      	strb	r2, [r3, #0]
 800eaaa:	e7d6      	b.n	800ea5a <sniprintf+0x16>
 800eaac:	20000030 	.word	0x20000030

0800eab0 <__sread>:
 800eab0:	b510      	push	{r4, lr}
 800eab2:	460c      	mov	r4, r1
 800eab4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800eab8:	f000 f984 	bl	800edc4 <_read_r>
 800eabc:	2800      	cmp	r0, #0
 800eabe:	bfab      	itete	ge
 800eac0:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 800eac2:	89a3      	ldrhlt	r3, [r4, #12]
 800eac4:	181b      	addge	r3, r3, r0
 800eac6:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 800eaca:	bfac      	ite	ge
 800eacc:	6563      	strge	r3, [r4, #84]	@ 0x54
 800eace:	81a3      	strhlt	r3, [r4, #12]
 800ead0:	bd10      	pop	{r4, pc}

0800ead2 <__swrite>:
 800ead2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ead6:	461f      	mov	r7, r3
 800ead8:	898b      	ldrh	r3, [r1, #12]
 800eada:	05db      	lsls	r3, r3, #23
 800eadc:	4605      	mov	r5, r0
 800eade:	460c      	mov	r4, r1
 800eae0:	4616      	mov	r6, r2
 800eae2:	d505      	bpl.n	800eaf0 <__swrite+0x1e>
 800eae4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800eae8:	2302      	movs	r3, #2
 800eaea:	2200      	movs	r2, #0
 800eaec:	f000 f958 	bl	800eda0 <_lseek_r>
 800eaf0:	89a3      	ldrh	r3, [r4, #12]
 800eaf2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800eaf6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800eafa:	81a3      	strh	r3, [r4, #12]
 800eafc:	4632      	mov	r2, r6
 800eafe:	463b      	mov	r3, r7
 800eb00:	4628      	mov	r0, r5
 800eb02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800eb06:	f000 b96f 	b.w	800ede8 <_write_r>

0800eb0a <__sseek>:
 800eb0a:	b510      	push	{r4, lr}
 800eb0c:	460c      	mov	r4, r1
 800eb0e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800eb12:	f000 f945 	bl	800eda0 <_lseek_r>
 800eb16:	1c43      	adds	r3, r0, #1
 800eb18:	89a3      	ldrh	r3, [r4, #12]
 800eb1a:	bf15      	itete	ne
 800eb1c:	6560      	strne	r0, [r4, #84]	@ 0x54
 800eb1e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 800eb22:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 800eb26:	81a3      	strheq	r3, [r4, #12]
 800eb28:	bf18      	it	ne
 800eb2a:	81a3      	strhne	r3, [r4, #12]
 800eb2c:	bd10      	pop	{r4, pc}

0800eb2e <__sclose>:
 800eb2e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800eb32:	f000 b8c7 	b.w	800ecc4 <_close_r>

0800eb36 <__swbuf_r>:
 800eb36:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eb38:	460e      	mov	r6, r1
 800eb3a:	4614      	mov	r4, r2
 800eb3c:	4605      	mov	r5, r0
 800eb3e:	b118      	cbz	r0, 800eb48 <__swbuf_r+0x12>
 800eb40:	6a03      	ldr	r3, [r0, #32]
 800eb42:	b90b      	cbnz	r3, 800eb48 <__swbuf_r+0x12>
 800eb44:	f7ff fed8 	bl	800e8f8 <__sinit>
 800eb48:	69a3      	ldr	r3, [r4, #24]
 800eb4a:	60a3      	str	r3, [r4, #8]
 800eb4c:	89a3      	ldrh	r3, [r4, #12]
 800eb4e:	071a      	lsls	r2, r3, #28
 800eb50:	d501      	bpl.n	800eb56 <__swbuf_r+0x20>
 800eb52:	6923      	ldr	r3, [r4, #16]
 800eb54:	b943      	cbnz	r3, 800eb68 <__swbuf_r+0x32>
 800eb56:	4621      	mov	r1, r4
 800eb58:	4628      	mov	r0, r5
 800eb5a:	f000 f82b 	bl	800ebb4 <__swsetup_r>
 800eb5e:	b118      	cbz	r0, 800eb68 <__swbuf_r+0x32>
 800eb60:	f04f 37ff 	mov.w	r7, #4294967295
 800eb64:	4638      	mov	r0, r7
 800eb66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800eb68:	6823      	ldr	r3, [r4, #0]
 800eb6a:	6922      	ldr	r2, [r4, #16]
 800eb6c:	1a98      	subs	r0, r3, r2
 800eb6e:	6963      	ldr	r3, [r4, #20]
 800eb70:	b2f6      	uxtb	r6, r6
 800eb72:	4283      	cmp	r3, r0
 800eb74:	4637      	mov	r7, r6
 800eb76:	dc05      	bgt.n	800eb84 <__swbuf_r+0x4e>
 800eb78:	4621      	mov	r1, r4
 800eb7a:	4628      	mov	r0, r5
 800eb7c:	f000 ff24 	bl	800f9c8 <_fflush_r>
 800eb80:	2800      	cmp	r0, #0
 800eb82:	d1ed      	bne.n	800eb60 <__swbuf_r+0x2a>
 800eb84:	68a3      	ldr	r3, [r4, #8]
 800eb86:	3b01      	subs	r3, #1
 800eb88:	60a3      	str	r3, [r4, #8]
 800eb8a:	6823      	ldr	r3, [r4, #0]
 800eb8c:	1c5a      	adds	r2, r3, #1
 800eb8e:	6022      	str	r2, [r4, #0]
 800eb90:	701e      	strb	r6, [r3, #0]
 800eb92:	6962      	ldr	r2, [r4, #20]
 800eb94:	1c43      	adds	r3, r0, #1
 800eb96:	429a      	cmp	r2, r3
 800eb98:	d004      	beq.n	800eba4 <__swbuf_r+0x6e>
 800eb9a:	89a3      	ldrh	r3, [r4, #12]
 800eb9c:	07db      	lsls	r3, r3, #31
 800eb9e:	d5e1      	bpl.n	800eb64 <__swbuf_r+0x2e>
 800eba0:	2e0a      	cmp	r6, #10
 800eba2:	d1df      	bne.n	800eb64 <__swbuf_r+0x2e>
 800eba4:	4621      	mov	r1, r4
 800eba6:	4628      	mov	r0, r5
 800eba8:	f000 ff0e 	bl	800f9c8 <_fflush_r>
 800ebac:	2800      	cmp	r0, #0
 800ebae:	d0d9      	beq.n	800eb64 <__swbuf_r+0x2e>
 800ebb0:	e7d6      	b.n	800eb60 <__swbuf_r+0x2a>
	...

0800ebb4 <__swsetup_r>:
 800ebb4:	b538      	push	{r3, r4, r5, lr}
 800ebb6:	4b29      	ldr	r3, [pc, #164]	@ (800ec5c <__swsetup_r+0xa8>)
 800ebb8:	4605      	mov	r5, r0
 800ebba:	6818      	ldr	r0, [r3, #0]
 800ebbc:	460c      	mov	r4, r1
 800ebbe:	b118      	cbz	r0, 800ebc8 <__swsetup_r+0x14>
 800ebc0:	6a03      	ldr	r3, [r0, #32]
 800ebc2:	b90b      	cbnz	r3, 800ebc8 <__swsetup_r+0x14>
 800ebc4:	f7ff fe98 	bl	800e8f8 <__sinit>
 800ebc8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800ebcc:	0719      	lsls	r1, r3, #28
 800ebce:	d422      	bmi.n	800ec16 <__swsetup_r+0x62>
 800ebd0:	06da      	lsls	r2, r3, #27
 800ebd2:	d407      	bmi.n	800ebe4 <__swsetup_r+0x30>
 800ebd4:	2209      	movs	r2, #9
 800ebd6:	602a      	str	r2, [r5, #0]
 800ebd8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800ebdc:	81a3      	strh	r3, [r4, #12]
 800ebde:	f04f 30ff 	mov.w	r0, #4294967295
 800ebe2:	e033      	b.n	800ec4c <__swsetup_r+0x98>
 800ebe4:	0758      	lsls	r0, r3, #29
 800ebe6:	d512      	bpl.n	800ec0e <__swsetup_r+0x5a>
 800ebe8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800ebea:	b141      	cbz	r1, 800ebfe <__swsetup_r+0x4a>
 800ebec:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800ebf0:	4299      	cmp	r1, r3
 800ebf2:	d002      	beq.n	800ebfa <__swsetup_r+0x46>
 800ebf4:	4628      	mov	r0, r5
 800ebf6:	f000 f945 	bl	800ee84 <_free_r>
 800ebfa:	2300      	movs	r3, #0
 800ebfc:	6363      	str	r3, [r4, #52]	@ 0x34
 800ebfe:	89a3      	ldrh	r3, [r4, #12]
 800ec00:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 800ec04:	81a3      	strh	r3, [r4, #12]
 800ec06:	2300      	movs	r3, #0
 800ec08:	6063      	str	r3, [r4, #4]
 800ec0a:	6923      	ldr	r3, [r4, #16]
 800ec0c:	6023      	str	r3, [r4, #0]
 800ec0e:	89a3      	ldrh	r3, [r4, #12]
 800ec10:	f043 0308 	orr.w	r3, r3, #8
 800ec14:	81a3      	strh	r3, [r4, #12]
 800ec16:	6923      	ldr	r3, [r4, #16]
 800ec18:	b94b      	cbnz	r3, 800ec2e <__swsetup_r+0x7a>
 800ec1a:	89a3      	ldrh	r3, [r4, #12]
 800ec1c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 800ec20:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800ec24:	d003      	beq.n	800ec2e <__swsetup_r+0x7a>
 800ec26:	4621      	mov	r1, r4
 800ec28:	4628      	mov	r0, r5
 800ec2a:	f000 ff1b 	bl	800fa64 <__smakebuf_r>
 800ec2e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800ec32:	f013 0201 	ands.w	r2, r3, #1
 800ec36:	d00a      	beq.n	800ec4e <__swsetup_r+0x9a>
 800ec38:	2200      	movs	r2, #0
 800ec3a:	60a2      	str	r2, [r4, #8]
 800ec3c:	6962      	ldr	r2, [r4, #20]
 800ec3e:	4252      	negs	r2, r2
 800ec40:	61a2      	str	r2, [r4, #24]
 800ec42:	6922      	ldr	r2, [r4, #16]
 800ec44:	b942      	cbnz	r2, 800ec58 <__swsetup_r+0xa4>
 800ec46:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 800ec4a:	d1c5      	bne.n	800ebd8 <__swsetup_r+0x24>
 800ec4c:	bd38      	pop	{r3, r4, r5, pc}
 800ec4e:	0799      	lsls	r1, r3, #30
 800ec50:	bf58      	it	pl
 800ec52:	6962      	ldrpl	r2, [r4, #20]
 800ec54:	60a2      	str	r2, [r4, #8]
 800ec56:	e7f4      	b.n	800ec42 <__swsetup_r+0x8e>
 800ec58:	2000      	movs	r0, #0
 800ec5a:	e7f7      	b.n	800ec4c <__swsetup_r+0x98>
 800ec5c:	20000030 	.word	0x20000030

0800ec60 <memcmp>:
 800ec60:	b510      	push	{r4, lr}
 800ec62:	3901      	subs	r1, #1
 800ec64:	4402      	add	r2, r0
 800ec66:	4290      	cmp	r0, r2
 800ec68:	d101      	bne.n	800ec6e <memcmp+0xe>
 800ec6a:	2000      	movs	r0, #0
 800ec6c:	e005      	b.n	800ec7a <memcmp+0x1a>
 800ec6e:	7803      	ldrb	r3, [r0, #0]
 800ec70:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800ec74:	42a3      	cmp	r3, r4
 800ec76:	d001      	beq.n	800ec7c <memcmp+0x1c>
 800ec78:	1b18      	subs	r0, r3, r4
 800ec7a:	bd10      	pop	{r4, pc}
 800ec7c:	3001      	adds	r0, #1
 800ec7e:	e7f2      	b.n	800ec66 <memcmp+0x6>

0800ec80 <memmove>:
 800ec80:	4288      	cmp	r0, r1
 800ec82:	b510      	push	{r4, lr}
 800ec84:	eb01 0402 	add.w	r4, r1, r2
 800ec88:	d902      	bls.n	800ec90 <memmove+0x10>
 800ec8a:	4284      	cmp	r4, r0
 800ec8c:	4623      	mov	r3, r4
 800ec8e:	d807      	bhi.n	800eca0 <memmove+0x20>
 800ec90:	1e43      	subs	r3, r0, #1
 800ec92:	42a1      	cmp	r1, r4
 800ec94:	d008      	beq.n	800eca8 <memmove+0x28>
 800ec96:	f811 2b01 	ldrb.w	r2, [r1], #1
 800ec9a:	f803 2f01 	strb.w	r2, [r3, #1]!
 800ec9e:	e7f8      	b.n	800ec92 <memmove+0x12>
 800eca0:	4402      	add	r2, r0
 800eca2:	4601      	mov	r1, r0
 800eca4:	428a      	cmp	r2, r1
 800eca6:	d100      	bne.n	800ecaa <memmove+0x2a>
 800eca8:	bd10      	pop	{r4, pc}
 800ecaa:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800ecae:	f802 4d01 	strb.w	r4, [r2, #-1]!
 800ecb2:	e7f7      	b.n	800eca4 <memmove+0x24>

0800ecb4 <memset>:
 800ecb4:	4402      	add	r2, r0
 800ecb6:	4603      	mov	r3, r0
 800ecb8:	4293      	cmp	r3, r2
 800ecba:	d100      	bne.n	800ecbe <memset+0xa>
 800ecbc:	4770      	bx	lr
 800ecbe:	f803 1b01 	strb.w	r1, [r3], #1
 800ecc2:	e7f9      	b.n	800ecb8 <memset+0x4>

0800ecc4 <_close_r>:
 800ecc4:	b538      	push	{r3, r4, r5, lr}
 800ecc6:	4d06      	ldr	r5, [pc, #24]	@ (800ece0 <_close_r+0x1c>)
 800ecc8:	2300      	movs	r3, #0
 800ecca:	4604      	mov	r4, r0
 800eccc:	4608      	mov	r0, r1
 800ecce:	602b      	str	r3, [r5, #0]
 800ecd0:	f7f2 fd7d 	bl	80017ce <_close>
 800ecd4:	1c43      	adds	r3, r0, #1
 800ecd6:	d102      	bne.n	800ecde <_close_r+0x1a>
 800ecd8:	682b      	ldr	r3, [r5, #0]
 800ecda:	b103      	cbz	r3, 800ecde <_close_r+0x1a>
 800ecdc:	6023      	str	r3, [r4, #0]
 800ecde:	bd38      	pop	{r3, r4, r5, pc}
 800ece0:	20014694 	.word	0x20014694

0800ece4 <_reclaim_reent>:
 800ece4:	4b2d      	ldr	r3, [pc, #180]	@ (800ed9c <_reclaim_reent+0xb8>)
 800ece6:	681b      	ldr	r3, [r3, #0]
 800ece8:	4283      	cmp	r3, r0
 800ecea:	b570      	push	{r4, r5, r6, lr}
 800ecec:	4604      	mov	r4, r0
 800ecee:	d053      	beq.n	800ed98 <_reclaim_reent+0xb4>
 800ecf0:	69c3      	ldr	r3, [r0, #28]
 800ecf2:	b31b      	cbz	r3, 800ed3c <_reclaim_reent+0x58>
 800ecf4:	68db      	ldr	r3, [r3, #12]
 800ecf6:	b163      	cbz	r3, 800ed12 <_reclaim_reent+0x2e>
 800ecf8:	2500      	movs	r5, #0
 800ecfa:	69e3      	ldr	r3, [r4, #28]
 800ecfc:	68db      	ldr	r3, [r3, #12]
 800ecfe:	5959      	ldr	r1, [r3, r5]
 800ed00:	b9b1      	cbnz	r1, 800ed30 <_reclaim_reent+0x4c>
 800ed02:	3504      	adds	r5, #4
 800ed04:	2d80      	cmp	r5, #128	@ 0x80
 800ed06:	d1f8      	bne.n	800ecfa <_reclaim_reent+0x16>
 800ed08:	69e3      	ldr	r3, [r4, #28]
 800ed0a:	4620      	mov	r0, r4
 800ed0c:	68d9      	ldr	r1, [r3, #12]
 800ed0e:	f000 f8b9 	bl	800ee84 <_free_r>
 800ed12:	69e3      	ldr	r3, [r4, #28]
 800ed14:	6819      	ldr	r1, [r3, #0]
 800ed16:	b111      	cbz	r1, 800ed1e <_reclaim_reent+0x3a>
 800ed18:	4620      	mov	r0, r4
 800ed1a:	f000 f8b3 	bl	800ee84 <_free_r>
 800ed1e:	69e3      	ldr	r3, [r4, #28]
 800ed20:	689d      	ldr	r5, [r3, #8]
 800ed22:	b15d      	cbz	r5, 800ed3c <_reclaim_reent+0x58>
 800ed24:	4629      	mov	r1, r5
 800ed26:	4620      	mov	r0, r4
 800ed28:	682d      	ldr	r5, [r5, #0]
 800ed2a:	f000 f8ab 	bl	800ee84 <_free_r>
 800ed2e:	e7f8      	b.n	800ed22 <_reclaim_reent+0x3e>
 800ed30:	680e      	ldr	r6, [r1, #0]
 800ed32:	4620      	mov	r0, r4
 800ed34:	f000 f8a6 	bl	800ee84 <_free_r>
 800ed38:	4631      	mov	r1, r6
 800ed3a:	e7e1      	b.n	800ed00 <_reclaim_reent+0x1c>
 800ed3c:	6961      	ldr	r1, [r4, #20]
 800ed3e:	b111      	cbz	r1, 800ed46 <_reclaim_reent+0x62>
 800ed40:	4620      	mov	r0, r4
 800ed42:	f000 f89f 	bl	800ee84 <_free_r>
 800ed46:	69e1      	ldr	r1, [r4, #28]
 800ed48:	b111      	cbz	r1, 800ed50 <_reclaim_reent+0x6c>
 800ed4a:	4620      	mov	r0, r4
 800ed4c:	f000 f89a 	bl	800ee84 <_free_r>
 800ed50:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 800ed52:	b111      	cbz	r1, 800ed5a <_reclaim_reent+0x76>
 800ed54:	4620      	mov	r0, r4
 800ed56:	f000 f895 	bl	800ee84 <_free_r>
 800ed5a:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800ed5c:	b111      	cbz	r1, 800ed64 <_reclaim_reent+0x80>
 800ed5e:	4620      	mov	r0, r4
 800ed60:	f000 f890 	bl	800ee84 <_free_r>
 800ed64:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 800ed66:	b111      	cbz	r1, 800ed6e <_reclaim_reent+0x8a>
 800ed68:	4620      	mov	r0, r4
 800ed6a:	f000 f88b 	bl	800ee84 <_free_r>
 800ed6e:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 800ed70:	b111      	cbz	r1, 800ed78 <_reclaim_reent+0x94>
 800ed72:	4620      	mov	r0, r4
 800ed74:	f000 f886 	bl	800ee84 <_free_r>
 800ed78:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 800ed7a:	b111      	cbz	r1, 800ed82 <_reclaim_reent+0x9e>
 800ed7c:	4620      	mov	r0, r4
 800ed7e:	f000 f881 	bl	800ee84 <_free_r>
 800ed82:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 800ed84:	b111      	cbz	r1, 800ed8c <_reclaim_reent+0xa8>
 800ed86:	4620      	mov	r0, r4
 800ed88:	f000 f87c 	bl	800ee84 <_free_r>
 800ed8c:	6a23      	ldr	r3, [r4, #32]
 800ed8e:	b11b      	cbz	r3, 800ed98 <_reclaim_reent+0xb4>
 800ed90:	4620      	mov	r0, r4
 800ed92:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800ed96:	4718      	bx	r3
 800ed98:	bd70      	pop	{r4, r5, r6, pc}
 800ed9a:	bf00      	nop
 800ed9c:	20000030 	.word	0x20000030

0800eda0 <_lseek_r>:
 800eda0:	b538      	push	{r3, r4, r5, lr}
 800eda2:	4d07      	ldr	r5, [pc, #28]	@ (800edc0 <_lseek_r+0x20>)
 800eda4:	4604      	mov	r4, r0
 800eda6:	4608      	mov	r0, r1
 800eda8:	4611      	mov	r1, r2
 800edaa:	2200      	movs	r2, #0
 800edac:	602a      	str	r2, [r5, #0]
 800edae:	461a      	mov	r2, r3
 800edb0:	f7f2 fd17 	bl	80017e2 <_lseek>
 800edb4:	1c43      	adds	r3, r0, #1
 800edb6:	d102      	bne.n	800edbe <_lseek_r+0x1e>
 800edb8:	682b      	ldr	r3, [r5, #0]
 800edba:	b103      	cbz	r3, 800edbe <_lseek_r+0x1e>
 800edbc:	6023      	str	r3, [r4, #0]
 800edbe:	bd38      	pop	{r3, r4, r5, pc}
 800edc0:	20014694 	.word	0x20014694

0800edc4 <_read_r>:
 800edc4:	b538      	push	{r3, r4, r5, lr}
 800edc6:	4d07      	ldr	r5, [pc, #28]	@ (800ede4 <_read_r+0x20>)
 800edc8:	4604      	mov	r4, r0
 800edca:	4608      	mov	r0, r1
 800edcc:	4611      	mov	r1, r2
 800edce:	2200      	movs	r2, #0
 800edd0:	602a      	str	r2, [r5, #0]
 800edd2:	461a      	mov	r2, r3
 800edd4:	f7f2 fcdd 	bl	8001792 <_read>
 800edd8:	1c43      	adds	r3, r0, #1
 800edda:	d102      	bne.n	800ede2 <_read_r+0x1e>
 800eddc:	682b      	ldr	r3, [r5, #0]
 800edde:	b103      	cbz	r3, 800ede2 <_read_r+0x1e>
 800ede0:	6023      	str	r3, [r4, #0]
 800ede2:	bd38      	pop	{r3, r4, r5, pc}
 800ede4:	20014694 	.word	0x20014694

0800ede8 <_write_r>:
 800ede8:	b538      	push	{r3, r4, r5, lr}
 800edea:	4d07      	ldr	r5, [pc, #28]	@ (800ee08 <_write_r+0x20>)
 800edec:	4604      	mov	r4, r0
 800edee:	4608      	mov	r0, r1
 800edf0:	4611      	mov	r1, r2
 800edf2:	2200      	movs	r2, #0
 800edf4:	602a      	str	r2, [r5, #0]
 800edf6:	461a      	mov	r2, r3
 800edf8:	f7f2 fcdb 	bl	80017b2 <_write>
 800edfc:	1c43      	adds	r3, r0, #1
 800edfe:	d102      	bne.n	800ee06 <_write_r+0x1e>
 800ee00:	682b      	ldr	r3, [r5, #0]
 800ee02:	b103      	cbz	r3, 800ee06 <_write_r+0x1e>
 800ee04:	6023      	str	r3, [r4, #0]
 800ee06:	bd38      	pop	{r3, r4, r5, pc}
 800ee08:	20014694 	.word	0x20014694

0800ee0c <__errno>:
 800ee0c:	4b01      	ldr	r3, [pc, #4]	@ (800ee14 <__errno+0x8>)
 800ee0e:	6818      	ldr	r0, [r3, #0]
 800ee10:	4770      	bx	lr
 800ee12:	bf00      	nop
 800ee14:	20000030 	.word	0x20000030

0800ee18 <__libc_init_array>:
 800ee18:	b570      	push	{r4, r5, r6, lr}
 800ee1a:	4d0d      	ldr	r5, [pc, #52]	@ (800ee50 <__libc_init_array+0x38>)
 800ee1c:	4c0d      	ldr	r4, [pc, #52]	@ (800ee54 <__libc_init_array+0x3c>)
 800ee1e:	1b64      	subs	r4, r4, r5
 800ee20:	10a4      	asrs	r4, r4, #2
 800ee22:	2600      	movs	r6, #0
 800ee24:	42a6      	cmp	r6, r4
 800ee26:	d109      	bne.n	800ee3c <__libc_init_array+0x24>
 800ee28:	4d0b      	ldr	r5, [pc, #44]	@ (800ee58 <__libc_init_array+0x40>)
 800ee2a:	4c0c      	ldr	r4, [pc, #48]	@ (800ee5c <__libc_init_array+0x44>)
 800ee2c:	f001 f85e 	bl	800feec <_init>
 800ee30:	1b64      	subs	r4, r4, r5
 800ee32:	10a4      	asrs	r4, r4, #2
 800ee34:	2600      	movs	r6, #0
 800ee36:	42a6      	cmp	r6, r4
 800ee38:	d105      	bne.n	800ee46 <__libc_init_array+0x2e>
 800ee3a:	bd70      	pop	{r4, r5, r6, pc}
 800ee3c:	f855 3b04 	ldr.w	r3, [r5], #4
 800ee40:	4798      	blx	r3
 800ee42:	3601      	adds	r6, #1
 800ee44:	e7ee      	b.n	800ee24 <__libc_init_array+0xc>
 800ee46:	f855 3b04 	ldr.w	r3, [r5], #4
 800ee4a:	4798      	blx	r3
 800ee4c:	3601      	adds	r6, #1
 800ee4e:	e7f2      	b.n	800ee36 <__libc_init_array+0x1e>
 800ee50:	080103b4 	.word	0x080103b4
 800ee54:	080103b4 	.word	0x080103b4
 800ee58:	080103b4 	.word	0x080103b4
 800ee5c:	080103b8 	.word	0x080103b8

0800ee60 <__retarget_lock_init_recursive>:
 800ee60:	4770      	bx	lr

0800ee62 <__retarget_lock_acquire_recursive>:
 800ee62:	4770      	bx	lr

0800ee64 <__retarget_lock_release_recursive>:
 800ee64:	4770      	bx	lr

0800ee66 <memcpy>:
 800ee66:	440a      	add	r2, r1
 800ee68:	4291      	cmp	r1, r2
 800ee6a:	f100 33ff 	add.w	r3, r0, #4294967295
 800ee6e:	d100      	bne.n	800ee72 <memcpy+0xc>
 800ee70:	4770      	bx	lr
 800ee72:	b510      	push	{r4, lr}
 800ee74:	f811 4b01 	ldrb.w	r4, [r1], #1
 800ee78:	f803 4f01 	strb.w	r4, [r3, #1]!
 800ee7c:	4291      	cmp	r1, r2
 800ee7e:	d1f9      	bne.n	800ee74 <memcpy+0xe>
 800ee80:	bd10      	pop	{r4, pc}
	...

0800ee84 <_free_r>:
 800ee84:	b538      	push	{r3, r4, r5, lr}
 800ee86:	4605      	mov	r5, r0
 800ee88:	2900      	cmp	r1, #0
 800ee8a:	d041      	beq.n	800ef10 <_free_r+0x8c>
 800ee8c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800ee90:	1f0c      	subs	r4, r1, #4
 800ee92:	2b00      	cmp	r3, #0
 800ee94:	bfb8      	it	lt
 800ee96:	18e4      	addlt	r4, r4, r3
 800ee98:	f000 f8e0 	bl	800f05c <__malloc_lock>
 800ee9c:	4a1d      	ldr	r2, [pc, #116]	@ (800ef14 <_free_r+0x90>)
 800ee9e:	6813      	ldr	r3, [r2, #0]
 800eea0:	b933      	cbnz	r3, 800eeb0 <_free_r+0x2c>
 800eea2:	6063      	str	r3, [r4, #4]
 800eea4:	6014      	str	r4, [r2, #0]
 800eea6:	4628      	mov	r0, r5
 800eea8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800eeac:	f000 b8dc 	b.w	800f068 <__malloc_unlock>
 800eeb0:	42a3      	cmp	r3, r4
 800eeb2:	d908      	bls.n	800eec6 <_free_r+0x42>
 800eeb4:	6820      	ldr	r0, [r4, #0]
 800eeb6:	1821      	adds	r1, r4, r0
 800eeb8:	428b      	cmp	r3, r1
 800eeba:	bf01      	itttt	eq
 800eebc:	6819      	ldreq	r1, [r3, #0]
 800eebe:	685b      	ldreq	r3, [r3, #4]
 800eec0:	1809      	addeq	r1, r1, r0
 800eec2:	6021      	streq	r1, [r4, #0]
 800eec4:	e7ed      	b.n	800eea2 <_free_r+0x1e>
 800eec6:	461a      	mov	r2, r3
 800eec8:	685b      	ldr	r3, [r3, #4]
 800eeca:	b10b      	cbz	r3, 800eed0 <_free_r+0x4c>
 800eecc:	42a3      	cmp	r3, r4
 800eece:	d9fa      	bls.n	800eec6 <_free_r+0x42>
 800eed0:	6811      	ldr	r1, [r2, #0]
 800eed2:	1850      	adds	r0, r2, r1
 800eed4:	42a0      	cmp	r0, r4
 800eed6:	d10b      	bne.n	800eef0 <_free_r+0x6c>
 800eed8:	6820      	ldr	r0, [r4, #0]
 800eeda:	4401      	add	r1, r0
 800eedc:	1850      	adds	r0, r2, r1
 800eede:	4283      	cmp	r3, r0
 800eee0:	6011      	str	r1, [r2, #0]
 800eee2:	d1e0      	bne.n	800eea6 <_free_r+0x22>
 800eee4:	6818      	ldr	r0, [r3, #0]
 800eee6:	685b      	ldr	r3, [r3, #4]
 800eee8:	6053      	str	r3, [r2, #4]
 800eeea:	4408      	add	r0, r1
 800eeec:	6010      	str	r0, [r2, #0]
 800eeee:	e7da      	b.n	800eea6 <_free_r+0x22>
 800eef0:	d902      	bls.n	800eef8 <_free_r+0x74>
 800eef2:	230c      	movs	r3, #12
 800eef4:	602b      	str	r3, [r5, #0]
 800eef6:	e7d6      	b.n	800eea6 <_free_r+0x22>
 800eef8:	6820      	ldr	r0, [r4, #0]
 800eefa:	1821      	adds	r1, r4, r0
 800eefc:	428b      	cmp	r3, r1
 800eefe:	bf04      	itt	eq
 800ef00:	6819      	ldreq	r1, [r3, #0]
 800ef02:	685b      	ldreq	r3, [r3, #4]
 800ef04:	6063      	str	r3, [r4, #4]
 800ef06:	bf04      	itt	eq
 800ef08:	1809      	addeq	r1, r1, r0
 800ef0a:	6021      	streq	r1, [r4, #0]
 800ef0c:	6054      	str	r4, [r2, #4]
 800ef0e:	e7ca      	b.n	800eea6 <_free_r+0x22>
 800ef10:	bd38      	pop	{r3, r4, r5, pc}
 800ef12:	bf00      	nop
 800ef14:	200146a0 	.word	0x200146a0

0800ef18 <sbrk_aligned>:
 800ef18:	b570      	push	{r4, r5, r6, lr}
 800ef1a:	4e0f      	ldr	r6, [pc, #60]	@ (800ef58 <sbrk_aligned+0x40>)
 800ef1c:	460c      	mov	r4, r1
 800ef1e:	6831      	ldr	r1, [r6, #0]
 800ef20:	4605      	mov	r5, r0
 800ef22:	b911      	cbnz	r1, 800ef2a <sbrk_aligned+0x12>
 800ef24:	f000 fdfc 	bl	800fb20 <_sbrk_r>
 800ef28:	6030      	str	r0, [r6, #0]
 800ef2a:	4621      	mov	r1, r4
 800ef2c:	4628      	mov	r0, r5
 800ef2e:	f000 fdf7 	bl	800fb20 <_sbrk_r>
 800ef32:	1c43      	adds	r3, r0, #1
 800ef34:	d103      	bne.n	800ef3e <sbrk_aligned+0x26>
 800ef36:	f04f 34ff 	mov.w	r4, #4294967295
 800ef3a:	4620      	mov	r0, r4
 800ef3c:	bd70      	pop	{r4, r5, r6, pc}
 800ef3e:	1cc4      	adds	r4, r0, #3
 800ef40:	f024 0403 	bic.w	r4, r4, #3
 800ef44:	42a0      	cmp	r0, r4
 800ef46:	d0f8      	beq.n	800ef3a <sbrk_aligned+0x22>
 800ef48:	1a21      	subs	r1, r4, r0
 800ef4a:	4628      	mov	r0, r5
 800ef4c:	f000 fde8 	bl	800fb20 <_sbrk_r>
 800ef50:	3001      	adds	r0, #1
 800ef52:	d1f2      	bne.n	800ef3a <sbrk_aligned+0x22>
 800ef54:	e7ef      	b.n	800ef36 <sbrk_aligned+0x1e>
 800ef56:	bf00      	nop
 800ef58:	2001469c 	.word	0x2001469c

0800ef5c <_malloc_r>:
 800ef5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ef60:	1ccd      	adds	r5, r1, #3
 800ef62:	f025 0503 	bic.w	r5, r5, #3
 800ef66:	3508      	adds	r5, #8
 800ef68:	2d0c      	cmp	r5, #12
 800ef6a:	bf38      	it	cc
 800ef6c:	250c      	movcc	r5, #12
 800ef6e:	2d00      	cmp	r5, #0
 800ef70:	4606      	mov	r6, r0
 800ef72:	db01      	blt.n	800ef78 <_malloc_r+0x1c>
 800ef74:	42a9      	cmp	r1, r5
 800ef76:	d904      	bls.n	800ef82 <_malloc_r+0x26>
 800ef78:	230c      	movs	r3, #12
 800ef7a:	6033      	str	r3, [r6, #0]
 800ef7c:	2000      	movs	r0, #0
 800ef7e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ef82:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 800f058 <_malloc_r+0xfc>
 800ef86:	f000 f869 	bl	800f05c <__malloc_lock>
 800ef8a:	f8d8 3000 	ldr.w	r3, [r8]
 800ef8e:	461c      	mov	r4, r3
 800ef90:	bb44      	cbnz	r4, 800efe4 <_malloc_r+0x88>
 800ef92:	4629      	mov	r1, r5
 800ef94:	4630      	mov	r0, r6
 800ef96:	f7ff ffbf 	bl	800ef18 <sbrk_aligned>
 800ef9a:	1c43      	adds	r3, r0, #1
 800ef9c:	4604      	mov	r4, r0
 800ef9e:	d158      	bne.n	800f052 <_malloc_r+0xf6>
 800efa0:	f8d8 4000 	ldr.w	r4, [r8]
 800efa4:	4627      	mov	r7, r4
 800efa6:	2f00      	cmp	r7, #0
 800efa8:	d143      	bne.n	800f032 <_malloc_r+0xd6>
 800efaa:	2c00      	cmp	r4, #0
 800efac:	d04b      	beq.n	800f046 <_malloc_r+0xea>
 800efae:	6823      	ldr	r3, [r4, #0]
 800efb0:	4639      	mov	r1, r7
 800efb2:	4630      	mov	r0, r6
 800efb4:	eb04 0903 	add.w	r9, r4, r3
 800efb8:	f000 fdb2 	bl	800fb20 <_sbrk_r>
 800efbc:	4581      	cmp	r9, r0
 800efbe:	d142      	bne.n	800f046 <_malloc_r+0xea>
 800efc0:	6821      	ldr	r1, [r4, #0]
 800efc2:	1a6d      	subs	r5, r5, r1
 800efc4:	4629      	mov	r1, r5
 800efc6:	4630      	mov	r0, r6
 800efc8:	f7ff ffa6 	bl	800ef18 <sbrk_aligned>
 800efcc:	3001      	adds	r0, #1
 800efce:	d03a      	beq.n	800f046 <_malloc_r+0xea>
 800efd0:	6823      	ldr	r3, [r4, #0]
 800efd2:	442b      	add	r3, r5
 800efd4:	6023      	str	r3, [r4, #0]
 800efd6:	f8d8 3000 	ldr.w	r3, [r8]
 800efda:	685a      	ldr	r2, [r3, #4]
 800efdc:	bb62      	cbnz	r2, 800f038 <_malloc_r+0xdc>
 800efde:	f8c8 7000 	str.w	r7, [r8]
 800efe2:	e00f      	b.n	800f004 <_malloc_r+0xa8>
 800efe4:	6822      	ldr	r2, [r4, #0]
 800efe6:	1b52      	subs	r2, r2, r5
 800efe8:	d420      	bmi.n	800f02c <_malloc_r+0xd0>
 800efea:	2a0b      	cmp	r2, #11
 800efec:	d917      	bls.n	800f01e <_malloc_r+0xc2>
 800efee:	1961      	adds	r1, r4, r5
 800eff0:	42a3      	cmp	r3, r4
 800eff2:	6025      	str	r5, [r4, #0]
 800eff4:	bf18      	it	ne
 800eff6:	6059      	strne	r1, [r3, #4]
 800eff8:	6863      	ldr	r3, [r4, #4]
 800effa:	bf08      	it	eq
 800effc:	f8c8 1000 	streq.w	r1, [r8]
 800f000:	5162      	str	r2, [r4, r5]
 800f002:	604b      	str	r3, [r1, #4]
 800f004:	4630      	mov	r0, r6
 800f006:	f000 f82f 	bl	800f068 <__malloc_unlock>
 800f00a:	f104 000b 	add.w	r0, r4, #11
 800f00e:	1d23      	adds	r3, r4, #4
 800f010:	f020 0007 	bic.w	r0, r0, #7
 800f014:	1ac2      	subs	r2, r0, r3
 800f016:	bf1c      	itt	ne
 800f018:	1a1b      	subne	r3, r3, r0
 800f01a:	50a3      	strne	r3, [r4, r2]
 800f01c:	e7af      	b.n	800ef7e <_malloc_r+0x22>
 800f01e:	6862      	ldr	r2, [r4, #4]
 800f020:	42a3      	cmp	r3, r4
 800f022:	bf0c      	ite	eq
 800f024:	f8c8 2000 	streq.w	r2, [r8]
 800f028:	605a      	strne	r2, [r3, #4]
 800f02a:	e7eb      	b.n	800f004 <_malloc_r+0xa8>
 800f02c:	4623      	mov	r3, r4
 800f02e:	6864      	ldr	r4, [r4, #4]
 800f030:	e7ae      	b.n	800ef90 <_malloc_r+0x34>
 800f032:	463c      	mov	r4, r7
 800f034:	687f      	ldr	r7, [r7, #4]
 800f036:	e7b6      	b.n	800efa6 <_malloc_r+0x4a>
 800f038:	461a      	mov	r2, r3
 800f03a:	685b      	ldr	r3, [r3, #4]
 800f03c:	42a3      	cmp	r3, r4
 800f03e:	d1fb      	bne.n	800f038 <_malloc_r+0xdc>
 800f040:	2300      	movs	r3, #0
 800f042:	6053      	str	r3, [r2, #4]
 800f044:	e7de      	b.n	800f004 <_malloc_r+0xa8>
 800f046:	230c      	movs	r3, #12
 800f048:	6033      	str	r3, [r6, #0]
 800f04a:	4630      	mov	r0, r6
 800f04c:	f000 f80c 	bl	800f068 <__malloc_unlock>
 800f050:	e794      	b.n	800ef7c <_malloc_r+0x20>
 800f052:	6005      	str	r5, [r0, #0]
 800f054:	e7d6      	b.n	800f004 <_malloc_r+0xa8>
 800f056:	bf00      	nop
 800f058:	200146a0 	.word	0x200146a0

0800f05c <__malloc_lock>:
 800f05c:	4801      	ldr	r0, [pc, #4]	@ (800f064 <__malloc_lock+0x8>)
 800f05e:	f7ff bf00 	b.w	800ee62 <__retarget_lock_acquire_recursive>
 800f062:	bf00      	nop
 800f064:	20014698 	.word	0x20014698

0800f068 <__malloc_unlock>:
 800f068:	4801      	ldr	r0, [pc, #4]	@ (800f070 <__malloc_unlock+0x8>)
 800f06a:	f7ff befb 	b.w	800ee64 <__retarget_lock_release_recursive>
 800f06e:	bf00      	nop
 800f070:	20014698 	.word	0x20014698

0800f074 <__ssputs_r>:
 800f074:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800f078:	688e      	ldr	r6, [r1, #8]
 800f07a:	461f      	mov	r7, r3
 800f07c:	42be      	cmp	r6, r7
 800f07e:	680b      	ldr	r3, [r1, #0]
 800f080:	4682      	mov	sl, r0
 800f082:	460c      	mov	r4, r1
 800f084:	4690      	mov	r8, r2
 800f086:	d82d      	bhi.n	800f0e4 <__ssputs_r+0x70>
 800f088:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 800f08c:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 800f090:	d026      	beq.n	800f0e0 <__ssputs_r+0x6c>
 800f092:	6965      	ldr	r5, [r4, #20]
 800f094:	6909      	ldr	r1, [r1, #16]
 800f096:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800f09a:	eba3 0901 	sub.w	r9, r3, r1
 800f09e:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 800f0a2:	1c7b      	adds	r3, r7, #1
 800f0a4:	444b      	add	r3, r9
 800f0a6:	106d      	asrs	r5, r5, #1
 800f0a8:	429d      	cmp	r5, r3
 800f0aa:	bf38      	it	cc
 800f0ac:	461d      	movcc	r5, r3
 800f0ae:	0553      	lsls	r3, r2, #21
 800f0b0:	d527      	bpl.n	800f102 <__ssputs_r+0x8e>
 800f0b2:	4629      	mov	r1, r5
 800f0b4:	f7ff ff52 	bl	800ef5c <_malloc_r>
 800f0b8:	4606      	mov	r6, r0
 800f0ba:	b360      	cbz	r0, 800f116 <__ssputs_r+0xa2>
 800f0bc:	6921      	ldr	r1, [r4, #16]
 800f0be:	464a      	mov	r2, r9
 800f0c0:	f7ff fed1 	bl	800ee66 <memcpy>
 800f0c4:	89a3      	ldrh	r3, [r4, #12]
 800f0c6:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 800f0ca:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800f0ce:	81a3      	strh	r3, [r4, #12]
 800f0d0:	6126      	str	r6, [r4, #16]
 800f0d2:	6165      	str	r5, [r4, #20]
 800f0d4:	444e      	add	r6, r9
 800f0d6:	eba5 0509 	sub.w	r5, r5, r9
 800f0da:	6026      	str	r6, [r4, #0]
 800f0dc:	60a5      	str	r5, [r4, #8]
 800f0de:	463e      	mov	r6, r7
 800f0e0:	42be      	cmp	r6, r7
 800f0e2:	d900      	bls.n	800f0e6 <__ssputs_r+0x72>
 800f0e4:	463e      	mov	r6, r7
 800f0e6:	6820      	ldr	r0, [r4, #0]
 800f0e8:	4632      	mov	r2, r6
 800f0ea:	4641      	mov	r1, r8
 800f0ec:	f7ff fdc8 	bl	800ec80 <memmove>
 800f0f0:	68a3      	ldr	r3, [r4, #8]
 800f0f2:	1b9b      	subs	r3, r3, r6
 800f0f4:	60a3      	str	r3, [r4, #8]
 800f0f6:	6823      	ldr	r3, [r4, #0]
 800f0f8:	4433      	add	r3, r6
 800f0fa:	6023      	str	r3, [r4, #0]
 800f0fc:	2000      	movs	r0, #0
 800f0fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800f102:	462a      	mov	r2, r5
 800f104:	f000 fd1c 	bl	800fb40 <_realloc_r>
 800f108:	4606      	mov	r6, r0
 800f10a:	2800      	cmp	r0, #0
 800f10c:	d1e0      	bne.n	800f0d0 <__ssputs_r+0x5c>
 800f10e:	6921      	ldr	r1, [r4, #16]
 800f110:	4650      	mov	r0, sl
 800f112:	f7ff feb7 	bl	800ee84 <_free_r>
 800f116:	230c      	movs	r3, #12
 800f118:	f8ca 3000 	str.w	r3, [sl]
 800f11c:	89a3      	ldrh	r3, [r4, #12]
 800f11e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800f122:	81a3      	strh	r3, [r4, #12]
 800f124:	f04f 30ff 	mov.w	r0, #4294967295
 800f128:	e7e9      	b.n	800f0fe <__ssputs_r+0x8a>
	...

0800f12c <_svfiprintf_r>:
 800f12c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f130:	4698      	mov	r8, r3
 800f132:	898b      	ldrh	r3, [r1, #12]
 800f134:	061b      	lsls	r3, r3, #24
 800f136:	b09d      	sub	sp, #116	@ 0x74
 800f138:	4607      	mov	r7, r0
 800f13a:	460d      	mov	r5, r1
 800f13c:	4614      	mov	r4, r2
 800f13e:	d510      	bpl.n	800f162 <_svfiprintf_r+0x36>
 800f140:	690b      	ldr	r3, [r1, #16]
 800f142:	b973      	cbnz	r3, 800f162 <_svfiprintf_r+0x36>
 800f144:	2140      	movs	r1, #64	@ 0x40
 800f146:	f7ff ff09 	bl	800ef5c <_malloc_r>
 800f14a:	6028      	str	r0, [r5, #0]
 800f14c:	6128      	str	r0, [r5, #16]
 800f14e:	b930      	cbnz	r0, 800f15e <_svfiprintf_r+0x32>
 800f150:	230c      	movs	r3, #12
 800f152:	603b      	str	r3, [r7, #0]
 800f154:	f04f 30ff 	mov.w	r0, #4294967295
 800f158:	b01d      	add	sp, #116	@ 0x74
 800f15a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f15e:	2340      	movs	r3, #64	@ 0x40
 800f160:	616b      	str	r3, [r5, #20]
 800f162:	2300      	movs	r3, #0
 800f164:	9309      	str	r3, [sp, #36]	@ 0x24
 800f166:	2320      	movs	r3, #32
 800f168:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 800f16c:	f8cd 800c 	str.w	r8, [sp, #12]
 800f170:	2330      	movs	r3, #48	@ 0x30
 800f172:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 800f310 <_svfiprintf_r+0x1e4>
 800f176:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 800f17a:	f04f 0901 	mov.w	r9, #1
 800f17e:	4623      	mov	r3, r4
 800f180:	469a      	mov	sl, r3
 800f182:	f813 2b01 	ldrb.w	r2, [r3], #1
 800f186:	b10a      	cbz	r2, 800f18c <_svfiprintf_r+0x60>
 800f188:	2a25      	cmp	r2, #37	@ 0x25
 800f18a:	d1f9      	bne.n	800f180 <_svfiprintf_r+0x54>
 800f18c:	ebba 0b04 	subs.w	fp, sl, r4
 800f190:	d00b      	beq.n	800f1aa <_svfiprintf_r+0x7e>
 800f192:	465b      	mov	r3, fp
 800f194:	4622      	mov	r2, r4
 800f196:	4629      	mov	r1, r5
 800f198:	4638      	mov	r0, r7
 800f19a:	f7ff ff6b 	bl	800f074 <__ssputs_r>
 800f19e:	3001      	adds	r0, #1
 800f1a0:	f000 80a7 	beq.w	800f2f2 <_svfiprintf_r+0x1c6>
 800f1a4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800f1a6:	445a      	add	r2, fp
 800f1a8:	9209      	str	r2, [sp, #36]	@ 0x24
 800f1aa:	f89a 3000 	ldrb.w	r3, [sl]
 800f1ae:	2b00      	cmp	r3, #0
 800f1b0:	f000 809f 	beq.w	800f2f2 <_svfiprintf_r+0x1c6>
 800f1b4:	2300      	movs	r3, #0
 800f1b6:	f04f 32ff 	mov.w	r2, #4294967295
 800f1ba:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800f1be:	f10a 0a01 	add.w	sl, sl, #1
 800f1c2:	9304      	str	r3, [sp, #16]
 800f1c4:	9307      	str	r3, [sp, #28]
 800f1c6:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 800f1ca:	931a      	str	r3, [sp, #104]	@ 0x68
 800f1cc:	4654      	mov	r4, sl
 800f1ce:	2205      	movs	r2, #5
 800f1d0:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f1d4:	484e      	ldr	r0, [pc, #312]	@ (800f310 <_svfiprintf_r+0x1e4>)
 800f1d6:	f7f1 f80b 	bl	80001f0 <memchr>
 800f1da:	9a04      	ldr	r2, [sp, #16]
 800f1dc:	b9d8      	cbnz	r0, 800f216 <_svfiprintf_r+0xea>
 800f1de:	06d0      	lsls	r0, r2, #27
 800f1e0:	bf44      	itt	mi
 800f1e2:	2320      	movmi	r3, #32
 800f1e4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800f1e8:	0711      	lsls	r1, r2, #28
 800f1ea:	bf44      	itt	mi
 800f1ec:	232b      	movmi	r3, #43	@ 0x2b
 800f1ee:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800f1f2:	f89a 3000 	ldrb.w	r3, [sl]
 800f1f6:	2b2a      	cmp	r3, #42	@ 0x2a
 800f1f8:	d015      	beq.n	800f226 <_svfiprintf_r+0xfa>
 800f1fa:	9a07      	ldr	r2, [sp, #28]
 800f1fc:	4654      	mov	r4, sl
 800f1fe:	2000      	movs	r0, #0
 800f200:	f04f 0c0a 	mov.w	ip, #10
 800f204:	4621      	mov	r1, r4
 800f206:	f811 3b01 	ldrb.w	r3, [r1], #1
 800f20a:	3b30      	subs	r3, #48	@ 0x30
 800f20c:	2b09      	cmp	r3, #9
 800f20e:	d94b      	bls.n	800f2a8 <_svfiprintf_r+0x17c>
 800f210:	b1b0      	cbz	r0, 800f240 <_svfiprintf_r+0x114>
 800f212:	9207      	str	r2, [sp, #28]
 800f214:	e014      	b.n	800f240 <_svfiprintf_r+0x114>
 800f216:	eba0 0308 	sub.w	r3, r0, r8
 800f21a:	fa09 f303 	lsl.w	r3, r9, r3
 800f21e:	4313      	orrs	r3, r2
 800f220:	9304      	str	r3, [sp, #16]
 800f222:	46a2      	mov	sl, r4
 800f224:	e7d2      	b.n	800f1cc <_svfiprintf_r+0xa0>
 800f226:	9b03      	ldr	r3, [sp, #12]
 800f228:	1d19      	adds	r1, r3, #4
 800f22a:	681b      	ldr	r3, [r3, #0]
 800f22c:	9103      	str	r1, [sp, #12]
 800f22e:	2b00      	cmp	r3, #0
 800f230:	bfbb      	ittet	lt
 800f232:	425b      	neglt	r3, r3
 800f234:	f042 0202 	orrlt.w	r2, r2, #2
 800f238:	9307      	strge	r3, [sp, #28]
 800f23a:	9307      	strlt	r3, [sp, #28]
 800f23c:	bfb8      	it	lt
 800f23e:	9204      	strlt	r2, [sp, #16]
 800f240:	7823      	ldrb	r3, [r4, #0]
 800f242:	2b2e      	cmp	r3, #46	@ 0x2e
 800f244:	d10a      	bne.n	800f25c <_svfiprintf_r+0x130>
 800f246:	7863      	ldrb	r3, [r4, #1]
 800f248:	2b2a      	cmp	r3, #42	@ 0x2a
 800f24a:	d132      	bne.n	800f2b2 <_svfiprintf_r+0x186>
 800f24c:	9b03      	ldr	r3, [sp, #12]
 800f24e:	1d1a      	adds	r2, r3, #4
 800f250:	681b      	ldr	r3, [r3, #0]
 800f252:	9203      	str	r2, [sp, #12]
 800f254:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 800f258:	3402      	adds	r4, #2
 800f25a:	9305      	str	r3, [sp, #20]
 800f25c:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 800f320 <_svfiprintf_r+0x1f4>
 800f260:	7821      	ldrb	r1, [r4, #0]
 800f262:	2203      	movs	r2, #3
 800f264:	4650      	mov	r0, sl
 800f266:	f7f0 ffc3 	bl	80001f0 <memchr>
 800f26a:	b138      	cbz	r0, 800f27c <_svfiprintf_r+0x150>
 800f26c:	9b04      	ldr	r3, [sp, #16]
 800f26e:	eba0 000a 	sub.w	r0, r0, sl
 800f272:	2240      	movs	r2, #64	@ 0x40
 800f274:	4082      	lsls	r2, r0
 800f276:	4313      	orrs	r3, r2
 800f278:	3401      	adds	r4, #1
 800f27a:	9304      	str	r3, [sp, #16]
 800f27c:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f280:	4824      	ldr	r0, [pc, #144]	@ (800f314 <_svfiprintf_r+0x1e8>)
 800f282:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 800f286:	2206      	movs	r2, #6
 800f288:	f7f0 ffb2 	bl	80001f0 <memchr>
 800f28c:	2800      	cmp	r0, #0
 800f28e:	d036      	beq.n	800f2fe <_svfiprintf_r+0x1d2>
 800f290:	4b21      	ldr	r3, [pc, #132]	@ (800f318 <_svfiprintf_r+0x1ec>)
 800f292:	bb1b      	cbnz	r3, 800f2dc <_svfiprintf_r+0x1b0>
 800f294:	9b03      	ldr	r3, [sp, #12]
 800f296:	3307      	adds	r3, #7
 800f298:	f023 0307 	bic.w	r3, r3, #7
 800f29c:	3308      	adds	r3, #8
 800f29e:	9303      	str	r3, [sp, #12]
 800f2a0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f2a2:	4433      	add	r3, r6
 800f2a4:	9309      	str	r3, [sp, #36]	@ 0x24
 800f2a6:	e76a      	b.n	800f17e <_svfiprintf_r+0x52>
 800f2a8:	fb0c 3202 	mla	r2, ip, r2, r3
 800f2ac:	460c      	mov	r4, r1
 800f2ae:	2001      	movs	r0, #1
 800f2b0:	e7a8      	b.n	800f204 <_svfiprintf_r+0xd8>
 800f2b2:	2300      	movs	r3, #0
 800f2b4:	3401      	adds	r4, #1
 800f2b6:	9305      	str	r3, [sp, #20]
 800f2b8:	4619      	mov	r1, r3
 800f2ba:	f04f 0c0a 	mov.w	ip, #10
 800f2be:	4620      	mov	r0, r4
 800f2c0:	f810 2b01 	ldrb.w	r2, [r0], #1
 800f2c4:	3a30      	subs	r2, #48	@ 0x30
 800f2c6:	2a09      	cmp	r2, #9
 800f2c8:	d903      	bls.n	800f2d2 <_svfiprintf_r+0x1a6>
 800f2ca:	2b00      	cmp	r3, #0
 800f2cc:	d0c6      	beq.n	800f25c <_svfiprintf_r+0x130>
 800f2ce:	9105      	str	r1, [sp, #20]
 800f2d0:	e7c4      	b.n	800f25c <_svfiprintf_r+0x130>
 800f2d2:	fb0c 2101 	mla	r1, ip, r1, r2
 800f2d6:	4604      	mov	r4, r0
 800f2d8:	2301      	movs	r3, #1
 800f2da:	e7f0      	b.n	800f2be <_svfiprintf_r+0x192>
 800f2dc:	ab03      	add	r3, sp, #12
 800f2de:	9300      	str	r3, [sp, #0]
 800f2e0:	462a      	mov	r2, r5
 800f2e2:	4b0e      	ldr	r3, [pc, #56]	@ (800f31c <_svfiprintf_r+0x1f0>)
 800f2e4:	a904      	add	r1, sp, #16
 800f2e6:	4638      	mov	r0, r7
 800f2e8:	f3af 8000 	nop.w
 800f2ec:	1c42      	adds	r2, r0, #1
 800f2ee:	4606      	mov	r6, r0
 800f2f0:	d1d6      	bne.n	800f2a0 <_svfiprintf_r+0x174>
 800f2f2:	89ab      	ldrh	r3, [r5, #12]
 800f2f4:	065b      	lsls	r3, r3, #25
 800f2f6:	f53f af2d 	bmi.w	800f154 <_svfiprintf_r+0x28>
 800f2fa:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800f2fc:	e72c      	b.n	800f158 <_svfiprintf_r+0x2c>
 800f2fe:	ab03      	add	r3, sp, #12
 800f300:	9300      	str	r3, [sp, #0]
 800f302:	462a      	mov	r2, r5
 800f304:	4b05      	ldr	r3, [pc, #20]	@ (800f31c <_svfiprintf_r+0x1f0>)
 800f306:	a904      	add	r1, sp, #16
 800f308:	4638      	mov	r0, r7
 800f30a:	f000 f9bb 	bl	800f684 <_printf_i>
 800f30e:	e7ed      	b.n	800f2ec <_svfiprintf_r+0x1c0>
 800f310:	08010340 	.word	0x08010340
 800f314:	0801034a 	.word	0x0801034a
 800f318:	00000000 	.word	0x00000000
 800f31c:	0800f075 	.word	0x0800f075
 800f320:	08010346 	.word	0x08010346

0800f324 <__sfputc_r>:
 800f324:	6893      	ldr	r3, [r2, #8]
 800f326:	3b01      	subs	r3, #1
 800f328:	2b00      	cmp	r3, #0
 800f32a:	b410      	push	{r4}
 800f32c:	6093      	str	r3, [r2, #8]
 800f32e:	da08      	bge.n	800f342 <__sfputc_r+0x1e>
 800f330:	6994      	ldr	r4, [r2, #24]
 800f332:	42a3      	cmp	r3, r4
 800f334:	db01      	blt.n	800f33a <__sfputc_r+0x16>
 800f336:	290a      	cmp	r1, #10
 800f338:	d103      	bne.n	800f342 <__sfputc_r+0x1e>
 800f33a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f33e:	f7ff bbfa 	b.w	800eb36 <__swbuf_r>
 800f342:	6813      	ldr	r3, [r2, #0]
 800f344:	1c58      	adds	r0, r3, #1
 800f346:	6010      	str	r0, [r2, #0]
 800f348:	7019      	strb	r1, [r3, #0]
 800f34a:	4608      	mov	r0, r1
 800f34c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800f350:	4770      	bx	lr

0800f352 <__sfputs_r>:
 800f352:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f354:	4606      	mov	r6, r0
 800f356:	460f      	mov	r7, r1
 800f358:	4614      	mov	r4, r2
 800f35a:	18d5      	adds	r5, r2, r3
 800f35c:	42ac      	cmp	r4, r5
 800f35e:	d101      	bne.n	800f364 <__sfputs_r+0x12>
 800f360:	2000      	movs	r0, #0
 800f362:	e007      	b.n	800f374 <__sfputs_r+0x22>
 800f364:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f368:	463a      	mov	r2, r7
 800f36a:	4630      	mov	r0, r6
 800f36c:	f7ff ffda 	bl	800f324 <__sfputc_r>
 800f370:	1c43      	adds	r3, r0, #1
 800f372:	d1f3      	bne.n	800f35c <__sfputs_r+0xa>
 800f374:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800f378 <_vfiprintf_r>:
 800f378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f37c:	460d      	mov	r5, r1
 800f37e:	b09d      	sub	sp, #116	@ 0x74
 800f380:	4614      	mov	r4, r2
 800f382:	4698      	mov	r8, r3
 800f384:	4606      	mov	r6, r0
 800f386:	b118      	cbz	r0, 800f390 <_vfiprintf_r+0x18>
 800f388:	6a03      	ldr	r3, [r0, #32]
 800f38a:	b90b      	cbnz	r3, 800f390 <_vfiprintf_r+0x18>
 800f38c:	f7ff fab4 	bl	800e8f8 <__sinit>
 800f390:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800f392:	07d9      	lsls	r1, r3, #31
 800f394:	d405      	bmi.n	800f3a2 <_vfiprintf_r+0x2a>
 800f396:	89ab      	ldrh	r3, [r5, #12]
 800f398:	059a      	lsls	r2, r3, #22
 800f39a:	d402      	bmi.n	800f3a2 <_vfiprintf_r+0x2a>
 800f39c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800f39e:	f7ff fd60 	bl	800ee62 <__retarget_lock_acquire_recursive>
 800f3a2:	89ab      	ldrh	r3, [r5, #12]
 800f3a4:	071b      	lsls	r3, r3, #28
 800f3a6:	d501      	bpl.n	800f3ac <_vfiprintf_r+0x34>
 800f3a8:	692b      	ldr	r3, [r5, #16]
 800f3aa:	b99b      	cbnz	r3, 800f3d4 <_vfiprintf_r+0x5c>
 800f3ac:	4629      	mov	r1, r5
 800f3ae:	4630      	mov	r0, r6
 800f3b0:	f7ff fc00 	bl	800ebb4 <__swsetup_r>
 800f3b4:	b170      	cbz	r0, 800f3d4 <_vfiprintf_r+0x5c>
 800f3b6:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800f3b8:	07dc      	lsls	r4, r3, #31
 800f3ba:	d504      	bpl.n	800f3c6 <_vfiprintf_r+0x4e>
 800f3bc:	f04f 30ff 	mov.w	r0, #4294967295
 800f3c0:	b01d      	add	sp, #116	@ 0x74
 800f3c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f3c6:	89ab      	ldrh	r3, [r5, #12]
 800f3c8:	0598      	lsls	r0, r3, #22
 800f3ca:	d4f7      	bmi.n	800f3bc <_vfiprintf_r+0x44>
 800f3cc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800f3ce:	f7ff fd49 	bl	800ee64 <__retarget_lock_release_recursive>
 800f3d2:	e7f3      	b.n	800f3bc <_vfiprintf_r+0x44>
 800f3d4:	2300      	movs	r3, #0
 800f3d6:	9309      	str	r3, [sp, #36]	@ 0x24
 800f3d8:	2320      	movs	r3, #32
 800f3da:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 800f3de:	f8cd 800c 	str.w	r8, [sp, #12]
 800f3e2:	2330      	movs	r3, #48	@ 0x30
 800f3e4:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 800f594 <_vfiprintf_r+0x21c>
 800f3e8:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 800f3ec:	f04f 0901 	mov.w	r9, #1
 800f3f0:	4623      	mov	r3, r4
 800f3f2:	469a      	mov	sl, r3
 800f3f4:	f813 2b01 	ldrb.w	r2, [r3], #1
 800f3f8:	b10a      	cbz	r2, 800f3fe <_vfiprintf_r+0x86>
 800f3fa:	2a25      	cmp	r2, #37	@ 0x25
 800f3fc:	d1f9      	bne.n	800f3f2 <_vfiprintf_r+0x7a>
 800f3fe:	ebba 0b04 	subs.w	fp, sl, r4
 800f402:	d00b      	beq.n	800f41c <_vfiprintf_r+0xa4>
 800f404:	465b      	mov	r3, fp
 800f406:	4622      	mov	r2, r4
 800f408:	4629      	mov	r1, r5
 800f40a:	4630      	mov	r0, r6
 800f40c:	f7ff ffa1 	bl	800f352 <__sfputs_r>
 800f410:	3001      	adds	r0, #1
 800f412:	f000 80a7 	beq.w	800f564 <_vfiprintf_r+0x1ec>
 800f416:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 800f418:	445a      	add	r2, fp
 800f41a:	9209      	str	r2, [sp, #36]	@ 0x24
 800f41c:	f89a 3000 	ldrb.w	r3, [sl]
 800f420:	2b00      	cmp	r3, #0
 800f422:	f000 809f 	beq.w	800f564 <_vfiprintf_r+0x1ec>
 800f426:	2300      	movs	r3, #0
 800f428:	f04f 32ff 	mov.w	r2, #4294967295
 800f42c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800f430:	f10a 0a01 	add.w	sl, sl, #1
 800f434:	9304      	str	r3, [sp, #16]
 800f436:	9307      	str	r3, [sp, #28]
 800f438:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 800f43c:	931a      	str	r3, [sp, #104]	@ 0x68
 800f43e:	4654      	mov	r4, sl
 800f440:	2205      	movs	r2, #5
 800f442:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f446:	4853      	ldr	r0, [pc, #332]	@ (800f594 <_vfiprintf_r+0x21c>)
 800f448:	f7f0 fed2 	bl	80001f0 <memchr>
 800f44c:	9a04      	ldr	r2, [sp, #16]
 800f44e:	b9d8      	cbnz	r0, 800f488 <_vfiprintf_r+0x110>
 800f450:	06d1      	lsls	r1, r2, #27
 800f452:	bf44      	itt	mi
 800f454:	2320      	movmi	r3, #32
 800f456:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800f45a:	0713      	lsls	r3, r2, #28
 800f45c:	bf44      	itt	mi
 800f45e:	232b      	movmi	r3, #43	@ 0x2b
 800f460:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 800f464:	f89a 3000 	ldrb.w	r3, [sl]
 800f468:	2b2a      	cmp	r3, #42	@ 0x2a
 800f46a:	d015      	beq.n	800f498 <_vfiprintf_r+0x120>
 800f46c:	9a07      	ldr	r2, [sp, #28]
 800f46e:	4654      	mov	r4, sl
 800f470:	2000      	movs	r0, #0
 800f472:	f04f 0c0a 	mov.w	ip, #10
 800f476:	4621      	mov	r1, r4
 800f478:	f811 3b01 	ldrb.w	r3, [r1], #1
 800f47c:	3b30      	subs	r3, #48	@ 0x30
 800f47e:	2b09      	cmp	r3, #9
 800f480:	d94b      	bls.n	800f51a <_vfiprintf_r+0x1a2>
 800f482:	b1b0      	cbz	r0, 800f4b2 <_vfiprintf_r+0x13a>
 800f484:	9207      	str	r2, [sp, #28]
 800f486:	e014      	b.n	800f4b2 <_vfiprintf_r+0x13a>
 800f488:	eba0 0308 	sub.w	r3, r0, r8
 800f48c:	fa09 f303 	lsl.w	r3, r9, r3
 800f490:	4313      	orrs	r3, r2
 800f492:	9304      	str	r3, [sp, #16]
 800f494:	46a2      	mov	sl, r4
 800f496:	e7d2      	b.n	800f43e <_vfiprintf_r+0xc6>
 800f498:	9b03      	ldr	r3, [sp, #12]
 800f49a:	1d19      	adds	r1, r3, #4
 800f49c:	681b      	ldr	r3, [r3, #0]
 800f49e:	9103      	str	r1, [sp, #12]
 800f4a0:	2b00      	cmp	r3, #0
 800f4a2:	bfbb      	ittet	lt
 800f4a4:	425b      	neglt	r3, r3
 800f4a6:	f042 0202 	orrlt.w	r2, r2, #2
 800f4aa:	9307      	strge	r3, [sp, #28]
 800f4ac:	9307      	strlt	r3, [sp, #28]
 800f4ae:	bfb8      	it	lt
 800f4b0:	9204      	strlt	r2, [sp, #16]
 800f4b2:	7823      	ldrb	r3, [r4, #0]
 800f4b4:	2b2e      	cmp	r3, #46	@ 0x2e
 800f4b6:	d10a      	bne.n	800f4ce <_vfiprintf_r+0x156>
 800f4b8:	7863      	ldrb	r3, [r4, #1]
 800f4ba:	2b2a      	cmp	r3, #42	@ 0x2a
 800f4bc:	d132      	bne.n	800f524 <_vfiprintf_r+0x1ac>
 800f4be:	9b03      	ldr	r3, [sp, #12]
 800f4c0:	1d1a      	adds	r2, r3, #4
 800f4c2:	681b      	ldr	r3, [r3, #0]
 800f4c4:	9203      	str	r2, [sp, #12]
 800f4c6:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 800f4ca:	3402      	adds	r4, #2
 800f4cc:	9305      	str	r3, [sp, #20]
 800f4ce:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 800f5a4 <_vfiprintf_r+0x22c>
 800f4d2:	7821      	ldrb	r1, [r4, #0]
 800f4d4:	2203      	movs	r2, #3
 800f4d6:	4650      	mov	r0, sl
 800f4d8:	f7f0 fe8a 	bl	80001f0 <memchr>
 800f4dc:	b138      	cbz	r0, 800f4ee <_vfiprintf_r+0x176>
 800f4de:	9b04      	ldr	r3, [sp, #16]
 800f4e0:	eba0 000a 	sub.w	r0, r0, sl
 800f4e4:	2240      	movs	r2, #64	@ 0x40
 800f4e6:	4082      	lsls	r2, r0
 800f4e8:	4313      	orrs	r3, r2
 800f4ea:	3401      	adds	r4, #1
 800f4ec:	9304      	str	r3, [sp, #16]
 800f4ee:	f814 1b01 	ldrb.w	r1, [r4], #1
 800f4f2:	4829      	ldr	r0, [pc, #164]	@ (800f598 <_vfiprintf_r+0x220>)
 800f4f4:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 800f4f8:	2206      	movs	r2, #6
 800f4fa:	f7f0 fe79 	bl	80001f0 <memchr>
 800f4fe:	2800      	cmp	r0, #0
 800f500:	d03f      	beq.n	800f582 <_vfiprintf_r+0x20a>
 800f502:	4b26      	ldr	r3, [pc, #152]	@ (800f59c <_vfiprintf_r+0x224>)
 800f504:	bb1b      	cbnz	r3, 800f54e <_vfiprintf_r+0x1d6>
 800f506:	9b03      	ldr	r3, [sp, #12]
 800f508:	3307      	adds	r3, #7
 800f50a:	f023 0307 	bic.w	r3, r3, #7
 800f50e:	3308      	adds	r3, #8
 800f510:	9303      	str	r3, [sp, #12]
 800f512:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800f514:	443b      	add	r3, r7
 800f516:	9309      	str	r3, [sp, #36]	@ 0x24
 800f518:	e76a      	b.n	800f3f0 <_vfiprintf_r+0x78>
 800f51a:	fb0c 3202 	mla	r2, ip, r2, r3
 800f51e:	460c      	mov	r4, r1
 800f520:	2001      	movs	r0, #1
 800f522:	e7a8      	b.n	800f476 <_vfiprintf_r+0xfe>
 800f524:	2300      	movs	r3, #0
 800f526:	3401      	adds	r4, #1
 800f528:	9305      	str	r3, [sp, #20]
 800f52a:	4619      	mov	r1, r3
 800f52c:	f04f 0c0a 	mov.w	ip, #10
 800f530:	4620      	mov	r0, r4
 800f532:	f810 2b01 	ldrb.w	r2, [r0], #1
 800f536:	3a30      	subs	r2, #48	@ 0x30
 800f538:	2a09      	cmp	r2, #9
 800f53a:	d903      	bls.n	800f544 <_vfiprintf_r+0x1cc>
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	d0c6      	beq.n	800f4ce <_vfiprintf_r+0x156>
 800f540:	9105      	str	r1, [sp, #20]
 800f542:	e7c4      	b.n	800f4ce <_vfiprintf_r+0x156>
 800f544:	fb0c 2101 	mla	r1, ip, r1, r2
 800f548:	4604      	mov	r4, r0
 800f54a:	2301      	movs	r3, #1
 800f54c:	e7f0      	b.n	800f530 <_vfiprintf_r+0x1b8>
 800f54e:	ab03      	add	r3, sp, #12
 800f550:	9300      	str	r3, [sp, #0]
 800f552:	462a      	mov	r2, r5
 800f554:	4b12      	ldr	r3, [pc, #72]	@ (800f5a0 <_vfiprintf_r+0x228>)
 800f556:	a904      	add	r1, sp, #16
 800f558:	4630      	mov	r0, r6
 800f55a:	f3af 8000 	nop.w
 800f55e:	4607      	mov	r7, r0
 800f560:	1c78      	adds	r0, r7, #1
 800f562:	d1d6      	bne.n	800f512 <_vfiprintf_r+0x19a>
 800f564:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 800f566:	07d9      	lsls	r1, r3, #31
 800f568:	d405      	bmi.n	800f576 <_vfiprintf_r+0x1fe>
 800f56a:	89ab      	ldrh	r3, [r5, #12]
 800f56c:	059a      	lsls	r2, r3, #22
 800f56e:	d402      	bmi.n	800f576 <_vfiprintf_r+0x1fe>
 800f570:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 800f572:	f7ff fc77 	bl	800ee64 <__retarget_lock_release_recursive>
 800f576:	89ab      	ldrh	r3, [r5, #12]
 800f578:	065b      	lsls	r3, r3, #25
 800f57a:	f53f af1f 	bmi.w	800f3bc <_vfiprintf_r+0x44>
 800f57e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 800f580:	e71e      	b.n	800f3c0 <_vfiprintf_r+0x48>
 800f582:	ab03      	add	r3, sp, #12
 800f584:	9300      	str	r3, [sp, #0]
 800f586:	462a      	mov	r2, r5
 800f588:	4b05      	ldr	r3, [pc, #20]	@ (800f5a0 <_vfiprintf_r+0x228>)
 800f58a:	a904      	add	r1, sp, #16
 800f58c:	4630      	mov	r0, r6
 800f58e:	f000 f879 	bl	800f684 <_printf_i>
 800f592:	e7e4      	b.n	800f55e <_vfiprintf_r+0x1e6>
 800f594:	08010340 	.word	0x08010340
 800f598:	0801034a 	.word	0x0801034a
 800f59c:	00000000 	.word	0x00000000
 800f5a0:	0800f353 	.word	0x0800f353
 800f5a4:	08010346 	.word	0x08010346

0800f5a8 <_printf_common>:
 800f5a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800f5ac:	4616      	mov	r6, r2
 800f5ae:	4698      	mov	r8, r3
 800f5b0:	688a      	ldr	r2, [r1, #8]
 800f5b2:	690b      	ldr	r3, [r1, #16]
 800f5b4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800f5b8:	4293      	cmp	r3, r2
 800f5ba:	bfb8      	it	lt
 800f5bc:	4613      	movlt	r3, r2
 800f5be:	6033      	str	r3, [r6, #0]
 800f5c0:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 800f5c4:	4607      	mov	r7, r0
 800f5c6:	460c      	mov	r4, r1
 800f5c8:	b10a      	cbz	r2, 800f5ce <_printf_common+0x26>
 800f5ca:	3301      	adds	r3, #1
 800f5cc:	6033      	str	r3, [r6, #0]
 800f5ce:	6823      	ldr	r3, [r4, #0]
 800f5d0:	0699      	lsls	r1, r3, #26
 800f5d2:	bf42      	ittt	mi
 800f5d4:	6833      	ldrmi	r3, [r6, #0]
 800f5d6:	3302      	addmi	r3, #2
 800f5d8:	6033      	strmi	r3, [r6, #0]
 800f5da:	6825      	ldr	r5, [r4, #0]
 800f5dc:	f015 0506 	ands.w	r5, r5, #6
 800f5e0:	d106      	bne.n	800f5f0 <_printf_common+0x48>
 800f5e2:	f104 0a19 	add.w	sl, r4, #25
 800f5e6:	68e3      	ldr	r3, [r4, #12]
 800f5e8:	6832      	ldr	r2, [r6, #0]
 800f5ea:	1a9b      	subs	r3, r3, r2
 800f5ec:	42ab      	cmp	r3, r5
 800f5ee:	dc26      	bgt.n	800f63e <_printf_common+0x96>
 800f5f0:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 800f5f4:	6822      	ldr	r2, [r4, #0]
 800f5f6:	3b00      	subs	r3, #0
 800f5f8:	bf18      	it	ne
 800f5fa:	2301      	movne	r3, #1
 800f5fc:	0692      	lsls	r2, r2, #26
 800f5fe:	d42b      	bmi.n	800f658 <_printf_common+0xb0>
 800f600:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 800f604:	4641      	mov	r1, r8
 800f606:	4638      	mov	r0, r7
 800f608:	47c8      	blx	r9
 800f60a:	3001      	adds	r0, #1
 800f60c:	d01e      	beq.n	800f64c <_printf_common+0xa4>
 800f60e:	6823      	ldr	r3, [r4, #0]
 800f610:	6922      	ldr	r2, [r4, #16]
 800f612:	f003 0306 	and.w	r3, r3, #6
 800f616:	2b04      	cmp	r3, #4
 800f618:	bf02      	ittt	eq
 800f61a:	68e5      	ldreq	r5, [r4, #12]
 800f61c:	6833      	ldreq	r3, [r6, #0]
 800f61e:	1aed      	subeq	r5, r5, r3
 800f620:	68a3      	ldr	r3, [r4, #8]
 800f622:	bf0c      	ite	eq
 800f624:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800f628:	2500      	movne	r5, #0
 800f62a:	4293      	cmp	r3, r2
 800f62c:	bfc4      	itt	gt
 800f62e:	1a9b      	subgt	r3, r3, r2
 800f630:	18ed      	addgt	r5, r5, r3
 800f632:	2600      	movs	r6, #0
 800f634:	341a      	adds	r4, #26
 800f636:	42b5      	cmp	r5, r6
 800f638:	d11a      	bne.n	800f670 <_printf_common+0xc8>
 800f63a:	2000      	movs	r0, #0
 800f63c:	e008      	b.n	800f650 <_printf_common+0xa8>
 800f63e:	2301      	movs	r3, #1
 800f640:	4652      	mov	r2, sl
 800f642:	4641      	mov	r1, r8
 800f644:	4638      	mov	r0, r7
 800f646:	47c8      	blx	r9
 800f648:	3001      	adds	r0, #1
 800f64a:	d103      	bne.n	800f654 <_printf_common+0xac>
 800f64c:	f04f 30ff 	mov.w	r0, #4294967295
 800f650:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800f654:	3501      	adds	r5, #1
 800f656:	e7c6      	b.n	800f5e6 <_printf_common+0x3e>
 800f658:	18e1      	adds	r1, r4, r3
 800f65a:	1c5a      	adds	r2, r3, #1
 800f65c:	2030      	movs	r0, #48	@ 0x30
 800f65e:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 800f662:	4422      	add	r2, r4
 800f664:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 800f668:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 800f66c:	3302      	adds	r3, #2
 800f66e:	e7c7      	b.n	800f600 <_printf_common+0x58>
 800f670:	2301      	movs	r3, #1
 800f672:	4622      	mov	r2, r4
 800f674:	4641      	mov	r1, r8
 800f676:	4638      	mov	r0, r7
 800f678:	47c8      	blx	r9
 800f67a:	3001      	adds	r0, #1
 800f67c:	d0e6      	beq.n	800f64c <_printf_common+0xa4>
 800f67e:	3601      	adds	r6, #1
 800f680:	e7d9      	b.n	800f636 <_printf_common+0x8e>
	...

0800f684 <_printf_i>:
 800f684:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800f688:	7e0f      	ldrb	r7, [r1, #24]
 800f68a:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 800f68c:	2f78      	cmp	r7, #120	@ 0x78
 800f68e:	4691      	mov	r9, r2
 800f690:	4680      	mov	r8, r0
 800f692:	460c      	mov	r4, r1
 800f694:	469a      	mov	sl, r3
 800f696:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 800f69a:	d807      	bhi.n	800f6ac <_printf_i+0x28>
 800f69c:	2f62      	cmp	r7, #98	@ 0x62
 800f69e:	d80a      	bhi.n	800f6b6 <_printf_i+0x32>
 800f6a0:	2f00      	cmp	r7, #0
 800f6a2:	f000 80d1 	beq.w	800f848 <_printf_i+0x1c4>
 800f6a6:	2f58      	cmp	r7, #88	@ 0x58
 800f6a8:	f000 80b8 	beq.w	800f81c <_printf_i+0x198>
 800f6ac:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800f6b0:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 800f6b4:	e03a      	b.n	800f72c <_printf_i+0xa8>
 800f6b6:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 800f6ba:	2b15      	cmp	r3, #21
 800f6bc:	d8f6      	bhi.n	800f6ac <_printf_i+0x28>
 800f6be:	a101      	add	r1, pc, #4	@ (adr r1, 800f6c4 <_printf_i+0x40>)
 800f6c0:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800f6c4:	0800f71d 	.word	0x0800f71d
 800f6c8:	0800f731 	.word	0x0800f731
 800f6cc:	0800f6ad 	.word	0x0800f6ad
 800f6d0:	0800f6ad 	.word	0x0800f6ad
 800f6d4:	0800f6ad 	.word	0x0800f6ad
 800f6d8:	0800f6ad 	.word	0x0800f6ad
 800f6dc:	0800f731 	.word	0x0800f731
 800f6e0:	0800f6ad 	.word	0x0800f6ad
 800f6e4:	0800f6ad 	.word	0x0800f6ad
 800f6e8:	0800f6ad 	.word	0x0800f6ad
 800f6ec:	0800f6ad 	.word	0x0800f6ad
 800f6f0:	0800f82f 	.word	0x0800f82f
 800f6f4:	0800f75b 	.word	0x0800f75b
 800f6f8:	0800f7e9 	.word	0x0800f7e9
 800f6fc:	0800f6ad 	.word	0x0800f6ad
 800f700:	0800f6ad 	.word	0x0800f6ad
 800f704:	0800f851 	.word	0x0800f851
 800f708:	0800f6ad 	.word	0x0800f6ad
 800f70c:	0800f75b 	.word	0x0800f75b
 800f710:	0800f6ad 	.word	0x0800f6ad
 800f714:	0800f6ad 	.word	0x0800f6ad
 800f718:	0800f7f1 	.word	0x0800f7f1
 800f71c:	6833      	ldr	r3, [r6, #0]
 800f71e:	1d1a      	adds	r2, r3, #4
 800f720:	681b      	ldr	r3, [r3, #0]
 800f722:	6032      	str	r2, [r6, #0]
 800f724:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 800f728:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 800f72c:	2301      	movs	r3, #1
 800f72e:	e09c      	b.n	800f86a <_printf_i+0x1e6>
 800f730:	6833      	ldr	r3, [r6, #0]
 800f732:	6820      	ldr	r0, [r4, #0]
 800f734:	1d19      	adds	r1, r3, #4
 800f736:	6031      	str	r1, [r6, #0]
 800f738:	0606      	lsls	r6, r0, #24
 800f73a:	d501      	bpl.n	800f740 <_printf_i+0xbc>
 800f73c:	681d      	ldr	r5, [r3, #0]
 800f73e:	e003      	b.n	800f748 <_printf_i+0xc4>
 800f740:	0645      	lsls	r5, r0, #25
 800f742:	d5fb      	bpl.n	800f73c <_printf_i+0xb8>
 800f744:	f9b3 5000 	ldrsh.w	r5, [r3]
 800f748:	2d00      	cmp	r5, #0
 800f74a:	da03      	bge.n	800f754 <_printf_i+0xd0>
 800f74c:	232d      	movs	r3, #45	@ 0x2d
 800f74e:	426d      	negs	r5, r5
 800f750:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800f754:	4858      	ldr	r0, [pc, #352]	@ (800f8b8 <_printf_i+0x234>)
 800f756:	230a      	movs	r3, #10
 800f758:	e011      	b.n	800f77e <_printf_i+0xfa>
 800f75a:	6821      	ldr	r1, [r4, #0]
 800f75c:	6833      	ldr	r3, [r6, #0]
 800f75e:	0608      	lsls	r0, r1, #24
 800f760:	f853 5b04 	ldr.w	r5, [r3], #4
 800f764:	d402      	bmi.n	800f76c <_printf_i+0xe8>
 800f766:	0649      	lsls	r1, r1, #25
 800f768:	bf48      	it	mi
 800f76a:	b2ad      	uxthmi	r5, r5
 800f76c:	2f6f      	cmp	r7, #111	@ 0x6f
 800f76e:	4852      	ldr	r0, [pc, #328]	@ (800f8b8 <_printf_i+0x234>)
 800f770:	6033      	str	r3, [r6, #0]
 800f772:	bf14      	ite	ne
 800f774:	230a      	movne	r3, #10
 800f776:	2308      	moveq	r3, #8
 800f778:	2100      	movs	r1, #0
 800f77a:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 800f77e:	6866      	ldr	r6, [r4, #4]
 800f780:	60a6      	str	r6, [r4, #8]
 800f782:	2e00      	cmp	r6, #0
 800f784:	db05      	blt.n	800f792 <_printf_i+0x10e>
 800f786:	6821      	ldr	r1, [r4, #0]
 800f788:	432e      	orrs	r6, r5
 800f78a:	f021 0104 	bic.w	r1, r1, #4
 800f78e:	6021      	str	r1, [r4, #0]
 800f790:	d04b      	beq.n	800f82a <_printf_i+0x1a6>
 800f792:	4616      	mov	r6, r2
 800f794:	fbb5 f1f3 	udiv	r1, r5, r3
 800f798:	fb03 5711 	mls	r7, r3, r1, r5
 800f79c:	5dc7      	ldrb	r7, [r0, r7]
 800f79e:	f806 7d01 	strb.w	r7, [r6, #-1]!
 800f7a2:	462f      	mov	r7, r5
 800f7a4:	42bb      	cmp	r3, r7
 800f7a6:	460d      	mov	r5, r1
 800f7a8:	d9f4      	bls.n	800f794 <_printf_i+0x110>
 800f7aa:	2b08      	cmp	r3, #8
 800f7ac:	d10b      	bne.n	800f7c6 <_printf_i+0x142>
 800f7ae:	6823      	ldr	r3, [r4, #0]
 800f7b0:	07df      	lsls	r7, r3, #31
 800f7b2:	d508      	bpl.n	800f7c6 <_printf_i+0x142>
 800f7b4:	6923      	ldr	r3, [r4, #16]
 800f7b6:	6861      	ldr	r1, [r4, #4]
 800f7b8:	4299      	cmp	r1, r3
 800f7ba:	bfde      	ittt	le
 800f7bc:	2330      	movle	r3, #48	@ 0x30
 800f7be:	f806 3c01 	strble.w	r3, [r6, #-1]
 800f7c2:	f106 36ff 	addle.w	r6, r6, #4294967295
 800f7c6:	1b92      	subs	r2, r2, r6
 800f7c8:	6122      	str	r2, [r4, #16]
 800f7ca:	f8cd a000 	str.w	sl, [sp]
 800f7ce:	464b      	mov	r3, r9
 800f7d0:	aa03      	add	r2, sp, #12
 800f7d2:	4621      	mov	r1, r4
 800f7d4:	4640      	mov	r0, r8
 800f7d6:	f7ff fee7 	bl	800f5a8 <_printf_common>
 800f7da:	3001      	adds	r0, #1
 800f7dc:	d14a      	bne.n	800f874 <_printf_i+0x1f0>
 800f7de:	f04f 30ff 	mov.w	r0, #4294967295
 800f7e2:	b004      	add	sp, #16
 800f7e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800f7e8:	6823      	ldr	r3, [r4, #0]
 800f7ea:	f043 0320 	orr.w	r3, r3, #32
 800f7ee:	6023      	str	r3, [r4, #0]
 800f7f0:	4832      	ldr	r0, [pc, #200]	@ (800f8bc <_printf_i+0x238>)
 800f7f2:	2778      	movs	r7, #120	@ 0x78
 800f7f4:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 800f7f8:	6823      	ldr	r3, [r4, #0]
 800f7fa:	6831      	ldr	r1, [r6, #0]
 800f7fc:	061f      	lsls	r7, r3, #24
 800f7fe:	f851 5b04 	ldr.w	r5, [r1], #4
 800f802:	d402      	bmi.n	800f80a <_printf_i+0x186>
 800f804:	065f      	lsls	r7, r3, #25
 800f806:	bf48      	it	mi
 800f808:	b2ad      	uxthmi	r5, r5
 800f80a:	6031      	str	r1, [r6, #0]
 800f80c:	07d9      	lsls	r1, r3, #31
 800f80e:	bf44      	itt	mi
 800f810:	f043 0320 	orrmi.w	r3, r3, #32
 800f814:	6023      	strmi	r3, [r4, #0]
 800f816:	b11d      	cbz	r5, 800f820 <_printf_i+0x19c>
 800f818:	2310      	movs	r3, #16
 800f81a:	e7ad      	b.n	800f778 <_printf_i+0xf4>
 800f81c:	4826      	ldr	r0, [pc, #152]	@ (800f8b8 <_printf_i+0x234>)
 800f81e:	e7e9      	b.n	800f7f4 <_printf_i+0x170>
 800f820:	6823      	ldr	r3, [r4, #0]
 800f822:	f023 0320 	bic.w	r3, r3, #32
 800f826:	6023      	str	r3, [r4, #0]
 800f828:	e7f6      	b.n	800f818 <_printf_i+0x194>
 800f82a:	4616      	mov	r6, r2
 800f82c:	e7bd      	b.n	800f7aa <_printf_i+0x126>
 800f82e:	6833      	ldr	r3, [r6, #0]
 800f830:	6825      	ldr	r5, [r4, #0]
 800f832:	6961      	ldr	r1, [r4, #20]
 800f834:	1d18      	adds	r0, r3, #4
 800f836:	6030      	str	r0, [r6, #0]
 800f838:	062e      	lsls	r6, r5, #24
 800f83a:	681b      	ldr	r3, [r3, #0]
 800f83c:	d501      	bpl.n	800f842 <_printf_i+0x1be>
 800f83e:	6019      	str	r1, [r3, #0]
 800f840:	e002      	b.n	800f848 <_printf_i+0x1c4>
 800f842:	0668      	lsls	r0, r5, #25
 800f844:	d5fb      	bpl.n	800f83e <_printf_i+0x1ba>
 800f846:	8019      	strh	r1, [r3, #0]
 800f848:	2300      	movs	r3, #0
 800f84a:	6123      	str	r3, [r4, #16]
 800f84c:	4616      	mov	r6, r2
 800f84e:	e7bc      	b.n	800f7ca <_printf_i+0x146>
 800f850:	6833      	ldr	r3, [r6, #0]
 800f852:	1d1a      	adds	r2, r3, #4
 800f854:	6032      	str	r2, [r6, #0]
 800f856:	681e      	ldr	r6, [r3, #0]
 800f858:	6862      	ldr	r2, [r4, #4]
 800f85a:	2100      	movs	r1, #0
 800f85c:	4630      	mov	r0, r6
 800f85e:	f7f0 fcc7 	bl	80001f0 <memchr>
 800f862:	b108      	cbz	r0, 800f868 <_printf_i+0x1e4>
 800f864:	1b80      	subs	r0, r0, r6
 800f866:	6060      	str	r0, [r4, #4]
 800f868:	6863      	ldr	r3, [r4, #4]
 800f86a:	6123      	str	r3, [r4, #16]
 800f86c:	2300      	movs	r3, #0
 800f86e:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 800f872:	e7aa      	b.n	800f7ca <_printf_i+0x146>
 800f874:	6923      	ldr	r3, [r4, #16]
 800f876:	4632      	mov	r2, r6
 800f878:	4649      	mov	r1, r9
 800f87a:	4640      	mov	r0, r8
 800f87c:	47d0      	blx	sl
 800f87e:	3001      	adds	r0, #1
 800f880:	d0ad      	beq.n	800f7de <_printf_i+0x15a>
 800f882:	6823      	ldr	r3, [r4, #0]
 800f884:	079b      	lsls	r3, r3, #30
 800f886:	d413      	bmi.n	800f8b0 <_printf_i+0x22c>
 800f888:	68e0      	ldr	r0, [r4, #12]
 800f88a:	9b03      	ldr	r3, [sp, #12]
 800f88c:	4298      	cmp	r0, r3
 800f88e:	bfb8      	it	lt
 800f890:	4618      	movlt	r0, r3
 800f892:	e7a6      	b.n	800f7e2 <_printf_i+0x15e>
 800f894:	2301      	movs	r3, #1
 800f896:	4632      	mov	r2, r6
 800f898:	4649      	mov	r1, r9
 800f89a:	4640      	mov	r0, r8
 800f89c:	47d0      	blx	sl
 800f89e:	3001      	adds	r0, #1
 800f8a0:	d09d      	beq.n	800f7de <_printf_i+0x15a>
 800f8a2:	3501      	adds	r5, #1
 800f8a4:	68e3      	ldr	r3, [r4, #12]
 800f8a6:	9903      	ldr	r1, [sp, #12]
 800f8a8:	1a5b      	subs	r3, r3, r1
 800f8aa:	42ab      	cmp	r3, r5
 800f8ac:	dcf2      	bgt.n	800f894 <_printf_i+0x210>
 800f8ae:	e7eb      	b.n	800f888 <_printf_i+0x204>
 800f8b0:	2500      	movs	r5, #0
 800f8b2:	f104 0619 	add.w	r6, r4, #25
 800f8b6:	e7f5      	b.n	800f8a4 <_printf_i+0x220>
 800f8b8:	08010351 	.word	0x08010351
 800f8bc:	08010362 	.word	0x08010362

0800f8c0 <__sflush_r>:
 800f8c0:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 800f8c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f8c8:	0716      	lsls	r6, r2, #28
 800f8ca:	4605      	mov	r5, r0
 800f8cc:	460c      	mov	r4, r1
 800f8ce:	d454      	bmi.n	800f97a <__sflush_r+0xba>
 800f8d0:	684b      	ldr	r3, [r1, #4]
 800f8d2:	2b00      	cmp	r3, #0
 800f8d4:	dc02      	bgt.n	800f8dc <__sflush_r+0x1c>
 800f8d6:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 800f8d8:	2b00      	cmp	r3, #0
 800f8da:	dd48      	ble.n	800f96e <__sflush_r+0xae>
 800f8dc:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 800f8de:	2e00      	cmp	r6, #0
 800f8e0:	d045      	beq.n	800f96e <__sflush_r+0xae>
 800f8e2:	2300      	movs	r3, #0
 800f8e4:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 800f8e8:	682f      	ldr	r7, [r5, #0]
 800f8ea:	6a21      	ldr	r1, [r4, #32]
 800f8ec:	602b      	str	r3, [r5, #0]
 800f8ee:	d030      	beq.n	800f952 <__sflush_r+0x92>
 800f8f0:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 800f8f2:	89a3      	ldrh	r3, [r4, #12]
 800f8f4:	0759      	lsls	r1, r3, #29
 800f8f6:	d505      	bpl.n	800f904 <__sflush_r+0x44>
 800f8f8:	6863      	ldr	r3, [r4, #4]
 800f8fa:	1ad2      	subs	r2, r2, r3
 800f8fc:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 800f8fe:	b10b      	cbz	r3, 800f904 <__sflush_r+0x44>
 800f900:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 800f902:	1ad2      	subs	r2, r2, r3
 800f904:	2300      	movs	r3, #0
 800f906:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 800f908:	6a21      	ldr	r1, [r4, #32]
 800f90a:	4628      	mov	r0, r5
 800f90c:	47b0      	blx	r6
 800f90e:	1c43      	adds	r3, r0, #1
 800f910:	89a3      	ldrh	r3, [r4, #12]
 800f912:	d106      	bne.n	800f922 <__sflush_r+0x62>
 800f914:	6829      	ldr	r1, [r5, #0]
 800f916:	291d      	cmp	r1, #29
 800f918:	d82b      	bhi.n	800f972 <__sflush_r+0xb2>
 800f91a:	4a2a      	ldr	r2, [pc, #168]	@ (800f9c4 <__sflush_r+0x104>)
 800f91c:	40ca      	lsrs	r2, r1
 800f91e:	07d6      	lsls	r6, r2, #31
 800f920:	d527      	bpl.n	800f972 <__sflush_r+0xb2>
 800f922:	2200      	movs	r2, #0
 800f924:	6062      	str	r2, [r4, #4]
 800f926:	04d9      	lsls	r1, r3, #19
 800f928:	6922      	ldr	r2, [r4, #16]
 800f92a:	6022      	str	r2, [r4, #0]
 800f92c:	d504      	bpl.n	800f938 <__sflush_r+0x78>
 800f92e:	1c42      	adds	r2, r0, #1
 800f930:	d101      	bne.n	800f936 <__sflush_r+0x76>
 800f932:	682b      	ldr	r3, [r5, #0]
 800f934:	b903      	cbnz	r3, 800f938 <__sflush_r+0x78>
 800f936:	6560      	str	r0, [r4, #84]	@ 0x54
 800f938:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 800f93a:	602f      	str	r7, [r5, #0]
 800f93c:	b1b9      	cbz	r1, 800f96e <__sflush_r+0xae>
 800f93e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 800f942:	4299      	cmp	r1, r3
 800f944:	d002      	beq.n	800f94c <__sflush_r+0x8c>
 800f946:	4628      	mov	r0, r5
 800f948:	f7ff fa9c 	bl	800ee84 <_free_r>
 800f94c:	2300      	movs	r3, #0
 800f94e:	6363      	str	r3, [r4, #52]	@ 0x34
 800f950:	e00d      	b.n	800f96e <__sflush_r+0xae>
 800f952:	2301      	movs	r3, #1
 800f954:	4628      	mov	r0, r5
 800f956:	47b0      	blx	r6
 800f958:	4602      	mov	r2, r0
 800f95a:	1c50      	adds	r0, r2, #1
 800f95c:	d1c9      	bne.n	800f8f2 <__sflush_r+0x32>
 800f95e:	682b      	ldr	r3, [r5, #0]
 800f960:	2b00      	cmp	r3, #0
 800f962:	d0c6      	beq.n	800f8f2 <__sflush_r+0x32>
 800f964:	2b1d      	cmp	r3, #29
 800f966:	d001      	beq.n	800f96c <__sflush_r+0xac>
 800f968:	2b16      	cmp	r3, #22
 800f96a:	d11e      	bne.n	800f9aa <__sflush_r+0xea>
 800f96c:	602f      	str	r7, [r5, #0]
 800f96e:	2000      	movs	r0, #0
 800f970:	e022      	b.n	800f9b8 <__sflush_r+0xf8>
 800f972:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800f976:	b21b      	sxth	r3, r3
 800f978:	e01b      	b.n	800f9b2 <__sflush_r+0xf2>
 800f97a:	690f      	ldr	r7, [r1, #16]
 800f97c:	2f00      	cmp	r7, #0
 800f97e:	d0f6      	beq.n	800f96e <__sflush_r+0xae>
 800f980:	0793      	lsls	r3, r2, #30
 800f982:	680e      	ldr	r6, [r1, #0]
 800f984:	bf08      	it	eq
 800f986:	694b      	ldreq	r3, [r1, #20]
 800f988:	600f      	str	r7, [r1, #0]
 800f98a:	bf18      	it	ne
 800f98c:	2300      	movne	r3, #0
 800f98e:	eba6 0807 	sub.w	r8, r6, r7
 800f992:	608b      	str	r3, [r1, #8]
 800f994:	f1b8 0f00 	cmp.w	r8, #0
 800f998:	dde9      	ble.n	800f96e <__sflush_r+0xae>
 800f99a:	6a21      	ldr	r1, [r4, #32]
 800f99c:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 800f99e:	4643      	mov	r3, r8
 800f9a0:	463a      	mov	r2, r7
 800f9a2:	4628      	mov	r0, r5
 800f9a4:	47b0      	blx	r6
 800f9a6:	2800      	cmp	r0, #0
 800f9a8:	dc08      	bgt.n	800f9bc <__sflush_r+0xfc>
 800f9aa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800f9ae:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800f9b2:	81a3      	strh	r3, [r4, #12]
 800f9b4:	f04f 30ff 	mov.w	r0, #4294967295
 800f9b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f9bc:	4407      	add	r7, r0
 800f9be:	eba8 0800 	sub.w	r8, r8, r0
 800f9c2:	e7e7      	b.n	800f994 <__sflush_r+0xd4>
 800f9c4:	20400001 	.word	0x20400001

0800f9c8 <_fflush_r>:
 800f9c8:	b538      	push	{r3, r4, r5, lr}
 800f9ca:	690b      	ldr	r3, [r1, #16]
 800f9cc:	4605      	mov	r5, r0
 800f9ce:	460c      	mov	r4, r1
 800f9d0:	b913      	cbnz	r3, 800f9d8 <_fflush_r+0x10>
 800f9d2:	2500      	movs	r5, #0
 800f9d4:	4628      	mov	r0, r5
 800f9d6:	bd38      	pop	{r3, r4, r5, pc}
 800f9d8:	b118      	cbz	r0, 800f9e2 <_fflush_r+0x1a>
 800f9da:	6a03      	ldr	r3, [r0, #32]
 800f9dc:	b90b      	cbnz	r3, 800f9e2 <_fflush_r+0x1a>
 800f9de:	f7fe ff8b 	bl	800e8f8 <__sinit>
 800f9e2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800f9e6:	2b00      	cmp	r3, #0
 800f9e8:	d0f3      	beq.n	800f9d2 <_fflush_r+0xa>
 800f9ea:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 800f9ec:	07d0      	lsls	r0, r2, #31
 800f9ee:	d404      	bmi.n	800f9fa <_fflush_r+0x32>
 800f9f0:	0599      	lsls	r1, r3, #22
 800f9f2:	d402      	bmi.n	800f9fa <_fflush_r+0x32>
 800f9f4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800f9f6:	f7ff fa34 	bl	800ee62 <__retarget_lock_acquire_recursive>
 800f9fa:	4628      	mov	r0, r5
 800f9fc:	4621      	mov	r1, r4
 800f9fe:	f7ff ff5f 	bl	800f8c0 <__sflush_r>
 800fa02:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 800fa04:	07da      	lsls	r2, r3, #31
 800fa06:	4605      	mov	r5, r0
 800fa08:	d4e4      	bmi.n	800f9d4 <_fflush_r+0xc>
 800fa0a:	89a3      	ldrh	r3, [r4, #12]
 800fa0c:	059b      	lsls	r3, r3, #22
 800fa0e:	d4e1      	bmi.n	800f9d4 <_fflush_r+0xc>
 800fa10:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 800fa12:	f7ff fa27 	bl	800ee64 <__retarget_lock_release_recursive>
 800fa16:	e7dd      	b.n	800f9d4 <_fflush_r+0xc>

0800fa18 <__swhatbuf_r>:
 800fa18:	b570      	push	{r4, r5, r6, lr}
 800fa1a:	460c      	mov	r4, r1
 800fa1c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800fa20:	2900      	cmp	r1, #0
 800fa22:	b096      	sub	sp, #88	@ 0x58
 800fa24:	4615      	mov	r5, r2
 800fa26:	461e      	mov	r6, r3
 800fa28:	da0d      	bge.n	800fa46 <__swhatbuf_r+0x2e>
 800fa2a:	89a3      	ldrh	r3, [r4, #12]
 800fa2c:	f013 0f80 	tst.w	r3, #128	@ 0x80
 800fa30:	f04f 0100 	mov.w	r1, #0
 800fa34:	bf14      	ite	ne
 800fa36:	2340      	movne	r3, #64	@ 0x40
 800fa38:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 800fa3c:	2000      	movs	r0, #0
 800fa3e:	6031      	str	r1, [r6, #0]
 800fa40:	602b      	str	r3, [r5, #0]
 800fa42:	b016      	add	sp, #88	@ 0x58
 800fa44:	bd70      	pop	{r4, r5, r6, pc}
 800fa46:	466a      	mov	r2, sp
 800fa48:	f000 f848 	bl	800fadc <_fstat_r>
 800fa4c:	2800      	cmp	r0, #0
 800fa4e:	dbec      	blt.n	800fa2a <__swhatbuf_r+0x12>
 800fa50:	9901      	ldr	r1, [sp, #4]
 800fa52:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 800fa56:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 800fa5a:	4259      	negs	r1, r3
 800fa5c:	4159      	adcs	r1, r3
 800fa5e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800fa62:	e7eb      	b.n	800fa3c <__swhatbuf_r+0x24>

0800fa64 <__smakebuf_r>:
 800fa64:	898b      	ldrh	r3, [r1, #12]
 800fa66:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800fa68:	079d      	lsls	r5, r3, #30
 800fa6a:	4606      	mov	r6, r0
 800fa6c:	460c      	mov	r4, r1
 800fa6e:	d507      	bpl.n	800fa80 <__smakebuf_r+0x1c>
 800fa70:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 800fa74:	6023      	str	r3, [r4, #0]
 800fa76:	6123      	str	r3, [r4, #16]
 800fa78:	2301      	movs	r3, #1
 800fa7a:	6163      	str	r3, [r4, #20]
 800fa7c:	b003      	add	sp, #12
 800fa7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fa80:	ab01      	add	r3, sp, #4
 800fa82:	466a      	mov	r2, sp
 800fa84:	f7ff ffc8 	bl	800fa18 <__swhatbuf_r>
 800fa88:	9f00      	ldr	r7, [sp, #0]
 800fa8a:	4605      	mov	r5, r0
 800fa8c:	4639      	mov	r1, r7
 800fa8e:	4630      	mov	r0, r6
 800fa90:	f7ff fa64 	bl	800ef5c <_malloc_r>
 800fa94:	b948      	cbnz	r0, 800faaa <__smakebuf_r+0x46>
 800fa96:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800fa9a:	059a      	lsls	r2, r3, #22
 800fa9c:	d4ee      	bmi.n	800fa7c <__smakebuf_r+0x18>
 800fa9e:	f023 0303 	bic.w	r3, r3, #3
 800faa2:	f043 0302 	orr.w	r3, r3, #2
 800faa6:	81a3      	strh	r3, [r4, #12]
 800faa8:	e7e2      	b.n	800fa70 <__smakebuf_r+0xc>
 800faaa:	89a3      	ldrh	r3, [r4, #12]
 800faac:	6020      	str	r0, [r4, #0]
 800faae:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800fab2:	81a3      	strh	r3, [r4, #12]
 800fab4:	9b01      	ldr	r3, [sp, #4]
 800fab6:	e9c4 0704 	strd	r0, r7, [r4, #16]
 800faba:	b15b      	cbz	r3, 800fad4 <__smakebuf_r+0x70>
 800fabc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800fac0:	4630      	mov	r0, r6
 800fac2:	f000 f81d 	bl	800fb00 <_isatty_r>
 800fac6:	b128      	cbz	r0, 800fad4 <__smakebuf_r+0x70>
 800fac8:	89a3      	ldrh	r3, [r4, #12]
 800faca:	f023 0303 	bic.w	r3, r3, #3
 800face:	f043 0301 	orr.w	r3, r3, #1
 800fad2:	81a3      	strh	r3, [r4, #12]
 800fad4:	89a3      	ldrh	r3, [r4, #12]
 800fad6:	431d      	orrs	r5, r3
 800fad8:	81a5      	strh	r5, [r4, #12]
 800fada:	e7cf      	b.n	800fa7c <__smakebuf_r+0x18>

0800fadc <_fstat_r>:
 800fadc:	b538      	push	{r3, r4, r5, lr}
 800fade:	4d07      	ldr	r5, [pc, #28]	@ (800fafc <_fstat_r+0x20>)
 800fae0:	2300      	movs	r3, #0
 800fae2:	4604      	mov	r4, r0
 800fae4:	4608      	mov	r0, r1
 800fae6:	4611      	mov	r1, r2
 800fae8:	602b      	str	r3, [r5, #0]
 800faea:	f7f1 fe73 	bl	80017d4 <_fstat>
 800faee:	1c43      	adds	r3, r0, #1
 800faf0:	d102      	bne.n	800faf8 <_fstat_r+0x1c>
 800faf2:	682b      	ldr	r3, [r5, #0]
 800faf4:	b103      	cbz	r3, 800faf8 <_fstat_r+0x1c>
 800faf6:	6023      	str	r3, [r4, #0]
 800faf8:	bd38      	pop	{r3, r4, r5, pc}
 800fafa:	bf00      	nop
 800fafc:	20014694 	.word	0x20014694

0800fb00 <_isatty_r>:
 800fb00:	b538      	push	{r3, r4, r5, lr}
 800fb02:	4d06      	ldr	r5, [pc, #24]	@ (800fb1c <_isatty_r+0x1c>)
 800fb04:	2300      	movs	r3, #0
 800fb06:	4604      	mov	r4, r0
 800fb08:	4608      	mov	r0, r1
 800fb0a:	602b      	str	r3, [r5, #0]
 800fb0c:	f7f1 fe67 	bl	80017de <_isatty>
 800fb10:	1c43      	adds	r3, r0, #1
 800fb12:	d102      	bne.n	800fb1a <_isatty_r+0x1a>
 800fb14:	682b      	ldr	r3, [r5, #0]
 800fb16:	b103      	cbz	r3, 800fb1a <_isatty_r+0x1a>
 800fb18:	6023      	str	r3, [r4, #0]
 800fb1a:	bd38      	pop	{r3, r4, r5, pc}
 800fb1c:	20014694 	.word	0x20014694

0800fb20 <_sbrk_r>:
 800fb20:	b538      	push	{r3, r4, r5, lr}
 800fb22:	4d06      	ldr	r5, [pc, #24]	@ (800fb3c <_sbrk_r+0x1c>)
 800fb24:	2300      	movs	r3, #0
 800fb26:	4604      	mov	r4, r0
 800fb28:	4608      	mov	r0, r1
 800fb2a:	602b      	str	r3, [r5, #0]
 800fb2c:	f7f1 fe5c 	bl	80017e8 <_sbrk>
 800fb30:	1c43      	adds	r3, r0, #1
 800fb32:	d102      	bne.n	800fb3a <_sbrk_r+0x1a>
 800fb34:	682b      	ldr	r3, [r5, #0]
 800fb36:	b103      	cbz	r3, 800fb3a <_sbrk_r+0x1a>
 800fb38:	6023      	str	r3, [r4, #0]
 800fb3a:	bd38      	pop	{r3, r4, r5, pc}
 800fb3c:	20014694 	.word	0x20014694

0800fb40 <_realloc_r>:
 800fb40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fb44:	4607      	mov	r7, r0
 800fb46:	4614      	mov	r4, r2
 800fb48:	460d      	mov	r5, r1
 800fb4a:	b921      	cbnz	r1, 800fb56 <_realloc_r+0x16>
 800fb4c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800fb50:	4611      	mov	r1, r2
 800fb52:	f7ff ba03 	b.w	800ef5c <_malloc_r>
 800fb56:	b92a      	cbnz	r2, 800fb64 <_realloc_r+0x24>
 800fb58:	f7ff f994 	bl	800ee84 <_free_r>
 800fb5c:	4625      	mov	r5, r4
 800fb5e:	4628      	mov	r0, r5
 800fb60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fb64:	f000 f81a 	bl	800fb9c <_malloc_usable_size_r>
 800fb68:	4284      	cmp	r4, r0
 800fb6a:	4606      	mov	r6, r0
 800fb6c:	d802      	bhi.n	800fb74 <_realloc_r+0x34>
 800fb6e:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 800fb72:	d8f4      	bhi.n	800fb5e <_realloc_r+0x1e>
 800fb74:	4621      	mov	r1, r4
 800fb76:	4638      	mov	r0, r7
 800fb78:	f7ff f9f0 	bl	800ef5c <_malloc_r>
 800fb7c:	4680      	mov	r8, r0
 800fb7e:	b908      	cbnz	r0, 800fb84 <_realloc_r+0x44>
 800fb80:	4645      	mov	r5, r8
 800fb82:	e7ec      	b.n	800fb5e <_realloc_r+0x1e>
 800fb84:	42b4      	cmp	r4, r6
 800fb86:	4622      	mov	r2, r4
 800fb88:	4629      	mov	r1, r5
 800fb8a:	bf28      	it	cs
 800fb8c:	4632      	movcs	r2, r6
 800fb8e:	f7ff f96a 	bl	800ee66 <memcpy>
 800fb92:	4629      	mov	r1, r5
 800fb94:	4638      	mov	r0, r7
 800fb96:	f7ff f975 	bl	800ee84 <_free_r>
 800fb9a:	e7f1      	b.n	800fb80 <_realloc_r+0x40>

0800fb9c <_malloc_usable_size_r>:
 800fb9c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800fba0:	1f18      	subs	r0, r3, #4
 800fba2:	2b00      	cmp	r3, #0
 800fba4:	bfbc      	itt	lt
 800fba6:	580b      	ldrlt	r3, [r1, r0]
 800fba8:	18c0      	addlt	r0, r0, r3
 800fbaa:	4770      	bx	lr

0800fbac <atan2f>:
 800fbac:	f000 b822 	b.w	800fbf4 <__ieee754_atan2f>

0800fbb0 <sqrtf>:
 800fbb0:	b508      	push	{r3, lr}
 800fbb2:	ed2d 8b02 	vpush	{d8}
 800fbb6:	eeb0 8a40 	vmov.f32	s16, s0
 800fbba:	f000 f817 	bl	800fbec <__ieee754_sqrtf>
 800fbbe:	eeb4 8a48 	vcmp.f32	s16, s16
 800fbc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fbc6:	d60c      	bvs.n	800fbe2 <sqrtf+0x32>
 800fbc8:	eddf 8a07 	vldr	s17, [pc, #28]	@ 800fbe8 <sqrtf+0x38>
 800fbcc:	eeb4 8ae8 	vcmpe.f32	s16, s17
 800fbd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fbd4:	d505      	bpl.n	800fbe2 <sqrtf+0x32>
 800fbd6:	f7ff f919 	bl	800ee0c <__errno>
 800fbda:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 800fbde:	2321      	movs	r3, #33	@ 0x21
 800fbe0:	6003      	str	r3, [r0, #0]
 800fbe2:	ecbd 8b02 	vpop	{d8}
 800fbe6:	bd08      	pop	{r3, pc}
 800fbe8:	00000000 	.word	0x00000000

0800fbec <__ieee754_sqrtf>:
 800fbec:	eeb1 0ac0 	vsqrt.f32	s0, s0
 800fbf0:	4770      	bx	lr
	...

0800fbf4 <__ieee754_atan2f>:
 800fbf4:	ee10 2a90 	vmov	r2, s1
 800fbf8:	f022 4100 	bic.w	r1, r2, #2147483648	@ 0x80000000
 800fbfc:	f1b1 4fff 	cmp.w	r1, #2139095040	@ 0x7f800000
 800fc00:	b510      	push	{r4, lr}
 800fc02:	eef0 7a40 	vmov.f32	s15, s0
 800fc06:	d806      	bhi.n	800fc16 <__ieee754_atan2f+0x22>
 800fc08:	ee10 0a10 	vmov	r0, s0
 800fc0c:	f020 4300 	bic.w	r3, r0, #2147483648	@ 0x80000000
 800fc10:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 800fc14:	d904      	bls.n	800fc20 <__ieee754_atan2f+0x2c>
 800fc16:	ee77 7aa0 	vadd.f32	s15, s15, s1
 800fc1a:	eeb0 0a67 	vmov.f32	s0, s15
 800fc1e:	bd10      	pop	{r4, pc}
 800fc20:	f1b2 5f7e 	cmp.w	r2, #1065353216	@ 0x3f800000
 800fc24:	d103      	bne.n	800fc2e <__ieee754_atan2f+0x3a>
 800fc26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800fc2a:	f000 b883 	b.w	800fd34 <atanf>
 800fc2e:	1794      	asrs	r4, r2, #30
 800fc30:	f004 0402 	and.w	r4, r4, #2
 800fc34:	ea44 74d0 	orr.w	r4, r4, r0, lsr #31
 800fc38:	b943      	cbnz	r3, 800fc4c <__ieee754_atan2f+0x58>
 800fc3a:	2c02      	cmp	r4, #2
 800fc3c:	d05e      	beq.n	800fcfc <__ieee754_atan2f+0x108>
 800fc3e:	ed9f 7a34 	vldr	s14, [pc, #208]	@ 800fd10 <__ieee754_atan2f+0x11c>
 800fc42:	2c03      	cmp	r4, #3
 800fc44:	bf08      	it	eq
 800fc46:	eef0 7a47 	vmoveq.f32	s15, s14
 800fc4a:	e7e6      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fc4c:	b941      	cbnz	r1, 800fc60 <__ieee754_atan2f+0x6c>
 800fc4e:	eddf 7a31 	vldr	s15, [pc, #196]	@ 800fd14 <__ieee754_atan2f+0x120>
 800fc52:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 800fd18 <__ieee754_atan2f+0x124>
 800fc56:	2800      	cmp	r0, #0
 800fc58:	bfa8      	it	ge
 800fc5a:	eef0 7a47 	vmovge.f32	s15, s14
 800fc5e:	e7dc      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fc60:	f1b1 4fff 	cmp.w	r1, #2139095040	@ 0x7f800000
 800fc64:	d110      	bne.n	800fc88 <__ieee754_atan2f+0x94>
 800fc66:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 800fc6a:	f104 34ff 	add.w	r4, r4, #4294967295
 800fc6e:	d107      	bne.n	800fc80 <__ieee754_atan2f+0x8c>
 800fc70:	2c02      	cmp	r4, #2
 800fc72:	d846      	bhi.n	800fd02 <__ieee754_atan2f+0x10e>
 800fc74:	4b29      	ldr	r3, [pc, #164]	@ (800fd1c <__ieee754_atan2f+0x128>)
 800fc76:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800fc7a:	edd3 7a00 	vldr	s15, [r3]
 800fc7e:	e7cc      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fc80:	2c02      	cmp	r4, #2
 800fc82:	d841      	bhi.n	800fd08 <__ieee754_atan2f+0x114>
 800fc84:	4b26      	ldr	r3, [pc, #152]	@ (800fd20 <__ieee754_atan2f+0x12c>)
 800fc86:	e7f6      	b.n	800fc76 <__ieee754_atan2f+0x82>
 800fc88:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 800fc8c:	d0df      	beq.n	800fc4e <__ieee754_atan2f+0x5a>
 800fc8e:	1a5b      	subs	r3, r3, r1
 800fc90:	f1b3 5ff4 	cmp.w	r3, #511705088	@ 0x1e800000
 800fc94:	ea4f 51e3 	mov.w	r1, r3, asr #23
 800fc98:	da1a      	bge.n	800fcd0 <__ieee754_atan2f+0xdc>
 800fc9a:	2a00      	cmp	r2, #0
 800fc9c:	da01      	bge.n	800fca2 <__ieee754_atan2f+0xae>
 800fc9e:	313c      	adds	r1, #60	@ 0x3c
 800fca0:	db19      	blt.n	800fcd6 <__ieee754_atan2f+0xe2>
 800fca2:	ee87 0aa0 	vdiv.f32	s0, s15, s1
 800fca6:	f000 f919 	bl	800fedc <fabsf>
 800fcaa:	f000 f843 	bl	800fd34 <atanf>
 800fcae:	eef0 7a40 	vmov.f32	s15, s0
 800fcb2:	2c01      	cmp	r4, #1
 800fcb4:	d012      	beq.n	800fcdc <__ieee754_atan2f+0xe8>
 800fcb6:	2c02      	cmp	r4, #2
 800fcb8:	d017      	beq.n	800fcea <__ieee754_atan2f+0xf6>
 800fcba:	2c00      	cmp	r4, #0
 800fcbc:	d0ad      	beq.n	800fc1a <__ieee754_atan2f+0x26>
 800fcbe:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800fd24 <__ieee754_atan2f+0x130>
 800fcc2:	ee77 7a87 	vadd.f32	s15, s15, s14
 800fcc6:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800fd28 <__ieee754_atan2f+0x134>
 800fcca:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800fcce:	e7a4      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fcd0:	eddf 7a11 	vldr	s15, [pc, #68]	@ 800fd18 <__ieee754_atan2f+0x124>
 800fcd4:	e7ed      	b.n	800fcb2 <__ieee754_atan2f+0xbe>
 800fcd6:	eddf 7a15 	vldr	s15, [pc, #84]	@ 800fd2c <__ieee754_atan2f+0x138>
 800fcda:	e7ea      	b.n	800fcb2 <__ieee754_atan2f+0xbe>
 800fcdc:	ee17 3a90 	vmov	r3, s15
 800fce0:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 800fce4:	ee07 3a90 	vmov	s15, r3
 800fce8:	e797      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fcea:	ed9f 7a0e 	vldr	s14, [pc, #56]	@ 800fd24 <__ieee754_atan2f+0x130>
 800fcee:	ee77 7a87 	vadd.f32	s15, s15, s14
 800fcf2:	ed9f 7a0d 	vldr	s14, [pc, #52]	@ 800fd28 <__ieee754_atan2f+0x134>
 800fcf6:	ee77 7a67 	vsub.f32	s15, s14, s15
 800fcfa:	e78e      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fcfc:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 800fd28 <__ieee754_atan2f+0x134>
 800fd00:	e78b      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fd02:	eddf 7a0b 	vldr	s15, [pc, #44]	@ 800fd30 <__ieee754_atan2f+0x13c>
 800fd06:	e788      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fd08:	eddf 7a08 	vldr	s15, [pc, #32]	@ 800fd2c <__ieee754_atan2f+0x138>
 800fd0c:	e785      	b.n	800fc1a <__ieee754_atan2f+0x26>
 800fd0e:	bf00      	nop
 800fd10:	c0490fdb 	.word	0xc0490fdb
 800fd14:	bfc90fdb 	.word	0xbfc90fdb
 800fd18:	3fc90fdb 	.word	0x3fc90fdb
 800fd1c:	08010380 	.word	0x08010380
 800fd20:	08010374 	.word	0x08010374
 800fd24:	33bbbd2e 	.word	0x33bbbd2e
 800fd28:	40490fdb 	.word	0x40490fdb
 800fd2c:	00000000 	.word	0x00000000
 800fd30:	3f490fdb 	.word	0x3f490fdb

0800fd34 <atanf>:
 800fd34:	b538      	push	{r3, r4, r5, lr}
 800fd36:	ee10 5a10 	vmov	r5, s0
 800fd3a:	f025 4400 	bic.w	r4, r5, #2147483648	@ 0x80000000
 800fd3e:	f1b4 4fa1 	cmp.w	r4, #1350565888	@ 0x50800000
 800fd42:	eef0 7a40 	vmov.f32	s15, s0
 800fd46:	d310      	bcc.n	800fd6a <atanf+0x36>
 800fd48:	f1b4 4fff 	cmp.w	r4, #2139095040	@ 0x7f800000
 800fd4c:	d904      	bls.n	800fd58 <atanf+0x24>
 800fd4e:	ee70 7a00 	vadd.f32	s15, s0, s0
 800fd52:	eeb0 0a67 	vmov.f32	s0, s15
 800fd56:	bd38      	pop	{r3, r4, r5, pc}
 800fd58:	eddf 7a4d 	vldr	s15, [pc, #308]	@ 800fe90 <atanf+0x15c>
 800fd5c:	ed9f 7a4d 	vldr	s14, [pc, #308]	@ 800fe94 <atanf+0x160>
 800fd60:	2d00      	cmp	r5, #0
 800fd62:	bfc8      	it	gt
 800fd64:	eef0 7a47 	vmovgt.f32	s15, s14
 800fd68:	e7f3      	b.n	800fd52 <atanf+0x1e>
 800fd6a:	4b4b      	ldr	r3, [pc, #300]	@ (800fe98 <atanf+0x164>)
 800fd6c:	429c      	cmp	r4, r3
 800fd6e:	d810      	bhi.n	800fd92 <atanf+0x5e>
 800fd70:	f1b4 5f44 	cmp.w	r4, #822083584	@ 0x31000000
 800fd74:	d20a      	bcs.n	800fd8c <atanf+0x58>
 800fd76:	ed9f 7a49 	vldr	s14, [pc, #292]	@ 800fe9c <atanf+0x168>
 800fd7a:	ee30 7a07 	vadd.f32	s14, s0, s14
 800fd7e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800fd82:	eeb4 7ae6 	vcmpe.f32	s14, s13
 800fd86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fd8a:	dce2      	bgt.n	800fd52 <atanf+0x1e>
 800fd8c:	f04f 33ff 	mov.w	r3, #4294967295
 800fd90:	e013      	b.n	800fdba <atanf+0x86>
 800fd92:	f000 f8a3 	bl	800fedc <fabsf>
 800fd96:	4b42      	ldr	r3, [pc, #264]	@ (800fea0 <atanf+0x16c>)
 800fd98:	429c      	cmp	r4, r3
 800fd9a:	d84f      	bhi.n	800fe3c <atanf+0x108>
 800fd9c:	f5a3 03d0 	sub.w	r3, r3, #6815744	@ 0x680000
 800fda0:	429c      	cmp	r4, r3
 800fda2:	d841      	bhi.n	800fe28 <atanf+0xf4>
 800fda4:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800fda8:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 800fdac:	eea0 7a27 	vfma.f32	s14, s0, s15
 800fdb0:	2300      	movs	r3, #0
 800fdb2:	ee30 0a27 	vadd.f32	s0, s0, s15
 800fdb6:	eec7 7a00 	vdiv.f32	s15, s14, s0
 800fdba:	1c5a      	adds	r2, r3, #1
 800fdbc:	ee27 6aa7 	vmul.f32	s12, s15, s15
 800fdc0:	ed9f 7a38 	vldr	s14, [pc, #224]	@ 800fea4 <atanf+0x170>
 800fdc4:	eddf 5a38 	vldr	s11, [pc, #224]	@ 800fea8 <atanf+0x174>
 800fdc8:	ed9f 5a38 	vldr	s10, [pc, #224]	@ 800feac <atanf+0x178>
 800fdcc:	ee66 6a06 	vmul.f32	s13, s12, s12
 800fdd0:	eee6 5a87 	vfma.f32	s11, s13, s14
 800fdd4:	ed9f 7a36 	vldr	s14, [pc, #216]	@ 800feb0 <atanf+0x17c>
 800fdd8:	eea5 7aa6 	vfma.f32	s14, s11, s13
 800fddc:	eddf 5a35 	vldr	s11, [pc, #212]	@ 800feb4 <atanf+0x180>
 800fde0:	eee7 5a26 	vfma.f32	s11, s14, s13
 800fde4:	ed9f 7a34 	vldr	s14, [pc, #208]	@ 800feb8 <atanf+0x184>
 800fde8:	eea5 7aa6 	vfma.f32	s14, s11, s13
 800fdec:	eddf 5a33 	vldr	s11, [pc, #204]	@ 800febc <atanf+0x188>
 800fdf0:	eee7 5a26 	vfma.f32	s11, s14, s13
 800fdf4:	ed9f 7a32 	vldr	s14, [pc, #200]	@ 800fec0 <atanf+0x18c>
 800fdf8:	eea6 5a87 	vfma.f32	s10, s13, s14
 800fdfc:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 800fec4 <atanf+0x190>
 800fe00:	eea5 7a26 	vfma.f32	s14, s10, s13
 800fe04:	ed9f 5a30 	vldr	s10, [pc, #192]	@ 800fec8 <atanf+0x194>
 800fe08:	eea7 5a26 	vfma.f32	s10, s14, s13
 800fe0c:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800fecc <atanf+0x198>
 800fe10:	eea5 7a26 	vfma.f32	s14, s10, s13
 800fe14:	ee27 7a26 	vmul.f32	s14, s14, s13
 800fe18:	eea5 7a86 	vfma.f32	s14, s11, s12
 800fe1c:	ee27 7a87 	vmul.f32	s14, s15, s14
 800fe20:	d121      	bne.n	800fe66 <atanf+0x132>
 800fe22:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800fe26:	e794      	b.n	800fd52 <atanf+0x1e>
 800fe28:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800fe2c:	ee30 7a67 	vsub.f32	s14, s0, s15
 800fe30:	ee30 0a27 	vadd.f32	s0, s0, s15
 800fe34:	2301      	movs	r3, #1
 800fe36:	eec7 7a00 	vdiv.f32	s15, s14, s0
 800fe3a:	e7be      	b.n	800fdba <atanf+0x86>
 800fe3c:	4b24      	ldr	r3, [pc, #144]	@ (800fed0 <atanf+0x19c>)
 800fe3e:	429c      	cmp	r4, r3
 800fe40:	d80b      	bhi.n	800fe5a <atanf+0x126>
 800fe42:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 800fe46:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800fe4a:	eea0 7a27 	vfma.f32	s14, s0, s15
 800fe4e:	2302      	movs	r3, #2
 800fe50:	ee70 6a67 	vsub.f32	s13, s0, s15
 800fe54:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800fe58:	e7af      	b.n	800fdba <atanf+0x86>
 800fe5a:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 800fe5e:	eec7 7a00 	vdiv.f32	s15, s14, s0
 800fe62:	2303      	movs	r3, #3
 800fe64:	e7a9      	b.n	800fdba <atanf+0x86>
 800fe66:	4a1b      	ldr	r2, [pc, #108]	@ (800fed4 <atanf+0x1a0>)
 800fe68:	491b      	ldr	r1, [pc, #108]	@ (800fed8 <atanf+0x1a4>)
 800fe6a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800fe6e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 800fe72:	edd3 6a00 	vldr	s13, [r3]
 800fe76:	ee37 7a66 	vsub.f32	s14, s14, s13
 800fe7a:	2d00      	cmp	r5, #0
 800fe7c:	ee37 7a67 	vsub.f32	s14, s14, s15
 800fe80:	edd2 7a00 	vldr	s15, [r2]
 800fe84:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800fe88:	bfb8      	it	lt
 800fe8a:	eef1 7a67 	vneglt.f32	s15, s15
 800fe8e:	e760      	b.n	800fd52 <atanf+0x1e>
 800fe90:	bfc90fdb 	.word	0xbfc90fdb
 800fe94:	3fc90fdb 	.word	0x3fc90fdb
 800fe98:	3edfffff 	.word	0x3edfffff
 800fe9c:	7149f2ca 	.word	0x7149f2ca
 800fea0:	3f97ffff 	.word	0x3f97ffff
 800fea4:	3c8569d7 	.word	0x3c8569d7
 800fea8:	3d4bda59 	.word	0x3d4bda59
 800feac:	bd6ef16b 	.word	0xbd6ef16b
 800feb0:	3d886b35 	.word	0x3d886b35
 800feb4:	3dba2e6e 	.word	0x3dba2e6e
 800feb8:	3e124925 	.word	0x3e124925
 800febc:	3eaaaaab 	.word	0x3eaaaaab
 800fec0:	bd15a221 	.word	0xbd15a221
 800fec4:	bd9d8795 	.word	0xbd9d8795
 800fec8:	bde38e38 	.word	0xbde38e38
 800fecc:	be4ccccd 	.word	0xbe4ccccd
 800fed0:	401bffff 	.word	0x401bffff
 800fed4:	0801039c 	.word	0x0801039c
 800fed8:	0801038c 	.word	0x0801038c

0800fedc <fabsf>:
 800fedc:	ee10 3a10 	vmov	r3, s0
 800fee0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800fee4:	ee00 3a10 	vmov	s0, r3
 800fee8:	4770      	bx	lr
	...

0800feec <_init>:
 800feec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800feee:	bf00      	nop
 800fef0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800fef2:	bc08      	pop	{r3}
 800fef4:	469e      	mov	lr, r3
 800fef6:	4770      	bx	lr

0800fef8 <_fini>:
 800fef8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fefa:	bf00      	nop
 800fefc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800fefe:	bc08      	pop	{r3}
 800ff00:	469e      	mov	lr, r3
 800ff02:	4770      	bx	lr
